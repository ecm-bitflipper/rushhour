/* -*- Mode: C -*- */
/*
 * Author: Henrik Theiling
 * Description:
 *     Implementation of library wide thingies.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 */
      
#define ERR_ERWIN_COMPILING 1

#include <assert.h>
#include "error/erwin/base_i.h"
#include "error/erwin/typeinfo.h"
#include "error/erwin/stdinc.h"

char const * const err_erwin_version=      "2.1.89877";
char const * const err_erwin_package_date= "Mon Sep 15 23:46:33 GMT 2008";
char const * const err_erwin_install_date= "Wed Sep 17 00:47:20 GMT 2008";
char const * const err_erwin_init_date=    "Wed Sep 17 00:47:56 GMT 2008";
int const err_erwin_version_1 = 1;
int const err_erwin_version_2 = 1;
ERR_ERWIN_BOOL err_erwin_assertion_is_fatal= ERR_ERWIN_TRUE;
ERR_ERWIN_BOOL err_erwin_initialised =       ERR_ERWIN_FALSE;

#define initialised err_erwin_initialised

/*
 * NULL safe string comparison
 */
int err_string_cmp (char const *a, char const *b)
{
    if (a == (char *)NULL) return b == (char*)NULL ? 0 : -1;
    if (b == (char *)NULL) return a == (char*)NULL ? 0 : 1;
#ifdef HAVE_STRCMP
    return strcmp (a, b);
#else
    while (*a && *b) {
        unsigned char al= *a;
        unsigned char bl= *b;
        if (al < bl) return -1;
        if (al > bl) return 1;
        a++;
        b++;
    }
    if (*a < *b) return -1;
    if (*a > *b) return 1;
    return 0;
#endif
}

int err_memory_cmp (void const *_a, void const *_b, size_t n)
{
    if (_a == NULL) return _b == NULL ? 0 : -1;
    if (_b == NULL) return _a == NULL ? 0 : 1;
#if 0
    return memcmp (_a, _b, n);
#else
    {
        unsigned char const *a= (unsigned char const *)_a;
        unsigned char const *b= (unsigned char const *)_b;
        while (n > 0) {
            unsigned char al= *a;
            unsigned char bl= *b;
            if (al < bl) return -1;
            if (al > bl) return +1;
            a++;
            b++;
            n--;
        }
    }
    return 0;
#endif
}

int err_string_case_cmp (char const *a, char const *b)
{
    if (a == (char *)NULL) return b == (char*)NULL ? 0 : -1;
    if (b == (char *)NULL) return a == (char*)NULL ? 0 : 1;
#if defined(HAVE_STRCASECMP)
    return strcasecmp (a, b);
#elif defined(HAVE_STRICMP)
    return stricmp (a, b);
#else
    while (*a && *b) {
        unsigned char al= err_char_to_lower (*a);
        unsigned char bl= err_char_to_lower (*b);
        if (al < bl) return -1;
        if (al > bl) return 1;
        a++;
        b++;
    }
    if (*a < *b) return -1;
    if (*a > *b) return 1;
    return 0;
#endif
}

int err_string_n_cmp (char const *a, char const *b, size_t n)
{
    if (a == (char *)NULL) return b == (char*)NULL ? 0 : -1;
    if (b == (char *)NULL) return a == (char*)NULL ? 0 : 1;
#ifdef HAVE_STRNCMP
    return strncmp (a, b, n);
#else
    for(;;) {
        unsigned char al;
        unsigned char bl;
        if (ERWIN_UNLIKELY(n <= 0))
            return 0;
        n--;
        if (!(*a && *b))
            break;
        al= *a;
        bl= *b;
        if (al < bl) return -1;
        if (al > bl) return 1;
        a++;
        b++;
    }
    if (*a < *b) return -1;
    if (*a > *b) return 1;
    return 0;
#endif
}

int err_string_n_case_cmp (char const *a, char const *b, size_t n)
{
    if (a == (char *)NULL) return b == (char*)NULL ? 0 : -1;
    if (b == (char *)NULL) return a == (char*)NULL ? 0 : 1;
#if defined(HAVE_STRNCASECMP)
    return strncasecmp (a, b, n);
#elif defined(HAVE_STRNICMP)
    return strnicmp (a, b, n);
#else
    for(;;) {
        unsigned char al;
        unsigned char bl;
        if (ERWIN_UNLIKELY(n <= 0))
            return 0;
        n--;
        if (!(*a && *b))
            break;
        al= err_char_to_lower (*a);
        bl= err_char_to_lower (*b);
        if (al < bl) return -1;
        if (al > bl) return 1;
        a++;
        b++;
    }
    if (*a < *b) return -1;
    if (*a > *b) return 1;
    return 0;
#endif
}

char *err_string_string (char const *haystack, char const *needle)
{
#ifndef HAVE_STRSTR
    int n;
#endif
    if (haystack == NULL || needle == NULL)
        return NULL;
#ifdef HAVE_STRSTR
    return ERWIN_CONST_CAST(char *,strstr (haystack, needle));
        /* strstr() might be overloaded for const and non-const in C++, e.g.
         * in MSVC, thus the cast.  This is probably not POSIX-conformant. */
#else
    /* FIXME: improve algorithm */
    n= err_erwin_strlen (needle);
    while (*haystack) {
        if (err_string_n_cmp (haystack, needle, n) == 0)
            return ERWIN_CONST_CAST(char *, haystack);
        haystack++;
    }
    return NULL;
#endif
}

void *err_memory_memory (
    void const *_haystack, size_t haycnt, void const *needle, size_t needlecnt)
{
    if (_haystack == NULL || needle == NULL)
        return NULL;
#if 0
    return ERWIN_CONST_CAST(void *, memmem (_haystack, haycnt, needle, needlecnt));
        /* Some memmem might be overloaded for const and non-const in C++, thus
         * the cast (see strstr) */
#else
    if (needlecnt == 0)
        return ERWIN_CONST_CAST(void *,_haystack);
    {
        unsigned char const *haystack= (unsigned char const *)_haystack;
        /* FIXME: improve algorithm */
        while (haycnt >= needlecnt) {
            if (err_memory_cmp ((void const *)haystack, needle, needlecnt) == 0)
                return (void *)haystack;
            haystack++;
            haycnt--;
        }
    }
    return NULL;
#endif
}

char *err_string_case_string (char const *haystack, char const *needle)
{
    size_t n;
    if (haystack == NULL || needle == NULL)
        return NULL;
    n= err_erwin_strlen (needle);
    while (*haystack) {
        if (err_string_n_case_cmp (haystack, needle, n) == 0)
            return (char *)haystack;
        haystack++;
    }
    return NULL;
}

char *err_string_n_string (char const *haystack, char const *needle, size_t n)
{
    if (haystack == NULL || needle == NULL)
        return NULL;
    while (*haystack) {
        if (err_string_n_cmp (haystack, needle, n) == 0)
            return (char *)haystack;
        haystack++;
    }
    return NULL;
}

char *err_string_n_case_string (char const *haystack, char const *needle, size_t n)
{
    if (haystack == NULL || needle == NULL)
        return NULL;
    while (*haystack) {
        if (err_string_n_case_cmp (haystack, needle, n) == 0)
            return (char *)haystack;
        haystack++;
    }
    return NULL;
}

/* NULL safe string free which overwrites the string before
 * freeing it. */
void err_string_free (char *c)
{
    if (c == NULL)
        return;

    /* memset (c, 0, strlen (c)+1);   Well, no, it's slower... */
    free (c);
}

void *err_erwin_memset0 (void *p, size_t start, size_t end_plus_1)
{
    if (p != NULL && end_plus_1 > start) {
#if defined(HAVE_MEMSET)
        memset ((void*)(((char*)p) + start), 0, end_plus_1 - start);
#elif defined(HAVE_BZERO)
        bzero  ((void*)(((char*)p) + start), end_plus_1 - start);
#else
        char *x= ((char*)p) + start;
        end_plus_1-= start;
        while (end_plus_1 > 0) {
            *x++= 0;
            end_plus_1--;
        }
#endif
    }
    return p;
}

size_t err_string_length (char const *c)
{
    if (c == NULL) return 0;
    return strlen (c);
}

size_t err_string_n_length (char const *c, size_t n)
{
    if (c == NULL) return 0;
#if 0
    /* defined(HAVE_STRNLEN)
     *    -> configure test does not work for some reason since this function needs
     *       _GNU_SOURCE, but the configure test does not seem to care (probably
     *       since it's done in C, but should be in C++ as we often compile this
     *       in C++.  But not always.  I don't feel like getting it right now...) */
    return strnlen (c, n);
#else
    {
        size_t i= 0;
        for (; n > 0 && *c; c++, n--)
            i++;
        return i;
    }
#endif
}

/*
 * This MUST NOT change NULL to "(null)" or equivalent.  Otherwise, the
 * index NULL is not found after insersion in the array.
 */
char *err_string_dup (char const *c, int *err)
{
    char *result;
    if (NULL == c)
        return NULL;

    result= (char *)malloc (err_erwin_strlen(c)+1);
    if (ERWIN_UNLIKELY(result == NULL)) {
        if (err != NULL)
            *err= ERR_ERWIN_TRUE;
    }
    else
        strcpy (result, c);
    return result;
}

char *err_string_n_dup (char const *c, size_t n, int *err)
{
    char *result;
    size_t len;
    if (NULL == c)
        return NULL;

    len= err_erwin_strlen(c);
    if (n < len)
        len= n;

    result= (char *)malloc (len+1);
    if (ERWIN_UNLIKELY(result == NULL)) {
        if (err != NULL)
            *err= ERR_ERWIN_TRUE;
    }
    else
        strncpy (result, c, len);
    return result;
}

char err_erwin_get_digit (int digit)
{
    static char const *lower_digit= "0123456789abcdefghijklmnopqrstuvwxyz";
    if (ERWIN_UNLIKELY(digit < 0 || digit > 35))
        return '\0';
    return lower_digit[digit];
}

char err_erwin_get_digit_upper (int digit)
{
    static char const *upper_digit= "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    if (ERWIN_UNLIKELY(digit < 0 || digit > 35))
        return '\0';
    return upper_digit[digit];
}

int err_erwin_digit_value (char c)
{
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'a' && c <= 'z') return c - 'a' + 10;
    if (c >= 'A' && c <= 'Z') return c - 'A' + 10;
    return 100;
}

/* Sometimes these do not work (found some glibc where strtoul was there, but broken)
 * Re-implement them.  Possibly add a configure check sometime to redirect them
 * to the system.
 * NOTE: These are more simple than the system functions as have almost no error
 *       checking.
 */
#define STRTOX(NAME2, NAME, NEG, TYPE)                                                       \
    TYPE err_erwin_##NAME (char const *c, size_t n, char **endptr, int options)           \
    {                                                                                        \
        TYPE result= 0;                                                                      \
        ERR_ERWIN_BOOL neg= 0;                                                            \
        int base= options & ERR_SO_BASE_MASK;                                             \
                                                                                             \
        if (ERWIN_UNLIKELY(c == NULL)) {                                                     \
            if (endptr)                                                                      \
                *endptr= NULL;                                                               \
            return 0;                                                                        \
        }                                                                                    \
                                                                                             \
        if (NEG)                                                                             \
            while (n > 0 && (*c == '-' || *c=='+')) {                                        \
                if (*c == '-') neg= !neg;                                                    \
                c++;                                                                         \
                n--;                                                                         \
            }                                                                                \
                                                                                             \
        if (base == 0) {                                                                     \
            if (n >= 2 && c[0] == '0' && (c[1]=='x' || c[1]=='X')) { base= 16; c+=2; n-=2; } \
            else                                                                             \
            if (!(options & ERR_SO_NO_BINARY) &&                                          \
                n >= 2 && c[0] == '0' && (c[1]=='b' || c[1]=='B')) { base= 2; c+=2; n-=2; }  \
            else                                                                             \
            if (n >= 1 && c[0] == '0') { base= 8; c++; n--; }                                \
            else                                                                             \
                base= 10;                                                                    \
        }                                                                                    \
                                                                                             \
        for (; n > 0; c++, n--) {                                                            \
            int digit= err_erwin_digit_value (*c);                                        \
            if (ERWIN_UNLIKELY(digit >= base)) {                                             \
                if (*c == '_' && !(options & ERR_SO_NO_UNDERBAR))                         \
                    continue;  /*!*/                                                         \
                else                                                                         \
                    break; /*!*/                                                             \
            }                                                                                \
                                                                                             \
            result= (result * base) + digit;                                                 \
        }                                                                                    \
        if (endptr != NULL)                                                                  \
            *endptr= (char *)c;                                                              \
                                                                                             \
        return (NEG && neg) ? -result : result;                                              \
    }                                                                                        \
    TYPE err_erwin_##NAME2 (char const *c, char **endptr, int options)                    \
    {                                                                                        \
        return err_erwin_##NAME (c, err_erwin_strlen (c), endptr, options);            \
    }

STRTOX(strtol,  strntol,   1, long)
STRTOX(strtoul, strntoul,  0, unsigned long)

#ifdef ERWIN_LONG_LONG
STRTOX(strtoll,  strntoll,  1, ERWIN_LONG_LONG)
STRTOX(strtoull, strntoull, 0, ERWIN_UNSIGNED_LONG_LONG)
#endif

char err_char_to_upper (char c)
{
#ifdef BROKEN_CTYPE
    if (((unsigned char)c) > 127)
        return c;
#endif

#ifdef HAVE_TOUPPER
    return (char)toupper ((unsigned char)c);
#else
    switch (c) {
        case 'a': return 'A';
        case 'b': return 'B';
        case 'c': return 'C';
        case 'd': return 'D';
        case 'e': return 'E';
        case 'f': return 'F';
        case 'g': return 'G';
        case 'h': return 'H';
        case 'i': return 'I';
        case 'j': return 'J';
        case 'k': return 'K';
        case 'l': return 'L';
        case 'm': return 'M';
        case 'n': return 'N';
        case 'o': return 'O';
        case 'p': return 'P';
        case 'q': return 'Q';
        case 'r': return 'R';
        case 's': return 'S';
        case 't': return 'T';
        case 'u': return 'U';
        case 'v': return 'V';
        case 'w': return 'W';
        case 'x': return 'X';
        case 'y': return 'Y';
        case 'z': return 'Z';
        default:  return c;
    }
#endif
}

char err_char_to_lower (char c)
{
#ifdef BROKEN_CTYPE
    if (((unsigned char)c) > 127)
        return c;
#endif

#ifdef HAVE_TOLOWER
    return (char)tolower (((unsigned char)c));
#else
    switch (c) {
        case 'A': return 'a';
        case 'B': return 'b';
        case 'C': return 'c';
        case 'D': return 'd';
        case 'E': return 'e';
        case 'F': return 'f';
        case 'G': return 'g';
        case 'H': return 'h';
        case 'I': return 'i';
        case 'J': return 'j';
        case 'K': return 'k';
        case 'L': return 'l';
        case 'M': return 'm';
        case 'N': return 'n';
        case 'O': return 'o';
        case 'P': return 'p';
        case 'Q': return 'q';
        case 'R': return 'r';
        case 'S': return 's';
        case 'T': return 't';
        case 'U': return 'u';
        case 'V': return 'v';
        case 'W': return 'w';
        case 'X': return 'x';
        case 'Y': return 'y';
        case 'Z': return 'z';
        default:  return c;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_alpha (char c)
{
#ifdef HAVE_ISALPHA
#ifdef BROKEN_CTYPE
    return ERR_ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isalpha (((unsigned char)c)));
#else
    return ERR_ERWIN_TO_BOOL (isalpha (((unsigned char)c)));
           /* e.g. Solaris 5.8 generates warning if cast is left out */
#endif
#else
    switch (c) {
        case 'A': case 'B': case 'C': case 'D':
        case 'E': case 'F': case 'G': case 'H':
        case 'I': case 'J': case 'K': case 'L':
        case 'M': case 'N': case 'O': case 'P':
        case 'Q': case 'R': case 'S': case 'T':
        case 'U': case 'V': case 'W': case 'X':
        case 'Y': case 'Z': case 'a': case 'b':
        case 'c': case 'd': case 'e': case 'f':
        case 'g': case 'h': case 'i': case 'j':
        case 'k': case 'l': case 'm': case 'n':
        case 'o': case 'p': case 'q': case 'r':
        case 's': case 't': case 'u': case 'v':
        case 'w': case 'x': case 'y': case 'z':
            return ERR_ERWIN_TRUE;

        default:
            return ERR_ERWIN_FALSE;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_upper (char c)
{
#ifdef HAVE_ISUPPER
#ifdef BROKEN_CTYPE
    return ERR_ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isupper (((unsigned char)c)));
#else
    return ERR_ERWIN_TO_BOOL (isupper (((unsigned char)c)));
           /* e.g. Solaris 5.8 generates warning if cast is left out */
#endif
#else
    switch (c) {
        case 'A': case 'B': case 'C': case 'D':
        case 'E': case 'F': case 'G': case 'H':
        case 'I': case 'J': case 'K': case 'L':
        case 'M': case 'N': case 'O': case 'P':
        case 'Q': case 'R': case 'S': case 'T':
        case 'U': case 'V': case 'W': case 'X':
        case 'Y': case 'Z':
            return ERR_ERWIN_TRUE;

        default:
            return ERR_ERWIN_FALSE;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_lower (char c)
{
#ifdef HAVE_ISLOWER
#ifdef BROKEN_CTYPE
    return ERR_ERWIN_TO_BOOL (((unsigned char)c) <= 127 && islower (((unsigned char)c)));
#else
    return ERR_ERWIN_TO_BOOL (islower (((unsigned char)c)));
           /* e.g. Solaris 5.8 generates warning if cast is left out */
#endif
#else
    switch (c) {
        case 'a': case 'b':
        case 'c': case 'd': case 'e': case 'f':
        case 'g': case 'h': case 'i': case 'j':
        case 'k': case 'l': case 'm': case 'n':
        case 'o': case 'p': case 'q': case 'r':
        case 's': case 't': case 'u': case 'v':
        case 'w': case 'x': case 'y': case 'z':
            return ERR_ERWIN_TRUE;

        default:
            return ERR_ERWIN_FALSE;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_digit (char c)
{
#ifdef HAVE_ISDIGIT
#ifdef BROKEN_CTYPE
    return ERR_ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isdigit (((unsigned char)c)));
#else
    return ERR_ERWIN_TO_BOOL (isdigit (((unsigned char)c)));
           /* e.g. Solaris 5.8 generates warning if cast is left out */
#endif
#else
    switch (c) {
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            return ERR_ERWIN_TRUE;

        default:
            return ERR_ERWIN_FALSE;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_xdigit (char c)
{
#ifdef HAVE_ISXDIGIT
#ifdef BROKEN_CTYPE
    return ERR_ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isxdigit (((unsigned char)c)));
#else
    return ERR_ERWIN_TO_BOOL (isxdigit (((unsigned char)c)));
           /* e.g. Solaris 5.8 generates warning if cast is left out */
#endif
#else
    switch (c) {
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
            return ERR_ERWIN_TRUE;

        default:
            return ERR_ERWIN_FALSE;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_space (char c)
{
#ifdef HAVE_ISSPACE
#ifdef BROKEN_CTYPE
    return ERR_ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isspace (((unsigned char)c)));
#else
    return ERR_ERWIN_TO_BOOL (isspace (((unsigned char)c)));
           /* e.g. Solaris 5.8 generates warning if cast is left out */
#endif
#else
    switch (c) {
        case ' ':
        case '\f':
        case '\t':
        case '\n':
        case '\r':
        case '\v': return ERR_ERWIN_TRUE;
        default:   return ERR_ERWIN_FALSE;
    }
#endif
}

ERR_ERWIN_BOOL err_char_is_cr (char c)
{
    return ERR_ERWIN_TO_BOOL (c == '\n' || c=='\r');
}

ERR_ERWIN_BOOL err_char_is_space0 (char c)
{
    return ERR_ERWIN_TO_BOOL (c == '\0' || err_char_is_space (c));
}

ERR_ERWIN_BOOL err_char_is_cr0 (char c)
{
    return ERR_ERWIN_TO_BOOL (c == '\0' || err_char_is_cr (c));
}

ERR_ERWIN_BOOL err_string_is_prefix (
    int *needle_length_p, char const *haystack, char const *needle)
{
    int n= err_erwin_strlen (needle);
    if (needle_length_p != NULL)
        *needle_length_p= n;
    return err_erwin_strncmp (haystack, needle, n) == 0;
}

ERR_ERWIN_BOOL err_string_is_suffix (
    int *needle_length_p, char const *haystack, char const *needle)
{
    int s= err_erwin_strlen (haystack);
    int n= err_erwin_strlen (needle);
    if (needle_length_p != NULL)
        *needle_length_p= n;
    return s >= n &&
           err_erwin_strncmp (haystack + s - n, needle, n) == 0;
}

char const *err_erwin_strsignal (int x)
{
#if defined(NSIG)
#   define ERWIN_SIGNAL_COUNT NSIG
#elif defined(_NSIG)
#   define ERWIN_SIGNAL_COUNT _NSIG
#endif

#if defined(SYS_SIGLIST_DECLARED)
#    define ERWIN_STRSIGNAL(X) (sys_siglist[X])
#elif defined(_SYS_SIGLIST_DECLARED)
#    define ERWIN_STRSIGNAL(X) (_sys_siglist[X])
#endif

     /* FIXME:
      *   This fails in 'make manytests'.  What's the way to do it?
      *   Probable -ansi is the case for the failure.
      */

     /* For the strsignal() function, we need _GNU_SOURCE under Linux, and
      * without it, HAVE_STRSIGNAL is still defined, but strsignal undeclared,
      * leading to problems.  The only way is to neglect the function, I think.
      * I don't like special handling.
      */

     /* If we have an array, we will not index it unless we also know
      * the number of signals.  This should work for at least Linux and
      * Solaris: */
#if defined(ERWIN_STRSIGNAL) && defined(ERWIN_SIGNAL_COUNT)
     if (x >= 0 && x < ERWIN_SIGNAL_COUNT)
         return ERWIN_STRSIGNAL(x);
#endif

    /* As a fall back, at least know a few signals.  E.g., some of these are
     * used under Windows. */
#if defined(SIGSEGV)
    if (x == SIGSEGV) return "Segmentation Violation";
#elif defined(_SIGSEGV)
    if (x == _SIGSEGV) return "Segmentation Violation";
#endif

#if defined(SIGBUS)
    if (x == SIGBUS) return "Bus Error";
#elif defined(_SIGBUS)
    if (x == _SIGBUS) return "Bus Error";
#endif

#if defined(SIGINT)
    if (x == SIGINT) return "Interrupt";
#elif defined(_SIGINT)
    if (x == _SIGINT) return "Interrupt";
#endif

#if defined(SIGABRT)
    if (x == SIGABRT) return "Aborted";
#elif defined(_SIGABRT)
    if (x == _SIGABRT) return "Aborted";
#endif

#if defined(SIGTERM)
    if (x == SIGTERM) return "Terminated";
#elif defined(_SIGTERM)
    if (x == _SIGTERM) return "Terminated";
#endif

#if defined(SIGFPE)
    if (x == SIGFPE) return "Floating Point Exception";
#elif defined(_SIGFPE)
    if (x == _SIGFPE) return "Floating Point Exception";
#endif

#if defined(SIGILL)
    if (x == SIGILL) return "Illegal Instruction";
#elif defined(_SIGILL)
    if (x == _SIGILL) return "Illegal Instruction";
#endif

    return NULL;
}

/* ////////////////////////////////////////////////////////////////////// */


#ifdef ERR_ERWIN_REQUIRE_DETERMINISM

static ERR_ERWIN_BOOL internal_erwin_require_determinism= ERR_ERWIN_TRUE;
static ERR_ERWIN_BOOL internal_erwin_init_determinism= ERR_ERWIN_TRUE;

void err_erwin_set_determinism (ERR_ERWIN_BOOL bol)
{
    if (initialised && !internal_erwin_init_determinism && bol) {
#ifdef HAVE_LIBERROR
        fleprintf (C_TAG_WARNING, 0, __FILE__, __LINE__,
            "Enabling determinism after initialisation might not work.\n");
#else
        ERR_ERWIN_ERROR_PRINT (ERR_ERWIN_ERROR_STREAM,
            "%s:%d: (Erwin:base.c) Warning: Enabling determinism after initialisation might not work.\n",
            __FILE__,
            __LINE__);
#endif
    }

    internal_erwin_require_determinism= bol;
    if (!initialised)
        internal_erwin_init_determinism= bol;
}

ERR_ERWIN_BOOL err_erwin_require_determinism (void)
{
    return internal_erwin_require_determinism;
}

#endif

#ifdef ERR_ERWIN_NEED_DET_RANDOM

static unsigned long erwin_rand_seed= 0;

unsigned long err_erwin_det_random (void)
{
    erwin_rand_seed= (erwin_rand_seed + 12985341UL) * 837417321UL;
    /* FIXME: Check that this is good.  However, this is a fallback, so it need
     *        not be good.  Note that this should not be changed without a
     *        compatibility #define later because it might be used to enforce
     *        determinism.
     */
    return erwin_rand_seed;
}

#endif

/* ////////////////////////////////////////////////////////////////////// */

/* Merge sort implementation (stable) */

typedef struct
{
  void *swap_buffer;
  void *base;
  size_t nmemb;
  size_t size;
  int (*compar)(const void *, const void *);
} sort_ctx_t;

/* Wrappers stuff */
#define NTH_AUX(I,B) ((void*)(((char*)B)+(I)*(ctx->size)))

ERWIN_STATIC_INLINE void *NTH (long i, void *b, sort_ctx_t *ctx)
{
    assert (i >= 0);
    assert (((size_t)i) < ctx->nmemb);
    return NTH_AUX (i, b);
}

#define CMP(I1,B1,I2,B2)      (ctx->compar(NTH(I1,B1,ctx),NTH(I2,B2,ctx)))
#define COPY1(I1,B1,I2,B2)    memcpy(NTH(I1,B1,ctx), NTH(I2,B2,ctx), ctx->size)
#define COPYN(I1,B1,I2,B2,N)  memcpy(NTH(I1,B1,ctx), NTH(I2,B2,ctx), (N) * ctx->size)

/* Merge sort */

/*
 * Bad implementation (too much copying), we needed it quickly.
 *
 * The crucial point about the implementation:
 * The only purpose for this implementation to exist is that
 * merge sort can be programmed to be stable.  To achieve this,
 * the merge functions must obbey the following rule:
 * Whenever two elements are found to be equal, keep their relative
 * position.  This is done by using <= in the below comparison, meaning:
 * if base[a1] is equal to base[a2], copy base[a1] first, since it was
 * first in the original array.
 */
ERWIN_STATIC_INLINE void merge (long a1, long b1, long a2, long b2, sort_ctx_t *ctx)
{
    long dst;
    long old_a1= a1;

    /* Position where */
    dst= 0;

    /* Copy with comparison */
    while (a1 <= b1 && a2 <= b2) {
        if (CMP (a1, ctx->base, a2, ctx->base) <= 0) { /* Do not use `<'! */
            COPY1 (dst, ctx->swap_buffer, a1, ctx->base);
            a1++;
        }
        else {
            COPY1 (dst, ctx->swap_buffer, a2, ctx->base);
            a2++;
        }
        dst++;
    }

    /* Copy rest of left array */
    while (a1 <= b1) {
        COPY1 (dst, ctx->swap_buffer, a1, ctx->base);
        a1++;
        dst++;
    }

    /* Copy rest of right array */
    while (a2 <= b2) {
        COPY1 (dst, ctx->swap_buffer, a2, ctx->base);
        a2++;
        dst++;
    }

    COPYN (old_a1, ctx->base, 0, ctx->swap_buffer, dst);
}

static void merge_sort (long a, long b, sort_ctx_t *ctx)
{
    if (b - a + 1 > 1) {
        long mitte= a + (b-a)/2;
        merge_sort (a, mitte, ctx);
        merge_sort (mitte+1, b, ctx);
        merge (a, mitte, mitte+1, b, ctx);
    }
}

/* ////////////////////////////////////////////////////////////////////// */

/*
 * The merge sort algorithm with correct interface */
void err_erwin_merge_sort (
    void *abase,
    size_t anmemb,
    size_t asize,
    int (*acompar)(const void *, const void *))
{
    sort_ctx_t ctx;

    if (ERWIN_LIKELY(anmemb > 1)) {
        ctx.base=  abase;
        ctx.swap_buffer= malloc (asize * anmemb); /* Unfortunate additional memory */
        ctx.size= asize;
        ctx.nmemb= anmemb;
        ctx.compar= acompar;

        assert (((long)ctx.nmemb) > 0);
        merge_sort (0, ctx.nmemb-1, &ctx);

        free (ctx.swap_buffer);
    }
}

/* ********************************************************************** */

#ifdef TYPE_INFO_T

static
TYPE_ENUM_T(ERR_ERWIN_BOOL)=
    TYPE_ENUM_BEGIN(ERR_ERWIN_BOOL)
    TYPE_ENUM_VALUE(ERR_ERWIN_BOOL, ERR_ERWIN_FALSE)
    TYPE_ENUM_VALUE(ERR_ERWIN_BOOL, ERR_ERWIN_TRUE)
    TYPE_ENUM_END
;
TYPE_INFO_T(ERR_ERWIN_BOOL)= TYPE_INFO_ENUM(ERR_ERWIN_BOOL, ERR_ERWIN_BOOL);

#ifdef __cplusplus
static
TYPE_ENUM_T(bool)=
    TYPE_ENUM_BEGIN(bool)
    TYPE_ENUM_VALUE(bool, false)
    TYPE_ENUM_VALUE(bool, true)
    TYPE_ENUM_END
;
TYPE_INFO_T(err_erwininternalbool)= TYPE_INFO_ENUM(bool, bool);
#endif

#ifdef __CHAR_UNSIGNED__
TYPE_INFO_T(err_erwininternalchar)= TYPE_INFO_UINT(char);
#else
TYPE_INFO_T(err_erwininternalchar)= TYPE_INFO_SINT(char);
#endif

TYPE_INFO_T(err_erwininternalunsigned_char)=  TYPE_INFO_UINT(unsigned char);
TYPE_INFO_T(err_erwininternalsigned_char)=    TYPE_INFO_SINT(signed char);

TYPE_INFO_T(err_erwininternalint)=            TYPE_INFO_SINT(int);
TYPE_INFO_T(err_erwininternalunsigned)=       TYPE_INFO_UINT(unsigned);

TYPE_INFO_T(err_erwininternalshort)=          TYPE_INFO_SINT(short);
TYPE_INFO_T(err_erwininternalunsigned_short)= TYPE_INFO_UINT(unsigned short);

TYPE_INFO_T(err_erwininternallong)=           TYPE_INFO_SINT(long);
TYPE_INFO_T(err_erwininternalunsigned_long)=  TYPE_INFO_UINT(unsigned long);

#ifdef ERWIN_LONG_LONG
TYPE_INFO_T(err_erwininternalERWIN_LONG_LONG)=         TYPE_INFO_SINT(ERWIN_LONG_LONG);
TYPE_INFO_T(err_erwininternalERWIN_UNSIGNED_LONG_LONG)=TYPE_INFO_UINT(ERWIN_UNSIGNED_LONG_LONG);
#endif

TYPE_INFO_T(err_erwininternalsize_t)=         TYPE_INFO_UINT(size_t);

TYPE_INFO_T(err_erwininternalvoid)=           TYPE_INFO_VOID(void);

TYPE_INFO_T(err_erwininternalfloat)=          TYPE_INFO_SINT(float);
TYPE_INFO_T(err_erwininternaldouble)=         TYPE_INFO_SINT(double);

TYPE_INFO_T(err_erwininternalchar_string)=    TYPE_INFO_STRING(char, char);

TYPE_INFO_T(err_erwininternalchar_p)=         TYPE_INFO_POINTER(char *, char_string);
TYPE_INFO_T(err_erwininternalchar_const_p)=   TYPE_INFO_POINTER(char const *, char_string);

TYPE_INFO_T(err_erwininternalvoid_p)=         TYPE_INFO_POINTER(void *, void);
TYPE_INFO_T(err_erwininternalvoid_const_p)=   TYPE_INFO_POINTER(void const *, void);


#if defined(err_erwin_kind_t_defined)

char const *err_erwin_kind_to_string (err_erwin_kind_t a)
{
    switch (a) {
    case ERR_KIND_VOID:     return "void";
    case ERR_KIND_SINT:     return "signed integer";
    case ERR_KIND_UINT:     return "unsigned integer";
    case ERR_KIND_ENUM:     return "enums";
    case ERR_KIND_FLOAT:    return "float";
    case ERR_KIND_STRUCT:   return "struct";
    case ERR_KIND_ARRAY:    return "array";
    case ERR_KIND_UNION:    return "union";
    case ERR_KIND_POINTER:  return "pointer";
    case ERR_KIND_REF:      return "reference";
    case ERR_KIND_STRING:   return "0-string";
    case ERR_KIND_VECTOR:   return "vector";
    case ERR_KIND_FUNCTION: return "function";
    case ERR_KIND_TUPLE:    return "tuple";
    }
    return "<unknown>";
}

#endif /*ERR_ERWIN_TYPE_INFO && !defined(TYPE_INFO_T) */


#endif /* defined TYPE_INFO_T */
