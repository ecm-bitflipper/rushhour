/* -*- Mode: C -*- */
/*
 * Author: Henrik Theiling
 * Description: Basic definitions for the Erwin library
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 * Great help for #define: http://predef.sourceforge.net/
 *
 */
#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including defs.h."
#endif

#ifndef ERR_ERWIN_DEFS_H
#define ERR_ERWIN_DEFS_H

#ifdef ERWIN_DEBUG_INCLUDE
#  warning "First inclusion of defs.h."
#endif


#include "error/settings.h"

#ifdef ERR_ERWIN_ADAM_NAME

#include <ERR_ADAM.h>

#ifdef ERR_ERWIN_VERSION
#define ERR_ERWIN_VERSION ERR_ERWIN_VERSION
#endif
#ifdef ERR_ERWIN_CPP_ONLY
#define ERR_ERWIN_CPP_ONLY ERR_ERWIN_CPP_ONLY
#endif
#ifdef ERR_ERWIN_DEFAULT_ASSERTION_FAILED_HANDLER
#define ERR_ERWIN_DEFAULT_ASSERTION_FAILED_HANDLER ERR_ERWIN_DEFAULT_ASSERTION_FAILED_HANDLER
#endif
#ifdef ERR_ERWIN_ERROR_PRINT
#define ERR_ERWIN_ERROR_PRINT ERR_ERWIN_ERROR_PRINT
#endif
#ifdef ERR_ERWIN_ERROR_STREAM
#define ERR_ERWIN_ERROR_STREAM ERR_ERWIN_ERROR_STREAM
#endif
#ifdef ERR_ERWIN_EXPORT
#define ERR_ERWIN_EXPORT ERR_ERWIN_EXPORT
#endif
#ifdef ERR_ERWIN_INLINE_PERHAPS
#define ERR_ERWIN_INLINE_PERHAPS ERR_ERWIN_INLINE_PERHAPS
#endif
#ifdef ERR_ERWIN_OPTIMISE_SIZE
#define ERR_ERWIN_OPTIMISE_SIZE ERR_ERWIN_OPTIMISE_SIZE
#endif
#ifdef ERR_ERWIN_RAND_MAX
#define ERR_ERWIN_RAND_MAX ERR_ERWIN_RAND_MAX
#endif
#ifdef ERR_ERWIN_NEED_DET_RANDOM
#define ERR_ERWIN_NEED_DET_RANDOM ERR_ERWIN_NEED_DET_RANDOM
#endif
#ifdef ERR_ERWIN_RANDOM
#define ERR_ERWIN_RANDOM ERR_ERWIN_RANDOM
#endif
#ifdef ERR_ERWIN_RANDOM_FUNC
#define ERR_ERWIN_RANDOM_FUNC ERR_ERWIN_RANDOM_FUNC
#endif
#ifdef ERR_ERWIN_THREAD_SAFE
#define ERR_ERWIN_THREAD_SAFE ERR_ERWIN_THREAD_SAFE
#endif
#ifdef ERR_ERWIN_TCALLOC
#define ERR_ERWIN_TCALLOC ERR_ERWIN_TCALLOC
#endif
#ifdef ERR_ERWIN_TMALLOC
#define ERR_ERWIN_TMALLOC ERR_ERWIN_TMALLOC
#endif
#ifdef ERR_ERWIN_TO_BOOL
#define ERR_ERWIN_TO_BOOL ERR_ERWIN_TO_BOOL
#endif
#ifdef ERR_ERWIN_TREALLOC_ARRAY
#define ERR_ERWIN_TREALLOC_ARRAY ERR_ERWIN_TREALLOC_ARRAY
#endif
#ifdef ERR_ERWIN_TREALLOC_ATOMS
#define ERR_ERWIN_TREALLOC_ATOMS ERR_ERWIN_TREALLOC_ATOMS
#endif
#ifdef ERR_ERWIN_TFREE
#define ERR_ERWIN_TFREE ERR_ERWIN_TFREE
#endif
#ifdef ERR_BOOL_DEFINED
#define ERR_BOOL_DEFINED ERR_BOOL_DEFINED
#endif
#ifdef ERR_ERWIN_FALSE
#define ERR_ERWIN_FALSE ERR_ERWIN_FALSE
#endif
#ifdef ERR_ERWIN_TRUE
#define ERR_ERWIN_TRUE ERR_ERWIN_TRUE
#endif
#ifdef ERR_ERWIN_EXPLICIT
#define ERR_ERWIN_EXPLICIT ERR_ERWIN_EXPLICIT
#endif
#ifdef ERR_ERWIN_USE_EXPLICIT
#define ERR_ERWIN_USE_EXPLICIT ERR_ERWIN_USE_EXPLICIT
#endif
#ifdef ERR_ERWIN_USE_MUTABLE
#define ERR_ERWIN_USE_MUTABLE ERR_ERWIN_USE_MUTABLE
#endif
#ifdef ERR_ERWIN_MUTABLE
#define ERR_ERWIN_MUTABLE ERR_ERWIN_MUTABLE
#endif

#else /* !defined(ERR_ERWIN_ADAM_NAME) */

#define ERR_ERWIN_VERSION(X,Y,Z) (((X) * 1000000UL) | ((Y) * 10000UL) | (Z))

/* Compatibility #defines */
#ifndef ERR_ERWIN_COMPAT_VERSION_CODE
#define ERR_ERWIN_COMPAT_VERSION_CODE ERR_ERWIN_VERSION(999,0,0)
#endif /* !defined ERR_ERWIN_COMPAT_VERSION_CODE */

#if !defined(ERR_ERWINMM_COMPAT1)
#  if ERR_ERWIN_COMPAT_VERSION_CODE < ERR_ERWIN_VERSION(2,0,0)
#    define ERR_ERWIN_COMPAT1 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_228)
#  if defined(ERR_ERWINMM_COMPAT1) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,228)
#    define ERR_ERWIN_COMPAT_2_0_228 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_236)
#  if defined(ERR_ERWIN_COMPAT_2_0_228) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,236)
#    define ERR_ERWIN_COMPAT_2_0_236 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_241)
#  if defined(ERR_ERWIN_COMPAT_2_0_236) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,241)
#    define ERR_ERWIN_COMPAT_2_0_241 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_249)
#  if defined(ERR_ERWIN_COMPAT_2_0_241) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,249)
#    define ERR_ERWIN_COMPAT_2_0_249 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_250)
#  if defined(ERR_ERWIN_COMPAT_2_0_249) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,250)
#    define ERR_ERWIN_COMPAT_2_0_250 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_260)
#  if defined(ERR_ERWIN_COMPAT_2_0_250) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,260)
#    define ERR_ERWIN_COMPAT_2_0_260 1
#  endif
#endif

#if !defined(ERR_ERWIN_COMPAT_2_0_264)
#  if defined(ERR_ERWIN_COMPAT_2_0_260) || ERR_ERWIN_COMPAT_VERSION_CODE <= ERR_ERWIN_VERSION(2,0,264)
#    define ERR_ERWIN_COMPAT_2_0_264 1
#  endif
#endif


/* C++ hack for some compilers */
#if defined(cplusplus) && !defined(__cplusplus)
#  define __cplusplus 1
#endif

#if defined(c_plusplus) && !defined(__cplusplus)
#  define __cplusplus 1
#endif

/* Is this MSVC?  We re-decide that here now, ignoring the -DERWIN_DOS that might
 * already be defined. */
#undef ERWIN_MSVC
#if defined(_MSC_VER)
#  define ERWIN_MSVC 1
#endif

#undef ERWIN_DOS
#if defined(_WIN32) || defined(__WIN32__) || defined(__TOS_WIN__)
#  define ERWIN_DOS
#endif

/* ********************************************************************** */
/* #define ERWIN_IGNORE_BROKEN_MS_COMPILER 0 */
/*
 * By default, do not ignore a broken MS compiler, but disable some
 * functions instead.
 */
#ifndef ERWIN_IGNORE_BROKEN_MS_COMPILER
#define ERWIN_IGNORE_BROKEN_MS_COMPILER 0
#endif /* !defined ERWIN_IGNORE_BROKEN_MS_COMPILER */

/* Is this (Open)Watcom C?
 */
#undef ERWIN_WATCOM
#if defined(__WATCOMC__)
#  define ERWIN_WATCOM 1
#endif


/* GNU C checks (before config.h is included because of #undef inline) */
#ifdef __GNUC__

#  undef inline

#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
#    define ERWIN_GNUC_V27X
#  endif
#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)
#    define ERWIN_GNUC_V28X
#  endif
#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 9)
#    define ERWIN_GNUC_V29X
#  endif
#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 0)
#    define ERWIN_GNUC_V30X
#  endif
#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
#    define ERWIN_GNUC_V31X
#  endif
#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 2)
#    define ERWIN_GNUC_V32X
#  endif
#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
#    define ERWIN_GNUC_V33X
#  endif
#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    define ERWIN_GNUC_V34X
#  endif
#  if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 0)
#    define ERWIN_GNUC_V40X
#  endif
#  if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)
#    define ERWIN_GNUC_V41X
#  endif
#  if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
#    define ERWIN_GNUC_V42X
#  endif
#  if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
#    define ERWIN_GNUC_V43X
#  endif

#  ifndef ERWIN_NO_ASM
#    ifdef __i386__
#      if defined(ERWIN_GNUC_V29X)
#         define ERWIN_GNUC_I386_ASM_NEW
#      elif defined(ERWIN_GNUC_V27X)
#         define ERWIN_GNUC_I386_ASM_OLD
#      endif
#    endif
#  endif

#  ifndef ERWIN_NO_ASM
#    if defined(__ppc__) || defined(__powerpc__)
#      if defined(ERWIN_GNUC_V29X)
#         define ERWIN_GNUC_PPC_ASM_NEW
#      endif
#    endif
#  endif

#  ifndef ERWIN_NO_ASM
#    ifdef __x86_64__
#      if defined(ERWIN_GNUC_V29X)
#         define ERWIN_GNUC_X86_64_ASM_NEW
#      endif
#    endif
#  endif

#endif /* defined(__GNUC__) */

#if 1
#  ifndef ERWIN_64BIT
#  define ERWIN_64BIT
#  endif /* !defined ERWIN_64BIT */
      /* Deprecated.  Use SIZEOF_VOIDP oder SIZEOF_LONG or whatever instead of
       * this coarse-grained thing. */
#else
#  error "This is code is to be deleted."
#  if defined(__LP64__)  || defined(__alpha__)  || defined(__ia64__)   || defined(__ppc64__)  || defined(__s390x__)  || defined(__x86_64__)
#    define ERWIN_64BIT 1
#  else
#    define ERWIN_64BIT 0
#  endif
#endif

#ifndef ERWIN_ARCH_FAST_MUL
#define ERWIN_ARCH_FAST_MUL 1
#endif /* !defined ERWIN_ARCH_FAST_MUL */
   /* FIXME: make this a configure test, or set it per architecture. */

#ifdef ERWIN_GNUC_V30X
#  ifndef ERWIN_EXPECT
#  define ERWIN_EXPECT(X,Y)   __builtin_expect(X,Y)
#  endif /* !defined ERWIN_EXPECT */
#endif

#ifndef ERWIN_EXPECT
#define ERWIN_EXPECT(X,Y) (X)
#endif /* !defined ERWIN_EXPECT */

#ifndef ERWIN_LIKELY
#define ERWIN_LIKELY(X) ERWIN_EXPECT(!!(X), 1)
#endif /* !defined ERWIN_LIKELY */
   /* 'I think condition X is true.' */
   /* Use as follows:
    *     if (ERWIN_LIKELY(x > 5)) {
    *        ...
    *     }
    *     else {
    *        ...
    *     }
    * The macro casts to bool (by using '!') so you can use it with pointers, too.
    */

#ifndef ERWIN_UNLIKELY
#define ERWIN_UNLIKELY(X) ERWIN_EXPECT(!!(X), 0)
#endif /* !defined ERWIN_UNLIKELY */
   /* 'I think condition X is false.' */

/* Decide which configure file we need */
#ifdef ERWIN_DOS

#  include <limits.h>
#  include <stdlib.h>

/* MSVC */
#  ifdef ERWIN_MSVC

#    ifndef ERWIN_NO_ASM
#      ifdef _M_IX86
#        define ERWIN_MSVC_I386_ASM
#      endif
#    endif

#    ifdef ERR_ERWIN_COMPILING
#      include "error/erwin/confmsvc.h"
#    else
#      include <error/erwin/confmsvc.h>
#    endif

#    ifndef ERR_ERWIN_OPTIMISE
#    define ERR_ERWIN_OPTIMISE      1
#    endif /* !defined ERR_ERWIN_OPTIMISE */
#    ifndef ERR_ERWIN_OPTIMISE_SIZE
#    define ERR_ERWIN_OPTIMISE_SIZE 1
#    endif /* !defined ERR_ERWIN_OPTIMISE_SIZE */

#  endif /* defined(ERWIN_MSVC) */

/* Watcom */
#  ifdef ERWIN_WATCOM

#    ifndef ERWIN_NO_ASM
#      ifdef _M_IX86
#        define ERWIN_WATCOM_I386_ASM
#      endif
#    endif

#    ifdef ERR_ERWIN_COMPILING
#      include "error/erwin/confwtcm.h"
#    else
#      include <error/erwin/confwtcm.h>
#    endif

#    ifndef ERR_ERWIN_OPTIMISE
#    define ERR_ERWIN_OPTIMISE      1
#    endif /* !defined ERR_ERWIN_OPTIMISE */
#    ifndef ERR_ERWIN_OPTIMISE_SIZE
#    define ERR_ERWIN_OPTIMISE_SIZE 1
#    endif /* !defined ERR_ERWIN_OPTIMISE_SIZE */

#  endif /* defined(ERWIN_WATCOM) */

/* djgpp */
#  ifdef ERWIN_CROSS
#    ifdef ERR_ERWIN_COMPILING
#      include "error/erwin/confdj.h"
#    else
#      include <error/erwin/confdj.h>
#    endif

#    ifndef ERR_ERWIN_OPTIMISE
#    define ERR_ERWIN_OPTIMISE      1
#    endif /* !defined ERR_ERWIN_OPTIMISE */
#    ifndef ERR_ERWIN_OPTIMISE_SIZE
#    define ERR_ERWIN_OPTIMISE_SIZE 1
#    endif /* !defined ERR_ERWIN_OPTIMISE_SIZE */

#  endif /* defined(ERWIN_CROSS) */

#else /* defined(ERWIN_DOS) */

#define ERWIN_UNIX 1

/* Unix compilers configured via configure script: */
#  ifdef ERR_ERWIN_COMPILING
#    include "error/erwin/config.h"
#  else
#    include <error/erwin/config.h>
#  endif

#  ifdef HAVE_LIMITS_H
#    include <limits.h>
#  endif

#  ifdef HAVE_STDLIB_H
#    include <stdlib.h>
#  endif

#endif /* defined(ERWIN_DOS) */

/* Some very simple settings wrt. Win/Unix path issues. */
#ifndef ERWIN_PATH_SEP
#define ERWIN_PATH_SEP '/'
#endif /* !defined ERWIN_PATH_SEP */
#ifndef ERWIN_PATH_SEP_STR
#define ERWIN_PATH_SEP_STR "/"
#endif /* !defined ERWIN_PATH_SEP_STR */
#ifndef ERWIN_DIR_LIST_SEP
#define ERWIN_DIR_LIST_SEP ':'
#endif /* !defined ERWIN_DIR_LIST_SEP */
#ifndef ERWIN_DIR_LIST_SEP_STR
#define ERWIN_DIR_LIST_SEP_STR ":"
#endif /* !defined ERWIN_DIR_LIST_SEP_STR */
#ifndef ERWIN_GLOBAL_CONF_DIR
#define ERWIN_GLOBAL_CONF_DIR "/etc"
#endif /* !defined ERWIN_GLOBAL_CONF_DIR */
#ifndef ERWIN_GLOBAL_CONF_EXT
#define ERWIN_GLOBAL_CONF_EXT ".conf"
#endif /* !defined ERWIN_GLOBAL_CONF_EXT */
#ifndef ERWIN_LOCAL_CONF_PREFIX
#define ERWIN_LOCAL_CONF_PREFIX "."
#endif /* !defined ERWIN_LOCAL_CONF_PREFIX */
#ifndef ERWIN_LOCAL_CONF_EXT
#define ERWIN_LOCAL_CONF_EXT "rc"
#endif /* !defined ERWIN_LOCAL_CONF_EXT */

/* Does the compiler know `long long'?
 *
 * Note: this must *not* be any of the types char,short,int,long, since in C++, we
 *       must be able to overlong functions with int, long, and ERWIN_LONG_LONG,
 *       so we need distinct types.
 */
#ifndef ERWIN_LONG_LONG
#  ifdef SIZEOF_LONG_LONG
#    if SIZEOF_LONG_LONG > 0

#      define ERWIN_LONG_LONG         long long

#      define ERWIN_LL_AUX2(X)        X ## LL
#      define ERWIN_LL_AUX(X)         ERWIN_LL_AUX2(X)
#      define ERWIN_LL(X)             ERWIN_LL_AUX(X)

#      define ERWIN_ULL_AUX2(X)       X ## ULL
#      define ERWIN_ULL_AUX(X)        ERWIN_ULL_AUX2(X)
#      define ERWIN_ULL(X)            ERWIN_ULL_AUX(X)

#      define ERWIN_SIZEOF_LONG_LONG  SIZEOF_LONG_LONG

#      define ERWIN_LONG_LONG_V2      1
#    endif
#  endif
#endif

#define ERWIN_L_AUX2(X)         X ## L
#define ERWIN_L_AUX(X)          ERWIN_L_AUX2(X)
#define ERWIN_L(X)              ERWIN_L_AUX(X)

#define ERWIN_UL_AUX2(X)        X ## UL
#define ERWIN_UL_AUX(X)         ERWIN_UL_AUX2(X)
#define ERWIN_UL(X)             ERWIN_UL_AUX(X)

#define ERWIN_F_AUX2(X)         X ## F
#define ERWIN_F_AUX(X)          ERWIN_F_AUX2(X)
#define ERWIN_F(X)              ERWIN_F_AUX(X)

/* Check whether we have int64_t but no long long.
 * (E.g. gcc with -ansi) */
#if !defined(ERWIN_LONG_LONG) && defined(SIZEOF_UINT64_T) && defined(SIZEOF_INT64_T) && defined(__INT64_C) && defined(__UINT64_C)
#  ifdef HAVE_STDINT_H
#    define __STDC_CONSTANT_MACROS 1
#    include <inttypes.h>
     /* FIXME:  We should use u?int(8|16|32|64) for ERWIN_[SU](8|16|32|64) if
      *         available so that the definitions are consistent with the
      *         system definitions.
      * FIXME2: This requires that inttypes.h is included all the time.  Think
      *         about whether that is good or not.
      */
#  endif
#  define ERWIN_LONG_LONG          int64_t
#  define ERWIN_UNSIGNED_LONG_LONG uint64_t
#  define ERWIN_LL_AUX(X)          INT64_C(X)
#  define ERWIN_LL(X)              ERWIN_LL_AUX(X)
#  define ERWIN_ULL_AUX(X)         UINT64_C(X)
#  define ERWIN_ULL(X)             ERWIN_ULL_AUX(X)
#  define ERWIN_SIZEOF_LONG_LONG   SIZEOF_INT64_T
#  define ERWIN_LONG_LONG_V2       1
#endif

/* Unsigned type */
#ifdef ERWIN_LONG_LONG
#  ifndef ERWIN_UNSIGNED_LONG_LONG
#  define ERWIN_UNSIGNED_LONG_LONG unsigned ERWIN_LONG_LONG
#  endif /* !defined ERWIN_UNSIGNED_LONG_LONG */
#endif /* defined ERWIN_LONG_LONG */

/* Check for old Erwin headers included before and repair the
 * situation by adding a definition for ERWIN_SIZEOF_LONG_LONG: */
#if !defined(ERWIN_LONG_LONG_V2) && !defined(ERWIN_SIZEOF_LONG_LONG)
#  ifdef __GNUC__
#    warning "There is an old Erwin header file somewhere included before.  Trying to repair."
#  endif
#  define ERWIN_SIZEOF_LONG_LONG  SIZEOF_LONG_LONG
#  define ERWIN_LONG_LONG_V2      1
#endif


#if SIZEOF_LONG_DOUBLE > 0
#  ifndef ERWIN_LONG_DOUBLE
#  define ERWIN_LONG_DOUBLE long double
#  endif /* !defined ERWIN_LONG_DOUBLE */
#endif


/* We might still not be allowed to use 64 bit ints. */
#if defined(__STRICT_ANSI__) || !defined(CONFIG_WITH_LONG_LONG)
#  undef ERWIN_LONG_LONG
#  undef ERWIN_UNSIGNED_LONG_LONG
#  undef ERWIN_LONG_DOUBLE
#endif


#ifdef ERWIN_LONG_LONG
#ifndef ERWIN_SIGNED_LONG_LONG
#define ERWIN_SIGNED_LONG_LONG ERWIN_LONG_LONG
#endif /* !defined ERWIN_SIGNED_LONG_LONG */
#endif /* defined ERWIN_LONG_LONG */

/* Prefer ERWIN_LONG_LONG for 64 bit int, so that 32 bit and 64 bit machines
 * are likely to have the same definitions for all ERWIN_(S|U)(8|16|32|64)
 * types.  This will hopefully make life easier.  (This contradicts the
 * definitions of glibc's (u)int64_t, however.)
 */
/* FIXME: Make ERWIN_S64 and ERWIN_U64 usable as C++ style cast.  We currently
 *        don't do that because the fallback definition of ERWIN_UNSIGNED_LONG_LONG
 *        requires ERWIN_LONG_LONG to be a macro, not a typedef.  Therefore,
 *        making both macros be typedefs would break downward compatibility (unless
 *        we implement a hack with typedef + #undef + #define...).
 */

#if defined(ERWIN_S32) && !defined(ERWIN_S32_C)
#  ifdef __GNUC__
#    warning "There is an old Erwin header file somewhere included before.  Trying to repair."
#  endif
#  undef ERWIN_S8
#  undef ERWIN_U8
#  undef ERWIN_S16
#  undef ERWIN_U16
#  undef ERWIN_S32
#  undef ERWIN_U32
#  undef ERWIN_S64
#  undef ERWIN_U64
#endif

#if 0
#if defined(ERWIN_S32) && !defined(ERWIN_UNSIGNED_SHORT)
#  ifdef __GNUC__
#    warning "There is an old Erwin header file somewhere included before.  Trying to repair."
#  endif
#  undef ERWIN_S8
#  undef ERWIN_U8
#  undef ERWIN_S16
#  undef ERWIN_U16
#  undef ERWIN_S32
#  undef ERWIN_U32
#  undef ERWIN_S64
#  undef ERWIN_U64
#endif
#endif

#ifndef ERWIN_S32
/* Ensure that the ERWIN_[SU]... macros can be used in C++ style casts and still
 * be shown in compiler messages as the underlying type they really are. */
typedef unsigned char  ERWIN_UNSIGNED_CHAR;
typedef signed char    ERWIN_SIGNED_CHAR;
typedef unsigned short ERWIN_UNSIGNED_SHORT;
typedef unsigned long  ERWIN_UNSIGNED_LONG;
#endif

#ifndef ERWIN_S64
#if defined(ERWIN_SIZEOF_LONG_LONG) && ERWIN_SIZEOF_LONG_LONG == 8 && defined(ERWIN_LONG_LONG)
#  define ERWIN_S64                ERWIN_LONG_LONG
#  define ERWIN_U64                ERWIN_UNSIGNED_LONG_LONG
#  define ERWIN_S64_C              ERWIN_LL
#  define ERWIN_U64_C              ERWIN_ULL
#  ifndef ERWIN_S64_TYPE_INFO
#  define ERWIN_S64_TYPE_INFO     ERWIN_LONG_LONG_TYPE_INFO
#  endif /* !defined ERWIN_S64_TYPE_INFO */
#  ifndef ERWIN_U64_TYPE_INFO
#  define ERWIN_U64_TYPE_INFO     ERWIN_UNSIGNED_LONG_LONG_TYPE_INFO
#  endif /* !defined ERWIN_U64_TYPE_INFO */
#  ifndef ERR_ERWIN_S64_CMP
#  define ERR_ERWIN_S64_CMP    ERR_ERWIN_LONG_LONG_CMP
#  endif /* !defined ERR_ERWIN_S64_CMP */
#  ifndef ERR_ERWIN_U64_CMP
#  define ERR_ERWIN_U64_CMP    ERR_ERWIN_UNSIGNED_LONG_LONG_CMP
#  endif /* !defined ERR_ERWIN_U64_CMP */
#  ifndef ERR_ERWIN_S64_HASH
#  define ERR_ERWIN_S64_HASH   ERR_ERWIN_LONG_LONG_HASH
#  endif /* !defined ERR_ERWIN_S64_HASH */
#  ifndef ERR_ERWIN_U64_HASH
#  define ERR_ERWIN_U64_HASH   ERR_ERWIN_UNSIGNED_LONG_LONG_HASH
#  endif /* !defined ERR_ERWIN_U64_HASH */
#elif SIZEOF_INT == 8
#  define ERWIN_S64                int
#  define ERWIN_U64                unsigned
#  define ERWIN_S64_C(X)           X
#  define ERWIN_U64_C(X)           X
#  ifndef ERWIN_S64_TYPE_INFO
#  define ERWIN_S64_TYPE_INFO     int_TYPE_INFO
#  endif /* !defined ERWIN_S64_TYPE_INFO */
#  ifndef ERWIN_U64_TYPE_INFO
#  define ERWIN_U64_TYPE_INFO     unsigned_TYPE_INFO
#  endif /* !defined ERWIN_U64_TYPE_INFO */
#  ifndef ERR_ERWIN_S64_CMP
#  define ERR_ERWIN_S64_CMP    ERR_INT_CMP
#  endif /* !defined ERR_ERWIN_S64_CMP */
#  ifndef ERR_ERWIN_U64_CMP
#  define ERR_ERWIN_U64_CMP    ERR_UNSIGNED_CMP
#  endif /* !defined ERR_ERWIN_U64_CMP */
#  ifndef ERR_ERWIN_S64_HASH
#  define ERR_ERWIN_S64_HASH   ERR_INT_HASH
#  endif /* !defined ERR_ERWIN_S64_HASH */
#  ifndef ERR_ERWIN_U64_HASH
#  define ERR_ERWIN_U64_HASH   ERR_UNSIGNED_HASH
#  endif /* !defined ERR_ERWIN_U64_HASH */
#elif SIZEOF_LONG == 8
#  define ERWIN_S64                long
#  define ERWIN_U64                ERWIN_UNSIGNED_LONG
#  define ERWIN_S64_C              ERWIN_L
#  define ERWIN_U64_C              ERWIN_UL
#  ifndef ERWIN_S64_TYPE_INFO
#  define ERWIN_S64_TYPE_INFO     long_TYPE_INFO
#  endif /* !defined ERWIN_S64_TYPE_INFO */
#  ifndef ERWIN_U64_TYPE_INFO
#  define ERWIN_U64_TYPE_INFO     unsigned_long_TYPE_INFO
#  endif /* !defined ERWIN_U64_TYPE_INFO */
#  ifndef ERR_ERWIN_S64_CMP
#  define ERR_ERWIN_S64_CMP    ERR_LONG_CMP
#  endif /* !defined ERR_ERWIN_S64_CMP */
#  ifndef ERR_ERWIN_U64_CMP
#  define ERR_ERWIN_U64_CMP    ERR_UNSIGNED_LONG_CMP
#  endif /* !defined ERR_ERWIN_U64_CMP */
#  ifndef ERR_ERWIN_S64_HASH
#  define ERR_ERWIN_S64_HASH   ERR_LONG_HASH
#  endif /* !defined ERR_ERWIN_S64_HASH */
#  ifndef ERR_ERWIN_U64_HASH
#  define ERR_ERWIN_U64_HASH   ERR_UNSIGNED_LONG_HASH
#  endif /* !defined ERR_ERWIN_U64_HASH */
#elif SIZEOF_LONG_LONG == 8 && defined(ERWIN_LONG_LONG)
#  define ERWIN_S64                ERWIN_LONG_LONG
#  define ERWIN_U64                ERWIN_UNSIGNED_LONG_LONG
#  define ERWIN_S64_C              ERWIN_LL
#  define ERWIN_U64_C              ERWIN_ULL
#  ifndef ERWIN_S64_TYPE_INFO
#  define ERWIN_S64_TYPE_INFO     long_long_TYPE_INFO
#  endif /* !defined ERWIN_S64_TYPE_INFO */
#  ifndef ERWIN_U64_TYPE_INFO
#  define ERWIN_U64_TYPE_INFO     unsigned_long_long_TYPE_INFO
#  endif /* !defined ERWIN_U64_TYPE_INFO */
#  ifndef ERR_ERWIN_S64_CMP
#  define ERR_ERWIN_S64_CMP    ERR_LONG_LONG_CMP
#  endif /* !defined ERR_ERWIN_S64_CMP */
#  ifndef ERR_ERWIN_U64_CMP
#  define ERR_ERWIN_U64_CMP    ERR_UNSIGNED_LONG_LONG_CMP
#  endif /* !defined ERR_ERWIN_U64_CMP */
#  ifndef ERR_ERWIN_S64_HASH
#  define ERR_ERWIN_S64_HASH   ERR_LONG_LONG_HASH
#  endif /* !defined ERR_ERWIN_S64_HASH */
#  ifndef ERR_ERWIN_U64_HASH
#  define ERR_ERWIN_U64_HASH   ERR_UNSIGNED_LONG_LONG_HASH
#  endif /* !defined ERR_ERWIN_U64_HASH */
#endif
#endif /* ERWIN_S64 */

#ifndef ERWIN_S32
#if SIZEOF_INT == 4
#  define ERWIN_S32                int
#  define ERWIN_U32                unsigned
#  define ERWIN_S32_C(X)           X
#  define ERWIN_U32_C(X)           X
#  ifndef ERWIN_S32_TYPE_INFO
#  define ERWIN_S32_TYPE_INFO     int_TYPE_INFO
#  endif /* !defined ERWIN_S32_TYPE_INFO */
#  ifndef ERWIN_U32_TYPE_INFO
#  define ERWIN_U32_TYPE_INFO     unsigned_TYPE_INFO
#  endif /* !defined ERWIN_U32_TYPE_INFO */
#  ifndef ERR_ERWIN_S32_CMP
#  define ERR_ERWIN_S32_CMP    ERR_INT_CMP
#  endif /* !defined ERR_ERWIN_S32_CMP */
#  ifndef ERR_ERWIN_U32_CMP
#  define ERR_ERWIN_U32_CMP    ERR_UNSIGNED_CMP
#  endif /* !defined ERR_ERWIN_U32_CMP */
#  ifndef ERR_ERWIN_S32_HASH
#  define ERR_ERWIN_S32_HASH   ERR_INT_HASH
#  endif /* !defined ERR_ERWIN_S32_HASH */
#  ifndef ERR_ERWIN_U32_HASH
#  define ERR_ERWIN_U32_HASH   ERR_UNSIGNED_HASH
#  endif /* !defined ERR_ERWIN_U32_HASH */
#elif SIZEOF_LONG == 4
#  define ERWIN_S32                long
#  define ERWIN_U32                ERWIN_UNSIGNED_LONG
#  define ERWIN_S32_C              ERWIN_L
#  define ERWIN_U32_C              ERWIN_UL
#  ifndef ERWIN_S32_TYPE_INFO
#  define ERWIN_S32_TYPE_INFO     long_TYPE_INFO
#  endif /* !defined ERWIN_S32_TYPE_INFO */
#  ifndef ERWIN_U32_TYPE_INFO
#  define ERWIN_U32_TYPE_INFO     unsigned_long_TYPE_INFO
#  endif /* !defined ERWIN_U32_TYPE_INFO */
#  ifndef ERR_ERWIN_S32_CMP
#  define ERR_ERWIN_S32_CMP    ERR_LONG_CMP
#  endif /* !defined ERR_ERWIN_S32_CMP */
#  ifndef ERR_ERWIN_U32_CMP
#  define ERR_ERWIN_U32_CMP    ERR_UNSIGNED_LONG_CMP
#  endif /* !defined ERR_ERWIN_U32_CMP */
#  ifndef ERR_ERWIN_S32_HASH
#  define ERR_ERWIN_S32_HASH   ERR_LONG_HASH
#  endif /* !defined ERR_ERWIN_S32_HASH */
#  ifndef ERR_ERWIN_U32_HASH
#  define ERR_ERWIN_U32_HASH   ERR_UNSIGNED_LONG_HASH
#  endif /* !defined ERR_ERWIN_U32_HASH */
#endif
#endif /* ERWIN_S32 */

#ifndef ERWIN_S16
#if SIZEOF_SHORT == 2
#  define ERWIN_S16                short
#  define ERWIN_U16                ERWIN_UNSIGNED_SHORT
#  ifndef ERWIN_S16_TYPE_INFO
#  define ERWIN_S16_TYPE_INFO     short_TYPE_INFO
#  endif /* !defined ERWIN_S16_TYPE_INFO */
#  ifndef ERWIN_U16_TYPE_INFO
#  define ERWIN_U16_TYPE_INFO     unsigned_short_TYPE_INFO
#  endif /* !defined ERWIN_U16_TYPE_INFO */
#  ifndef ERR_ERWIN_S16_CMP
#  define ERR_ERWIN_S16_CMP    ERR_SHORT_CMP
#  endif /* !defined ERR_ERWIN_S16_CMP */
#  ifndef ERR_ERWIN_U16_CMP
#  define ERR_ERWIN_U16_CMP    ERR_UNSIGNED_SHORT_CMP
#  endif /* !defined ERR_ERWIN_U16_CMP */
#  ifndef ERR_ERWIN_S16_HASH
#  define ERR_ERWIN_S16_HASH   ERR_SHORT_HASH
#  endif /* !defined ERR_ERWIN_S16_HASH */
#  ifndef ERR_ERWIN_U16_HASH
#  define ERR_ERWIN_U16_HASH   ERR_UNSIGNED_SHORT_HASH
#  endif /* !defined ERR_ERWIN_U16_HASH */
#elif SIZEOF_INT == 2
#  define ERWIN_S16                int
#  define ERWIN_U16                unsigned
#  ifndef ERWIN_S16_TYPE_INFO
#  define ERWIN_S16_TYPE_INFO     int_TYPE_INFO
#  endif /* !defined ERWIN_S16_TYPE_INFO */
#  ifndef ERWIN_U16_TYPE_INFO
#  define ERWIN_U16_TYPE_INFO     unsigned_int_TYPE_INFO
#  endif /* !defined ERWIN_U16_TYPE_INFO */
#  ifndef ERR_ERWIN_S16_CMP
#  define ERR_ERWIN_S16_CMP    ERR_INT_CMP
#  endif /* !defined ERR_ERWIN_S16_CMP */
#  ifndef ERR_ERWIN_U16_CMP
#  define ERR_ERWIN_U16_CMP    ERR_UNSIGNED_CMP
#  endif /* !defined ERR_ERWIN_U16_CMP */
#  ifndef ERR_ERWIN_S16_HASH
#  define ERR_ERWIN_S16_HASH   ERR_INT_HASH
#  endif /* !defined ERR_ERWIN_S16_HASH */
#  ifndef ERR_ERWIN_U16_HASH
#  define ERR_ERWIN_U16_HASH   ERR_UNSIGNED_HASH
#  endif /* !defined ERR_ERWIN_U16_HASH */
#endif
#endif /* ERWIN_S16 */

#ifndef ERWIN_S8
#define ERWIN_S8                   ERWIN_SIGNED_CHAR
#define ERWIN_U8                   ERWIN_UNSIGNED_CHAR
#ifndef ERWIN_S8_TYPE_INFO
#define ERWIN_S8_TYPE_INFO        signed_char_TYPE_INFO
#endif /* !defined ERWIN_S8_TYPE_INFO */
#ifndef ERWIN_U8_TYPE_INFO
#define ERWIN_U8_TYPE_INFO        unsigned_char_TYPE_INFO
#endif /* !defined ERWIN_U8_TYPE_INFO */
#ifndef ERR_ERWIN_S8_CMP
#define ERR_ERWIN_S8_CMP       ERR_SIGNED_CHAR_CMP
#endif /* !defined ERR_ERWIN_S8_CMP */
#ifndef ERR_ERWIN_U8_CMP
#define ERR_ERWIN_U8_CMP       ERR_UNSIGNED_CHAR_CMP
#endif /* !defined ERR_ERWIN_U8_CMP */
#ifndef ERR_ERWIN_S8_HASH
#define ERR_ERWIN_S8_HASH      ERR_SIGNED_CHAR_HASH
#endif /* !defined ERR_ERWIN_S8_HASH */
#ifndef ERR_ERWIN_U8_HASH
#define ERR_ERWIN_U8_HASH      ERR_UNSIGNED_CHAR_HASH
#endif /* !defined ERR_ERWIN_U8_HASH */
#endif /* ERWIN_S8 */

/* NOTE: We cannot handle sizeof(void(*)()) != sizeof(void*). */
#if SIZEOF_VOIDP <= SIZEOF_INT
#  define ERWIN_PTRINT             unsigned
#  ifndef ERWIN_PTRINT_TYPE_INFO
#  define ERWIN_PTRINT_TYPE_INFO  unsigned_TYPE_INFO
#  endif /* !defined ERWIN_PTRINT_TYPE_INFO */
#  ifndef ERR_PTRINT_CMP
#  define ERR_PTRINT_CMP       ERR_UNSIGNED_CMP
#  endif /* !defined ERR_PTRINT_CMP */
#  ifndef ERR_PTRINT_EQUAL
#  define ERR_PTRINT_EQUAL     ERR_UNSIGNED_EQUAL
#  endif /* !defined ERR_PTRINT_EQUAL */
#  ifndef ERR_PTRINT_HASH
#  define ERR_PTRINT_HASH      ERR_UNSIGNED_HASH
#  endif /* !defined ERR_PTRINT_HASH */
#elif SIZEOF_VOIDP <= SIZEOF_LONG
#  define ERWIN_PTRINT             ERWIN_UNSIGNED_LONG
#  ifndef ERWIN_PTRINT_TYPE_INFO
#  define ERWIN_PTRINT_TYPE_INFO  unsigned_long_TYPE_INFO
#  endif /* !defined ERWIN_PTRINT_TYPE_INFO */
#  ifndef ERR_PTRINT_CMP
#  define ERR_PTRINT_CMP       ERR_UNSIGNED_LONG_CMP
#  endif /* !defined ERR_PTRINT_CMP */
#  ifndef ERR_PTRINT_EQUAL
#  define ERR_PTRINT_EQUAL     ERR_UNSIGNED_LONG_EQUAL
#  endif /* !defined ERR_PTRINT_EQUAL */
#  ifndef ERR_PTRINT_HASH
#  define ERR_PTRINT_HASH      ERR_UNSIGNED_LONG_HASH
#  endif /* !defined ERR_PTRINT_HASH */
#elif defined(ERWIN_UNSIGNED_LONG_LONG) && SIZEOF_VOIDP <= ERWIN_SIZEOF_LONG_LONG
#  define ERWIN_PTRINT             ERWIN_UNSIGNED_LONG_LONG
#  ifndef ERWIN_PTRINT_TYPE_INFO
#  define ERWIN_PTRINT_TYPE_INFO  unsigned_long_long_TYPE_INFO
#  endif /* !defined ERWIN_PTRINT_TYPE_INFO */
#  ifndef ERR_PTRINT_CMP
#  define ERR_PTRINT_CMP       ERR_UNSIGNED_LONG_LONG_CMP
#  endif /* !defined ERR_PTRINT_CMP */
#  ifndef ERR_PTRINT_EQUAL
#  define ERR_PTRINT_EQUAL     ERR_UNSIGNED_LONG_LONG_EQUAL
#  endif /* !defined ERR_PTRINT_EQUAL */
#  ifndef ERR_PTRINT_HASH
#  define ERR_PTRINT_HASH      ERR_UNSIGNED_LONG_LONG_HASH
#  endif /* !defined ERR_PTRINT_HASH */
#else
#  error "Unable to define ERWIN_PTRINT: sizeof(void*) is larger than any known integer type"
#endif

/* For some macros that need the byte size, not the bit size: */
#ifndef ERWIN_UB1
#define ERWIN_UB1 ERWIN_U8
#endif /* !defined ERWIN_UB1 */
#ifndef ERWIN_UB2
#define ERWIN_UB2 ERWIN_U16
#endif /* !defined ERWIN_UB2 */
#ifndef ERWIN_UB4
#define ERWIN_UB4 ERWIN_U32
#endif /* !defined ERWIN_UB4 */
#ifdef ERWIN_U64
#ifndef ERWIN_UB8
#define ERWIN_UB8 ERWIN_U64
#endif /* !defined ERWIN_UB8 */
#endif /* defined ERWIN_U64 */
#ifndef ERWIN_SB1
#define ERWIN_SB1 ERWIN_S8
#endif /* !defined ERWIN_SB1 */
#ifndef ERWIN_SB2
#define ERWIN_SB2 ERWIN_S16
#endif /* !defined ERWIN_SB2 */
#ifndef ERWIN_SB4
#define ERWIN_SB4 ERWIN_S32
#endif /* !defined ERWIN_SB4 */
#ifdef ERWIN_S64
#ifndef ERWIN_SB8
#define ERWIN_SB8 ERWIN_S64
#endif /* !defined ERWIN_SB8 */
#endif /* defined ERWIN_S64 */

#ifndef ERWIN_WCHAR_T
#  if SIZEOF_WCHAR_T > 0
#    define ERWIN_WCHAR_T wchar_t
#  elif SIZEOF__WCHAR_T > 0
#    define ERWIN_WCHAR_T _wchar_t
#  elif SIZEOF___WCHAR_T > 0
#    define ERWIN_WCHAR_T __wchar_t
#  elif SIZEOF_INT >= 32
#    define ERWIN_WCHAR_T int
#  elif SIZEOF_LONG >= 32
#    define ERWIN_WCHAR_T long
#  endif
#endif

#ifndef ERWIN_WINT_T
#  if SIZEOF_WINT_T > 0
#    define ERWIN_WINT_T wint_t
#  elif SIZEOF__WINT_T > 0
#    define ERWIN_WINT_T _wint_t
#  elif SIZEOF___WINT_T > 0
#    define ERWIN_WINT_T __wint_t
#  elif SIZEOF_INT >= 32
#    define ERWIN_WINT_T int
#  elif SIZEOF_LONG >= 32
#    define ERWIN_WINT_T long
#  endif
#endif

#if defined(ERWIN_WCHAR_T) && defined(ERWIN_WINT_T) && defined(HAVE_WCRTOMB) && HAVE_WCRTOMB && defined(MB_CUR_MAX)
#  ifndef ERWIN_WIDE_CHARACTERS
#  define ERWIN_WIDE_CHARACTERS 1
#  endif /* !defined ERWIN_WIDE_CHARACTERS */
#endif

/* Pretend we can handle CHAR_BIT != 8.  This is in preparation for times
 * when we do support such architectures: */
#if defined(CHAR_BIT)
#  define ERWIN_CHAR_BIT CHAR_BIT
#elif defined(CHARBITS)
#  define ERWIN_CHAR_BIT CHARBITS
#elif defined(BITSPERBYTE)
#  define ERWIN_CHAR_BIT BITSPERBYTE
#else
#  define ERWIN_CHAR_BIT 8
#endif

#define ERWIN_BIT_SIZEOF(X) (sizeof(X) * ERWIN_CHAR_BIT)

/* But we really can't, so fail if CHAR_BIT != 8: */
#if ERWIN_CHAR_BIT != 8
#   error "We currently do not support CHAR_BIT != 8."
#endif

/* Define ERR_ERWIN_EXPLICIT to be empty or 'explicit'. */
#if defined(__cplusplus) && defined(HAVE_WORKING_EXPLICIT)
#  define ERR_ERWIN_EXPLICIT     explicit
#  define ERR_ERWIN_USE_EXPLICIT 1
#else
#  define ERR_ERWIN_EXPLICIT
#  define ERR_ERWIN_USE_EXPLICIT 0
#endif

/* Define ERR_ERWIN_MUTABLE to be empty or 'mutable'. */
#if defined(__cplusplus) && defined(HAVE_WORKING_MUTABLE)
#  define ERR_ERWIN_MUTABLE     mutable
#  define ERR_ERWIN_USE_MUTABLE 1
#else
#  define ERR_ERWIN_MUTABLE
#  define ERR_ERWIN_USE_MUTABLE 0
#endif


/* Attribute feature of GNU C. */
#ifndef GNUC_ATTRIBUTE
#  if defined(ERWIN_GNUC_V27X) && !defined(ERWIN_NO_CC_EXTENSIONS)
#    define GNUC_ATTRIBUTE(X) __attribute__(X)
   /*
    * #  ifdef  __cplusplus
    * #    define ERWIN_WEAK_STORAGE
    * #    define ERWIN_LINK_WEAK    __attribute__((weak))
    * #  else
    * #    define ERWIN_WEAK_STORAGE
    * #    define ERWIN_LINK_WEAK    __attribute__((weak))
    * #  endif
    */
#  else
#    define GNUC_ATTRIBUTE(X)
#  endif
#endif /* !defined(GNUC_ATTRIBUTE) */

#ifdef ERWIN_GNUC_V30X
#  ifndef GNUC_ATTRIBUTE_V30
#  define GNUC_ATTRIBUTE_V30(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V30 */
#endif
#ifndef GNUC_ATTRIBUTE_V30
#define GNUC_ATTRIBUTE_V30(X)
#endif /* !defined GNUC_ATTRIBUTE_V30 */

#ifdef ERWIN_GNUC_V31X
#  ifndef GNUC_ATTRIBUTE_V31
#  define GNUC_ATTRIBUTE_V31(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V31 */
#endif
#ifndef GNUC_ATTRIBUTE_V31
#define GNUC_ATTRIBUTE_V31(X)
#endif /* !defined GNUC_ATTRIBUTE_V31 */

#ifdef ERWIN_GNUC_V32X
#  ifndef GNUC_ATTRIBUTE_V32
#  define GNUC_ATTRIBUTE_V32(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V32 */
#endif
#ifndef GNUC_ATTRIBUTE_V32
#define GNUC_ATTRIBUTE_V32(X)
#endif /* !defined GNUC_ATTRIBUTE_V32 */

#ifdef ERWIN_GNUC_V33X
#  ifndef GNUC_ATTRIBUTE_V33
#  define GNUC_ATTRIBUTE_V33(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V33 */
#endif
#ifndef GNUC_ATTRIBUTE_V33
#define GNUC_ATTRIBUTE_V33(X)
#endif /* !defined GNUC_ATTRIBUTE_V33 */

#ifdef ERWIN_GNUC_V34X
#  ifndef GNUC_ATTRIBUTE_V34
#  define GNUC_ATTRIBUTE_V34(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V34 */
#endif
#ifndef GNUC_ATTRIBUTE_V34
#define GNUC_ATTRIBUTE_V34(X)
#endif /* !defined GNUC_ATTRIBUTE_V34 */

#ifdef ERWIN_GNUC_V40X
#  ifndef GNUC_ATTRIBUTE_V40
#  define GNUC_ATTRIBUTE_V40(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V40 */
#endif
#ifndef GNUC_ATTRIBUTE_V40
#define GNUC_ATTRIBUTE_V40(X)
#endif /* !defined GNUC_ATTRIBUTE_V40 */

#ifdef ERWIN_GNUC_V41X
#  ifndef GNUC_ATTRIBUTE_V41
#  define GNUC_ATTRIBUTE_V41(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V41 */
#endif
#ifndef GNUC_ATTRIBUTE_V41
#define GNUC_ATTRIBUTE_V41(X)
#endif /* !defined GNUC_ATTRIBUTE_V41 */

#ifdef ERWIN_GNUC_V42X
#  ifndef GNUC_ATTRIBUTE_V42
#  define GNUC_ATTRIBUTE_V42(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V42 */
#endif
#ifndef GNUC_ATTRIBUTE_V42
#define GNUC_ATTRIBUTE_V42(X)
#endif /* !defined GNUC_ATTRIBUTE_V42 */

#ifdef ERWIN_GNUC_V43X
#  ifndef GNUC_ATTRIBUTE_V43
#  define GNUC_ATTRIBUTE_V43(X)  GNUC_ATTRIBUTE(X)
#  endif /* !defined GNUC_ATTRIBUTE_V43 */
#endif
#ifndef GNUC_ATTRIBUTE_V43
#define GNUC_ATTRIBUTE_V43(X)
#endif /* !defined GNUC_ATTRIBUTE_V43 */

#if defined(__linux__) && (defined(__i386__) || defined (__x86_64__))
#  ifndef GNUC_ATTRIBUTE_V34_X86_LINUX
#  define GNUC_ATTRIBUTE_V34_X86_LINUX(X)  GNUC_ATTRIBUTE_V34(X)
#  endif /* !defined GNUC_ATTRIBUTE_V34_X86_LINUX */
#endif
#ifndef GNUC_ATTRIBUTE_V34_X86_LINUX
#define GNUC_ATTRIBUTE_V34_X86_LINUX(X)
#endif /* !defined GNUC_ATTRIBUTE_V34_X86_LINUX */

#ifndef ATTR_ALWAYS_INLINE
#define ATTR_ALWAYS_INLINE               GNUC_ATTRIBUTE_V31((__always_inline__))
#endif /* !defined ATTR_ALWAYS_INLINE */
#ifndef ATTR_CONST
#define ATTR_CONST                       GNUC_ATTRIBUTE((__const__))
#endif /* !defined ATTR_CONST */
#ifndef ATTR_DEPRECATED
#define ATTR_DEPRECATED                  GNUC_ATTRIBUTE_V31((__deprecated__))
#endif /* !defined ATTR_DEPRECATED */
#ifndef ATTR_FLATTEN
#define ATTR_FLATTEN                     GNUC_ATTRIBUTE_V41((__flatten__))
#endif /* !defined ATTR_FLATTEN */
#ifndef ATTR_FORMAT
#define ATTR_FORMAT(A)                   GNUC_ATTRIBUTE((__format__ A))
#endif /* !defined ATTR_FORMAT */
#ifndef ATTR_FORMAT_PRINTF
#define ATTR_FORMAT_PRINTF(A,B)          GNUC_ATTRIBUTE((__format__(__printf__,A,B)))
#endif /* !defined ATTR_FORMAT_PRINTF */
#ifndef ATTR_FORMAT_VPRINTF
#define ATTR_FORMAT_VPRINTF(A)           GNUC_ATTRIBUTE((__format__(__printf__,A,0)))
#endif /* !defined ATTR_FORMAT_VPRINTF */
#ifndef ATTR_MALLOC
#define ATTR_MALLOC                      GNUC_ATTRIBUTE_V30((__malloc__))
#endif /* !defined ATTR_MALLOC */
#ifndef ATTR_MAY_ALIAS
#define ATTR_MAY_ALIAS                   GNUC_ATTRIBUTE_V33((__may_alias__))
#endif /* !defined ATTR_MAY_ALIAS */
#ifndef ATTR_NOINLINE
#define ATTR_NOINLINE                    GNUC_ATTRIBUTE_V31((__noinline__))
#endif /* !defined ATTR_NOINLINE */
#ifndef ATTR_NONNULL
#define ATTR_NONNULL(A)                  GNUC_ATTRIBUTE_V33((__nonnull__ A))
#endif /* !defined ATTR_NONNULL */
#ifndef ATTR_NORETURN
#define ATTR_NORETURN                    GNUC_ATTRIBUTE((__noreturn__))
#endif /* !defined ATTR_NORETURN */
#ifndef ATTR_PURE
#define ATTR_PURE                        GNUC_ATTRIBUTE_V30((__pure__))
#endif /* !defined ATTR_PURE */
#ifndef ATTR_SECTION
#define ATTR_SECTION(X)                  GNUC_ATTRIBUTE_V34_X86_LINUX((__section__(X)))
#endif /* !defined ATTR_SECTION */
#ifndef ATTR_UNUSED
#define ATTR_UNUSED                      GNUC_ATTRIBUTE_V30((__unused__))
#endif /* !defined ATTR_UNUSED */
#ifndef ATTR_FUNC_UNUSED
#define ATTR_FUNC_UNUSED                 GNUC_ATTRIBUTE_V30((__unused__))
#endif /* !defined ATTR_FUNC_UNUSED */
#ifndef ATTR_TYPE_UNUSED
#define ATTR_TYPE_UNUSED                 GNUC_ATTRIBUTE_V30((__unused__))
#endif /* !defined ATTR_TYPE_UNUSED */
#ifndef ATTR_VARIABLE_UNUSED
#define ATTR_VARIABLE_UNUSED             GNUC_ATTRIBUTE((__unused__))
#endif /* !defined ATTR_VARIABLE_UNUSED */
#ifndef ATTR_USED
#define ATTR_USED                        GNUC_ATTRIBUTE_V31((__used__))
#endif /* !defined ATTR_USED */
#ifndef ATTR_WARN_UNUSED_RESULT
#define ATTR_WARN_UNUSED_RESULT          GNUC_ATTRIBUTE_V33((__warn_unused_result__))
#endif /* !defined ATTR_WARN_UNUSED_RESULT */
#ifndef ATTR_WEAK
#define ATTR_WEAK                        GNUC_ATTRIBUTE((__weak__))
#endif /* !defined ATTR_WEAK */

/* FIXME: Continue with the macro definitions for GNU attributes. */

#ifndef ATTR_ERRNO_PURE
#define ATTR_ERRNO_PURE
#endif /* !defined ATTR_ERRNO_PURE */
   /* This is just a marker for the developper to show that this function
    * would be pure, if it did not set the errno as a side effect.  It
    * is there to remind us of a suboptimal design (from the compiler's
    * POV)... */


#if defined(HAVE_STRERROR_R)
#  ifndef ERWIN_GET_STRERRNO
#  define ERWIN_GET_STRERRNO(S,N) ((void)(strerror_r(errno,S,N)))
#  endif /* !defined ERWIN_GET_STRERRNO */
#endif

#ifndef ERR_ERWIN_THREAD_SAFE
#  if defined ERWIN_MSVC || defined ERWIN_WATCOM
#    ifndef ERWIN_STRERRNO
#    define ERWIN_STRERRNO     (_strerror(NULL))
#    endif /* !defined ERWIN_STRERRNO */
#  else
#    ifndef ERWIN_STRERRNO
#    define ERWIN_STRERRNO     (strerror(errno))
#    endif /* !defined ERWIN_STRERRNO */
#  endif
#endif

#ifdef HAVE_STRNCPY
#ifdef ERWIN_STRERRNO
#  ifndef ERWIN_GET_STRERRNO
#  define ERWIN_GET_STRERRNO(S,N) ((void)strncpy(S,ERWIN_STRERRNO,N))
#  endif /* !defined ERWIN_GET_STRERRNO */
#endif /* defined ERWIN_STRERRNO */
#endif


#ifndef ERWIN_INLINE
#  if defined(__cplusplus)
#    define ERWIN_INLINE inline
#  elif defined(ERWIN_GNUC_V27X) && !defined(ERWIN_NO_CC_EXTENSIONS)
#    define ERWIN_INLINE __inline__
#  elif defined(ERWIN_GNUC_V27X) && defined(__STRICT_ANSI__)
#    define ERWIN_INLINE __inline__
#  elif defined(ERWIN_MSVC) && !defined(ERWIN_NO_CC_EXTENSIONS)
#    define ERWIN_INLINE _inline
#  elif defined(ERWIN_WATCOM) && !defined(ERWIN_NO_CC_EXTENSIONS)
#    define ERWIN_INLINE _inline
#  else
#    define ERWIN_INLINE inline
     /* This line looks strange.  But note that `inline' might be re-defined
      * by the configure script in config.h if the name is different or if it is
      * not working. */
#  endif
#endif

/*
 * GCC's ({ }) feature is deprecated since it does not work well with all versions
 * of the compiler.  Actually, the following defined are there for compatibility
 * only.  You should use do{ ... }while(0) literally. */
#ifndef ERWIN_BEGIN_GROUP
#  define ERWIN_BEGIN_GROUP  do{
#  define ERWIN_END_GROUP    }while(0)
#endif

/* Well, this might not be defined on every platform */
#ifdef PATH_MAX
#  ifndef ERWIN_PATH_MAX
#  define ERWIN_PATH_MAX PATH_MAX
#  endif /* !defined ERWIN_PATH_MAX */
#else
#  ifndef ERWIN_PATH_MAX
#  define ERWIN_PATH_MAX 256
#  endif /* !defined ERWIN_PATH_MAX */
#endif

/* Switch on thread safety in if obviously necessary.  There are two typical system
 * #defines that indicate that thread safety is requested.
 *
 * There is currently only one thing that might not be thread safe: the global
 * errno values for the data structures.  We are currently thinking about an
 * implementation that does not have them at all (so you need to check the return
 * values), but it is not easily implemented since the errno values are used
 * internally.
 */
#if defined(_REENTRANT) || defined(_THREAD_SAFE)
#  ifndef ERR_ERWIN_THREAD_SAFE
#  define ERR_ERWIN_THREAD_SAFE 1
#  endif /* !defined ERR_ERWIN_THREAD_SAFE */
#endif

/* We do not switch on thread safety just because a possible implementation
 * is requested.  Those macro defines are meant to be set for a given
 * architecture to give a hint which method is the best to implement thread
 * safety:
 *
 * #if defined(ERR_ERWIN_USE_PTHREAD) && ERR_ERWIN_USE_PTHREAD
 * #  define ?ERR_ERWIN_THREAD_SAFE 1
 * #endif
 * #if defined(ERR_ERWIN_USE_THREAD_KEYWORD) && ERR_ERWIN_USE_THREAD_KEYWORD
 * #  define ?ERR_ERWIN_THREAD_SAFE 1
 * #endif
 */

/* The preferred way to compile thread safe: we use the __thread keyword.
 * There is a nice configure test for this, so we usually find out
 * whether it is available.
 *
 * This is the most elegant and probably efficient method, so it is
 * preferred over other methods.  It is currently not supported
 * by all platforms (notably Mac OS X), but we will try to define this
 * such that it will be autodetected in many cases.
 *
 * Despite the configure check, the user can disable __thread by defining
 * ERR_ERWIN_USE_THREAD_KEYWORD to 0.  Setting that variable to 1 does
 * not force the usage of __thread, but requests it when possible (i.e.,
 * if we know that it works).  If you want to use __thread if possible
 * and otherwise use pthread (i.e., you know it works), you have to
 * define both macros to 1 (i.e., also ERR_ERWIN_USE_PTHREAD).
 *
 * Current macro logic:
 *
 * THREAD_SAFE USE_THREAD_KEYWORD USE_PTHREAD What happens?
 *
 * undef       whatever           whatever    no thread safety
 *
 * defined     undef or 1         undef       __thread if HAVE_THREAD_KEYWORD,
 *                                            otherwise pthread if available,
 *                                            otherwise manual impl.
 *
 * defined     undef or 1         0           __thread if HAVE_THREAD_KEYWORD,
 *                                            otherwise manual impl.
 *
 * defined     0                  undef or 1  pthread if available,
 *                                            otherwise manual impl.
 *
 * defined     0                  0           manual impl.
 *
 * defined     1                  1           __thread if HAVE_THREAD_KEYWORD,
 *                                            pthread otherwise
 *
 * ('manual impl.' means that there is no global _errno, but each object
 * has its own errno member.  This is quite inefficient...)
 */
/* if __thread does *not* work, we will not use it: */
#ifndef HAVE_THREAD_KEYWORD
#  undef ERR_ERWIN_USE_THREAD_KEYWORD
#  define ERR_ERWIN_USE_THREAD_KEYWORD 0
#endif
/* do not use __thread keyword if pthread is explicitly requested instead: */
#if defined(ERR_ERWIN_USE_PTHREAD) && ERR_ERWIN_USE_PTHREAD
#  ifndef ERR_ERWIN_USE_THREAD_KEYWORD
#  define ERR_ERWIN_USE_THREAD_KEYWORD 0
#  endif /* !defined ERR_ERWIN_USE_THREAD_KEYWORD */
#endif
/* if __thread does work, we try to use it only if thread safety is requested: */
#if defined(HAVE_THREAD_KEYWORD) && defined(ERR_ERWIN_THREAD_SAFE)
#  ifndef ERR_ERWIN_USE_THREAD_KEYWORD
#  define ERR_ERWIN_USE_THREAD_KEYWORD 1
#  endif /* !defined ERR_ERWIN_USE_THREAD_KEYWORD */
#endif
/* Otherwise, __thread is not used: */
#ifndef ERR_ERWIN_USE_THREAD_KEYWORD
#define ERR_ERWIN_USE_THREAD_KEYWORD 0
#endif /* !defined ERR_ERWIN_USE_THREAD_KEYWORD */


/* The __thread keyword might not actually be '__thread' (e.g. MSVC): */
#ifdef HAVE_THREAD_KEYWORD
#  ifndef ERWIN_THREAD_KEYWORD
#  define ERWIN_THREAD_KEYWORD __thread
#  endif /* !defined ERWIN_THREAD_KEYWORD */
#else
#  ifndef ERWIN_THREAD_KEYWORD
#  define ERWIN_THREAD_KEYWORD
#  endif /* !defined ERWIN_THREAD_KEYWORD */
#endif

/* Have another convenince macro to be __thread or empty. */
#if ERR_ERWIN_USE_THREAD_KEYWORD
#  ifndef ERR_ERWIN_THREAD_LOCAL
#  define ERR_ERWIN_THREAD_LOCAL ERWIN_THREAD_KEYWORD
#  endif /* !defined ERR_ERWIN_THREAD_LOCAL */
#else
#  ifndef ERR_ERWIN_THREAD_LOCAL
#  define ERR_ERWIN_THREAD_LOCAL
#  endif /* !defined ERR_ERWIN_THREAD_LOCAL */
#endif


/* And now for pthreads, another method to compile thread safe.
 * If we know it works, so can set HAVE_PTHRAD to 1 if it not
 * set otherwise.
 *
 * We might add a configure check to see whether pthreads work.
 */
#if defined(__APPLE__) && defined(__MACH__)
#  ifndef ERR_ERWIN_USE_PTHREAD
#  define ERR_ERWIN_USE_PTHREAD 1
#  endif /* !defined ERR_ERWIN_USE_PTHREAD */
#endif
/* By default, we will not try to use it: */
#ifndef ERR_ERWIN_USE_PTHREAD
#define ERR_ERWIN_USE_PTHREAD 0
#endif /* !defined ERR_ERWIN_USE_PTHREAD */

/* Only incled <pthread.h> for the implementation, and only use it if we are
 * not using the __thread keyword, and, of course, if thread safety is requested:
 */
#ifdef ERR_ERWIN_THREAD_SAFE
#  ifdef ERR_ERWIN_COMPILING
#    if ERR_ERWIN_USE_PTHREAD && !ERR_ERWIN_USE_THREAD_KEYWORD
#      include <pthread.h>
#    endif
#  endif

#endif /* ERR_ERWIN_THREAD_SAFE */


/* Automatically select thread safety if system has that. */
/* Have an easy decision variable to know whether we need to implement errno for
 * each object or whether we have a global (possible thread local) version.
 *
 * This #define must be in sync with map.h, vector.h, list.h.
 */
#if !defined(ERR_ERWIN_THREAD_SAFE) || ERR_ERWIN_USE_THREAD_KEYWORD || ERR_ERWIN_USE_PTHREAD
#  define ERR_ERWIN_GLOBAL_ERRNO 1
#else
#  define ERR_ERWIN_GLOBAL_ERRNO 0
#endif


#ifdef ERR_ERWIN_COMPAT_2_0_249
#define ERR_ERWIN_CPP_ONLY 0
#define BOOL  ERR_ERWIN_BOOL
#define TRUE  ERR_ERWIN_TRUE
#define FALSE ERR_ERWIN_FALSE
#else
#define ERR_ERWIN_CPP_ONLY 0
#endif

#if !defined(ERR_BOOL_DEFINED) && !defined(ERR_ERWIN_BOOL)

#  define ERR_BOOL_DEFINED

#  if ERR_ERWIN_CPP_ONLY

#  ifndef __cplusplus
#    error  "Please invoke 'untemplatize --init --cpp-lib=0' if you want to compile this with a non-C++ compiler."
#  endif

     /* This helps the compiler generate better code. */
     typedef bool ERR_ERWIN_BOOL_;
#    define ERR_ERWIN_BOOL  ERR_ERWIN_BOOL_
#    define ERR_ERWIN_FALSE false
#    define ERR_ERWIN_TRUE  true

#  else

     /*
      * One possibility would be to use (unsigned) int.
      * We use unsigned char.*/
     typedef unsigned char err_erwin_bool_t;
#    define ERR_ERWIN_BOOL   err_erwin_bool_t
#    define ERR_ERWIN_FALSE  0
#    define ERR_ERWIN_TRUE   1

#  endif

#endif

#ifndef ERR_ERWIN_TO_BOOL
#  ifdef __cplusplus
#    define ERR_ERWIN_TO_BOOL(X) ((X) ? true : false)
#  else
#    define ERR_ERWIN_TO_BOOL(X) ((X) ? ERR_ERWIN_TRUE : ERR_ERWIN_FALSE)
#  endif
#endif

#ifdef ERR_ERWIN_WEAK_DETERMINISM
#  define ERR_ERWIN_REQUIRE_DETERMINISM 1
#endif

#if defined(ERR_ERWIN_REQUIRE_DETERMINISM) || !defined(HAVE_RAND)
#  define ERR_ERWIN_RANDOM_FUNC     err_erwin_det_random
#  define ERR_ERWIN_RAND_MAX        0xffffffffUL
#  define ERR_ERWIN_NEED_DET_RANDOM 1
#else
#  define ERR_ERWIN_RANDOM_FUNC     rand
#ifdef RAND_MAX
#  define ERR_ERWIN_RAND_MAX        RAND_MAX
#endif /* defined RAND_MAX */
#endif

#ifndef ERR_ERWIN_RANDOM
#define ERR_ERWIN_RANDOM(N) \
         ((unsigned long)err_erwin_hash_into(ERR_ERWIN_RANDOM_FUNC(),N))
#endif /* !defined ERR_ERWIN_RANDOM */

#if defined(ERWIN_GNUC_V27X) && !defined(ERWIN_NO_CC_EXTENSIONS)

#  ifndef ERWIN_SUPERFLUOUS_CAST
#  define ERWIN_SUPERFLUOUS_CAST(X,Y)  (Y)
#  endif /* !defined ERWIN_SUPERFLUOUS_CAST */

#  if defined(__OPTIMIZE_SIZE__)
#    ifndef ERR_ERWIN_OPTIMISE_SIZE
#    define ERR_ERWIN_OPTIMISE_SIZE 1
#    endif /* !defined ERR_ERWIN_OPTIMISE_SIZE */
#  endif

#  if defined(__OPTIMIZE__)

#    ifndef ERR_ERWIN_OPTIMISE
#    define ERR_ERWIN_OPTIMISE 1
#    endif /* !defined ERR_ERWIN_OPTIMISE */

     /* Decide whether we can define 'extern inline' functions in headers.  */
#    ifndef ERWIN_EXTERN_INLINE
#    define ERWIN_EXTERN_INLINE extern ERWIN_INLINE
#    endif /* !defined ERWIN_EXTERN_INLINE */

     /* Decide whether we can use __asm__ on an i386. */
#    if !defined(ERWIN_GNUC_I386_ASM) && !defined(ERWIN_NO_ASM)
#      if defined (ERWIN_GNUC_I386_ASM_OLD) || defined (ERWIN_GNUC_I386_ASM_NEW)
#        define ERWIN_GNUC_I386_ASM 1
#      endif
#    endif

     /* Decide whether we can use __asm__ on a PowerPC.
      * Unfortunately, this only works without -ansi on an iBook. */
#    if !defined(ERWIN_GNUC_PPC_ASM) && !defined(ERWIN_NO_ASM)
#      if defined (ERWIN_GNUC_PPC_ASM_NEW) && !defined(__STRICT_ANSI__)
#        define ERWIN_GNUC_PPC_ASM 1
#      endif
#    endif

     /* Decide whether we can use __asm__ on an amd64 (=x64_86). */
#    if !defined(ERWIN_GNUC_X86_64_ASM) && !defined(ERWIN_NO_ASM)
#      if defined (ERWIN_GNUC_X86_64_ASM_NEW)
#        define ERWIN_GNUC_X86_64_ASM 1
#      endif
#    endif

#  endif

#else

#  ifndef ERWIN_SUPERFLUOUS_CAST
#  define ERWIN_SUPERFLUOUS_CAST(X,Y)  ((X)(Y))
#  endif /* !defined ERWIN_SUPERFLUOUS_CAST */
   /* This is for automatic casts that are allowed but that
    * some compilers might not like (usually because of `const'
    * problems). */

#endif

#ifdef ERWIN_EXTERN_INLINE
#  ifndef ERWIN_WRAPPER
#  define ERWIN_WRAPPER ERWIN_EXTERN_INLINE
#  endif /* !defined ERWIN_WRAPPER */
#else
#  ifndef ERWIN_WRAPPER
#  define ERWIN_WRAPPER ERWIN_STATIC_INLINE
#  endif /* !defined ERWIN_WRAPPER */
#endif


#ifndef ERWIN_CONCAT_TOKEN_AUX2
#define ERWIN_CONCAT_TOKEN_AUX2(A,B) A ## B
#endif /* !defined ERWIN_CONCAT_TOKEN_AUX2 */
#ifndef ERWIN_CONCAT_TOKEN_AUX
#define ERWIN_CONCAT_TOKEN_AUX(A,B)  ERWIN_CONCAT_TOKEN_AUX2(A,B)
#endif /* !defined ERWIN_CONCAT_TOKEN_AUX */
#ifndef ERWIN_CONCAT_TOKEN
#define ERWIN_CONCAT_TOKEN(A,B)      ERWIN_CONCAT_TOKEN_AUX(A,B)
#endif /* !defined ERWIN_CONCAT_TOKEN */

#ifndef ERWIN_STR_AUX2
#define ERWIN_STR_AUX2(X)            #X
#endif /* !defined ERWIN_STR_AUX2 */
#ifndef ERWIN_STR_AUX
#define ERWIN_STR_AUX(X)             ERWIN_STR_AUX2(X)
#endif /* !defined ERWIN_STR_AUX */
#ifndef ERWIN_STR
#define ERWIN_STR(X)                 ERWIN_STR_AUX(X)
#endif /* !defined ERWIN_STR */

#ifndef ERWIN_GENSYM
#define ERWIN_GENSYM(A)              ERWIN_CONCAT_TOKEN(A,__LINE__)
#endif /* !defined ERWIN_GENSYM */

#ifndef ERWIN_CONCAT
#define ERWIN_CONCAT(A,B)            ERWIN_CONCAT_TOKEN(A,B)
#endif /* !defined ERWIN_CONCAT */

  /* BEGIN LISP */
  /* (setf (long-float-digits) 200) */
#ifndef ERWIN_GOLDEN_RATIO
#define ERWIN_GOLDEN_RATIO                 0.6180339887498948482045868343656381177203
#endif /* !defined ERWIN_GOLDEN_RATIO */
  /* (setq ERWIN_GOLDEN_RATIO  (/ 2 (1+ (sqrt 5L0)))) */

#ifndef ERWIN_GOLDEN_RATIO_SHL_32_RAW
#define ERWIN_GOLDEN_RATIO_SHL_32_RAW      2654435769
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_32_RAW */
#ifndef ERWIN_GOLDEN_RATIO_SHL_32_INT_RAW
#define ERWIN_GOLDEN_RATIO_SHL_32_INT_RAW  -1640531527
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_32_INT_RAW */
#ifndef ERWIN_GOLDEN_RATIO_SHL_32
#define ERWIN_GOLDEN_RATIO_SHL_32          ERWIN_UL(ERWIN_GOLDEN_RATIO_SHL_32_RAW)
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_32 */
#ifndef ERWIN_GOLDEN_RATIO_SHL_32_INT
#define ERWIN_GOLDEN_RATIO_SHL_32_INT      ERWIN_L(ERWIN_GOLDEN_RATIO_SHL_32_INT_RAW)
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_32_INT */
  /* (setq ERWIN_GOLDEN_RATIO_SHL_32     (floor (* (expt 2 32) ERWIN_GOLDEN_RATIO))) */
  /* (setq ERWIN_GOLDEN_RATIO_SHL_32_INT (- ERWIN_GOLDEN_RATIO_SHL_32 (expt 2 32)))  */

#ifndef ERWIN_GOLDEN_RATIO_SHL_64_RAW
#define ERWIN_GOLDEN_RATIO_SHL_64_RAW      11400714819323198485
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_64_RAW */
#ifndef ERWIN_GOLDEN_RATIO_SHL_64_INT_RAW
#define ERWIN_GOLDEN_RATIO_SHL_64_INT_RAW  -7046029254386353131
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_64_INT_RAW */
#ifndef ERWIN_GOLDEN_RATIO_SHL_64
#define ERWIN_GOLDEN_RATIO_SHL_64          ERWIN_ULL(ERWIN_GOLDEN_RATIO_SHL_64_RAW)
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_64 */
#ifndef ERWIN_GOLDEN_RATIO_SHL_64_INT
#define ERWIN_GOLDEN_RATIO_SHL_64_INT      ERWIN_ULL(ERWIN_GOLDEN_RATIO_SHL_64_INT_RAW)
#endif /* !defined ERWIN_GOLDEN_RATIO_SHL_64_INT */
  /* (setq ERWIN_GOLDEN_RATIO_SHL_64     (floor (* (expt 2 64) ERWIN_GOLDEN_RATIO))) */
  /* (setq ERWIN_GOLDEN_RATIO_SHL_64_INT (- ERWIN_GOLDEN_RATIO_SHL_64 (expt 2 64)))  */

#ifndef ERWIN_GOLDEN_RATIO_APPROX
#define ERWIN_GOLDEN_RATIO_APPROX          0.61803398863412439823150634765625
#endif /* !defined ERWIN_GOLDEN_RATIO_APPROX */
  /* (setq ERWIN_GOLDEN_RATIO_APPROX  (* 1L0 (/ ERWIN_GOLDEN_RATIO_SHL_32 (expt 2 32)))) */

#ifndef ERWIN_GOLDEN_RATIO_APPROX_64
#define ERWIN_GOLDEN_RATIO_APPROX_64       0.6180339887498948481529999210426495892534
#endif /* !defined ERWIN_GOLDEN_RATIO_APPROX_64 */
  /* (setq ERWIN_GOLDEN_RATIO_APPROX_64  (* 1L0 (/ ERWIN_GOLDEN_RATIO_SHL_64 (expt 2 64)))) */
  /* END LISP */


#ifndef ERWIN_EPSILON
#define ERWIN_EPSILON                1e-8
#endif /* !defined ERWIN_EPSILON */

/* ********************************************************************** */
/* #define ERR_ERWIN_HASH_STRENGTH  2 */
/* This can have one of the following values:
 *
 *   0 - the weakest method: needs no additional data and is not really
 *       good.  Only use this when memory is short.
 *
 *   1 - allocates 1kB of randomised data and hashes the lower
 *       8 bits of all data types.  Sufficient for most purposes.
 *
 *   2 - like 1, but hashes up to 32 bits of each data type.
 *       This is the default.  You can try to check whether method 1
 *       is faster.  The hash function surely is, but due to weaker
 *       distribution, the hash performance in general may decrease
 *       in some rare cases (though it is expected that 1 is also a
 *       good method).
 *
 *   3 - like 2, but allocates 4kB of random data to have four different
 *       random tables for each byte in longer integer data types.  Also,
 *       the string hashing functions make use of all four tables.  This is
 *       the strongest, yet slowest method that also uses the most memory.
 *       It is usually overkill to use this.
 */

#ifndef ERR_ERWIN_HASH_STRENGTH
#define ERR_ERWIN_HASH_STRENGTH  2
#endif /* !defined ERR_ERWIN_HASH_STRENGTH */

/*
 * Preprocessor boolean values.  Will be used when stage0 is working
 * (probably in erwin-2.1.x) */
#define ERWIN_THE_BOOL_VALUE_       1
#define ERWIN_THE_BOOL_VALUE_0      0
#define ERWIN_THE_BOOL_VALUE_1      1
#define ERWIN_THE_BOOL_VALUE_no     0
#define ERWIN_THE_BOOL_VALUE_yes    1
#define ERWIN_THE_BOOL_VALUE_false  0
#define ERWIN_THE_BOOL_VALUE_true   1
#define ERWIN_THE_BOOL_VALUE_NO     0
#define ERWIN_THE_BOOL_VALUE_YES    1
#define ERWIN_THE_BOOL_VALUE_FALSE  0
#define ERWIN_THE_BOOL_VALUE_TRUE   1

#ifndef NDEBUG
#  define ERWIN_THE_BOOL_VALUE_NDEBUG  0
#  define ERWIN_THE_BOOL_VALUE_DEBUG   1
#else
#  define ERWIN_THE_BOOL_VALUE_NDEBUG  1
#  define ERWIN_THE_BOOL_VALUE_DEBUG   0
#endif

#ifdef RELEASE
#  define ERWIN_THE_BOOL_VALUE_NRELEASE  0
#  define ERWIN_THE_BOOL_VALUE_RELEASE   1
#else
#  define ERWIN_THE_BOOL_VALUE_NRELEASE  1
#  define ERWIN_THE_BOOL_VALUE_RELEASE   0
#endif

#ifndef ERWIN_BOOL_VALUE
#  define ERWIN_BOOL_VALUE_AUX2(X) ERWIN_THE_BOOL_VALUE_##X
#  define ERWIN_BOOL_VALUE_AUX(X)  ERWIN_BOOL_VALUE_AUX2(X)
#  define ERWIN_BOOL_VALUE(X)      ERWIN_BOOL_VALUE_AUX(X)
#endif

/* Check how to optimise (this works at least for GNU C) */
#ifndef ERR_ERWIN_OPTIMISE
#define ERR_ERWIN_OPTIMISE      0
#endif /* !defined ERR_ERWIN_OPTIMISE */
#ifndef ERR_ERWIN_OPTIMISE_SIZE
#define ERR_ERWIN_OPTIMISE_SIZE 0
#endif /* !defined ERR_ERWIN_OPTIMISE_SIZE */

#ifndef ERWIN_STATIC_INLINE
#define ERWIN_STATIC_INLINE static ERWIN_INLINE
#endif /* !defined ERWIN_STATIC_INLINE */

#if ERR_ERWIN_OPTIMISE_SIZE
#  ifndef ERWIN_STATIC_INLINE_SPEED
#  define ERWIN_STATIC_INLINE_SPEED static
#  endif /* !defined ERWIN_STATIC_INLINE_SPEED */
#else
#  ifndef ERWIN_STATIC_INLINE_SPEED
#  define ERWIN_STATIC_INLINE_SPEED ERWIN_STATIC_INLINE
#  endif /* !defined ERWIN_STATIC_INLINE_SPEED */
#endif
/* This is thought to be an indicator that a function is declared static inline
 * because we want to speed up execution.
 */

#ifndef ERWIN_STATIC_INLINE_ONCE
#define ERWIN_STATIC_INLINE_ONCE ERWIN_STATIC_INLINE
#endif /* !defined ERWIN_STATIC_INLINE_ONCE */
/* This is thought to be an indicator that a function is declared static inline
 * because it is used only once.  Then this may be inlined even if we are optimising
 * for size.  Well, of course, only if the compiler throws the static version of
 * the function away. */


/* Another strange definition.  Again, see maptest2.cpp for details. */
#ifndef ERWIN_FLOAT_VOLATILE
#define ERWIN_FLOAT_VOLATILE volatile
#endif /* !defined ERWIN_FLOAT_VOLATILE */

/*
 * Memory management for C.
 * When the data structures are compiled with C++, the C++ family of
 * functions is used if possible (only maps and lists use the C++
 * things, since vectors have strange data structures that shrink
 * and grow, so realloc is used.  This poses constraints on the
 * contained data, of course.  Further, maps use the calloc function
 * for the hash table of pointers instead of TNEWARR.
 */

#ifndef ERR_ERWIN_TMUL_OR_NULL
#define ERR_ERWIN_TMUL_OR_NULL(TYPE,COUNT,EXPR) \
        (ERWIN_LIKELY(err_erwin_mul_ok(COUNT,sizeof(TYPE))) ? ((TYPE*)(EXPR)) : ((TYPE*)NULL))
#endif /* !defined ERR_ERWIN_TMUL_OR_NULL */

#ifndef ERR_ERWIN_TMALLOC
   /* NOTE:
    *    The allocation interface has changed, since it was totally wrong
    *    before version 2.1.66203.  It only worked with the default
    *    interface.  If you changed the memory management, please excuse
    *    any inconveniences if having to fix your code now, but
    *    I simply *had* to fix bugs.  The code is fixed in a way that
    *    the compiler will throw errors so you'll see how to fix this.
    *
    *    Functions that add basic functionality similar to that of clib,
    *    do not use the following functions, but instead malloc() and free()
    *    just as the clib itself.
    *
    *    The following functions use malloc():
    *        err_string_dup()        - returns pointer to caller
    *        err_string_n_dup()      - returns pointer to caller
    *        err_erwin_merge_sort()  - allocates temporary memory freed
    *                                     before returning to caller
    *
    *    The following functions use free():
    *        err_erwin_merge_sort()
    *
    *    All other basic functions do *not* allocate memory.
    *
    *    The interface defined here will provide the memory allocator
    *    with as many information as Erwin has, e.g. the old size
    *    in realloc, which might come in handy, or the number of
    *    elements in an array-delete.  Of course, you may discard
    *    any of these if you don't need them.
    *
    *    All data structure functions use the following interface:
    */

/* Use the default implementation for operator new/operator delete: */
#ifndef ERR_ERWIN_DEFAULT_NEW_DELETE
#define ERR_ERWIN_DEFAULT_NEW_DELETE 1
#endif /* !defined ERR_ERWIN_DEFAULT_NEW_DELETE */

/* For non-resizable types: */
/* These must handle byte sizes and TYPE may be 'void'.  They are not
 * necessarily used for allocating single TYPE objects, but may be
 * used for arrays, too.  The constraint is that the resulting array
 * is not resizable.
 */
#  define ERR_ERWIN_TMALLOC(TYPE,SIZE)             (TYPE*)(malloc (SIZE))
#  define ERR_ERWIN_TCALLOC(TYPE,SIZE)             (TYPE*)(calloc (1, SIZE))
#  define ERR_ERWIN_TFREE(PTR,TYPE,SIZE)           free(PTR)

/* For resizable types (arrays of things): */
/* Note: when compiling for C and C++, these will be used for
 * resizing vectors, so the copy constructors are *not* invoked.
 * Copy constructors are only invoked when compiling exclusively
 * for C++.
 */
#  define ERR_ERWIN_TMALLOC_ARRAY(TYPE,COUNT) \
          ERR_ERWIN_TMUL_OR_NULL (TYPE, COUNT, malloc (COUNT * sizeof(TYPE)))

   /* We do not trust calloc's int overflow detection.
    * FIXME: We should check this in configure. */
#  define ERR_ERWIN_TCALLOC_ARRAY(TYPE,COUNT) \
          ERR_ERWIN_TMUL_OR_NULL (TYPE, COUNT, calloc (COUNT, sizeof(TYPE)))

#  define ERR_ERWIN_TREALLOC_ARRAY(PTR,TYPE,NEWCOUNT,OLDCOUNT) \
          ERR_ERWIN_TMUL_OR_NULL (TYPE, NEWCOUNT, realloc(PTR,NEWCOUNT * sizeof(TYPE)))

#  undef  ERR_ERWIN_TCREALLOC_ARRAY /*(PTR,TYPE,NEWCOUNT,OLDCOUNT)*/
       /* not available in standard libc, so use default implemented below. */

#  define  ERR_ERWIN_TFREE_ARRAY(PTR)  free(PTR)

/* And the same especially for C++ (where there is neither realloc
 * nor clear by default). */
/* non-resizable */
/* This is used to implement the 'operator new', 'operator new[]', 'operator delete',
 * 'operator delete[]' (if you do not the default implementation, where these
 * macros are not used at all.
 */
#  define ERR_ERWIN_TNEW(TYPE,SIZE)                (TYPE*)(::operator new(SIZE))
#  undef  ERR_ERWIN_TCNEW /*(TYPE,COUNT)*/
#  define ERR_ERWIN_TDELETE(PTR,TYPE,SIZE)         ::operator delete(PTR)

/* resizable */
/* The TNEW_ARRAY should invoke the constructor if there is one.  Note that if
 * compiling for C, this function will not be used, so storing C++ types
 * with constructors in vectors that need that is only supported when compiling
 * Erwin in C++. (There is a hack to still do it: oType_CONSTRUCTOR.).
 *
 * Also note that TCNEW_ARRAY is only invoked for pointer types.  If it is not
 * defined, TNEW_ARRAY will be used and the memory cleared with memset or bzero.
 * This is the same behaviour as with TCALLOC_ARRAY and TMALLOC_ARRAY.
 */
#  define ERR_ERWIN_TNEW_ARRAY(TYPE,COUNT)         new TYPE[COUNT]
#  undef  ERR_ERWIN_TCNEW_ARRAY /*(TYPE,COUNT)*/

#  undef  ERR_ERWIN_TRENEW_ARRAY /*(PTR,TYPE,NEWCOUNT,OLDCOUNT)*/
#  undef  ERR_ERWIN_TCRENEW_ARRAY /*(PTR,TYPE,NEWCOUNT,OLDCOUNT)*/
    /* The C++ standard does not have a concept of reallocation in C++,
     * so it is more efficient to use C-style allocation here.
     */

#  define ERR_ERWIN_TDELETE_ARRAY(PTR)             delete[] PTR
    /* Note: because TDELETE_ARRAY may be invoked by the user (indirectly,
     *       anyway), we cannot pass the element count here: we just don't
     *       know in all cases.  Internally, we know, be the user should
     *       not be required to know.
     */

   /* If you decide to use a different menory interfac, a minimal interface must have
    * at least the following functions:
    *   - ERR_ERWIN_TMALLOC
    *   - ERR_ERWIN_TFREE
    *   - ERR_ERWIN_TMALLOC_ARRAY
    *   - ERR_ERWIN_TFREE_ARRAY
    *
    * There are no default implementations for the _ARRAY macros, because
    * ERR_ERWIN_TFREE_ARRAY does not have enough parameters to be implemented
    * correctly with ERR_ERWIN_TFREE in all cases.
    *
    * All other functions are optional, but there are certain constraints that have
    * to be fulfilled if you want to define more than the above four functions:
    *
    * If you define ERR_ERWIN_TNEW, you must at least define ERR_ERWIN_TMALLOC
    * (and the other mandatory functions), and also ERR_ERWIN_TDELETE,
    * ERR_ERWIN_TNEW_ARRAY, ERR_ERWIN_TDELETE_ARRAY.
    *
    * If you define ERR_ERWIN_TMALLOC_ATOMS, you must at least define
    * ERR_ERWIN_TMALLOC (and the other mandatory functions) and
    * ERR_ERWIN_TFREE_ATOMS.
    *
    * If you define ERR_ERWIN_TNEW_ATOMS, you must at least define
    * ERR_ERWIN_TNEW (and all the macros that macro requires to be defined) and
    * ERR_ERWIN_TDELETE_ATOMS.
    *
    * Default implementations are used if you do not implement some functions:
    *
    * The C++ family will be implemented using the C family, unless you define
    * ERR_ERWIN_TNEW, in which case no default implementation will be used
    * for any of the C++ macros.
    *
    * The _ATOMS family will be implemented using the _ARRAY family, unless you
    * define ERR_ERWIN_TNEW_ATOMS, in which case no default implementation
    * is used at all for any _ATOMS macro.
    *
    * The clearing macros (TCALLOC*, TCNEW*, TCREALLOC*, TCRENEW*), if missing,
    * will be implemented using the non-clearing macros.
    *
    * The C++ functions are used for internal data structures only if compiling
    * with C++.  If they are not defined, the same set as for C is used.  This will
    * include the realloc functions, which might cause problems for vectors of objects,
    * because the copy constructor will not be called in this case.  If unsure whether
    * it works, do provide ERR_ERWIN_TNEW and ERR_ERWIN_TDELETE (and maybe more)
    * to avoid the implementation using the C style functions.
    *
    * If you define your own allocator functions, the C++ implementation of the data
    * structures will define an operator new and operator delete to use your allocators.
    * If you do not want this, define ERR_ERWIN_DEFAULT_NEW_DELETE to 1.
    *
    * Functionality:
    *  +-----------------+---------------+-----------------------------------------------+
    *  |! C              |! C++          |! Description                                  |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TMALLOC         | TNEW          | allocate non-resizable memory of a given size |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TCALLOC         | TCNEW         | like TMALLOC/TNEW, but memory is 0-filled     |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TFREE           | TDELETE       | delete one element of the given type          |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TMALLOC_ARRAY   | TNEW_ARRAY    | allocate an array of elements of the given    |
    *  |                 |               | type                                          |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TCALLOC_ARRAY   | TCNEW_ARRAY   | like TMALLOC_ARRAY/TNEW_ARRAY, but memory is  |
    *  |                 |               | filled with 0                                 |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TREALLOC_ARRAY  | TRENEW_ARRAY  | reallocate an array of elements of a given    |
    *  |                 |               | type                                          |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TCREALLOC_ARRAY | TCRENEW_ARRAY | like TREALLOC_ARRAY/TRENEW_ARRAY, but new     |
    *  |                 |               | memory is filled with 0                       |
    *  +-----------------+---------------+-----------------------------------------------+
    *  | TFREE_ARRAY     | TDELETE_ARRAY | delete an array of elements of the given type |
    *  +-----------------+---------------+-----------------------------------------------+
    *
    * Further, there is TMALLOC_ATOMS, TCALLOC_ATOMS, TREALLOC_ATOMS, TCREALLOC_ATOMS, and
    * TFREE_ATOMS etc., and the corresponding functions for C++, which are just like
    * the _ARRAY variants,  but ensure that no pointers will be stored in the allocated
    * memory.  This might be important for garbage collectors.  The _ATOMS macros,
    * default to the _ARRAY macros, if TMALLOC_ATOMS is not defined.  If it is defined,
    * you have to provide all the other _ATOMS functions you wish to use.
    *
    * Note that standard C++ interface does not provide implementations for TCNEW and
    * TRENEW_ARRAY, since the C++ way of allocation does not provide them.
    *
    * - TREALLOC_ARRAY/TRENEW_ARRAY:
    *       if defined, vectors will probably perform more efficiently.
    *
    *       Note that for TRENEW_ARRAY, invoking copy constructors correctly
    *       might be tricky (there is a reason why C++ only defines new[] and
    *       delete[] but nothing like realloc()).
    *
    * - TCALLOC/TCNEW:
    *       if defined, maps will probably perform more efficiently.
    *
    * - TCREALLOC_ARRAY/TCRENEW_ARRAY:
    *       if defined, nothing currently changes.
    *
    * If TMALLOC_ARRAY/TNEW_ARRAY is NOT defined, the implementations of maps and vectors
    * become less efficient, because a new type for each used element size will have to
    * be used.  The structures will only resize in factors of 2 in that case, so the
    * realloc triggering will be less fine-grained.
    *
    * Note: When compiling under C++ with the standard settings, you can force the
    * usage of C memory management for vectors by #defining VECTOR_..._USE_C_MM.
    * This will probably make the implementation more efficient.
    * See vector_..._u.h.
    *
    * Note: The top level structs that are created for a data structure will
    *     be allocated either with the C functions, or by yourself by using
    *     the new/delete operators.  Be aware that you cannot mix construction/
    *     destruction of C and C++ on the same data structure although the
    *     structure can otherwise be used in both languages.
    */

#else /* defined(ERR_ERWIN_TMALLOC) */
   /* See if someone has programmed an  old interface: */

#  ifdef ERR_ERWIN_FREE

#    error "Please fix your memory management macros for new version of Erwin."
       /* Old interface: FREE is now TFREE.  Without another layer of
        * macros, we cannot make a wrapper.  Assumingly no one has
        * ever uses this interface so far, so simply generate an error
        * until someone complains. */

#  endif

#endif  /* defined(ERR_ERWIN_TMALLOC) */


#ifndef ERR_ERWIN_PTR_ASSIGN
#define ERR_ERWIN_PTR_ASSIGN(P,Q)  ((P)=(Q))
#endif /* !defined ERR_ERWIN_PTR_ASSIGN */
   /* This can be overridded and used for debugging, e.g. using Boehm's GC_PTR_STORE.
    *
    * Note: this must be an expression, so no do{...}while(0) is allowed!
    *
    * Although this macro does not need to be properly parenthesized as macros usually
    * need to be, it is a good custom to still do that.
    */


/* Nicer wrappers around the bare interface: */

/* The following are used by the implementations of the data structures.
 * The definitions may change, so do not use yourself.
 *
 * Only use C++ function if the library is exclusively for C++.  Otherwise,
 * we must use C allocation, since some data structures may be passed to
 * the user, e.g. the internal vector of vectors in _as_array_detach().
 * This must be freeable with free() in C.
 *
 * I'm affraid this change (2.0.64631) affects the API.
 *
 * The raw macros are not expected to contain a correct macro structure, so
 * we use many parens and do{}while() to ensure one in own internal macros.
 */

/* If not available, implement the clearing functions using the helper erwin_memset0() (base.c)
 * It is assumed that the multiplication constraints have been checked already (whether
 * (C)*sizeof(T) overflows or not).
 */

/* Have nice TCLEAR macros: */
#ifndef ERR_ERWIN_TCLEAR
#define ERR_ERWIN_TCLEAR(T,P,S) \
               ((T*)err_erwin_memset0((void*)(P), 0, S))
#endif /* !defined ERR_ERWIN_TCLEAR */

#ifndef ERR_ERWIN_TCLEAR_ARRAY
#define ERR_ERWIN_TCLEAR_ARRAY(T,P,N,O) \
               ((T*)err_erwin_memset0((void*)(P), (O)*sizeof(T), (N)*sizeof(T)))
#endif /* !defined ERR_ERWIN_TCLEAR_ARRAY */


/* For C: */
#ifdef ERR_ERWIN_TMALLOC
#ifndef ERR_ERWIN_TCALLOC
#define ERR_ERWIN_TCALLOC(T,S) \
               ERR_ERWIN_TCLEAR(T, ERR_ERWIN_TMALLOC(T,S), S)
#endif /* !defined ERR_ERWIN_TCALLOC */
#endif /* defined ERR_ERWIN_TMALLOC */

#ifdef ERR_ERWIN_TMALLOC_ARRAY
#ifndef ERR_ERWIN_TCALLOC_ARRAY
#define ERR_ERWIN_TCALLOC_ARRAY(T,C) \
               ERR_ERWIN_TCLEAR_ARRAY(T, ERR_ERWIN_TMALLOC_ARRAY(T,C), C, 0)
#endif /* !defined ERR_ERWIN_TCALLOC_ARRAY */
#endif /* defined ERR_ERWIN_TMALLOC_ARRAY */

#ifdef ERR_ERWIN_TREALLOC_ARRAY
#ifndef ERR_ERWIN_TCREALLOC_ARRAY
#define ERR_ERWIN_TCREALLOC_ARRAY(P,T,N,O) \
               ERR_ERWIN_TCLEAR_ARRAY(T, ERR_ERWIN_TREALLOC_ARRAY(P,T,N,O), N, O)
#endif /* !defined ERR_ERWIN_TCREALLOC_ARRAY */
#endif /* defined ERR_ERWIN_TREALLOC_ARRAY */


/* For C++: */
#ifdef ERR_ERWIN_TNEW
#ifndef ERR_ERWIN_TCNEW
#define ERR_ERWIN_TCNEW(T,S) \
               ERR_ERWIN_TCLEAR(T, ERR_ERWIN_TNEW(T,S), S)
#endif /* !defined ERR_ERWIN_TCNEW */
#endif /* defined ERR_ERWIN_TNEW */

#ifdef ERR_ERWIN_TNEW_ARRAY
#ifndef ERR_ERWIN_TCNEW_ARRAY
#define ERR_ERWIN_TCNEW_ARRAY(T,C) \
               ERR_ERWIN_TCLEAR_ARRAY(T, ERR_ERWIN_TNEW_ARRAY(T,C), C, 0)
#endif /* !defined ERR_ERWIN_TCNEW_ARRAY */
#endif /* defined ERR_ERWIN_TNEW_ARRAY */

#ifdef ERR_ERWIN_TRENEW_ARRAY
#ifndef ERR_ERWIN_TCRENEW_ARRAY
#define ERR_ERWIN_TCRENEW_ARRAY(P,T,N,O) \
               ERR_ERWIN_TCLEAR_ARRAY(T, ERR_ERWIN_TRENEW_ARRAY(P,T,N,O), N, O)
#endif /* !defined ERR_ERWIN_TCRENEW_ARRAY */
#endif /* defined ERR_ERWIN_TRENEW_ARRAY */


#ifndef ERR_ERWIN_TMALLOC_ATOMS
/* Use _ARRAY as default for _ATOMS: */

#ifdef ERR_ERWIN_TMALLOC_ARRAY
#ifndef ERR_ERWIN_TMALLOC_ATOMS
#define ERR_ERWIN_TMALLOC_ATOMS    ERR_ERWIN_TMALLOC_ARRAY
#endif /* !defined ERR_ERWIN_TMALLOC_ATOMS */
#endif /* defined ERR_ERWIN_TMALLOC_ARRAY */
#ifdef ERR_ERWIN_TCALLOC_ARRAY
#ifndef ERR_ERWIN_TCALLOC_ATOMS
#define ERR_ERWIN_TCALLOC_ATOMS    ERR_ERWIN_TCALLOC_ARRAY
#endif /* !defined ERR_ERWIN_TCALLOC_ATOMS */
#endif /* defined ERR_ERWIN_TCALLOC_ARRAY */
#ifdef ERR_ERWIN_TREALLOC_ARRAY
#ifndef ERR_ERWIN_TREALLOC_ATOMS
#define ERR_ERWIN_TREALLOC_ATOMS   ERR_ERWIN_TREALLOC_ARRAY
#endif /* !defined ERR_ERWIN_TREALLOC_ATOMS */
#endif /* defined ERR_ERWIN_TREALLOC_ARRAY */
#ifdef ERR_ERWIN_TRECALLOC_ARRAY
#ifndef ERR_ERWIN_TRECALLOC_ATOMS
#define ERR_ERWIN_TRECALLOC_ATOMS  ERR_ERWIN_TRECALLOC_ARRAY
#endif /* !defined ERR_ERWIN_TRECALLOC_ATOMS */
#endif /* defined ERR_ERWIN_TRECALLOC_ARRAY */
#ifdef ERR_ERWIN_TFREE_ARRAY
#ifndef ERR_ERWIN_TFREE_ATOMS
#define ERR_ERWIN_TFREE_ATOMS      ERR_ERWIN_TFREE_ARRAY
#endif /* !defined ERR_ERWIN_TFREE_ATOMS */
#endif /* defined ERR_ERWIN_TFREE_ARRAY */

#ifdef ERR_ERWIN_TNEW_ARRAY
#ifndef ERR_ERWIN_TNEW_ATOMS
#define ERR_ERWIN_TNEW_ATOMS       ERR_ERWIN_TNEW_ARRAY
#endif /* !defined ERR_ERWIN_TNEW_ATOMS */
#endif /* defined ERR_ERWIN_TNEW_ARRAY */
#ifdef ERR_ERWIN_TCNEW_ARRAY
#ifndef ERR_ERWIN_TCNEW_ATOMS
#define ERR_ERWIN_TCNEW_ATOMS      ERR_ERWIN_TCNEW_ARRAY
#endif /* !defined ERR_ERWIN_TCNEW_ATOMS */
#endif /* defined ERR_ERWIN_TCNEW_ARRAY */
#ifdef ERR_ERWIN_TRENEW_ARRAY
#ifndef ERR_ERWIN_TRENEW_ATOMS
#define ERR_ERWIN_TRENEW_ATOMS     ERR_ERWIN_TRENEW_ARRAY
#endif /* !defined ERR_ERWIN_TRENEW_ATOMS */
#endif /* defined ERR_ERWIN_TRENEW_ARRAY */
#ifdef ERR_ERWIN_TRECNEW_ARRAY
#ifndef ERR_ERWIN_TRECNEW_ATOMS
#define ERR_ERWIN_TRECNEW_ATOMS    ERR_ERWIN_TRECNEW_ARRAY
#endif /* !defined ERR_ERWIN_TRECNEW_ATOMS */
#endif /* defined ERR_ERWIN_TRECNEW_ARRAY */
#ifdef ERR_ERWIN_TDELETE_ARRAY
#ifndef ERR_ERWIN_TDELETE_ATOMS
#define ERR_ERWIN_TDELETE_ATOMS    ERR_ERWIN_TDELETE_ARRAY
#endif /* !defined ERR_ERWIN_TDELETE_ATOMS */
#endif /* defined ERR_ERWIN_TDELETE_ARRAY */

#endif


#if defined(__cplusplus) && defined(ERR_ERWIN_TNEW) && ERR_ERWIN_CPP_ONLY && !defined(ERR_ERWIN_C_MM)

#  define ERR_ERWIN_THING_NEW(T,S)              (ERR_ERWIN_TNEW(T,(S)))
#ifdef ERR_ERWIN_TCNEW
#  define ERR_ERWIN_THING_CNEW(T,S)             (ERR_ERWIN_TCNEW(T,(S)))
#endif /* defined ERR_ERWIN_TCNEW */
#  define ERR_ERWIN_THING_DELETE(P,T,S)         do{ ERR_ERWIN_TDELETE((P),T,(S)); }while(0)

#  define ERR_ERWIN_THING_NEW_ARRAY(T,C)        (ERR_ERWIN_TNEW_ARRAY(T,(C)))
#ifdef ERR_ERWIN_TCNEW_ARRAY
#  define ERR_ERWIN_THING_CNEW_ARRAY(T,C)       (ERR_ERWIN_TCNEW_ARRAY(T,(C)))
#endif /* defined ERR_ERWIN_TCNEW_ARRAY */
#ifdef ERR_ERWIN_TRENEW_ARRAY
#  define ERR_ERWIN_THING_RENEW_ARRAY(P,T,N,O)  (ERR_ERWIN_TRENEW_ARRAY((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TRENEW_ARRAY */
#ifdef ERR_ERWIN_TCRENEW_ARRAY
#  define ERR_ERWIN_THING_CRENEW_ARRAY(P,T,N,O) (ERR_ERWIN_TCRENEW_ARRAY((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TCRENEW_ARRAY */
#  define ERR_ERWIN_THING_DELETE_ARRAY(P)       do{ ERR_ERWIN_TDELETE_ARRAY((P)); }while(0)

#  define ERR_ERWIN_THING_NEW_ATOMS(T,C)        (ERR_ERWIN_TNEW_ATOMS(T,(C)))
#ifdef ERR_ERWIN_TCNEW_ATOMS
#  define ERR_ERWIN_THING_CNEW_ATOMS(T,C)       (ERR_ERWIN_TCNEW_ATOMS(T,(C)))
#endif /* defined ERR_ERWIN_TCNEW_ATOMS */
#ifdef ERR_ERWIN_TRENEW_ATOMS
#  define ERR_ERWIN_THING_RENEW_ATOMS(P,T,N,O)  (ERR_ERWIN_TRENEW_ATOMS((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TRENEW_ATOMS */
#ifdef ERR_ERWIN_TCRENEW_ATOMS
#  define ERR_ERWIN_THING_CRENEW_ATOMS(P,T,N,O) (ERR_ERWIN_TCRENEW_ATOMS((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TCRENEW_ATOMS */
#  define ERR_ERWIN_THING_DELETE_ATOMS(P)       do{ ERR_ERWIN_TDELETE_ATOMS((P)); }while(0)

#else

#  define ERR_ERWIN_THING_NEW(T,S)              (ERR_ERWIN_TMALLOC(T,(S)))
#ifdef ERR_ERWIN_TCALLOC
#  define ERR_ERWIN_THING_CNEW(T,S)             (ERR_ERWIN_TCALLOC(T,(S)))
#endif /* defined ERR_ERWIN_TCALLOC */
#  define ERR_ERWIN_THING_DELETE(P,T,S)         do{ ERR_ERWIN_TFREE((P),T,(S)); }while(0)

#  define ERR_ERWIN_THING_NEW_ARRAY(T,C)        (ERR_ERWIN_TMALLOC_ARRAY(T,(C)))
#ifdef ERR_ERWIN_TCALLOC_ARRAY
#  define ERR_ERWIN_THING_CNEW_ARRAY(T,C)       (ERR_ERWIN_TCALLOC_ARRAY(T,(C)))
#endif /* defined ERR_ERWIN_TCALLOC_ARRAY */
#ifdef ERR_ERWIN_TREALLOC_ARRAY
#  define ERR_ERWIN_THING_RENEW_ARRAY(P,T,N,O)  (ERR_ERWIN_TREALLOC_ARRAY((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TREALLOC_ARRAY */
#ifdef ERR_ERWIN_TCREALLOC_ARRAY
#  define ERR_ERWIN_THING_CRENEW_ARRAY(P,T,N,O) (ERR_ERWIN_TCREALLOC_ARRAY((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TCREALLOC_ARRAY */
#  define ERR_ERWIN_THING_DELETE_ARRAY(P)       do{ ERR_ERWIN_TFREE_ARRAY((P)); }while(0)

#  define ERR_ERWIN_THING_NEW_ATOMS(T,C)        (ERR_ERWIN_TMALLOC_ATOMS(T,(C)))
#ifdef ERR_ERWIN_TCALLOC_ATOMS
#  define ERR_ERWIN_THING_CNEW_ATOMS(T,C)       (ERR_ERWIN_TCALLOC_ATOMS(T,(C)))
#endif /* defined ERR_ERWIN_TCALLOC_ATOMS */
#ifdef ERR_ERWIN_TREALLOC_ATOMS
#  define ERR_ERWIN_THING_RENEW_ATOMS(P,T,N,O)  (ERR_ERWIN_TREALLOC_ATOMS((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TREALLOC_ATOMS */
#ifdef ERR_ERWIN_TCREALLOC_ATOMS
#  define ERR_ERWIN_THING_CRENEW_ATOMS(P,T,N,O) (ERR_ERWIN_TCREALLOC_ATOMS((P),T,(N),(O)))
#endif /* defined ERR_ERWIN_TCREALLOC_ATOMS */
#  define ERR_ERWIN_THING_DELETE_ATOMS(P)       do{ ERR_ERWIN_TFREE_ATOMS((P)); }while(0)

#endif


/* The raw macros are not expected to contain a correct macro structure, so
 * we use many parens and do{}while() to ensure one in own internal macros. */
#define ERR_ERWIN_TMALLOC1(T)              (ERR_ERWIN_TMALLOC(T,sizeof(T)))
#define ERR_ERWIN_TCALLOC1(T)              (ERR_ERWIN_TCALLOC(T,sizeof(T)))
#define ERR_ERWIN_TFREE1(P,T)              do{ ERR_ERWIN_TFREE((P),T,sizeof(T)); }while(0)


#define ERR_ERWIN_TNEW1(T)                 (ERR_ERWIN_TNEW(T,sizeof(T)))
#define ERR_ERWIN_TCNEW1(T)                (ERR_ERWIN_TCNEW(T,sizeof(T)))
#define ERR_ERWIN_TDELETE1(P,T)            do{ ERR_ERWIN_TDELETE((P),T,sizeof(T)); }while(0)

/* The _THING_ macros already wrap the raw macros, so they do have a correct macro structure. */
#define ERR_ERWIN_THING_NEW1(T)            ERR_ERWIN_THING_NEW(T,sizeof(T))
#define ERR_ERWIN_THING_CNEW1(T)           ERR_ERWIN_THING_CNEW(T,sizeof(T))
#define ERR_ERWIN_THING_DELETE1(P,T)       ERR_ERWIN_THING_DELETE(P,T,sizeof(T))


#if defined(ERR_ERWIN_TNEW)
#  define ERR_ERWIN_PREFER_TNEW     ERR_ERWIN_TNEW
#  define ERR_ERWIN_PREFER_TDELETE  ERR_ERWIN_TDELETE
#else
#  define ERR_ERWIN_PREFER_TNEW     ERR_ERWIN_TMALLOC
#  define ERR_ERWIN_PREFER_TDELETE  ERR_ERWIN_TFREE
#endif


#define ERR_ERWIN_SET_PTR(X,Y)  ((void)(ERR_ERWIN_PTR_ASSIGN((X),(Y))))


#ifndef ERR_ERWIN_DEFAULT_NEW_DELETE
#define ERR_ERWIN_DEFAULT_NEW_DELETE 0
#endif /* !defined ERR_ERWIN_DEFAULT_NEW_DELETE */

/*
 * Decide the storage class */
#ifdef ERR_ERWIN_INLINE_FUNCTIONS
#  ifndef ERR_ERWIN_INLINE_PERHAPS
#  define ERR_ERWIN_INLINE_PERHAPS ERWIN_INLINE
#  endif /* !defined ERR_ERWIN_INLINE_PERHAPS */
#else
#  ifndef ERR_ERWIN_INLINE_PERHAPS
#  define ERR_ERWIN_INLINE_PERHAPS
#  endif /* !defined ERR_ERWIN_INLINE_PERHAPS */
#endif /* defined(ERR_ERWIN_INLINE_FUNCTIONS) */

#ifndef NDEBUG
#  ifndef ERWIN_CAST_INLINING
#  define ERWIN_CAST_INLINING 0
#  endif /* !defined ERWIN_CAST_INLINING */
           /* quick compilation */
# else
#  ifndef ERWIN_CAST_INLINING
#  define ERWIN_CAST_INLINING 1
#  endif /* !defined ERWIN_CAST_INLINING */
           /* quick program */
#endif

#ifdef ERR_ERWIN_STATIC
#  ifndef ERR_ERWIN_EXPORT
#  define ERR_ERWIN_EXPORT static ERR_ERWIN_INLINE_PERHAPS
#  endif /* !defined ERR_ERWIN_EXPORT */
#else
#  ifndef ERR_ERWIN_EXPORT
#  define ERR_ERWIN_EXPORT extern ERR_ERWIN_INLINE_PERHAPS
#  endif /* !defined ERR_ERWIN_EXPORT */
#endif /* defined(ERR_ERWIN_STATIC) */

#if defined(__GNUC__) && defined(__cplusplus)
#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
#    define ERWIN_REINTERPRET_CAST(TYPE,VALUE)  (reinterpret_cast<TYPE>(VALUE))
#    define ERWIN_STATIC_CAST(TYPE,VALUE)       (static_cast<TYPE>(VALUE))
#    define ERWIN_CONST_CAST(TYPE,VALUE)        (const_cast<TYPE>(VALUE))
#  endif
#endif

#ifndef ERWIN_REINTERPRET_CAST
#define ERWIN_REINTERPRET_CAST(TYPE,VALUE) ((TYPE)(VALUE))
#endif /* !defined ERWIN_REINTERPRET_CAST */
#ifndef ERWIN_STATIC_CAST
#define ERWIN_STATIC_CAST(TYPE,VALUE)      ((TYPE)(VALUE))
#endif /* !defined ERWIN_STATIC_CAST */
#ifndef ERWIN_CONST_CAST
#define ERWIN_CONST_CAST(TYPE,VALUE)       ((TYPE)(VALUE))
#endif /* !defined ERWIN_CONST_CAST */

#if defined(_MSC_VER) && (_MSC_VER >= 1300)
#  define ERWIN_FUNCTION         __FUNCTION__
#  define ERWIN_PRETTY_FUNCTION  __FUNCSIG__
#elif defined(__GNUC__)
#  define ERWIN_FUNCTION         __FUNCTION__
#  define ERWIN_PRETTY_FUNCTION  __PRETTY_FUNCTION__
#endif

#ifndef ERWIN_FUNCTION
#define ERWIN_FUNCTION         "<unknown function>"
#endif /* !defined ERWIN_FUNCTION */
#ifndef ERWIN_PRETTY_FUNCTION
#define ERWIN_PRETTY_FUNCTION  ERWIN_FUNCTION
#endif /* !defined ERWIN_PRETTY_FUNCTION */

#ifndef ERR_ERWIN_ERROR_STREAM
#  define ERR_ERWIN_ERROR_STREAM stderr
#endif

#ifndef ERR_ERWIN_ERROR_PRINT
#  define ERR_ERWIN_ERROR_PRINT fprintf
#endif

#ifdef __cplusplus
#  define ERWIN_IF_CXX(X) X
#  define ERWIN_IF_C(X)
#else
#  define ERWIN_IF_CXX(X)
#  define ERWIN_IF_C(X)   X
#endif

/* Write numbers in binary format in C.  We implement it byte-wise: */

/* Version 1: arbitrary arguments, including non-literals: */
#define ERWIN_BIN1_RAW(X)                           \
        (                                           \
            (((X) & 0x00000001u) ? 0x01u : 0x00u) | \
            (((X) & 0x00000010u) ? 0x02u : 0x00u) | \
            (((X) & 0x00000100u) ? 0x04u : 0x00u) | \
            (((X) & 0x00001000u) ? 0x08u : 0x00u) | \
            (((X) & 0x00010000u) ? 0x10u : 0x00u) | \
            (((X) & 0x00100000u) ? 0x20u : 0x00u) | \
            (((X) & 0x01000000u) ? 0x40u : 0x00u) | \
            (((X) & 0x10000000u) ? 0x80u : 0x00u)   \
        )

#define ERWIN_BIN2_RAW(XH,XL)           (ERWIN_BIN1_RAW(XL)      + (ERWIN_BIN1_RAW(XH)      << 8))
#define ERWIN_BIN4_RAW(XHH,XHL,XLH,XLL) (ERWIN_BIN2_RAW(XLH,XLL) + (ERWIN_BIN2_RAW(XHH,XHL) << 16))

/* For constants without the 0x prefix: */
#define ERWIN_BIN1(X)               ERWIN_BIN1_RAW(0x##X)
#define ERWIN_BIN2(XH,XL)           ERWIN_BIN2_RAW(0x##XH, 0x##XL)
#define ERWIN_BIN4(XHH,XHL,XLH,XLL) ERWIN_BIN4_RAW(0x##XHH, 0x##XHL, 0x##XLH, 0x##XLL)

#define ERWIN_XCHG(TYPE,A,B) \
        do{ TYPE ERWIN_GENSYM(e_xchg)= (A); (A)= (B); (B)= ERWIN_GENSYM(e_xchg); }while(0)

#define ERWIN_PTR_TYPEDEFS(X)          \
        typedef X * X##_p;             \
        typedef X const * X##_const_p;

#define ERWIN_KIND_TYPEDEFS(KIND,X)  \
        typedef KIND _##X X;         \
        ERWIN_PTR_TYPEDEFS(X)

#define ERWIN_DEFAULT_ARG(X) ERWIN_IF_CXX(= X)

#define ERWIN_IDENTITY(X)        X

#define ERWIN_IS_POWER2(X)       (((X) > 0) && (((X) & ((X)-1)) == 0))
        /* Note: X is used multiple times! */

#define ERWIN_POWER2(TYPE,N)     (((TYPE)1) << (N))

#define ERWIN_BITS0(TYPE,N)      ((~((TYPE)0)) << (N))
#define ERWIN_BITS1(TYPE,N)      (~ERWIN_BITS0(TYPE,N))

#define ERWIN_BITS1_2(TYPE,N,M)  ((~((~((TYPE)0)) << (N))) << (M))
#define ERWIN_BITS0_2(TYPE,N,M)  (~ERWIN_BITS1_2(TYPE,N,M))

/* offsetof() is a problem and in fact, so is finding the slot offset
 * in general in C++: */
#ifndef __cplusplus
#    define ERR_ERWIN_SIZEOF_MEMBER(Container,slot) \
                  sizeof(((Container*)0)->slot)

#    define ERR_ERWIN_OFFSETOF(Container,slot)       \
                  (((char *)&(((Container*)0)->slot)) - \
                  ((char *)(Container*)0))

#else
#    define ERR_ERWIN_SIZEOF_MEMBER(Container,slot) \
                  sizeof(((Container*)&err_erwin_init)->slot)

#    define ERR_ERWIN_OFFSETOF(Container,slot)                                              \
                  ((&reinterpret_cast<char volatile const &>(((Container*)&err_erwin_init)->slot)) - \
                   ((char const *)(Container*)&err_erwin_init))

   /* When using the normal C method or the offsetof() macro, this generates
    * warnings for no obvious reason.  I *know* that the offset is
    * computable.  What's the correct way to compute it then?  The obvious
    * way seems to violate the C++ standard.  The system offsetof() macro
    * is also implemented in that obvious way.  Strange language specs...
    *
    * We cannot use '(Container*)0', either.  Oh my!  So much superfluous work
    * this stupid warning triggers off.
    */

/* Another implementation I found:
 * #define offsetof(TYPE, MEMBER)                              \
 *   (__offsetof__ (reinterpret_cast <size_t>                  \
 *                  (&reinterpret_cast <const volatile char &> \
 *                   (static_cast<TYPE *> (0)->MEMBER))))
 *
 * Does this also warn about 'NULL'?
 */

#endif


/* ********************************************************************** */
/* #define ERR_ERWIN_TYPE_INFO 0 */
/*
 * Whether to include Erwin type info.  See erwin/typeinfo.h for the
 * definitions.
 */
#ifndef ERR_ERWIN_TYPE_INFO
#define ERR_ERWIN_TYPE_INFO 0
#endif /* !defined ERR_ERWIN_TYPE_INFO */

/* ********************************************************************** */
/* #define ALL_ERWIN_SPLIT    1 */
/* #define ERR_ERWIN_SPLIT 1 */
/*
 * This is also available for each data structure.
 *
 * Whether to put the functions in different sections to help
 * the linker simplify the resulting program.  For GCC, you
 * need -Wl,--gc-sections to remove unused sections.
 *
 * The value of this variable may be:
 *
 *   0: link traditionally, don't try to fiddle with sections
 *   1: make a separate section for each function
 *
 * The default depends on the optimisation strategy and on whether
 * we're doing a release or a debug build.
 */

#ifdef ALL_ERWIN_SPLIT
#ifndef ERR_ERWIN_SPLIT
#define ERR_ERWIN_SPLIT ALL_ERWIN_SPLIT
#endif /* !defined ERR_ERWIN_SPLIT */
#endif /* defined ALL_ERWIN_SPLIT */

#if ERR_ERWIN_OPTIMISE
#  ifndef ERR_ERWIN_SPLIT
#  define ERR_ERWIN_SPLIT 1
#  endif /* !defined ERR_ERWIN_SPLIT */
#endif
#ifndef ERR_ERWIN_SPLIT
#define ERR_ERWIN_SPLIT 0
#endif /* !defined ERR_ERWIN_SPLIT */

/* Little vs. big endian.  We call in 'LBF': low byte first
 * or 'HBF': high byte first, for simplicity. */
/* Note that PDP_ENDIAN is currently not supported here. */

/* The Erwin byte order macro ERWIN_BYTE_ORDER shows how 32 bit ints are stored:
 * when 0x03020100 is stored, then n is stored at byte with index
 * ((ERWIN_BYTE_ORDER >> (n*4)) & 0xf) for n \n {0,1,2,3}
 *
 * So for
 *    union {
 *      ERWIN_U32 one;
 *      ERWIN_U8  many[4];
 *    } x;
 *
 * it holds that:
 *      (x.one         & 0xff) == x.many[ ERWIN_INDEX_BYTE(ERWIN_BYTE_ORDER,0) ]
 *   && ((x.one >> 8)  & 0xff) == x.many[ ERWIN_INDEX_BYTE(ERWIN_BYTE_ORDER,1) ]
 *   && ((x.one >> 16) & 0xff) == x.many[ ERWIN_INDEX_BYTE(ERWIN_BYTE_ORDER,2) ]
 *   && ((x.one >> 24) & 0xff) == x.many[ ERWIN_INDEX_BYTE(ERWIN_BYTE_ORDER,3) ]
 *
 * So you can extract a word in a given byte order with:
 *
 *     ERWIN_U8 byte[4];
 *     ...
 *     ERWIN_U32 x=  (((ERWIN_U32)(byte[ERWIN_INDEX_BYTE(byte_order,0)]))      ) |
 *                   (((ERWIN_U32)(byte[ERWIN_INDEX_BYTE(byte_order,1)])) <<  8) |
 *                   (((ERWIN_U32)(byte[ERWIN_INDEX_BYTE(byte_order,2)])) << 16) |
 *                   (((ERWIN_U32)(byte[ERWIN_INDEX_BYTE(byte_order,3)])) << 24);
 *
 * Likewise, you can extract the nth byte from a word:
 *     ERWIN_U32 x;
 *     ERWIN_U8  byte[4];
 *
 *     byte[0]= (x >> (ERWIN_INDEX_BYTE(byte_order,0) << 3)) & 0xff;
 *     byte[1]= (x >> (ERWIN_INDEX_BYTE(byte_order,1) << 3)) & 0xff;
 *     byte[2]= (x >> (ERWIN_INDEX_BYTE(byte_order,2) << 3)) & 0xff;
 *     byte[3]= (x >> (ERWIN_INDEX_BYTE(byte_order,3) << 3)) & 0xff;
 *
 * where byte_order \n { ERWIN_LBF, ERWIN_HBF }
 *
 * Byte orders for 16 bits can be obtained by using (X & 0x11) on the
 * byte order constants, e.g. (ERWIN_LBF & 0x11) is a 16-bit byte
 * order and can be used with ERWIN_INDEX_BYTE, too.
 *
 * Generic byte orders for 64 bits are currently not supported, so
 * for ERWIN_LBF and ERWIN_HBF you have to program special cases.
 */

#define ERWIN_INDEX_BYTE(ORDER,N) (((ORDER) >> ((N) << 2)) & 0xf)

#define ERWIN_MAKE_BYTE_ORDER(I0,I1,I2,I3)                    \
            ((I0) | ((I1) << 4) | ((I2) << 8) | ((I3) << 12))

#define ERWIN_LBF 0x3210
#define ERWIN_HBF 0x0123

#define ERWIN_LITTLE_ENDIAN ERWIN_LBF
#define ERWIN_BIG_ENDIAN    ERWIN_HBF

/* #define ERWIN_PDP_ENDIAN  0x1032   ?? */
/* #define ERWIN_PDP_ENDIAN  0x2301   ?? */

#if defined(WORDS_BIGENDIAN)
#  ifndef ERWIN_BYTE_ORDER
#  define ERWIN_BYTE_ORDER ERWIN_HBF
#  endif /* !defined ERWIN_BYTE_ORDER */
#  ifdef WORDS_LITTLEENDIAN
#    error "Both WORDS_BIGENDIAN and WORDS_LITTLEENDIAN are defined."
#  endif
#elif defined(WORDS_LITTLEENDIAN)
#  ifndef ERWIN_BYTE_ORDER
#  define ERWIN_BYTE_ORDER ERWIN_LBF
#  endif /* !defined ERWIN_BYTE_ORDER */
#endif

#ifndef ERWIN_BYTE_ORDER

/* Try to find out byte order by preprocessor macros for architectures: */
/** LBF **/
/* x86 and amd64: */
#  define ERWIN_X86_ENDIAN  ERWIN_LBF
#  if defined(__amd64__) || defined(__amd64) || defined(__x86_64__) || defined(_M_X64)
#    define ERWIN_BYTE_ORDER  ERWIN_X86_ENDIAN
#  elif defined(__i386__) || defined(__i386) || defined(_M_IX86)
#    define ERWIN_BYTE_ORDER  ERWIN_X86_ENDIAN
#  endif

/** HBF **/
/* Sparc: */
#  define ERWIN_SPARC_ENDIAN  ERWIN_HBF
#  if defined(__sparc__) || defined(__sparc)
#    define ERWIN_BYTE_ORDER  ERWIN_SPARC_ENDIAN
#  endif

/* PPC: */
#  define ERWIN_PPC_ENDIAN  ERWIN_HBF
#  if defined(__powerpc__) || defined(__powerpc) || defined(_M_PPC)
#    define ERWIN_BYTE_ORDER  ERWIN_PPC_ENDIAN
#  endif

#endif /* !defined(ERWIN_BYTE_ORDER) */

/* **** */

#ifdef HAVE_LIBERROR
#  define ERR_ERWIN_ABORT err_crash
#else
#  define ERR_ERWIN_ABORT abort
#endif

#ifndef ERR_ERWIN_DEFAULT_ASSERTION_FAILED_HANDLER
#  define ERR_ERWIN_DEFAULT_ASSERTION_FAILED_HANDLER(FL,I,FU,A) \
    ((void)(err_erwin_assertion_is_fatal ? (ERR_ERWIN_ABORT(), 0) : 0))
#endif

#ifdef ERR_ERWIN_COMPILING
#  include "error/erwin/asm.h"
#else
#  include <error/erwin/asm.h>
#endif

#endif /* defined(ERR_ERWIN_ADAM_NAME */

#endif /* ERR_ERWIN_DEFS_H */
