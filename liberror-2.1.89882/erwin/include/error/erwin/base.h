/* -*- Mode: C -*- */
/* Author: Henrik Theiling
 * Description:
 *       The Erwin library for standard data structures and algorithms.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 */

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including base.h."
#endif

#ifndef ERR_ERWIN_BASE_H
#define ERR_ERWIN_BASE_H

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of base.h."
#endif

#ifdef ERR_ERWIN_COMPILING
#  include "error/erwin/defs.h"
#  include "error/erwin/map.h"
#  include "error/erwin/vector.h"
#  include "error/erwin/list.h"
#  include "error/erwin/typeinfo.h"
#else
#  include <error/erwin/defs.h>
#  include <error/erwin/map.h>
#  include <error/erwin/vector.h>
#  include <error/erwin/list.h>
#  include <error/erwin/typeinfo.h>
#endif

#ifdef ERR_ERWIN_ADAM_NAME

#ifdef ERR_ERWIN_MAJOR_VERSION
#define ERR_ERWIN_MAJOR_VERSION ERR_ERWIN_MAJOR_VERSION
#endif
#ifdef ERR_ERWIN_MINOR_VERSION
#define ERR_ERWIN_MINOR_VERSION ERR_ERWIN_MINOR_VERSION
#endif
#ifdef ERR_ERWIN_MICRO_VERSION
#define ERR_ERWIN_MICRO_VERSION ERR_ERWIN_MICRO_VERSION
#endif
#ifdef ERR_ERWIN_VERSION_CODE
#define ERR_ERWIN_VERSION_CODE ERR_ERWIN_VERSION_CODE
#endif

#define err_initializer_t err_initializer_t
#define err_erwin_strtoul err_erwin_strtoul
#define err_erwin_strtol err_erwin_strtol
#define err_erwin_strtoull err_erwin_strtoull
#define err_erwin_strtoll err_erwin_strtoll
#define err_erwin_strntoul err_erwin_strntoul
#define err_erwin_strntol err_erwin_strntol
#define err_erwin_strntoull err_erwin_strntoull
#define err_erwin_strntoll err_erwin_strntoll
#define err_string_free err_string_free
#define err_string_cmp err_string_cmp
#define err_string_equ err_string_equ
#define err_string_case_cmp err_string_case_cmp
#define err_string_case_equ err_string_case_equ
#define err_string_dup err_string_dup
#define err_string_length err_string_length
#define err_char_is_alpha err_char_is_alpha
#define err_char_is_lower err_char_is_lower
#define err_char_is_upper err_char_is_upper
#define err_char_is_digit err_char_is_digit
#define err_char_is_xdigit err_char_is_xdigit
#define err_char_is_space err_char_is_space
#define err_char_is_space0 err_char_is_space0
#define err_char_is_cr err_char_is_cr
#define err_char_is_cr0 err_char_is_cr0
#define err_erwin_merge_sort err_erwin_merge_sort
#define err_erwin_register_init err_erwin_register_init
#define err_erwin_version err_erwin_version
#define err_erwin_package_date err_erwin_package_date
#define err_erwin_assertion_is_fatal err_erwin_assertion_is_fatal
#define err_erwin_install_date err_erwin_install_date
#define err_erwin_init_date err_erwin_init_date
#define err_erwin_version_1 err_erwin_version_1
#define err_erwin_version_2 err_erwin_version_2
#define err_erwin_set_determinism err_erwin_set_determinism
#define err_erwin_require_determinism err_erwin_require_determinism
#define err_erwin_det_random err_erwin_det_random

#else /* !defined(ERR_ERWIN_ADAM_NAME) */

/* A family of overloaded functions to write assertions of the
 * following type:
 *
 *    assert (x >= 0);
 *
 * The problem is that this often leads to a compiler warning while
 * you still do not want to remove the assertion; you agree with
 * the compiler that x >= 0, but you do want to make this assertion
 * explicit.
 *
 * The following function family is overloaded for all numeric types
 * (I think), so whether the x>=0-check is necessary or not is decided
 * here once and forall.  You can simply write:
 *
 *    assert (erwin_nonnegative(x));
 *
 * The result of the function will be a constant true for unsigned
 * types and a dynamically checked condition for signed types.
 *
 * For C, the problem is not fully solved:
 *
 *   Because in C, there is no overloading, the whole thing does not work,
 *   and we're still looking for a solution.  The only thing I came up
 *   with produces additional code and/or only works for ints but not for
 *   floats.  I consider both minor flaws, especially the float thing.
 *   But since you may currently use erwin_nonnegative() in any expression
 *   instead of x >= 0, producing more code is suboptimal.  Depending on
 *   ERWIN_OPTIMISE, we either use our special test (non-optimised code) or
 *   we use x >= 0 (optimised code), which the compiler should eliminate.
 *
 *   Method 1 (works only for ints, but produces faster code):
 *
 *          (int)(x >> (sizeof(x)*8-1)) >= 0
 *
 *   Method 2 (works for floats and ints, but produces more code).
 *
 *          (double)(x / (2 << (sizeof(x)*8-1))) >= 0
 *
 *          This also has the problem that 2 << ... may overflow and
 *          that using a cast might change the result.
 *
 *   So we use Method 1, making erwin_nonnegative() only for for integers
 *   in C mode.  Note that no such restriction exists in C++.
 *
 * assert.pl also uses this function in out_of_bounds assertions.
 */

#ifndef erwin_nonnegative

#ifdef __cplusplus

#define erwin_nonnegative erwin_nonnegative

ERWIN_WRAPPER bool erwin_nonnegative (char) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (char x)
{
#ifdef __CHAR_UNSIGNED__
     return true;
#else
     return x >= 0;
#endif
}

ERWIN_WRAPPER bool erwin_nonnegative (signed char) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed char x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (signed short) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed short x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (signed int) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed int x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (signed long) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed long x)
{
     return x >= 0;
}

#ifdef ERWIN_LONG_LONG
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_LONG_LONG) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_LONG_LONG x)
{
     return x >= 0;
}
#endif

ERWIN_WRAPPER bool erwin_nonnegative (float) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (float x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (double) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (double x)
{
     return x >= 0;
}

#if SIZEOF_LONG_DOUBLE > 0
ERWIN_WRAPPER bool erwin_nonnegative (long double) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (long double x)
{
     return x >= 0;
}
#endif

ERWIN_WRAPPER bool erwin_nonnegative (bool) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (bool)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned char) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned char)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned short) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned short)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned int) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned int)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned long) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned long)
{
     return true;
}

#ifdef ERWIN_UNSIGNED_LONG_LONG
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_UNSIGNED_LONG_LONG) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_UNSIGNED_LONG_LONG)
{
     return true;
}
#endif

#else /* !defined __cplusplus */

/* C mode: no overloading possible, so just do the check: */
#if ERR_ERWIN_OPTIMISE
#  define erwin_nonnegative(x)  ((x) >= 0)
#else
#  define erwin_nonnegative(x)  (((int)((x) >> (sizeof(x)*8-1))) >= 0)
#endif

#endif /* !defined __cplusplus */

#endif /* defined erwin_nonnegative */


#ifdef __cplusplus
extern "C" {
#endif

/*
 * An initialisation function */
typedef void (*err_initializer_t) (int *, char ***);

/*! enum: ERR_SO_* */
#define ERR_SO_NO_UNDERBAR    0x80
#define ERR_SO_NO_BINARY     0x100
#define ERR_SO_BASE_MASK      0x7f

/*! group: strtol-Functions
 *
 * Read numbers from string.  Use instead of system functions as the
 * clib functions may be broken on some systems.  Note, however,
 * that the functions have no overflow checking. (FIXME: implement that).
 *
 * These functions have the following extensions compared to the
 * standard strto* family:
 *     - they skip and ignore _ in numbers (like Perl)
 *     - they understand 0b and 0B as binary prefix
 * To disable these extensions, use the following constants in the
 * radix parameter:
 *     - ERR_SO_NO_UNDERBAR
 *     - ERR_SO_NO_BINARY
 * And or them with the base.  E.g.:
 *    : err_erwin_strtol (x, &r, 16 | ERR_ERWIN_NO_UNDERBAR)
 *
 * SO is short for 'scan option'.
 * (Vectors have a 'format option' and this is the reverse)
 *
 * NULL is allowed for all pointers.  If c == NULL, the result is 0.
 */

extern unsigned long err_erwin_strtoul  (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern long err_erwin_strtol (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#ifdef ERWIN_LONG_LONG

extern ERWIN_UNSIGNED_LONG_LONG err_erwin_strtoull (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern ERWIN_LONG_LONG  err_erwin_strtoll  (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#endif

extern unsigned long err_erwin_strntoul  (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern long err_erwin_strntol (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#ifdef ERWIN_LONG_LONG

extern ERWIN_UNSIGNED_LONG_LONG err_erwin_strntoull (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern ERWIN_LONG_LONG  err_erwin_strntoll  (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#endif

/*! end-group */

/*
 * Overwrites the string before free() to make sure its contents
 * will not be used.  Do not use this as a random number generator
 * This is NULL safe.
 */
extern void err_string_free (char * /*c*/);

/*! group: String Comparison
 *
 * NULL-safe string functions:
 *
 * These are all NULL safe (NULL < "") comparison functions:
 * Note that the _case_ functions use 'tolower' (via char_to_lower),
 * so that they pay attention to the locale if that function does.
 *
 */

extern int err_string_cmp (char const * /*a*/, char const * /*b*/) ATTR_PURE;
  /*
   * This compares two strings like the standard strcmp().
   *
   * This has macro aliases err_erwin_strcmp().
   *
   * For err_erwin_strcmp(a,b) == 0, there is an alias:
   *    : err_erwin_strequ(a,b)
   */

extern int err_memory_cmp (void const * /*a*/, void const * /*b*/, size_t /*cnt*/) ATTR_PURE;
  /*
   * This compares two strings like the standard memcmp().
   *
   * This has macro aliases err_erwin_memcmp().
   *
   * For err_erwin_strcmp(a,b) == 0, there is an alias:
   *    : err_erwin_strequ(a,b)
   */

extern int err_string_n_cmp (char const * /*a*/, char const * /*b*/, size_t /*n*/) ATTR_PURE;
  /* Replacement for strncmp()
   *
   * This has macro aliases err_erwin_strncmp().
   *
   * For err_erwin_strncmp(a,b,n) == 0, there is an alias:
   *    : err_erwin_strnequ(a,b,n)
   */

extern char *err_string_string (char const * /*haystack*/, char const * /*needle*/) ATTR_PURE;
  /* Like strstr: finds a substring.
   *
   * Has a macro alias err_erwin_strstr.
   */

extern char *err_string_n_string      (
    char const * /*haystack*/, char const * /*needle*/, size_t) ATTR_PURE;
  /* Like a potential strnstr: finds a substring for a needle with a limited length.
   *
   * Has a macro alias err_erwin_strnstr.
   */

extern void *err_memory_memory (
    void const * /*haystack*/, size_t /*haycnt*/,
    void const * /*needle*/,   size_t /*needlecnt*/) ATTR_PURE;
  /* Like memmem: finds a substring.
   *
   * Has a macro alias err_erwin_memmem.
   */

/*! group: Case Insensitive Variants
 * Note that the _case_ functions use 'tolower' (via char_to_lower),
 * so that they pay attention to the locale if that function does.
 */

extern int err_string_case_cmp (char const * /*a*/, char const * /*b*/) ATTR_PURE;
  /* Like strcasecmp() / stricmp().
   *
   * This has macro aliases err_erwin_strcasecmp() and err_erwin_stricmp
   */

extern int err_string_n_case_cmp (char const * /*a*/, char const * /*b*/, size_t /*n*/)
     ATTR_PURE;
  /* Like strncasecmp() / strnicmp()
   *
   * This has macro aliases err_erwin_strncasecmp() and err_erwin_strnicmp
   */

extern char *err_string_case_string   (char const * /*haystack*/, char const * /*needle*/)
     ATTR_PURE;
  /* Like a potential strcasestr: finds a substring case-insensitively.
   *
   * Has a macro alias err_erwin_strcasestr.
   */

extern char *err_string_n_case_string (
    char const * /*haystack*/, char const * /*needle*/, size_t) ATTR_PURE;
  /* Like a potential strcasestr: finds a substring for a needle with a limited length.
   *
   * Has a macro alias err_erwin_strncasestr.
   */

/*! end-group */
/*! end-group */

extern char *err_string_dup   (
    char const * /*c*/, int * /*err*/ ERWIN_DEFAULT_ARG((int*)NULL))
    ATTR_MALLOC;
    /*
     * This DOES NOT change NULL to "(null)" or anything like that. NULL
     * on input returns NULL. Otherwise, the index NULL could not be
     * found after insertion in an array.  If there is not enough memory,
     * *err is set to 1.  Otherwise, *err is not touched.
     * err may be NULL. In that case, NULL is returned of the system
     * is out of memory.
     *
     * This has an alias err_erwin_strdup.
     */

extern char *err_string_n_dup (
    char const * /*c*/, size_t /*n*/, int * /*err*/ ERWIN_DEFAULT_ARG((int*)NULL))
    ATTR_MALLOC;
    /* Also see err_string_dup.
     *
     * This has an alias err_erwin_strdup.
     */

extern void *err_erwin_memset0 (
    void * /*p*/, size_t /*start*/, size_t /*end_plus_1*/);
    /* Like memset or bzero, but by using start, you can clear a suffix only.
     * This is internally used to emulate clearing after malloc and realloc.
     * Depending on what is available, the internal implementation uses
     * memset, bzero, or clears with a for loop manually.
     *
     * The returned pointer is just the one passed to the function.  If it is
     * NULL or start >= end_plus_1, no clearing is attempted.
     */

extern size_t err_string_length (char const *) ATTR_PURE;
   /* A NULL-safe replacement for strlen(): NULL has length 0.
    *
    * This has an alias err_erwin_strlen.
    */

extern size_t err_string_n_length (char const *, size_t) ATTR_PURE;
   /* A NULL-safe replacement for strnlen(): NULL has length 0.
    *
    * This has an alias err_erwin_strnlen.
    */

extern int err_erwin_digit_value (char) ATTR_CONST;
   /* Returns the digit value of a given character.  Can be used up to
    * a radix of 36.  (Probably usually used for hexadecimal digits.)
    *
    * If the character is invalid, returns 100, which is larger a value
    * than that of any representable digit.
    */

extern char err_erwin_get_digit (int /*digit*/) ATTR_CONST;
   /* The reverse of the err_erwin_digit_value.
    * Returns '\0' if digit is not between 0 and 35.
    */

extern char err_erwin_get_digit_upper (int /*digit*/) ATTR_CONST;
   /* This variant of err_erwin_get_digit returns upper case
    * letters first. */

/* The names string_... are nice to show that they all belong to the
 * data type string, but they are not nice for remembring when you
 * know the libc function names.  So we introduce aliases here. */

#define err_erwin_strcmp      err_string_cmp
#define err_erwin_memcmp      err_memory_cmp
#define err_erwin_strncmp     err_string_n_cmp
#define err_erwin_strlen      err_string_length
#define err_erwin_strnlen     err_string_n_length

/* non-ANSI, but BSD */
#define err_erwin_strdup(A)   err_string_dup((A), NULL)

/* BSD, Linux: */
#define err_erwin_strcasecmp  err_string_case_cmp
#define err_erwin_strncasecmp err_string_n_case_cmp
#define err_erwin_strstr      err_string_string
#define err_erwin_memmem      err_memory_memory
#define err_erwin_strcasestr  err_string_case_string
#define err_erwin_strnstr     err_string_n_string
#define err_erwin_strncasestr err_string_n_case_string

/* Windows: */
#define err_erwin_stricmp     err_string_case_cmp
#define err_erwin_strnicmp    err_string_n_case_cmp
#define err_erwin_stristr     err_string_case_string
#define err_erwin_strnistr    err_string_n_case_string

/* Some invented names: */
#define err_erwin_strfree             err_string_free
#define err_erwin_strndup             err_string_n_dup

#define err_erwin_memequ(A,B,C)       (err_memory_cmp(A,B,C) == 0)
#define err_erwin_strequ(A,B)         (err_string_cmp(A,B) == 0)
#define err_erwin_strcaseequ(A,B)     (err_string_case_cmp(A,B) == 0)
#define err_erwin_strnequ(A,B,N)      (err_string_n_cmp(A,B,N) == 0)
#define err_erwin_strncaseequ(A,B,N)  (err_string_n_case_cmp(A,B,N) == 0)

#define err_string_equ(A,B)           (err_string_cmp(A,B) == 0)
#define err_string_case_equ(A,B)      (err_string_case_cmp(A,B) == 0)
#define err_string_n_equ(A,B,N)       (err_string_n_cmp(A,B,N) == 0)
#define err_string_n_case_equ(A,B,N)  (err_string_n_case_cmp(A,B,N) == 0)

extern ERR_ERWIN_BOOL err_string_is_prefix (
    int * /*needle_length*/, char const * /*haystack*/, char const * /*needle*/);

extern ERR_ERWIN_BOOL err_string_is_suffix (
    int * /*needle_length*/, char const * /*haystack*/, char const * /*needle*/);

extern char const *err_erwin_strsignal (int);
   /* This returns NULL if the signal is not known or no name is known. */

/*
 * Some character functions.   These are wrappers around ctype functions. */
/* extern char err_char_to_upper (char);    declared in map.h */
/* extern char err_char_to_lower (char);    declared in map.h */
extern ERR_ERWIN_BOOL err_char_is_alpha  (char) ATTR_CONST;
extern ERR_ERWIN_BOOL err_char_is_lower  (char) ATTR_CONST;
extern ERR_ERWIN_BOOL err_char_is_upper  (char) ATTR_CONST;
extern ERR_ERWIN_BOOL err_char_is_digit  (char) ATTR_CONST;
extern ERR_ERWIN_BOOL err_char_is_xdigit (char) ATTR_CONST;
extern ERR_ERWIN_BOOL err_char_is_space  (char) ATTR_CONST;  /* '\0' is not space. */
extern ERR_ERWIN_BOOL err_char_is_space0 (char) ATTR_CONST;  /* '\0' is space. */
extern ERR_ERWIN_BOOL err_char_is_cr     (char) ATTR_CONST;  /* '\0' is not cr. */
extern ERR_ERWIN_BOOL err_char_is_cr0    (char) ATTR_CONST;  /* '\0' is cr. */
  /* The *0 versions return ERR_ERWIN_TRUE for \0. */

#define err_erwin_isalpha  err_char_is_alpha
#define err_erwin_islower  err_char_is_lower
#define err_erwin_isupper  err_char_is_upper
#define err_erwin_isdigit  err_char_is_digit
#define err_erwin_isxdigit err_char_is_xdigit
#define err_erwin_isspace  err_char_is_space
/* invented ones: */
#define err_erwin_isspace0  err_char_is_space0
#define err_erwin_iscr      err_char_is_cr
#define err_erwin_iscr0     err_char_is_cr0

/* The following functions hash the contents of the strings: */
ERWIN_WRAPPER err_hashval_t err_string_hash (char const *) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_string_hash (char const *c)
{
    return err_erwin_u8_array_hash ((ERWIN_U8*)c, err_string_length(c));
}

ERWIN_WRAPPER err_hashval_t err_string_case_hash (char const *) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_string_case_hash (char const *c)
{
    return err_erwin_u8_array_case_hash ((ERWIN_U8*)c, err_string_length(c));
}

typedef int (* err_erwin_comparison_t) (void const *, void const *);

void err_erwin_merge_sort (
    void *abase,
    size_t anmemb,
    size_t asize,
    err_erwin_comparison_t /*acompar*/);
   /* The stable sort algorithm Mergesort.
    *
    * Warning: This needs as much additional memory as you have stored in the
    *          array being sorted!
    */

/*
 * Initialise erwin and all its modules.  This might read
 * eventually parse options some time.
 */
extern void err_erwin_init (int * /*argc*/, char *** /*argv*/);

extern int err_erwin_register_init (err_initializer_t);
/* The suggested usage is this:

     static void module_init (int *argc, char ***argv)
     {
       ....
     }

     static int init_dummy = erwin_register_initialiser (module_init);

   module_init will then automatically be called by erwin_init
 */

#define ERR_ERWIN_MAJOR_VERSION  2
#define ERR_ERWIN_MINOR_VERSION  1
#define ERR_ERWIN_MICRO_VERSION  89877
#define ERR_ERWIN_VERSION_CODE   ERR_ERWIN_VERSION(ERR_ERWIN_MAJOR_VERSION,ERR_ERWIN_MINOR_VERSION,ERR_ERWIN_MICRO_VERSION)
/*
 * Like in the Linux kernel, you can write something like:
 *
 * #if ERR_ERWIN_VERSION_CODE >= ERR_ERWIN_VERSION(2,0,178)
 *
 */

extern char const *const err_erwin_version;
extern char const *const err_erwin_package_date;
   /* version and release date of this Erwin package */

extern ERR_ERWIN_BOOL err_erwin_assertion_is_fatal;
   /* whether assertions are fatal */

extern char const *const err_erwin_install_date;
   /* site install date */

extern char const *const err_erwin_init_date;
   /* date of untemplatize -init */

extern int const err_erwin_version_1;
extern int const err_erwin_version_2;
   /* These are for link-checking Erwin in a configure script. */

#ifdef ERR_ERWIN_REQUIRE_DETERMINISM

extern void err_erwin_set_determinism (ERR_ERWIN_BOOL);
    /* Default: ERR_ERWIN_TRUE
     * This means: if you define ERR_ERWIN_REQUIRE_DETERMINISM, you get ERR_ERWIN_TRUE as a
     *             default.  If you don't, you get ERR_ERWIN_FALSE as a default because the
     *             whole machinery needed for enforcing determinism is not compiled in.
     */

extern ERR_ERWIN_BOOL err_erwin_require_determinism (void);
    /* returns the current status of the determinism state. */

#endif
   /* If you compile the library with ERWIN_REQUIRE_DETERMINISM, all the data
    * structures will be able to be switched into determinism mode.  Note that
    * you have to call this function *before* err_erwin_init()!
    *
    * The influence on data structures is that, e.g for maps, functions
    * returning a list of the entries (either key, values or pairs) will
    * for sorted.  The same holds for iterators.  Note that when comparing
    * pointers by their address, the sort order is still machine and
    * machine configuration (->shared libraries, etc) dependent.  However,
    * directly subsequent calls to your problems will probably result in
    * the same order.
    *
    * NOTE: When you define ERR_ERWIN_REQUIRE_DETERMINISM, maps *must* be
    *       supplied with a compare function for the keys.  There can be
    *       a special compare function if you do not want to influence
    *       the rest of the data structure.
    *
    * FURTHER NOTE: When you define this, the library is a bit slower, because
    *       it has to check the determinism flag.
    *
    * FURTHER NOTE: This feature is currently only implemented correctly
    *       for C++ since the map iterators for C cannot be correctly
    *       de-allocated automatically.
    *       E.g. when an application programmer uses `break' to exit a
    *       map_xyz_forall loop, a possibly allocated sorted array cannot
    *       be deallocated in C.  This would require something like
    *       MAP_XYZ_FORALL_BREAK(iter) or (which I do not like because
    *       it breaks nestability) an additional entry in the map_xyz_t struct.
    */
#ifdef ERR_ERWIN_NEED_DET_RANDOM
extern unsigned long err_erwin_det_random (void);
    /* deterministic random. (haha!)
     * No srand() necessary...
     * Usually, use the frontend ERR_ERWIN_RANDOM(N) (defs.h)
     */
#endif

#ifdef __cplusplus
}
#endif

#endif /* !defined(ERR_ERWIN_ADAM_NAME) */


#include "error/decls.h"

#endif /* ERR_ERWIN_BASE_H */
