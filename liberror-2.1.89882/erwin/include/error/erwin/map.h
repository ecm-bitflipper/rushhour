/*-*- Mode: C -*-*/
/*
 * Author: Henrik Theiling
 * Description:
 *     Support functions for the map template parts of the Erwin--
 *     library.  These are basically hash functions for standard types.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 * ---------------------------------------------------------------------- */

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including map.h."
#endif

#ifndef ERR_ERWIN_MAP_H
#define ERR_ERWIN_MAP_H

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of map.h."
#endif

#ifdef ERR_ERWIN_COMPILING
#include "error/erwin/defs.h"
#else
#include <error/erwin/defs.h>
#endif

#ifdef ERR_ERWIN_ADAM_NAME

#define err_char_to_upper err_char_to_upper
#define err_char_to_lower err_char_to_lower
#define err_erwin_random_table err_erwin_random_table
#define err_erwin_mapinitialised err_erwin_mapinitialised
#define err_char_hash err_char_hash
#define err_char_hash2 err_char_hash2
#define err_char_hash3 err_char_hash3
#define err_char_hash4 err_char_hash4
#define err_char_case_hash err_char_case_hash
#define err_char_case_hash2 err_char_case_hash2
#define err_char_case_hash3 err_char_case_hash3
#define err_char_case_hash4 err_char_case_hash4
#define err_long_hash err_long_hash
#define err_int_hash err_int_hash
#define err_short_hash err_short_hash
#define err_hash_voidp err_hash_voidp
#define err_string_hash err_string_hash
#define err_string_case_hash err_string_case_hash
#define err_erwininternalmaperrno err_erwininternalmaperrno
#define err_erwininternalmapstrerror err_erwininternalmapstrerror
#define ERR_ERWININTERNALMAPOK ERR_ERWININTERNALMAPOK
#define ERR_ERWININTERNALMAPISOK ERR_ERWININTERNALMAPISOK
#define ERR_ERWININTERNALMAPISERROR ERR_ERWININTERNALMAPISERROR
#define ERR_ERWININTERNALMAPISWARNING ERR_ERWININTERNALMAPISWARNING
#define ERR_ERWININTERNALMAPERRNOMEM ERR_ERWININTERNALMAPERRNOMEM
#define ERR_ERWININTERNALMAPERRASSERTIONFAILED ERR_ERWININTERNALMAPERRASSERTIONFAILED
#define ERR_ERWININTERNALMAPWARNEMPTY ERR_ERWININTERNALMAPWARNEMPTY
#define ERR_ERWININTERNALMAPWARNNOMOREELEMS ERR_ERWININTERNALMAPWARNNOMOREELEMS
#define ERR_ERWININTERNALMAPWARNEXISTINGKEY ERR_ERWININTERNALMAPWARNEXISTINGKEY
#define ERR_ERWININTERNALMAPWARNKEYNOTFOUND ERR_ERWININTERNALMAPWARNKEYNOTFOUND
#define ERR_ERWININTERNALMAPREHASHNOMEM ERR_ERWININTERNALMAPREHASHNOMEM
#define ERR_ERWININTERNALMAPREHASHDUPLICATEKEY ERR_ERWININTERNALMAPREHASHDUPLICATEKEY
#define ERR_ERWININTERNALMAPREHASHRECURSION ERR_ERWININTERNALMAPREHASHRECURSION

#else /* !defined(ERR_ERWIN_ADAM_NAME) */

#ifdef __cplusplus
extern "C" {
#endif

/* These are in base.c but are needed here already. */
extern char err_char_to_upper (char) ATTR_CONST;
extern char err_char_to_lower (char) ATTR_CONST;

#define err_erwin_toupper  err_char_to_upper
#define err_erwin_tolower  err_char_to_lower

extern ERR_ERWIN_BOOL err_erwin_mapinitialised;

/* Hashing */

#ifdef ERR_ERWIN_REQUIRE_DETERMINISM
typedef err_hashval_t const err_erwin_random_table_t[256];
#else
typedef err_hashval_t err_erwin_random_table_t[256];
#endif

#if ERR_ERWIN_HASH_STRENGTH >= 1
extern err_erwin_random_table_t err_erwin_random_table;
extern err_erwin_random_table_t err_erwin_random_table2;
#if ERR_ERWIN_HASH_STRENGTH >= 3
extern err_erwin_random_table_t err_erwin_random_table3;
extern err_erwin_random_table_t err_erwin_random_table4;
#endif
#endif

/* Convenience definitions for old applications.  */
#ifdef ERR_ERWIN_COMPAT_2_0_236
#  define err_hash_char        err_char_hash
#  define err_hash_char_case   err_char_case_hash
#  define err_hash_long        err_long_hash
#  define err_hash_int         err_int_hash
#  define err_hash_short       err_short_hash
#  define err_hash_string      err_string_hash
#  define err_hash_string_case err_string_case_hash
#endif

#define err_erwin_hash0(X) (((((err_hashval_t)(X)) * 3) + \
                                (((err_hashval_t)(X)) * 7131) + \
                                (((err_hashval_t)(X)) * 9111371)) ^ \
                                (((err_hashval_t)(X)) * 755543))


ERWIN_WRAPPER err_hashval_t err_char_hash(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_hash(unsigned char x)
{
#if ERR_ERWIN_HASH_STRENGTH >= 1
    return err_erwin_random_table[x];
#else
    return err_erwin_hash0(x);
#endif
}

#define err_unsigned_char_hash err_char_hash
#define err_signed_char_hash   err_char_hash

ERWIN_WRAPPER err_hashval_t err_char_hash2(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_hash2(unsigned char x)
{
#if ERR_ERWIN_HASH_STRENGTH >= 1
    return err_erwin_random_table2[x];
#else
    return err_char_hash (x);
#endif
}

ERWIN_WRAPPER err_hashval_t err_char_hash3(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_hash3(unsigned char x)
{
#if ERR_ERWIN_HASH_STRENGTH >= 3
    return err_erwin_random_table3[x];
#else
    return err_char_hash (x);
#endif
}

ERWIN_WRAPPER err_hashval_t err_char_hash4(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_hash4(unsigned char x)
{
#if ERR_ERWIN_HASH_STRENGTH >= 3
    return err_erwin_random_table4[x];
#else
    return err_char_hash2 (x);
#endif
}

/* Internal function, do not use!  It may change or disappear without notice! */
ERWIN_WRAPPER err_hashval_t err_erwin_mul9 (err_hashval_t x) ATTR_CONST;
ERWIN_WRAPPER err_hashval_t err_erwin_mul9 (err_hashval_t x)
{
    return x + (x << 3);
        /* i386/x86_64 and probably many: one cycle by using 'lea' */
}

#ifndef err_erwin_mul_x1_defined

/* Internal function, do not use!  It may change or disappear without notice! */
ERWIN_WRAPPER err_hashval_t err_erwin_mul_x1 (err_hashval_t x) ATTR_CONST;
ERWIN_WRAPPER err_hashval_t err_erwin_mul_x1 (err_hashval_t x)
{
#if ERR_SIZEOF_HASHVAL_T == 8 && defined(ERWIN_U64)
    return x * ERWIN_U64_C(0x0000800200400081);
#else
    return x * 0x400081;
        /* i386/x86_64: hardward multiplier, so mul ist fast.
         * Other architectures may want to use shift & add:
         *
         *   return x + (x << 7) + (x << 22)
         */
#endif
}

#endif /*  err_erwin_mul_x1_defined */


/* Basic hash functions that may be available as assembly versions.
 *
 * All of these hash functions are collision-free, except when compiling
 * with required determinism.  In that case, long_hash() is constructed
 * in such a way that it hashes 'unsigned int' and 'int' in the same
 * way as int_hash(), which requires artificial introduction of collisions.
 */
#ifndef err_erwin_u16_hash_defined

ERWIN_WRAPPER err_hashval_t err_erwin_u16_hash (ERWIN_U16 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_u16_hash (ERWIN_U16 x)
{
    err_hashval_t y= x;

    y^= err_erwin_swap16(x) << 1;
    y+= err_char_hash  ((unsigned char)y);
    y=  err_erwin_mul_x1 (y);
    y^= err_char_hash2 ((unsigned char)(y >> 8));

    return y;
}

#endif /* err_erwin_u16_hash_defined */

#ifndef err_erwin_u32_hash_defined

ERWIN_WRAPPER err_hashval_t err_erwin_u32_hash (ERWIN_U32 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_u32_hash (ERWIN_U32 x)
{
    err_hashval_t y= x;

    y^= err_erwin_swap_low32(y) << 1;
    y+= err_char_hash  ((unsigned char)y);
    y=  err_erwin_mul_x1 (y);
    y^= err_char_hash2 ((unsigned char)(y >> 8));

    /* gcc 4:

     x86_64, 32-bit:
        movl    %edx, %eax
        bswapl  %eax
        roll    $1,%eax
        xorl    %edx, %eax
        movzbl  %al, %edx
        addl    erwin_random_table(,%rdx,4), %eax
        imull   $4194433, %eax, %eax
        movzbl  %ah, %edx
        xorl    erwin_random_table2(,%rdx,4), %eax

     x86_64, 64-bit:
        mov     %edx, %edx
        movq    %rdx, %rax
        bswapl  %eax
        rolq    $1,%rax
        xorq    %rdx, %rax
        movzbl  %al, %edx
        addq    erwin_random_table(,%rdx,8), %rax
        movabsq $140746082484353, %rdx
        imulq   %rdx, %rax
        movzbl  %ah, %edx
        xorq    erwin_random_table2(,%rdx,8), %rax
     */

    return y;
}

#endif /* err_erwin_u32_hash_defined */

#ifdef ERWIN_U64
#ifndef err_erwin_u64_hash_defined

ERWIN_WRAPPER err_hashval_t err_erwin_u64_hash (ERWIN_U64 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_u64_hash (ERWIN_U64 x)
{
    err_hashval_t y;

#if defined(ERR_ERWIN_REQUIRE_DETERMINISM)
    /* In this case, this function must hash values in int and unsigned
     * range in the same way as erwin_u32, otherwise long_hash(x) is
     * different on 32 vs. 64 bits, despite the same bit width of hashval_t. */

    y= err_erwin_u32_hash((ERWIN_U32)x);
    {
        ERWIN_U32 x32= (ERWIN_U32)(x >> 32);
        if (x32 && ~x32) {
            y^= err_erwin_swap_low32 (x32) << 1;
            y+= err_char_hash3 ((unsigned char)y);
            y=  err_erwin_mul_x1 (y);
            y^= err_char_hash4 ((unsigned char)(y >> 8));
        }
    }

#else /* !REQUIRE_DETERMINISM */

    y=  (err_hashval_t)x;

#if ERR_SIZEOF_HASHVAL_T == 8
    y^= err_erwin_swap64(y) << 1;
#else
    y^= err_erwin_swap_low32(y) << 1;
    y^= err_erwin_swap_low32((err_hashval_t)(x >> 32)) << 3;
#endif
    y+= err_char_hash  ((unsigned char)y);
    y=  err_erwin_mul_x1 (y);
    y^= err_char_hash2 ((unsigned char)(y >> 8));

#endif /* !REQUIRE_DETERMINISM */

    return y;
}

#endif /* err_erwin_u64_hash_defined */
#endif /* ERWIN_U64 */

ERWIN_WRAPPER err_hashval_t err_short_hash (unsigned short x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_short_hash (unsigned short x)
{
    return err_erwin_u16_hash (x);
}

#define err_unsigned_short_hash err_short_hash

ERWIN_WRAPPER err_hashval_t err_int_hash(unsigned int x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_int_hash(unsigned int x)
{
#if SIZEOF_INT == 8 && defined(ERWIN_U64)
    return err_erwin_u64_hash (x);
#elif SIZEOF_INT == 2
    return err_erwin_u16_hash (x);
#else
    return err_erwin_u32_hash (x);
#endif
}

#define err_unsigned_hash err_int_hash

ERWIN_WRAPPER err_hashval_t err_long_hash(unsigned long x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_long_hash(unsigned long x)
{
#if SIZEOF_LONG == 8 && defined(ERWIN_U64)
    return err_erwin_u64_hash (x);
#else
    return err_erwin_u32_hash (x);
#endif
}

#define err_unsigned_long_hash err_long_hash

#if defined(ERWIN_UNSIGNED_LONG_LONG) && defined(ERWIN_U64)

ERWIN_WRAPPER err_hashval_t err_long_long_hash(ERWIN_UNSIGNED_LONG_LONG x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_long_long_hash(ERWIN_UNSIGNED_LONG_LONG x)
{
    return err_erwin_u64_hash (x);
}

#define err_unsigned_long_long_hash err_long_long_hash

#endif

ERWIN_WRAPPER err_hashval_t err_voidp_hash (void const *x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_voidp_hash (void const *x)
{
#if SIZEOF_VOIDP == SIZEOF_LONG
    return err_long_hash ((unsigned long)x);
#else
    return err_int_hash ((unsigned int)x);
#endif
}

ERWIN_WRAPPER err_hashval_t err_size_t_hash(size_t x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_size_t_hash(size_t x)
{
#if SIZEOF_SIZE_T == 8 && defined(ERWIN_U64)
    return err_erwin_u64_hash (x);
#elif SIZEOF_SIZE_T == 2
    return err_erwin_u16_hash (x);
#else
    return err_erwin_u32_hash (x);
#endif
}

/* Shoot, this has a bad name.  Use voidp_hash() instead.
 * We keep it for compatibility, but mark it deprecated: */
ERWIN_WRAPPER err_hashval_t err_hash_voidp (void const *x) ATTR_PURE ATTR_DEPRECATED;
ERWIN_WRAPPER err_hashval_t err_hash_voidp (void const *x)
{
    return err_voidp_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_char_case_hash(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_case_hash(unsigned char x)
{
    return err_char_hash ((unsigned char)err_char_to_lower((char)x));
}

#define err_unsigned_char_case_hash err_char_case_hash
#define err_signed_char_case_hash   err_char_case_hash


ERWIN_WRAPPER err_hashval_t err_char_case_hash2(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_case_hash2(unsigned char x)
{
    return err_char_hash2 ((unsigned char)err_char_to_lower((char)x));
}

ERWIN_WRAPPER err_hashval_t err_char_case_hash3(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_case_hash3(unsigned char x)
{
    return err_char_hash3 ((unsigned char)err_char_to_lower((char)x));
}

ERWIN_WRAPPER err_hashval_t err_char_case_hash4(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_char_case_hash4(unsigned char x)
{
    return err_char_hash4 ((unsigned char)err_char_to_lower((char)x));
}

ERWIN_WRAPPER err_hashval_t err_erwin_make_hash_result(
    err_hashval_t, err_hashval_t) ATTR_PURE;

ERWIN_WRAPPER err_hashval_t err_erwin_make_hash_result(
    err_hashval_t h1, err_hashval_t h2)
{
#if ERR_SIZEOF_HASHVAL_T == 4 && defined(ERWIN_U64)
    return err_erwin_u64_hash (((ERWIN_U64)h1) + (((ERWIN_U64)h2) << 32));
#else
    err_hashval_t y;

    y=  h1;
    y^= err_char_hash4 ((unsigned char)(y >> 8));
    y+= h2;
    y^= err_erwin_swap (y) << 1;
    y+= err_char_hash3 ((unsigned char)y);

    return y;
#endif
}

/* And another one for hashing memory areas of a given size (with various sizes).
 * All functions take the pointer to the array and the number of elements of the array
 * to be hashed: */
extern err_hashval_t err_erwin_u8_array_hash       (ERWIN_U8  const *, size_t) ATTR_PURE;
extern err_hashval_t err_erwin_u8_array_case_hash  (ERWIN_U8  const *, size_t) ATTR_PURE;
extern err_hashval_t err_erwin_u16_array_hash      (ERWIN_U16 const *, size_t) ATTR_PURE;
extern err_hashval_t err_erwin_u32_array_hash      (ERWIN_U32 const *, size_t) ATTR_PURE;

#ifdef ERWIN_U64
extern err_hashval_t err_erwin_u64_array_hash      (ERWIN_U64 const *, size_t) ATTR_PURE;
#endif

ERWIN_WRAPPER err_hashval_t err_erwin_s8_array_hash (ERWIN_S8 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s8_array_hash (ERWIN_S8 const *x, size_t s)
{
    return err_erwin_u8_array_hash((ERWIN_U8*)x,s);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s8_array_case_hash (ERWIN_S8 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s8_array_case_hash (ERWIN_S8 const *x, size_t s)
{
    return err_erwin_u8_array_case_hash ((ERWIN_U8*)x,s);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s16_array_hash (ERWIN_S16 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s16_array_hash (ERWIN_S16 const *x, size_t s)
{
    return err_erwin_u16_array_hash((ERWIN_U16*)x,s);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s32_array_hash (ERWIN_S32 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s32_array_hash (ERWIN_S32 const *x, size_t s)
{
    return err_erwin_u32_array_hash((ERWIN_U32*)x,s);
}

#if defined(ERWIN_U64) && defined(ERWIN_S64)
ERWIN_WRAPPER err_hashval_t err_erwin_s64_array_hash (ERWIN_S64 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s64_array_hash (ERWIN_S64 const *x, size_t s)
{
    return err_erwin_u64_array_hash((ERWIN_U64*)x,s);
}
#endif

ERWIN_WRAPPER err_hashval_t err_erwin_u8_hash (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_u8_hash (ERWIN_S8 x)
{
    return err_char_hash((ERWIN_U8)x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_u8_hash_case (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_u8_hash_case (ERWIN_S8 x)
{
    return err_char_case_hash ((ERWIN_U8)x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s8_hash (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s8_hash (ERWIN_S8 x)
{
    return err_char_hash((ERWIN_U8)x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s8_hash_case (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s8_hash_case (ERWIN_S8 x)
{
    return err_char_case_hash ((ERWIN_U8)x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s16_hash (ERWIN_S16 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s16_hash (ERWIN_S16 x)
{
    return err_erwin_u16_hash((ERWIN_U16)x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_s32_hash (ERWIN_S32 x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s32_hash (ERWIN_S32 x)
{
    return err_erwin_u32_hash((ERWIN_U32)x);
}

#if defined(ERWIN_U64) && defined(ERWIN_S64)
ERWIN_WRAPPER err_hashval_t err_erwin_s64_hash (ERWIN_S64 const x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_s64_hash (ERWIN_S64 const x)
{
    return err_erwin_u64_hash((ERWIN_U64)x);
}
#endif


#define err_erwin_char_array_hash(x,s)   err_erwin_u8_array_hash((ERWIN_U8 const *)x,s)

#if SIZEOF_SHORT == 2
#define err_erwin_short_array_hash(x,s)  err_erwin_u16_array_hash((ERWIN_U16 const *)x,s)
#endif

#if SIZEOF_INT == 2
#define err_erwin_int_array_hash(x,s)    err_erwin_u16_array_hash((ERWIN_U16 const *)x,s)
#elif SIZEOF_INT == 4
#define err_erwin_int_array_hash(x,s)    err_erwin_u32_array_hash((ERWIN_U32 const *)x,s)
#elif SIZEOF_INT == 8
#define err_erwin_int_array_hash(x,s)    err_erwin_u64_array_hash((ERWIN_U64 const *)x,s)
#endif

#if SIZEOF_LONG == 4
#define err_erwin_long_array_hash(x,s)   err_erwin_u32_array_hash((ERWIN_U32 const *)x,s)
#elif SIZEOF_LONG == 8
#define err_erwin_long_array_hash(x,s)   err_erwin_u64_array_hash((ERWIN_U64 const *)x,s)
#endif


#ifdef __cplusplus
/* overloaded versions: */
extern "C++" {

ERWIN_WRAPPER err_hashval_t err_erwin_hash (bool x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (bool x)
{
    return err_char_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (char x)
{
    return err_char_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (signed char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (signed char x)
{
    return err_char_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned char x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned char x)
{
    return err_char_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (short x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (short x)
{
    return err_short_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned short x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned short x)
{
    return err_short_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (int x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (int x)
{
    return err_int_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned x)
{
    return err_int_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (long x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (long x)
{
    return err_long_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned long x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (unsigned long x)
{
    return err_long_hash (x);
}

#ifdef ERWIN_LONG_LONG
ERWIN_WRAPPER err_hashval_t err_erwin_hash (ERWIN_LONG_LONG x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (ERWIN_LONG_LONG x)
{
    return err_long_long_hash (x);
}

ERWIN_WRAPPER err_hashval_t err_erwin_hash (ERWIN_UNSIGNED_LONG_LONG x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (ERWIN_UNSIGNED_LONG_LONG x)
{
    return err_long_long_hash (x);
}
#endif /* defined ERWIN_LONG_LONG */


/* Pointers */
ERWIN_WRAPPER err_hashval_t err_erwin_hash (void const *x) ATTR_PURE;
ERWIN_WRAPPER err_hashval_t err_erwin_hash (void const *x)
{
    return err_voidp_hash (x);
}

/* Other pointers are not hashed in a default way, because it is up to the
 * user to decide whether the pointer or the contents are to be hashed. */

} /* extern "C++" */
#endif /* C++ */

/* NOTE: string_hash and string_case_hash are now in base.h. */

/* ********************************************************************** */
/* Combine multiple hash values into one.  Use these macros instead of
 * thinking of something yourself when you write hash functions for your
 * own macros so that the macros can eventually be improved if necessary
 * and your code automatically improves, too.
 *
 * Use them as follows (example for a struct):
 *
 *   hashval_t mypair_hash (struct mypair_t const *x)
 *   {
 *       err_erwin_hash_state_t state;
 *
 *       ERR_ERWIN_STATE_INIT (state);
 *       ERR_ERWIN_STATE_MIX_ORDERED2(state, mytype1_hash(x->a), mytype2_hash(x->b));
 *
 *       return ERR_ERWIN_STATE_GET_HASHVAL(state);
 *   }
 *
 * Or a string.  You may use ERWIN_HASH_INIT* for quick hash values for special
 * keys:
 *
 *   hashval_t mystring_hash (mytype_t const *x)
 *   {
 *       if (x == NULL)
 *           return ERWIN_HASH_INIT;
 *
 *       err_erwin_hash_state_t state;
 *       ERR_ERWIN_STATE_INIT(state);
 *
 *       for (; *x; x++)
 *            ERR_ERWIN_STATE_MIX_ORDERED (state, mytype_hash(*x));
 *
 *       return ERR_ERWIN_STATE_GET_HASHVAL(state);
 *   }
 *
 * Use the _UNORDERED variants if the iteration is non-deterministic (e.g. in
 * randomised hash tables).
 *
 * To speed up a bit, you can have a slightly faster initialisation (we're talking
 * about a few machine instructions here), you can ERWIN_STATE_INIT_WITH(s,first_value)
 * instead of ERWIN_STATE_INIT(s); ERWIN_STATE_MIX_ORDERED(s,first_value).  This
 * is handy since many structure have a size + dynamic set of elements, and for
 * the size, this comes in handy.  Don't bother to optimise too much, though.  If
 * you have two initial values, use the normal ERWIN_STATE_MIX_ORDERED2 instead to
 * add them too the hash state.
 *
 * The result of such a construction of have values via a state will be very good
 * hash values.  No need for another hashval_t_hash().  You can directly use
 * (hashval % size) or better erwin_hash_into(hashval,size), which uses multiplication
 * instead of division, to reduce the hashval to a given size.
 */

/* Combine some digits:

   (setq *print-base* 16)
   (setf (long-float-digits) 800)
   (integer-decode-float pi)

32 bits:
   C90FDAA2
   2168C234
   C4C6628B
   80DC1CD1
   29024E08
   8A67CC74
   020BBEA6
   3B139B22
   514A0879
   8E3404DD
   EF9519B3
   CD3A431B
   ...

64 bits:
   C90FDAA22168C234
   C4C6628B80DC1CD1
   29024E088A67CC74
   020BBEA63B139B22
   514A08798E3404DD
   EF9519B3CD3A431B
   302B0A6DF25F1437
   4FE1356D6D51C245
   E485B576625E7EC6
   F44C42E9A637ED6B
   0BFF5CB6F406B7ED
   EE386BFB5A899FA5
   ...
*/


/* Some initial hashvalues (quite arbitrary, actually, these are the first
 * few digits of pi (shifted)): */
#if ERR_SIZEOF_HASHVAL_T == 8
# ifndef ERR_ERWIN_HASH_INIT
# define ERR_ERWIN_HASH_INIT   ERR_HASHVAL_C(0xC90FDAA22168C234)
# endif /* !defined ERR_ERWIN_HASH_INIT */
# ifndef ERR_ERWIN_HASH_INIT2
# define ERR_ERWIN_HASH_INIT2  ERR_HASHVAL_C(0xC4C6628B80DC1CD1)
# endif /* !defined ERR_ERWIN_HASH_INIT2 */
# ifndef ERR_ERWIN_HASH_INIT3
# define ERR_ERWIN_HASH_INIT3  ERR_HASHVAL_C(0x29024E088A67CC74)
# endif /* !defined ERR_ERWIN_HASH_INIT3 */
# ifndef ERR_ERWIN_HASH_INIT4
# define ERR_ERWIN_HASH_INIT4  ERR_HASHVAL_C(0x020BBEA63B139B22)
# endif /* !defined ERR_ERWIN_HASH_INIT4 */
# ifndef ERR_ERWIN_HASH_INIT5
# define ERR_ERWIN_HASH_INIT5  ERR_HASHVAL_C(0x514A08798E3404DD)
# endif /* !defined ERR_ERWIN_HASH_INIT5 */
# ifndef ERR_ERWIN_HASH_INIT6
# define ERR_ERWIN_HASH_INIT6  ERR_HASHVAL_C(0xEF9519B3CD3A431B)
# endif /* !defined ERR_ERWIN_HASH_INIT6 */
# ifndef ERR_ERWIN_HASH_INIT7
# define ERR_ERWIN_HASH_INIT7  ERR_HASHVAL_C(0x302B0A6DF25F1437)
# endif /* !defined ERR_ERWIN_HASH_INIT7 */
# ifndef ERR_ERWIN_HASH_INIT8
# define ERR_ERWIN_HASH_INIT8  ERR_HASHVAL_C(0x4FE1356D6D51C245)
# endif /* !defined ERR_ERWIN_HASH_INIT8 */
# ifndef ERR_ERWIN_HASH_INIT9
# define ERR_ERWIN_HASH_INIT9  ERR_HASHVAL_C(0xE485B576625E7EC6)
# endif /* !defined ERR_ERWIN_HASH_INIT9 */
#else
# ifndef ERR_ERWIN_HASH_INIT
# define ERR_ERWIN_HASH_INIT   ERR_HASHVAL_C(0xC90FDAA2)
# endif /* !defined ERR_ERWIN_HASH_INIT */
# ifndef ERR_ERWIN_HASH_INIT2
# define ERR_ERWIN_HASH_INIT2  ERR_HASHVAL_C(0x2168C234)
# endif /* !defined ERR_ERWIN_HASH_INIT2 */
# ifndef ERR_ERWIN_HASH_INIT3
# define ERR_ERWIN_HASH_INIT3  ERR_HASHVAL_C(0xC4C6628B)
# endif /* !defined ERR_ERWIN_HASH_INIT3 */
# ifndef ERR_ERWIN_HASH_INIT4
# define ERR_ERWIN_HASH_INIT4  ERR_HASHVAL_C(0x80DC1CD1)
# endif /* !defined ERR_ERWIN_HASH_INIT4 */
# ifndef ERR_ERWIN_HASH_INIT5
# define ERR_ERWIN_HASH_INIT5  ERR_HASHVAL_C(0x29024E08)
# endif /* !defined ERR_ERWIN_HASH_INIT5 */
# ifndef ERR_ERWIN_HASH_INIT6
# define ERR_ERWIN_HASH_INIT6  ERR_HASHVAL_C(0x8A67CC74)
# endif /* !defined ERR_ERWIN_HASH_INIT6 */
# ifndef ERR_ERWIN_HASH_INIT7
# define ERR_ERWIN_HASH_INIT7  ERR_HASHVAL_C(0x020BBEA6)
# endif /* !defined ERR_ERWIN_HASH_INIT7 */
# ifndef ERR_ERWIN_HASH_INIT8
# define ERR_ERWIN_HASH_INIT8  ERR_HASHVAL_C(0x3B139B22)
# endif /* !defined ERR_ERWIN_HASH_INIT8 */
# ifndef ERR_ERWIN_HASH_INIT9
# define ERR_ERWIN_HASH_INIT9  ERR_HASHVAL_C(0x514A0879)
# endif /* !defined ERR_ERWIN_HASH_INIT9 */
#endif

/* For data structures with deterministic combination order: */
#ifndef ERR_ERWIN_HASH_MIX_ORDERED
#define ERR_ERWIN_HASH_MIX_ORDERED(h1,h2,newvalue)                   \
        do{                                                              \
            h2^= err_erwin_ror1(h1) - ((err_hashval_t)(newvalue)); \
            h1+= err_erwin_mul9(h2);                                  \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_ORDERED */

/* Another function for combining two values at once: */
#ifndef ERR_ERWIN_HASH_MIX_ORDERED2
#define ERR_ERWIN_HASH_MIX_ORDERED2(h1,h2,newvalue1,newvalue2)        \
        do{                                                               \
            h2^= err_erwin_ror1(h1) - ((err_hashval_t)(newvalue1)); \
            h1+= err_erwin_mul9(h2) ^ newvalue2;                       \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_ORDERED2 */

#ifndef ERR_ERWIN_HASH_MIX_ORDERED3
#define ERR_ERWIN_HASH_MIX_ORDERED3(h1,h2,n1,n2,n3)  \
        do{                                              \
            ERR_ERWIN_HASH_MIX_ORDERED2(h1,h2,n1,n2); \
            ERR_ERWIN_HASH_MIX_ORDERED (h1,h2,n3);    \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_ORDERED3 */

#ifndef ERR_ERWIN_HASH_MIX_ORDERED4
#define ERR_ERWIN_HASH_MIX_ORDERED4(h1,h2,n1,n2,n3,n4) \
        do{                                                \
            ERR_ERWIN_HASH_MIX_ORDERED2(h1,h2,n1,n2);   \
            ERR_ERWIN_HASH_MIX_ORDERED2(h1,h2,n3,n4);   \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_ORDERED4 */

#ifndef ERR_ERWIN_HASH_MIX_ORDERED5
#define ERR_ERWIN_HASH_MIX_ORDERED5(h1,h2,n1,n2,n3,n4,n5) \
        do{                                                   \
            ERR_ERWIN_HASH_MIX_ORDERED3(h1,h2,n1,n2,n3);   \
            ERR_ERWIN_HASH_MIX_ORDERED2(h1,h2,n4,n5);      \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_ORDERED5 */

#ifndef ERR_ERWIN_HASH_RESULT_ORDERED
#define ERR_ERWIN_HASH_RESULT_ORDERED(h1,h2) \
        err_erwin_make_hash_result(h1,h2)
#endif /* !defined ERR_ERWIN_HASH_RESULT_ORDERED */

/* For data structures with non-deterministic combination order.
 * It is assumed that the arguments of these functions are in
 * deterministic order, i.e., that you hash a non-deterministic
 * sequence of n record entries each:
 *     MIX(h,i,a,b)       ; order of lines non-deterministic, but
 *     MIX(h,i,a,b)       ; never b,a instead of a,b
 *     ...
 *     MIX(h,i,a,b)
 * If this is not the case, the easiest way to mix the result
 * is to use  a simple + or ^.
 */

#ifndef ERR_ERWIN_HASH_MIX_UNORDERED
#define ERR_ERWIN_HASH_MIX_UNORDERED(h1,h2,newvalue) \
        do{                                              \
            h1^= ((err_hashval_t)(newvalue));         \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_UNORDERED */

/* Another function for combining two values at once: */
#ifndef ERR_ERWIN_HASH_MIX_UNORDERED2
#define ERR_ERWIN_HASH_MIX_UNORDERED2(h1,h2,newvalue1,newvalue2) \
        do{                                                          \
            h1^= ((err_hashval_t)(newvalue1));                    \
            h2+= newvalue2;                                          \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_UNORDERED2 */

#ifndef ERR_ERWIN_HASH_MIX_UNORDERED3
#define ERR_ERWIN_HASH_MIX_UNORDERED3(h1,h2,n1,n2,n3)  \
        do{                                                \
            ERR_ERWIN_HASH_MIX_UNORDERED2(h1,h2,n1,n2); \
            ERR_ERWIN_HASH_MIX_UNORDERED (h1,h2,n3);    \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_UNORDERED3 */

#ifndef ERR_ERWIN_HASH_MIX_UNORDERED4
#define ERR_ERWIN_HASH_MIX_UNORDERED4(h1,h2,n1,n2,n3,n4) \
        do{                                                  \
            ERR_ERWIN_HASH_MIX_UNORDERED2(h1,h2,n1,n2);   \
            ERR_ERWIN_HASH_MIX_UNORDERED2(h1,h2,n3,n4);   \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_UNORDERED4 */

#ifndef ERR_ERWIN_HASH_MIX_UNORDERED5
#define ERR_ERWIN_HASH_MIX_UNORDERED5(h1,h2,n1,n2,n3,n4,n5) \
        do{                                                     \
            ERR_ERWIN_HASH_MIX_UNORDERED3(h1,h2,n1,n2,n3);   \
            ERR_ERWIN_HASH_MIX_UNORDERED2(h1,h2,n4,n5);      \
        }while(0)
#endif /* !defined ERR_ERWIN_HASH_MIX_UNORDERED5 */

/* the following function is provided for compatibility with older
 * versions.  It is of no use. */;
#ifndef ERR_ERWIN_HASH_RESULT_UNORDERED
#define ERR_ERWIN_HASH_RESULT_UNORDERED \
        ERR_ERWIN_HASH_RESULT_ORDERED
#endif /* !defined ERR_ERWIN_HASH_RESULT_UNORDERED */

/* The more modern state based interface which leaves more space for
 * future improvements. */
#ifndef ERR_ERWIN_STATE_INIT
#define ERR_ERWIN_STATE_INIT(s)            \
            do{                                \
                s.h1= ERR_ERWIN_HASH_INIT2; \
                s.h2= ERR_ERWIN_HASH_INIT3; \
            }while(0)
#endif /* !defined ERR_ERWIN_STATE_INIT */

#ifndef ERR_ERWIN_STATE_INIT_WITH
#define ERR_ERWIN_STATE_INIT_WITH(s,h)                             \
            do{                                                        \
                s.h1= ERR_ERWIN_HASH_INIT2 - ((err_hashval_t)h); \
                s.h2= ERR_ERWIN_HASH_INIT3;                         \
            }while(0)
#endif /* !defined ERR_ERWIN_STATE_INIT_WITH */


struct err_erwin_hash_state_t {
    err_hashval_t h1;
    err_hashval_t h2;
};

#ifndef __cplusplus
typedef struct err_erwin_hash_state_t err_erwin_hash_state_t;
#endif

#ifndef ERR_ERWIN_STATE_MIX_ORDERED
#define ERR_ERWIN_STATE_MIX_ORDERED(s,n1) \
            ERR_ERWIN_HASH_MIX_ORDERED(s.h1,s.h2,n1)
#endif /* !defined ERR_ERWIN_STATE_MIX_ORDERED */

#ifndef ERR_ERWIN_STATE_MIX_ORDERED2
#define ERR_ERWIN_STATE_MIX_ORDERED2(s,n1,n2) \
            ERR_ERWIN_HASH_MIX_ORDERED2(s.h1,s.h2,n1,n2)
#endif /* !defined ERR_ERWIN_STATE_MIX_ORDERED2 */

#ifndef ERR_ERWIN_STATE_MIX_ORDERED3
#define ERR_ERWIN_STATE_MIX_ORDERED3(s,n1,n2,n3) \
            ERR_ERWIN_HASH_MIX_ORDERED3(s.h1,s.h2,n1,n2,n3)
#endif /* !defined ERR_ERWIN_STATE_MIX_ORDERED3 */

#ifndef ERR_ERWIN_STATE_MIX_ORDERED4
#define ERR_ERWIN_STATE_MIX_ORDERED4(s,n1,n2,n3,n4) \
            ERR_ERWIN_HASH_MIX_ORDERED4(s.h1,s.h2,n1,n2,n3,n4)
#endif /* !defined ERR_ERWIN_STATE_MIX_ORDERED4 */

#ifndef ERR_ERWIN_STATE_MIX_ORDERED5
#define ERR_ERWIN_STATE_MIX_ORDERED5(s,n1,n2,n3,n4,n5) \
            ERR_ERWIN_HASH_MIX_ORDERED5(s.h1,s.h2,n1,n2,n3,n4,n5)
#endif /* !defined ERR_ERWIN_STATE_MIX_ORDERED5 */


#ifndef ERR_ERWIN_STATE_MIX_UNORDERED
#define ERR_ERWIN_STATE_MIX_UNORDERED(s,n1) \
            ERR_ERWIN_HASH_MIX_UNORDERED(s.h1,s.h2,n1)
#endif /* !defined ERR_ERWIN_STATE_MIX_UNORDERED */

#ifndef ERR_ERWIN_STATE_MIX_UNORDERED2
#define ERR_ERWIN_STATE_MIX_UNORDERED2(s,n1,n2) \
            ERR_ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2)
#endif /* !defined ERR_ERWIN_STATE_MIX_UNORDERED2 */

#ifndef ERR_ERWIN_STATE_MIX_UNORDERED3
#define ERR_ERWIN_STATE_MIX_UNORDERED3(s,n1,n2,n3) \
            ERR_ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2,n3)
#endif /* !defined ERR_ERWIN_STATE_MIX_UNORDERED3 */

#ifndef ERR_ERWIN_STATE_MIX_UNORDERED4
#define ERR_ERWIN_STATE_MIX_UNORDERED4(s,n1,n2,n3,n4) \
            ERR_ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2,n3,n4)
#endif /* !defined ERR_ERWIN_STATE_MIX_UNORDERED4 */

#ifndef ERR_ERWIN_STATE_MIX_UNORDERED5
#define ERR_ERWIN_STATE_MIX_UNORDERED5(s,n1,n2,n3,n4,n5) \
            ERR_ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2,n3,n4,n5)
#endif /* !defined ERR_ERWIN_STATE_MIX_UNORDERED5 */


#ifndef ERR_ERWIN_STATE_GET_HASHVAL
#define ERR_ERWIN_STATE_GET_HASHVAL(s) \
            ERR_ERWIN_HASH_RESULT_ORDERED(s.h1,s.h2)
#endif /* !defined ERR_ERWIN_STATE_GET_HASHVAL */


/*
 * The implementation of global errno is not straightforward when using
 * a complex string replacement algorithm like the template mechanism
 * of Erwin--.  E.g. we cannot declare a global map_errno, because
 * someone might choose to map `map' to `hash'.  Then the instantiated
 * templates would not be able to be liked with this library.  Therefore,
 * we must introduce stupid names which hopefully no-one remaps to
 * something strange.  Then, {map,vector}_errno (or whatever they will
 * be renamed to) are macros mapping to one of the following variables.
 *
 * Another problem is that map_errno is a global variable which is not
 * thread safe.  Therefore, its declaration is not straightforward...
 */
/* must be in sync with map.c: */
#if !defined(ERR_ERWIN_THREAD_SAFE) || ERR_ERWIN_USE_THREAD_KEYWORD
extern ERR_ERWIN_THREAD_LOCAL int err_erwininternalmaperrno;
#elif ERR_ERWIN_USE_PTHREAD
extern int *err_erwininternalmaperrnoptr(void);
#define err_erwininternalmaperrno (*err_erwininternalmaperrnoptr())
#endif

extern char const *err_erwininternalmapstrerror (int) ATTR_PURE;

#define ERR_ERWININTERNALMAPOK                   1
/* The value 0 is not used for error codes because 0 is polymorphic
 * and can be a pointer.  1 cannot. */

#define ERR_ERWININTERNALMAPISOK(X)              ((X) == ERR_ERWININTERNALMAPOK)
#define ERR_ERWININTERNALMAPISERROR(X)           ((X) <  ERR_ERWININTERNALMAPOK)
#define ERR_ERWININTERNALMAPISWARNING(X)         ((X) >  ERR_ERWININTERNALMAPOK)

#define ERR_ERWININTERNALMAPERRNOMEM             (-2)
#define ERR_ERWININTERNALMAPERRASSERTIONFAILED   (-5)

#define ERR_ERWININTERNALMAPWARNEMPTY            5
#define ERR_ERWININTERNALMAPWARNNOMOREELEMS      6
#define ERR_ERWININTERNALMAPWARNEXISTINGKEY      7
#define ERR_ERWININTERNALMAPWARNKEYNOTFOUND      8

#define ERR_ERWININTERNALMAPREHASHNOMEM          2
#define ERR_ERWININTERNALMAPREHASHDUPLICATEKEY   3
#define ERR_ERWININTERNALMAPREHASHRECURSION      4

#ifdef __cplusplus
}
#endif

#endif /* defined(ERR_ERWIN_ADAM_NAME) */

#endif /* ERR_ERWIN_ERWIN_MAP_H */
