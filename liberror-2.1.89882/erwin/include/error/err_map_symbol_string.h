/* -*- Mode: C -*- */
/* Generated Wed Sep 17 00:48:20 GMT 2008
 */
/*
 * Author: Henrik Theiling
 * Description:
 *     Public header file for maps with arbitrary key and value types.
 *     The implementation uses dynamic hashing with lists as conflict
 *     resolving mechanism.
 *
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including err_map_symbol_string.h"
#endif

#ifndef ERWIN_ERR_MAP_SYMBOL_STRING_h
#define ERWIN_ERR_MAP_SYMBOL_STRING_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of err_map_symbol_string.h"
#endif

/* Include basic configuration */
#ifdef ERR_ERWIN_COMPILING
#  include "error/erwin/defs.h"
#else
#  include <error/erwin/defs.h>
#endif

/* Include the definitions: */
#include "error/err_map_symbol_string_d.h"

/* Include basic definitions */
#ifdef ERR_ERWIN_COMPILING
#  include "error/erwin/base.h"
#else
#  include <error/erwin/base.h>
#endif

/* Include forward declarations */
#ifdef ERR_ERWIN_COMPILING
#  include "error/erwin/forwards.h"
#else
#  include <error/erwin/forwards.h>
#endif

#ifdef HAVE_STDIO_H
#include <stdio.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(ERR_ERWIN_REQUIRE_DETERMINISM) && !defined(ERR_ERWIN_WEAK_DETERMINISM)
#  ifndef __cplusplus
/* #    error "Determinism for maps is currently only available for C++." */
/*     Too many problems with mixed C/C++ projects. */
/*     Actually, C projects will still be 'weakly' deterministic, in the sence
 *     that they are determinstic on the EQUAL and HASH_RAW level.  Only the
 *     special DETCMP are ignored.  This is because iteration in C still
 *     iterates over the internal structure deterministically, which is
 *     sorted by HASH_RAW mainly and the insertion order and EQUAL secondly.
 *     And since with enabled determinism, the internal hash table for
 *     distributing HASH_RAW to HASH is not randomised when using determinism,
 *     hash tables are still, well, weakly determistic.
 *     The non-determinsm usually occurs when symbols are hash, since the
 *     system simply produces different pointer values during different
 *     runs, leading to different structures inside the hash table.  This
 *     is then overcome in C++ by sorting the table before iteration. */
#  endif
#endif

/* These are undef'ed first because there is only one error code for all
 * the maps in your program.
 * All the functions returing error codes will both return this error
 * and write it into err_map_errno.
 *    == ERR_MAP_OK: Ok.
 *               Macro: ERR_MAP_IS_OK(X)
 *
 *    <  ERR_MAP_OK: Error: operation did not succeed.
 *               Macro: ERR_MAP_IS_ERROR(X)
 *
 *    >  ERR_MAP_OK: Warning: operation did succeed but not perfectly. (e.g.
 *                        rehash failed)
 *               Macro: ERR_MAP_IS_WARNING(X)
 *
 *  In all cases, success, errors, warnings, rehash failures, failed assertions, etc, the
 *  consistency of the data structure is guaranteed.
 */

#undef  err_map_errno

#if ERR_ERWIN_GLOBAL_ERRNO
#  define err_map_errno err_erwininternalmaperrno
  /* The global map status code. */
#endif

#undef  err_map_strerror
#define err_map_strerror err_erwininternalmapstrerror
  /* Returns a textual description of a given error.  This description
   * starts with `Error: ' or `Warning: ' or something the like
   * to indicate the status level.  This is then followed by a
   * short description phrase.
   */

/*! enum: ERR_MAP_OK, ERR_MAP_ERR_*, ERR_MAP_WARN_*, ERR_MAP_REHASH_* */
#undef  ERR_MAP_OK
#define ERR_MAP_OK                     ERR_ERWININTERNALMAPOK
    /* No error occurred */

#undef  ERR_MAP_IS_OK
#define ERR_MAP_IS_OK(X)               ERR_ERWININTERNALMAPISOK(X)
  /* Find out whether the status code map_errno indicates that everything is fine. */

#undef  ERR_MAP_IS_ERROR
#define ERR_MAP_IS_ERROR(X)            ERR_ERWININTERNALMAPISERROR(X)
  /* Find out whether the status code map_errno indicates that an error occured. */

#undef  ERR_MAP_IS_WARNING
#define ERR_MAP_IS_WARNING(X)          ERR_ERWININTERNALMAPISWARNING(X)
  /* Find out whether the status code map_errno indicates that an error occured. */

#undef  ERR_MAP_ERR_NOMEM
#define ERR_MAP_ERR_NOMEM              ERR_ERWININTERNALMAPERRNOMEM
  /* Memory exhausted.  If you think this is a fatal error and should be
   * treated like a failed assertion, #define ERR_ERWIN_NOMEM_IS_FATAL.
   */

#undef  ERR_MAP_ERR_ASSERTIONFAILED
#define ERR_MAP_ERR_ASSERTIONFAILED    ERR_ERWININTERNALMAPERRASSERTIONFAILED
  /* Whenever an axiomatic assertion failed, this error is occured.
   *
   * Note: Something really went wrong in this case, so do not expect that
   *       every failed assertion allows normal control flow to continue.
   *       This error means the program is broken and would have crashed
   *       or done something bad if the assertion had not been checked.
   */

  /* The following are warnings only.  They are created by the iterator functions: */

#undef  ERR_MAP_WARN_EXISTINGKEY
#define ERR_MAP_WARN_EXISTINGKEY       ERR_ERWININTERNALMAPWARNEXISTINGKEY
  /* A key could not be inserted into a map, because it already exists. */

#undef  ERR_MAP_ERR_EXISTINGKEY
#define ERR_MAP_ERR_EXISTINGKEY please_use_MAP_WARN_EXISTINGKEY_instead

#undef  ERR_MAP_WARN_KEYNOTFOUND
#define ERR_MAP_WARN_KEYNOTFOUND       ERR_ERWININTERNALMAPWARNKEYNOTFOUND
  /* A key was not found in the map. */

#undef  ERR_MAP_ERR_KEYNOTFOUND
#define ERR_MAP_ERR_KEYNOTFOUND please_use_MAP_WARN_KEYNOTFOUND_instead

#undef  ERR_MAP_WARN_EMTPY
#define ERR_MAP_WARN_EMPTY             ERR_ERWININTERNALMAPWARNEMPTY

#undef  ERR_MAP_WARN_NOMOREELEMS
#define ERR_MAP_WARN_NOMOREELEMS       ERR_ERWININTERNALMAPWARNNOMOREELEMS

#undef  ERR_MAP_REHASH_NOMEM
#define ERR_MAP_REHASH_NOMEM           ERR_ERWININTERNALMAPREHASHNOMEM
  /* This is returned if the element could be inserted but the rehash then failed. */

#undef  ERR_MAP_REHASH_DUPLICATEKEY
#define ERR_MAP_REHASH_DUPLICATEKEY    ERR_ERWININTERNALMAPREHASHDUPLICATEKEY
  /* This is returned if a consistency error is detected during a rehash operation.
   * In this case there where two duplicate keys.
   *   This can happen if the copy function for the
   *   keys is missing or if the comparison and hash functions do not
   *   work properly. */

#undef  ERR_MAP_REHASH_RECURSION
#define ERR_MAP_REHASH_RECURSION       ERR_ERWININTERNALMAPREHASHRECURSION
  /* This is returned if a rehash operation behaved totally unexpectedly
   * and triggered its own recursive call. */


typedef err_symbol_t err_map_symbol_string_index_t;
typedef char const * err_map_symbol_string_value_t;

typedef struct _err_map_symbol_string_pair_t {
    err_symbol_t key;
    char const * value;
} err_map_symbol_string_pair_t;

typedef err_map_symbol_string_pair_t err_map_symbol_string_pair_dynarray;


typedef struct _err_map_symbol_string_pair_ptr_t {
    err_symbol_t key;
    char * *value;
} err_map_symbol_string_pair_ptr_t;


typedef err_map_symbol_string_pair_ptr_t err_map_symbol_string_pair_ptr_dynarray;

typedef int (*err_map_symbol_string_pair_cmp_t)(err_map_symbol_string_pair_t const *, err_map_symbol_string_pair_t const *);

typedef int (*err_map_symbol_string_pair_ptr_cmp_t)(err_map_symbol_string_pair_ptr_t const *, err_map_symbol_string_pair_ptr_t const *);

typedef int (*err_map_symbol_string_void_pair_cmp_t)(void const *, void const *);



typedef ERR_ERWIN_BOOL (*err_map_symbol_string_feature_t)(err_symbol_t , char const * );


typedef char const * const *err_map_symbol_string_element_ptr_t;



typedef err_symbol_t err_map_symbol_string_key_result_t;


#ifndef ERR_MAP_ITERATOR

#define ERR_MAP_ITERATOR
struct _err_map_iterator_t;

typedef void (*_err_map_iterator_callback_t) (void const *, struct _err_map_iterator_t *);

typedef struct _err_map_iterator_t {
    /* This is an iterator for maps.  You need to know about this struct
     * when programming in C, since you have to declare such an iterator
     * manually.  err_map_symbol_string iteration looks like this:
     *     : err_map_iterator_t iter;
     *     : ...
     *     : err_map_symbol_string_forall (map, iter, key, value) {
     *     :     ...
     *     : }
     *
     * The internal structure of this class is not important to the user,
     * however -- you should never try to look inside an iterator structure.
     */

    /*! class-ignore */
    void *p;
    int i;
#ifdef __cplusplus
    _err_map_iterator_t ()
    {}

   /* This is a hack, but I did not find a good way of programming the C++ iterator. */
    _err_map_iterator_t (
        _err_map_iterator_callback_t callback,
        void const *map)
    {
         callback (map, this);
    }
#endif /* defined(__cplusplus) */
} err_map_iterator_t;


#ifdef __cplusplus
/*
 * Only available in C++ since otherwise some easy to produce memory leaks would be
 * really hard to find for the user.  In C, the user must sort the array themself.
 */
struct _err_map_iterator_sorted_t;

typedef void (*_err_map_iterator_sorted_callback_t)
                 (void const *, struct _err_map_iterator_sorted_t *);

typedef int  (*_err_map_iterator_cmp_callback_t)(void const *, void const *);

typedef void (*_err_map_iterator_sorted_init_callback_t)(
            void const *,
            struct _err_map_iterator_sorted_t *,
            _err_map_iterator_cmp_callback_t);

typedef struct _err_map_iterator_sorted_t {
    /* You do not need any knowledge about this class, since
     * the C++ interface introduces iterators on the fly and
     * the C interface currently has no support for sorted
     * iteration, since allocation/deallocation of the needed
     * help structures is a serious problem in C.
     */

    /*! class-ignore */
    void *p;
    int l;
    int c;
    void (*free_cb)(void *);

    _err_map_iterator_sorted_t ():
         free_cb(0)
    {}

    _err_map_iterator_sorted_t (
        _err_map_iterator_sorted_callback_t callback,
        void const *map)
    {
        callback (map, this);
    }

    _err_map_iterator_sorted_t (
        _err_map_iterator_sorted_init_callback_t callback,
        void const *map,
        _err_map_iterator_cmp_callback_t u)
    {
         callback (map, this, u);
    }

    ~_err_map_iterator_sorted_t ()
    {
         if (free_cb) free_cb ((void*)this);
            /* (a kind of virtual destructor)
             * Callback, since the operator does not know how to do it.
             */
    }
} err_map_iterator_sorted_t;
#endif

#endif /* defined(ERR_MAP_ITERATOR) */


/* ***** handling `hash' objects: ***** */


/*--BEGIN-C--*/
ERR_ERWIN_EXPORT
err_map_symbol_string_t *err_map_symbol_string_new (void) ATTR_MALLOC;
  /* Return a new map with default settings.  I.e., with the
   * default zero element ERR_MAP_SYMBOL_STRING_ZERO and the default initial hash table
   * size of ERR_MAP_SYMBOL_STRING_INITIAL_SIZE.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
err_map_symbol_string_t *err_map_symbol_string_new_with_initial_size (int /*initial_size*/) ATTR_MALLOC;
  /* Create a new map with a given initial hash table.  This is
   * useful whenever you know how many entries you will have.
   *
   * The number you pass is interpreted as the number of elements.
   * The real hash size that will be used will be computed in such
   * a way that no rehash will occur when inserting the number of
   * elements given.  Note that a single deletion of an element may
   * still trigger a rehash, only when only inserting the elements,
   * no rehash is guaranteed.
   *
   * If initial_size < 0 the default size ERR_MAP_SYMBOL_STRING_INITIAL_SIZE will be used.
   * If initial_size == 0 but ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE > 0, a size of 1 will be
   * used.
   *
   * With the default value of the re-hash parameters, a re-hash
   * will be done when the map has more than 80% entries compared
   * to the hash table size.  So if you intend to insert 80 entries,
   * you must specify more than 100 for the initial size.  To be
   * precise, you must specify more than
   * ERR_MAP_SYMBOL_STRING_TRIGGER_NUMERATOR * 80 / ERR_MAP_SYMBOL_STRING_TRIGGER_DENOMINATOR.
   *
   * \errno(OK, ERR_NOMEM)
   */

#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
ERR_ERWIN_EXPORT
err_map_symbol_string_t *err_map_symbol_string_new_with_zero (char const *  /*zero*/) ATTR_MALLOC;
  /* zero will eventually be tried to be copied!  So if you provide
   * CHAR_CONST_P_OCOPY, make sure it handles the zero element appropriately.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
err_map_symbol_string_t *err_map_symbol_string_new_with_zero_and_initial_size (char const *  /*zero*/, int /*initial_size*/) ATTR_MALLOC;
  /* Create a new, empty map.  The first form uses
   * err_char_const_p_zero as the zero element.
   *
   * If initial_size < 0 the default size ERR_MAP_SYMBOL_STRING_INITIAL_SIZE will be used.
   * If initial_size == 0 but ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE > 0, a size of 1 will be
   * used.
   *
   * \errno(OK, ERR_NOMEM)
   */
#endif

ERR_ERWIN_EXPORT
int err_map_symbol_string_init (
    err_map_symbol_string_t * /*self*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap err_map_symbol_string_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
ERR_ERWIN_EXPORT
int err_map_symbol_string_init_with_zero_and_initial_size (
    err_map_symbol_string_t *      /*self*/,
    char const *  /*zero*/,
    int          /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap err_map_symbol_string_t objects that are allocated
   * manually (thus, not via err_map_symbol_string_new).
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */
#endif

ERR_ERWIN_EXPORT
int err_map_symbol_string_init_with_initial_size (
    err_map_symbol_string_t * /*self*/,
    int     /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap err_map_symbol_string_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
void err_map_symbol_string_destroy (err_map_symbol_string_t * /*self*/);
  /*
   * This is for deleting non-heap err_map_symbol_string_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK)
   */

ERR_ERWIN_EXPORT
void err_map_symbol_string_xchg (err_map_symbol_string_t * /*self*/, err_map_symbol_string_t * /*other*/);
  /*
   * Exchanges the two maps' contents.  No memory allocation is
   * performed; this is a fast O(1) operation for swapping two values.
   */

ERR_ERWIN_EXPORT
void err_map_symbol_string_destroy_flags (
  err_map_symbol_string_t * /*self*/, ERR_ERWIN_BOOL /* destroy_keys */, ERR_ERWIN_BOOL /* destroy_values */);
  /*
   * Same as err_map_symbol_string_destroy with the possiblity to determine what to destroy.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK)
   */


#if !ERR_ERWIN_GLOBAL_ERRNO
ERR_ERWIN_EXPORT
int err_map_symbol_string_errno(err_map_symbol_string_t const *) ATTR_PURE ATTR_NONNULL((1));
  /* If the library was compiled with ERR_ERWIN_THREAD_SAFE, this is the
   * way to retrieve the status code of a map.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \noerrno
   */

ERR_ERWIN_EXPORT
void err_map_symbol_string_clear_errno(err_map_symbol_string_t const *) ATTR_NONNULL((1));
  /* Resets the status code to MAP_OK.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \errno(OK)
   */

#else

#define err_map_symbol_string_errno(X)          err_map_errno
  /* If the library was not compiled with ERR_ERWIN_THREAD_SAFE, err_map_symbol_string_errno(X)
   * is just a synonym for the global variable err_map_errno.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \noerrno
   */

#define err_map_symbol_string_clear_errno(X)    ((void)(err_map_errno= ERR_MAP_OK))
  /* If the library was not compiled with ERR_ERWIN_THREAD_SAFE, err_map_symbol_string_clear_errno(X)
   * is a small macro that resets the status code to ERR_MAP_OK.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \errno(OK)
   */

#endif

ERR_ERWIN_EXPORT
err_map_symbol_string_t *err_map_symbol_string_copy (err_map_symbol_string_t const* /*self*/);
  /* Copies the map with all its keys and elements
   *
   * NULL is allowed and passed through.
   *
   * Don't use as a copy function for other Erwin structures.  Use _copy_err instead.
   *
   * \errno(OK,REHASH_*,ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
err_map_symbol_string_t *err_map_symbol_string_copy_err (err_map_symbol_string_t const* /*self*/, int *err);
  /* Copies the map with all its keys and elements.  *err will be set
   * to 1 if an error occurs.
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */


ERR_ERWIN_EXPORT
void err_map_symbol_string_delete (err_map_symbol_string_t* /*self*/);
  /* Deletes everything in the map and the map structure itself
   *
   * \errno(OK)
   */

ERR_ERWIN_EXPORT
void   err_map_symbol_string_delete_flags (err_map_symbol_string_t* /* self*/, ERR_ERWIN_BOOL /* destroy_keys */, ERR_ERWIN_BOOL /* destroy_values */);
  /* Deletes only the map structure, not the entries.  This is
   * useful if you got the entries via err_map_symbol_string_get_{values|keys}.
   * err_map_symbol_string_delete_flat (a, true, true) is the same as
   * err_map_symbol_string_delete (a);
   *
   * \errno(OK)
   */


/* *****  normal operations: ***** */


/* The `err_symbol_t' is used to force the caller to provide copy functions
 * when pointers are used for err_symbol_t.  Otherwise, duplicate keys are
 * easily possible. */
ERR_ERWIN_EXPORT
int err_map_symbol_string_insert (err_map_symbol_string_t* /*self*/, err_symbol_t  /*key*/, char const *  /*value*/) ATTR_NONNULL((1));
  /* Introduces a value for a given key into the map.  If the key did not
   * exist, errno will be OK.  If the key existed, the map will not be changed,
   * and errno will be WARN_EXISTINGKEY.
   *
   * Key and value are copied (if copy functions are available, as usual).
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_insert_map (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* Inserts all keys from other into self.  If any key is not inserted,
   * returns WARN_EXISTINGKEY.
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
err_symbol_t  err_map_symbol_string_ensure (err_map_symbol_string_t* /*self*/, err_symbol_t  /*key*/) ATTR_NONNULL((1));
  /* This ensures that key is inserted in the table, i.e., it allocates a cell
   * for it.  The inserted value will be ERR_CHAR_CONST_P_ZERO.  If you
   * want to change this, re-define ERR_MAP_SYMBOL_STRING_ENSURE_VALUE.
   * The result is the key as inserted in the hash table, so if you defined
   * ERR_ERR_SYMBOL_T_ICOPY, you will get a copy of your key.
   *
   * Note: This function implements symbol tables.
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
err_symbol_t  err_map_symbol_string_ensure_no_icopy (err_map_symbol_string_t * /*self*/, err_symbol_t  /*key*/) ATTR_NONNULL((1));
  /* This is like err_map_symbol_string_ensure(), but the input key will be stolen or freed, i.e.,
   * it will be used as a copy inside the hash table, instead of being copied
   * as in err_map_symbol_string_ensure.  If the key already exists, the key passed will be freed.
   *
   * Note: This function implements symbol tables.
   *
   * This could be called err_map_symbol_string_ensure_steal(), but we already have poke_no_icopy().
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
char const *  err_map_symbol_string_find_any (err_map_symbol_string_t const* /*self*/)
  ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element if not found.
   *
   * For maps with 0 or 1 elements and in the non-deterministic
   * case, this is very fast.  In the deterministic mode, this
   * is O(n).  In weak determinism, it is typically O(1) as in
   * the non-deterministic mode.  (The very unlikely worst case
   * is always O(n)).
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */


ERR_ERWIN_EXPORT
int err_map_symbol_string_find_any_pair (err_map_symbol_string_key_result_t *, err_map_symbol_string_element_ptr_t *, err_map_symbol_string_t const* /*self*/)
  ATTR_ERRNO_PURE;
  /* Returns the number of elements in the map.  If that is > 0, the
   * first argument is set to any key, and the second to the pointer to
   * the corresponding value.
   *
   * You may pass NULL for any of the first two parameters if you do not want
   * the return value.
   *
   * See err_map_symbol_string_find_any() for more documentation.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */


ERR_ERWIN_EXPORT
char const *   err_map_symbol_string_find (err_map_symbol_string_t const* /*self*/, err_symbol_t  /*index*/)
  ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element if not found.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
char const *  err_map_symbol_string_find_ensure (err_map_symbol_string_t * /*self*/, err_symbol_t  /*index*/);
  /* Returns the found element or introduces an empty element into the
   * map and returns that (use ERR_MAP_SYMBOL_STRING_ENSURE_VALUE to determine the value
   * that is introduced).
   *
   * Also consider find_ptr_ensure if you want to modify the (newly
   * introduced) value.  Also see err_map_symbol_string_ensure if you need the key, not
   * the value after the operation.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
err_symbol_t   err_map_symbol_string_find_key (err_map_symbol_string_t const* /*self*/, err_symbol_t  /*index*/) ATTR_ERRNO_PURE;
  /* Returns the key as stored in the table.  For copied pointer types, this
   * might be different from index.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
err_symbol_t   err_map_symbol_string_find_any_key (err_map_symbol_string_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns some key that is stored in the table.
   *
   * See err_map_symbol_string_find_any() for docu.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */


ERR_ERWIN_EXPORT
err_map_symbol_string_element_ptr_t err_map_symbol_string_find_ptr (err_map_symbol_string_t const* /*self*/, err_symbol_t  /*index*/) ATTR_ERRNO_PURE;
  /* Returns a pointer to the found element or NULL on failure.
   *
   * Note: If char const * == char *, you may not use the pointer to directly
   * write into the hash table because this circumvents copying and that
   * is prohibited.  Use poke_no_ocopy for things like that to make it
   * explicit.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
err_map_symbol_string_element_ptr_t err_map_symbol_string_find_any_ptr (err_map_symbol_string_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns a pointer to some element or NULL on failure.
   *
   * Note: If char const * == char *, you may not use the pointer to directly
   * write into the hash table because this circumvents copying and that
   * is prohibited.  Use poke_no_ocopy for things like that to make it
   * explicit.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
err_map_symbol_string_element_ptr_t err_map_symbol_string_find_ptr_ensure (err_map_symbol_string_t * /*self*/, err_symbol_t  /*index*/);
  /* Returns a pointer to the found element or one to a newly allocated one.
   * In the case when it was not possible to allocate space for a new element,
   * the result NULL.  Otherwise, it is not NULL.
   *
   * If a new element was introduced, errno will be set to MAP_WARN_KEYNOTFOUND,
   * otherwise to MAP_OK.  Note again that in both cases, the result is non-NULL!
   *
   * Note: If char const * == char *, you may not use the pointer to directly
   * write into the hash table because this circumvents copying and that
   * is prohibited.  Use poke_no_ocopy for things like that to make it
   * explicit.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
char * err_map_symbol_string_modify (
    err_map_symbol_string_t* /*self*/, err_symbol_t  /*index*/, char const *  /*value*/) ATTR_NONNULL((1));
  /* Change an existing value for the given index (errno=OK).  If the index does
   * not exist, do not modify the map nothing (errno=WARN_KETNOTFOUND).
   *
   * Returns the old value or ERR_CHAR_CONST_P_ZERO if it is new in which case the map is
   * not changed.  Nothing is freed, value is copied.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_modify_map (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* like err_map_symbol_string_modify on all entries in other.  If any key was not found,
   * WARN_KEYNOTFOUND is returned.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_set (err_map_symbol_string_t* /*self*/, err_symbol_t  /*index*/, char const *  /*value*/) ATTR_NONNULL((1));
  /* Insert or modify a value: introduce value for given index if it does not
   * exist (errno=OK) or change value if index does exist (errno=WARN_EXISTINGKEY).
   *
   * Similar to err_map_symbol_string_modify, but value is freed and the status instead of the value
   * is returned.   Furthermore, of course, it is different in that if the value
   * does not exist, it will be inserted.
   *
   * Note: If you don't care whether to use err_map_symbol_string_set or err_map_symbol_string_insert, use err_map_symbol_string_insert.
   *       err_map_symbol_string_insert might be a little faster.
   *
   * Result:
   *    The error code, same as err_map_errno.
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_set_map (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* like err_map_symbol_string_set on all entries in other
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */


ERR_ERWIN_EXPORT
int err_map_symbol_string_intersect (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* Implements set intersection: this invokes err_map_symbol_string_erase on all entries
   * in self that are not in other.
   * Returns the number of erased elements (quite like err_map_symbol_string_erase_if).
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_intersect_no_resize (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* Like err_map_symbol_string_intersect, but does not shrink the internal hash table.
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
char * err_map_symbol_string_remove (err_map_symbol_string_t* /*self*/, err_symbol_t  /*index*/) ATTR_NONNULL((1));
  /* Returns the old value or ERR_CHAR_CONST_P_ZERO. Does *not* free the value (which is
   * returned), but only the key.   A more appropriate name for this function
   * might be `steal', because the value is kept.
   *
   * In error-free operation, returns errno=OK if the index was found and erased,
   * and WARN_KEYNOTFOUND if the index was not found.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERR_ERWIN_EXPORT
char * err_map_symbol_string_remove_no_resize (err_map_symbol_string_t* /*self*/, err_symbol_t  /*index*/) ATTR_NONNULL((1));
  /* Like err_map_symbol_string_remove, but does not shrink the internal hash table.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_remove_map (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* like err_map_symbol_string_remove on all entries in other.  If any key was not found,
   * WARN_KEYNOTFOUND is returned.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_remove_if (err_map_symbol_string_t * /*self */, err_map_symbol_string_feature_t /* feature */, ERR_ERWIN_BOOL /* value */);
  /* Remove some entries from the map according to a given feature.  This
   * is much faster than repeated deletions and maximally requires one
   * rehash operation only.
   *
   * NOTE: Even if the library is compiled with determinism, the order of the
   *       invocations of the feature callback is non-deterministic!
   *
   * \errno (OK, REHASH_*)
   */


ERR_ERWIN_EXPORT
int err_map_symbol_string_erase (err_map_symbol_string_t* /*self*/, err_symbol_t  /*index*/) ATTR_NONNULL((1));
  /* Same as err_map_symbol_string_remove, but value is freed.  In error-free operation, returns
   * errno=OK if the index was found and erased, and WARN_KEYNOTFOUND if the
   * index was not found.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_erase_no_resize (err_map_symbol_string_t* /*self*/, err_symbol_t  /*index*/) ATTR_NONNULL((1));
  /* Same as err_map_symbol_string_erase, but does not shrink the internal hash table.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_erase_map (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* like err_map_symbol_string_erase on all entries in other.  If any key was not found,
   * WARN_KEYNOTFOUND is returned.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_erase_map_no_resize (err_map_symbol_string_t* /*self*/, err_map_symbol_string_t const * /* other */);
  /* Like err_map_symbol_string_erase_map, but does not shrink the internal hash table.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_erase_if (err_map_symbol_string_t * /*self */, err_map_symbol_string_feature_t /* feature */, ERR_ERWIN_BOOL /* value */);
  /* Erase some entries from the map according to a given feature.  This
   * is much faster than repeated deletions and maximally requires one
   * rehash operation only.
   *
   * NOTE: Even if the library is compiled with determinism, the order of the
   *       invocations of the feature callback is non-deterministic!
   *
   * \errno (OK, REHASH_*)
   */


ERR_ERWIN_EXPORT
int err_map_symbol_string_poke (
        err_symbol_t *      /* key_out */,
        char * *   /* value_out */,
        err_map_symbol_string_t *      /* self */,
        err_symbol_t  /* key */,
        char const *  /* value */,
        ERR_ERWIN_BOOL       /* introduce */,
        ERR_ERWIN_BOOL       /* overwrite */) ATTR_NONNULL((3));
  /* This is the generalised interface to err_map_symbol_string_insert, err_map_symbol_string_modify, err_map_symbol_string_set, err_map_symbol_string_ensure, err_map_symbol_string_find
   * and err_map_symbol_string_find_key.  This function cannot erase, however (see err_map_symbol_string_erase).
   *
   * Input parameters:
   *   +--------------+----------------------------------------------------------------------+
   *   | \p self      | is the map as usual                                                  |
   *   | \p key       | defines the entry which is to be inserted or changed                 |
   *   | \p value     | is the value that is inserted or with which the entry is overwritten |
   *   | \p introduce | insert a new value if nothing exists for the key                     |
   *   | \p overwrite | defines whether a value will be overwritten if it already exists     |
   *   +--------------+----------------------------------------------------------------------+
   *
   * Output parameters:
   *   +--------------+----------------------------------------------------------------------+
   *   | return value | the error code (err_map_errno)                                    |
   *   +--------------+----------------------------------------------------------------------+
   *   | \p key_out   | *key_out will be the key as inserted in the map.  This can be        |
   *   |              | different from key when the keys are copied.                         |
   *   |              | key_out may be NULL                                                  |
   *   +--------------+----------------------------------------------------------------------+
   *   | \p value_out | If non-NULL, the entry found in the map will be stored here. It      |
   *   |              | will not be freed if it is overwritten of value_out != NULL.         |
   *   |              | If value_out==NULL, overwritten values are freed as usual.           |
   *   +--------------+----------------------------------------------------------------------+
   *
   * Note: The is an important difference between key_out and value_out.  Via
   *       key_out, the *current* key in the map is returned, but via value_out, the
   *       *old* value is returned.
   *
   * The following shows the (idealised) bodies of some functions.
   *
   * err_map_symbol_string_insert:
   *       : return err_map_symbol_string_poke (NULL, NULL, self, key, value,
   *       :                  ERR_ERWIN_TRUE, ERR_ERWIN_FALSE);
   *
   * err_map_symbol_string_set:
   *       : return err_map_symbol_string_poke (NULL, NULL, self, key, value,
   *       :                 ERR_ERWIN_TRUE, ERR_ERWIN_TRUE);
   *
   * err_map_symbol_string_modify:
   *       : char * *result;
   *       : err_map_symbol_string_poke (NULL, &result, self, key, value,
   *       :           ERR_ERWIN_FALSE, ERR_ERWIN_TRUE);
   *       : return result;
   *
   * err_map_symbol_string_find:
   *       : char * *result;
   *       : err_map_symbol_string_poke (NULL, &result, self, key, ZERO (char const *),
   *       :           ERR_ERWIN_FALSE, ERR_ERWIN_FALSE);
   *       : return (char const **)result;
   *
   * err_map_symbol_string_find_key:
   *       : err_symbol_t *result;
   *       : err_map_symbol_string_poke (&result, NULL, self, key, ZERO (char const *),
   *       :           ERR_ERWIN_FALSE, ERR_ERWIN_FALSE);
   *       : return (err_symbol_t*)result;
   *
   * Almost:
   * err_map_symbol_string_ensure:
   *       : err_symbol_t *result;
   *       : err_map_symbol_string_poke (&result, NULL, self, key, ZERO (char const *),
   *       :           ERR_ERWIN_TRUE, ERR_ERWIN_FALSE);
   *       : result;
   * (Only err_map_symbol_string_ensure uses ERR_MAP_SYMBOL_STRING_ENSURE_VALUE to introduce a new element, not
   * ZERO and without copying)
   *
   * Note that err_map_symbol_string_find_ptr, err_map_symbol_string_remove and err_map_symbol_string_erase cannot be implemented with
   * this function.
   *
   * Return Values:
   *    - ERR_MAP_OK:
   *         If an entry was not found, but could be successfully inserted
   *         or if an entry was found and could be successfully overwritten
   *         or if an entry was found and neither insertion nor overwriting was
   *         allowed (introduce == overwrite == ERR_ERWIN_FALSE).
   *
   *     - ERR_MAP_WARN_KEYNOTFOUND:
   *         If a key was not found, but not inserted (due to introduce ==
   *         ERR_ERWIN_FALSE).
   *
   *     - ERR_MAP_WARN_EXISTINGKEY:
   *         If a key was found, but not overwritten (due to overwrite == ERR_ERWIN_FALSE).
   *
   *     - ERR_MAP_ERR_NOMEM:
   *         If a structure could not be allocated, or a key or a value could not
   *         be copied. In this case, the map is returned unmodified.
   *
   *     - ERR_MAP_ERR_ASSERTIONFAILED:
   *         If an assertion failed.
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_poke_no_icopy (
   err_symbol_t * /*key_out*/,
   char * * /*value_out*/,
   err_map_symbol_string_t * /*self*/,
   err_symbol_t  /*key*/,
   char const *  /*value*/,
   ERR_ERWIN_BOOL /*introduce*/,
   ERR_ERWIN_BOOL /*overwrite*/) ATTR_NONNULL((3));
  /* Like err_map_symbol_string_poke, but the key is not copied.  However, \p key will be freed if it is not
   * used for the map.  This means that you pass the responsibility for memory management
   * of the key to the map.  In particular, if you use this function for searching
   * only (i.e., \p introduce == ERWIN_FALSE, \p overwrite == ERWIN_FALSE), the key will
   * always be deallocated.
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_poke_no_ocopy (
  err_symbol_t * /*key_out*/,
  char * * /*value_out*/,
  err_map_symbol_string_t * /*self*/,
  err_symbol_t  /*key*/,
  char *  /*value*/,
  ERR_ERWIN_BOOL /*introduce*/,
  ERR_ERWIN_BOOL /*overwrite*/) ATTR_NONNULL((3));
  /* Like err_map_symbol_string_poke, but the value is not copied.  However, value may be freed if
   * value_out is NULL.  The rules for copying and freeing values are the same as
   * for key with err_map_symbol_string_poke_no_icopy.
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_poke_no_icopy_no_ocopy (
  err_symbol_t * /*key_out*/,
  char * * /*value_out*/,
  err_map_symbol_string_t * /*self*/,
  err_symbol_t  /*key*/,
  char *  /*value*/,
  ERR_ERWIN_BOOL /*introduce*/,
  ERR_ERWIN_BOOL /*overwrite*/) ATTR_NONNULL((3));
  /* Like err_map_symbol_string_poke, but neither the key nor the value are copied.  Both, key and value
   * may be freed.  The rules for copying and freeing keys and values are the same
   * as for err_map_symbol_string_poke_no_icopy and err_map_symbol_string_poke_no_ocopy.
   */

ERR_ERWIN_EXPORT
char const *  err_map_symbol_string_zero (err_map_symbol_string_t const* /*self*/) ATTR_PURE ATTR_NONNULL((1));
  /* Returns the zero element of char const *
   *
   * \noerrno
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_cmp (err_map_symbol_string_t const* /*self*/, err_map_symbol_string_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns a comparison value for the two maps.  The keys must be sortable for this to
   * work.  Maps are invariant in the actual storage order in the hash table.
   *
   * Note: This operation is expensive and needs additional space for copying the
   *       keys of self for sorting!
   *
   * For equality tests, use err_map_symbol_string_equal instead, which is faster.
   *
   * The comparison value is as follows:
   *    a) the map that contains most elements is assumed largest.
   *    b) for equally sized maps, a lexical order is used by sorting the keys and
   *       comparing the values of the two maps.  'Not contained' is assumed
   *       smallest.
   *
   * Further Note: Calling this results in a runtime error if either
   *    ERR_ERR_SYMBOL_T_CMP or ERR_CHAR_CONST_P_CMP is not defined.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_equal (err_map_symbol_string_t const* /*self*/, err_map_symbol_string_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns whether two maps are equal.  (Of course, maps are invariant in the
   * actual storage order in the hash table.)
   *
   * Note: This operation is quite expensive but *much* *less* *expensive*
   *       than err_map_symbol_string_cmp!
   *
   * Further Note: Calling this results in a runtime error if
   * ERR_CHAR_CONST_P_EQUAL is not defined.
   *
   * \errno(OK)
   */

ERR_ERWIN_EXPORT
int err_map_symbol_string_cmp_keys (err_map_symbol_string_t const* /*self*/, err_map_symbol_string_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns whether the set of keys in the map is equal.
   *
   * Note: This operation is quite expensive.  Use keys_equal
   *                if that is sufficient.
   *
   * Further Note: Calling this results in a runtime error if either
   *    ERR_ERR_SYMBOL_T_CMP is not defined.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_equal_keys (err_map_symbol_string_t const* /*self*/, err_map_symbol_string_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns whether the set of keys in the map is equal.
   *
   * Note: This operation is quite expensive but less expensive than
   *                err_map_symbol_string_keys_cmp
   *
   * \errno(OK)
   */

ERR_ERWIN_EXPORT
err_hashval_t err_map_symbol_string_hash_raw (err_map_symbol_string_t const * /*self*/) ATTR_ERRNO_PURE;
  /* Calculates a hash value for this hash table.  In earlier versions of Erwin,
   * the result was inferior to that of err_map_symbol_string_hash, but they are now the same
   * and no additional hashing of the result needs to be done.
   *
   * Note: Calling this results in a runtime error if ERR_CHAR_CONST_P_HASH is not defined.
   *
   * \errno(OK)
   */

ERWIN_WRAPPER err_hashval_t err_map_symbol_string_hash (err_map_symbol_string_t const *) ATTR_ERRNO_PURE;
    /* Same as err_map_symbol_string_hash_raw() now that hash_raw() is good enough. */

ERWIN_WRAPPER err_hashval_t err_map_symbol_string_hash (err_map_symbol_string_t const *x)
{
    return err_map_symbol_string_hash_raw(x);
}


/* ***** access to all entries: ***** */
ERR_ERWIN_EXPORT
void err_map_symbol_string_clear (err_map_symbol_string_t* /*self*/);
   /* Like err_map_symbol_string_erase for all elements
    *
    * \errno(OK)
    */

ERR_ERWIN_EXPORT
void err_map_symbol_string_clear_no_resize (err_map_symbol_string_t* /*self*/);
   /* Like err_map_symbol_string_erase for all elements, but does not shrink the internal hash table.
    *
    * \errno(OK)
    */

ERR_ERWIN_EXPORT
void err_map_symbol_string_clear_flags (
    err_map_symbol_string_t* /*self*/,
    ERR_ERWIN_BOOL     /*destroy_keys*/,
    ERR_ERWIN_BOOL     /*destroy_values*/);
   /* Clear and selectively free the map
    *
    * \errno(OK)
    */

ERR_ERWIN_EXPORT
void err_map_symbol_string_clear_flags_no_resize (
    err_map_symbol_string_t* /*self*/,
    ERR_ERWIN_BOOL     /*destroy_keys*/,
    ERR_ERWIN_BOOL     /*destroy_values*/);
   /* Like err_map_symbol_string_clear_flags, but does not shrink the internal hash table.
    *
    * \errno(OK)
    */

ERR_ERWIN_EXPORT
int err_map_symbol_string_nentries (err_map_symbol_string_t const* /*self*/) ATTR_PURE;
   /* Returns the number of entries (pairs of keys and values)
    *
    * \noerrno
    */

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_empty (err_map_symbol_string_t const* /*self*/) ATTR_PURE;
   /* Returns whether map has 0 entries
    *
    * \noerrno
    */

ERR_ERWIN_EXPORT
err_map_symbol_string_pair_t *err_map_symbol_string_get_entries (err_map_symbol_string_t const* /*self*/) ATTR_MALLOC;
   /* Use err_map_symbol_string_delete_entries to deallocate the returned array.
    *
    * \errno(OK, ERR_NOMEM)
    */

ERR_ERWIN_EXPORT
void err_map_symbol_string_delete_entries (err_map_symbol_string_pair_t * /*entries*/);
   /* Deallocate keys obtained by err_map_symbol_string_get_entries(). */


ERR_ERWIN_EXPORT
err_map_symbol_string_pair_ptr_t *err_map_symbol_string_get_entries_ptr (err_map_symbol_string_t const* /*self*/) ATTR_MALLOC;
   /* Usp err_map_symbol_string_delete_entries_ptr to deallocate the returned array.
    *
    * \errno(OK, ERR_NOMEM) */

ERR_ERWIN_EXPORT
void err_map_symbol_string_delete_entries_ptr (err_map_symbol_string_pair_ptr_t * /*entries_ptr*/);
   /* Deallocate keys obtained by err_map_symbol_string_get_entries_ptr(). */

ERR_ERWIN_EXPORT
char const * *err_map_symbol_string_get_values (err_map_symbol_string_t const* /*self*/) ATTR_MALLOC;
   /* \errno(OK, ERR_NOMEM) */

ERR_ERWIN_EXPORT
void err_map_symbol_string_delete_values (char const * * /*values*/);
   /* Deallocate keys obtained by err_map_symbol_string_get_values(). */

ERR_ERWIN_EXPORT
err_symbol_t *err_map_symbol_string_get_keys   (err_map_symbol_string_t const* /*self*/) ATTR_MALLOC;
   /* Get all keys, values, or key/value pairs as a normal standard C array.
    * The elements and keys are *not* copied.   The array will be terminated
    * with the zero value.
    *
    * Note: The returned maps are newly allocated and must eventually be
    *       freed by the user using err_map_symbol_string_delete_keys().  In earlier versions
    *       of Erwin, free() was recommended for freeing, but due to more
    *       sophisticated memory management, err_map_symbol_string_delete_keys() is the
    *       primary choice now.  It old code, no adjustment should be
    *       necessary, since this is only different if you
    *       customise ERR_ERWIN_TMALLOC etc.
    *
    * \errno(OK, ERR_NOMEM)
    */

ERR_ERWIN_EXPORT
void err_map_symbol_string_delete_keys (err_symbol_t * /*keys*/);
   /* Deallocate keys obtained by err_map_symbol_string_get_keys(). */


/* ***** debugging and special purposes (use rarely!): ***** */
ERR_ERWIN_EXPORT
int err_map_symbol_string_hash_size (err_map_symbol_string_t const* /*self*/) ATTR_PURE;
   /* Returns the size of the internal array of list pointers used to implement
    * the hash table.
    *
    * \noerrno
    */

ERR_ERWIN_EXPORT
void err_map_symbol_string_rehash (err_map_symbol_string_t* /*self*/, int /*newsize*/);
   /* Do a manual rehash.   If err_map_errno holds anything other than MAP_OK,
    * the map operation did not succeed.  However, the map is guaranteed to be
    * usable after the function call; either rehashed or original.
    * The return type is set to void because the function should not be
    * considered failed if anything bad has happened.
    *
    * \errno(OK, REHASH_*)
    */

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_expect_size (err_map_symbol_string_t* /*self*/, int /*newsize*/);
   /* Declare that the immediately following action will
    * insert or delete elements so that the new number of
    * elements will be newsize.  This will possibly rehash
    * to a hash size that requires no rehashes during the
    * following operation.  Note: this only works if you
    * consistently insert or consistently delete elements.
    * If you mix the operations, further rehashes might
    * occur.
    *
    * Returns whether a rehash was performed.
    *
    * \errno(OK, REHASH_*)
    */

ERR_ERWIN_EXPORT
double err_map_symbol_string_average_line_length (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
double err_map_symbol_string_variance_line_length (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

#ifdef HAVE_SQRT
ERR_ERWIN_EXPORT
double err_map_symbol_string_deviation_line_length (err_map_symbol_string_t const* /*self*/) ATTR_PURE;
#endif

ERR_ERWIN_EXPORT
int err_map_symbol_string_max_line_length (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
int err_map_symbol_string_min_line_length (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
void err_map_symbol_string_dump (FILE *, err_map_symbol_string_t const * /*self*/);
  /* Dumps the internal structure of the map to the given file. */

/* ***** iteration: ***** */
/* New approach: */
#define err_map_symbol_string_forall_nondet(h,i,k,v) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration ((h),&i,&k,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over keys and values.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#define err_map_symbol_string_forall_ptr_nondet(h,i,k,v) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration_ptr ((h),&i,&k,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over keys and pointers to values.  You need a map_iterator_t as a
 * temporary for using this.  See err_map_symbol_string_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#define err_map_symbol_string_forall_values_nondet(h,i,v) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration_values ((h),&i,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#define err_map_symbol_string_forall_values_ptr_nondet(h,i,v) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration_values_ptr ((h),&i,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#define err_map_symbol_string_forall_keys_nondet(h,i,k) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration_keys ((h),&i,&k);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over keys only.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#define err_map_symbol_string_forall_pairs_nondet(h,i,p) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration_pairs ((h),&i,&p);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#define err_map_symbol_string_forall_pairs_ptr_nondet(h,i,p) \
        for(err_map_symbol_string_init_iterator ((h),&i); \
            err_map_symbol_string_next_iteration_pairs_ptr ((h),&i,&p);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERR_ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#if !defined (ERR_ERWIN_REQUIRE_DETERMINISM) || defined (ERR_ERWIN_WEAK_DETERMINISM)
   /* Only have these implementations if the user does not require
    * non-determinism. */

#  define err_map_symbol_string_forall(h,i,k,v) err_map_symbol_string_forall_nondet(h,i,k,v)
/* Operator for hash iteration.  This iterates over keys and values.  To use it,
 * declare an additional map_iterator_t.  Example:
 *    : map_int_char_p_t *m= map_int_char_p_new ();
 *    : ...
 *    : int i;
 *    : char *s;
 *    : map_iterator_t iter;
 *    : map_int_char_p_forall (m, iter, i, s) {
 *    :     printf ("key=%d, value=%s\n", i, s);
 *    : }
 */

#  define err_map_symbol_string_forall_ptr(h,i,k,v) err_map_symbol_string_forall_ptr_nondet(h,i,k,v)
/* Works similar to map_forall.
 *
 * This iterates over keys and pointers to values.  You need a map_iterator_t as a
 * temporary for using this.  See err_map_symbol_string_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#  define err_map_symbol_string_forall_values(h,i,v) err_map_symbol_string_forall_values_nondet(h,i,v)
/* Works similar to map_forall.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#  define err_map_symbol_string_forall_values_ptr(h,i,v) err_map_symbol_string_forall_values_ptr_nondet(h,i,v)
/* Works similar to map_forall.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#  define err_map_symbol_string_forall_keys(h,i,k)   err_map_symbol_string_forall_keys_nondet(h,i,k)
/* Works similar to map_forall.
 *
 * This iterates over keys only.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#  define err_map_symbol_string_forall_pairs(h,i,p)  err_map_symbol_string_forall_pairs_nondet(h,i,p)
/* Works similar to map_forall.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.
 */

#  define err_map_symbol_string_forall_pairs_ptr(h,i,p)  err_map_symbol_string_forall_pairs_ptr_nondet(h,i,p)
/* Works similar to map_forall.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See err_map_symbol_string_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#endif

/* The following function should not be invoked by the user! */
/* BEGIN: Generated automatically by makeforall.pl (part of Erwin2) */

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator (err_map_symbol_string_t const *, err_map_iterator_t *);
/*private*/

#ifdef __cplusplus
ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_key (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_value (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_key_and_value (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_value_and_key (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_user (err_map_symbol_string_t const *, err_map_iterator_sorted_t *,
    err_map_symbol_string_pair_cmp_t);
/*private*/

ERR_ERWIN_EXPORT                       
void err_map_symbol_string_init_iterator_ptr_sorted_by_key (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_value (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_user (err_map_symbol_string_t const *, err_map_iterator_sorted_t *,
    err_map_symbol_string_pair_ptr_cmp_t);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_key_reverse (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_value_reverse (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_key_and_value_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_value_and_key_reverse (
   err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_sorted_by_user_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *, err_map_symbol_string_pair_cmp_t);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_key_reverse (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_value_reverse (err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *);
/*private*/

ERR_ERWIN_EXPORT
void err_map_symbol_string_init_iterator_ptr_sorted_by_user_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *, err_map_symbol_string_pair_ptr_cmp_t);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted (err_map_symbol_string_t const *, err_map_iterator_sorted_t *,
    err_symbol_t *, char const * *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_ptr (err_map_symbol_string_t const *, err_map_iterator_sorted_t *,
    err_symbol_t *, err_map_symbol_string_element_ptr_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_keys (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_symbol_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, char const * *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values_ptr (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_map_symbol_string_element_ptr_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_map_symbol_string_pair_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs_ptr (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_map_symbol_string_pair_ptr_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *, err_symbol_t *, char const * *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_ptr_reverse (
    err_map_symbol_string_t const *, err_map_iterator_sorted_t *, err_symbol_t *, err_map_symbol_string_element_ptr_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_keys_reverse (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_symbol_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values_reverse (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, char const * *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values_ptr_reverse (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_map_symbol_string_element_ptr_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs_reverse (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_map_symbol_string_pair_t *);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs_ptr_reverse (err_map_symbol_string_t const *,
    err_map_iterator_sorted_t *, err_map_symbol_string_pair_ptr_t *);
/*private*/

#endif /* defined(__cplusplus) */

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration  (err_map_symbol_string_t const* /*self*/,
    err_map_iterator_t *, err_symbol_t * /*key*/, char const * * /*value*/);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_ptr  (err_map_symbol_string_t const* /*self*/,
    err_map_iterator_t *, err_symbol_t * /*key*/, err_map_symbol_string_element_ptr_t * /*value_ptr*/);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_values  (err_map_symbol_string_t const * /*self*/,
    err_map_iterator_t *, char const * * /* value */);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_values_ptr  (err_map_symbol_string_t const * /*self*/,
    err_map_iterator_t *, err_map_symbol_string_element_ptr_t * /* value_ptr */);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_keys  (err_map_symbol_string_t const* /*self*/,
    err_map_iterator_t *, err_symbol_t * /* key */);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_pairs (err_map_symbol_string_t const* /*self*/,
    err_map_iterator_t *, err_map_symbol_string_pair_t * /*pair*/);
/*private*/

ERR_ERWIN_EXPORT
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_pairs_ptr (err_map_symbol_string_t const* /*self*/,
    err_map_iterator_t *, err_map_symbol_string_pair_ptr_t * /*pair*/);
/*private*/

#ifdef ERR_ERWIN_PROFILE

ERR_ERWIN_EXPORT
int err_map_symbol_string_nrehash_ops (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
int err_map_symbol_string_nrehash (err_map_symbol_string_t const* /*self*/) ATTR_PURE;
  /* rehash_ops is the number of pure rehash operations and rehash
   * is the number of elements moved around during rehashes */

ERR_ERWIN_EXPORT
int err_map_symbol_string_ninsert (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
int err_map_symbol_string_nremove (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
int err_map_symbol_string_nfind (err_map_symbol_string_t const* /*self*/) ATTR_PURE;

ERR_ERWIN_EXPORT
int err_map_symbol_string_nops (err_map_symbol_string_t const* /*self*/) ATTR_PURE;
  /* Sum of inserts, deletions, and searches */

  /* Most interesting are err_map_symbol_string_nops / err_map_symbol_string_nrehash. */
#endif

/*--END-C--*/

/*
 * Unfortunately, for a good implementation of the C++ class, we need to
 * include the file showing the internal structure of an map.  This
 * is only to give the compiler information about the size of the
 * structure.  I don't like an #ifdef'd include, so always include this:
 */
#include "error/err_map_symbol_string_i.h"

#ifdef __cplusplus
} /* extern "C" */
#endif

struct err_map_symbol_string_t
#ifdef ERR_MAP_SYMBOL_STRING_SUPER_CLASS
   : ERR_MAP_SYMBOL_STRING_SUPER_CLASS_ACCESS ERR_MAP_SYMBOL_STRING_SUPER_CLASS
#endif
{
    /* The err_map_symbol_string Class
     * =============
     * This class implements hash tables.
     *
     * Throughout the documentation, the following prefixes will be used:
     *   - err_:
     *       The library prefix: for applications, this is typically
     *       empty, for an xyz-Library, this is either \tt(XYZ_), \tt(xyz_) or
     *       \tt(Xyz), depending on the identifier in occurs in.
     *       +------------------+-----------------+
     *       |! Template        |! Instantiation  |
     *       | ERR_MAP_OK    | XYZ_MAP_OK      |
     *       | err_map_new   | xyz_map_new     |
     *       +------------------+-----------------+
     *
     *   - err_map_symbol_string_:
     *       This is equivalent to err_map_symbol_string, or the name
     *       that was set with \tt(-name=...) for this data structure.
     *       The case and underbar convention is adjusted, too.
     *
     *       Assuming a library prefix \tt(xyz) and err_symbol_t=int *,
     *       char const * == int, you get:
     *       +-------------------+------------------------------+
     *       |! Template         |! Instantiation               |
     *       | err_map_symbol_string_t             | xyz_map_int_p_int_t          |
     *       | ERR_MAP_SYMBOL_STRING_ALLOW_NULL    | XYZ_MAP_INT_P_INT_ALLOW_NULL |
     *       +-------------------+------------------------------+
     *   - ErrMapSymbolString:
     *       This is the name of the data structure type in C++: capitalised
     *       and with underbars removed:
     *       +-------------------+-----------------+
     *       |! err_map_symbol_string_t            |! ErrMapSymbolString      |
     *       | map_int_p_int_t   | MapIntPInt      |
     *       +-------------------+-----------------+
     *
     * In the following, for many functions, the error code values are given.  There are
     * two kinds, those for success and those for failure.  The error codes (if set at all)
     * are  always stored in the global variable err_map_errno, no mattern whether the function
     * returns its success or not.  Note that the error value MAP_ERR_ASSERTIONFAILED
     * is never explicitly given, because it
     *
     *   - can happen virtually always
     *
     *   - is considered a fatal error and should therefore lead to program
     *     abortion immediately.
     *
     * Successful operation is indicated by ERR_MAP_OK, ERR_MAP_WARN_*, and
     * ERR_MAP_REHASH*.
     *
     * Failure is indicated by ERR_MAP_ERR_*.  If a functions does not return the error code,
     * its result value in case of an error is _always_ the zero element of the result type.
     * I.e. NULL for pointers, 0 for integers, the user specified zero element for err_symbol_t or char const *,
     * ERR_ERWIN_FALSE for ERR_ERWIN_BOOL, etc.
     *
     * Functions that only set map_errno to ERR_MAP_REHASH_* or ERR_MAP_OK will return
     * void if they do not have a natural result.
     *
     * Note: The term `success' means that the function could perform its operation
     *       according to the specification.  E.g. if you call _insert and the
     *       key exists, the functions does not insert it.  However, this is no
     *       error.  It is defined that it should not be inserted in this case.
     *       Accordingly, you get a warning, not an error.
     */

    ERR_MAP_SYMBOL_STRING_STD_MEMBERS(err_map_symbol_string_t)

#ifdef __cplusplus
public:
#endif

    err_map_symbol_string_record

#ifdef __cplusplus

    /*! doc-ignore */
    err_map_symbol_string_t *it()             { return this; }

    /*! doc-ignore */
    err_map_symbol_string_t const *it() const { return this; }

protected:
#ifndef NDEBUG
    void cn() const;
    void cn(void const *) const;
#else
    /* Hopefully optimised away: */
    static void cn() {}
    static void cn(void const *) {}
#endif
    static void nocn() {}             /* makes explicit that functions might handle NULL well. */
    static void nocn(void const *) {} /* makes explicit that functions might handle NULL well. */

/*--BEGIN-CLASS--*/
public:
#ifdef __cplusplus
#if !ERR_ERWIN_DEFAULT_NEW_DELETE
    static void *operator new(size_t);
    static void operator delete(void *, size_t);
    static void *operator new[](size_t);
    static void operator delete[](void *, size_t);
#endif
#endif

    /* Creation */

    err_map_symbol_string_t (void);

    static err_map_symbol_string_t const &static_zero();

#if ERR_MAP_SYMBOL_STRING_HAVE_INT_CONSTRUCTOR
    ERR_ERWIN_EXPLICIT err_map_symbol_string_t (int initial_size);
#endif
#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
    ERR_ERWIN_EXPLICIT err_map_symbol_string_t (char const *  zero_element);
    err_map_symbol_string_t (char const *  zero_element, int initial_size);
#endif

    /* status code */
#if !ERR_ERWIN_GLOBAL_ERRNO
    int get_errno(void) const        { cn(); return it()->m_errno; }
    void clear_errno(void) const     { cn(); err_map_symbol_string_clear_errno (it()); }
#else
    static int get_errno(void)       { return err_map_errno; }
    static void clear_errno(void)    { err_map_errno= ERR_MAP_OK; }
#endif

    /* Copying */

    ERR_ERWIN_EXPLICIT err_map_symbol_string_t (err_map_symbol_string_t const *a);

    err_map_symbol_string_t (err_map_symbol_string_t const &a);

    err_map_symbol_string_t *copy (void) const
    {
        cn();
        return new err_map_symbol_string_t (it());
    }

    err_map_symbol_string_t *copy_err (int *err) const
    {
        cn();
        err_map_symbol_string_t *result= new err_map_symbol_string_t (it());
        if (err != NULL && ERR_MAP_IS_ERROR (get_errno ()))
            *err= 1;
        return result;
    }

    err_map_symbol_string_t &xchg(err_map_symbol_string_t *other)
    {
        err_map_symbol_string_xchg (it(), other);
        return *this;
    }

    err_map_symbol_string_t &xchg(err_map_symbol_string_t &other)
    {
        err_map_symbol_string_xchg (this, &other);
        return *this;
    }

    /* Assignment */

    err_map_symbol_string_t &operator= (err_map_symbol_string_t const &);

    err_map_symbol_string_t &operator= (err_map_symbol_string_t const *);
        /* without this, it would be copied twice */

    void _constructor (void);
        /* Quite private: do not use unless you know what you're doing:
         *
         * This constructs the map for a given preallocated memory location.
         *
         * FIXME: There should be an operator new() for this. */

    void _destructor  (void);
        /* Quite private: do not use unless you know what you're doing:
         *
         * Needed if you want to use maps without a pointer in vectors.  vectors use
         * C-style memory allocation because they need realloc.  The constructor/destructors
         * are invoked via these two functions.
         */

    /* Destruction */

    ~err_map_symbol_string_t ();
        /* There is no delete_flags here in C++, but you can clear_flags() before
         * deletion. */


    /* Conversion to C type.
     * DO NOT CALL err_map_symbol_string_delete or err_map_symbol_string_delete_flags ON THE RETURNED VALUE!
     * All other things you do are ok. */

    operator err_map_symbol_string_t *(void)             { cn(); return it(); }
    operator err_map_symbol_string_t const *(void) const { cn(); return it(); }

    /* More operators for easy use: */

    /* char const *  == char const *  */

    char const *  operator[] (err_symbol_t  i) const
    {
        nocn();
        return err_map_symbol_string_find (it(), i);
    }

    /* operator int () const { return get_errno(); }
     * FIXME: maybe add this one day.  It produces invisible semantics changes with
     * old versions when 'explicit' is used as well. */


    char const * const *find_ptr (err_symbol_t  i) const
        { nocn(); return err_map_symbol_string_find_ptr (it(), i); }

    char const * const *find_ptr_ensure (err_symbol_t  i)
        { cn(); return err_map_symbol_string_find_ptr_ensure (it(), i); }

    /* All other members map to the C equivalent directly. */
    char const *  find (err_symbol_t  i) const
        { nocn(); return err_map_symbol_string_find (it(), i); }
      
    char const *  find_ensure (err_symbol_t  i)
        { cn(); return err_map_symbol_string_find_ensure (it(), i); }

    err_symbol_t  find_any_key() const
        { nocn(); return err_map_symbol_string_find_any_key (it()); }

    char const *  find_any() const
        { nocn(); return err_map_symbol_string_find_any (it()); }

    err_map_symbol_string_element_ptr_t find_any_ptr() const
        { nocn(); return err_map_symbol_string_find_any_ptr (it()); }

    int find_any_pair(err_map_symbol_string_key_result_t &kp, err_map_symbol_string_element_ptr_t &vp) const
        { nocn(); return err_map_symbol_string_find_any_pair (&kp, &vp, it()); }


    /* insert */
    err_map_symbol_string_t  &insert (err_symbol_t  k, char const *  v)
        { cn(); err_map_symbol_string_insert (it(), k, v); return *this; }

    err_map_symbol_string_t  &insert_map (err_map_symbol_string_t const &other)
        { cn(&other); err_map_symbol_string_insert_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &insert_map (err_map_symbol_string_t const *other)
        { cn(other); err_map_symbol_string_insert_map (it(), other->it()); return *this; }

#if ERR_MAP_SYMBOL_STRING_DIRECT_RECURSION == 0
    err_map_symbol_string_t  &insert (err_map_symbol_string_t const &other)
        { cn(&other); err_map_symbol_string_insert_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &insert (err_map_symbol_string_t const *other)
        { cn(other); err_map_symbol_string_insert_map (it(), other->it()); return *this; }

#endif

    /* modify */
    char * modify (err_symbol_t  i, char const *  v)
        { cn(); return err_map_symbol_string_modify (it(), i, v); }

    err_map_symbol_string_t  &modify_map (err_map_symbol_string_t const &other)
        { cn(&other);  err_map_symbol_string_modify_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &modify_map (err_map_symbol_string_t const *other)
        { cn(other); err_map_symbol_string_modify_map (it(), other->it()); return *this; }

#if ERR_MAP_SYMBOL_STRING_DIRECT_RECURSION == 0
    err_map_symbol_string_t  &modify (err_map_symbol_string_t const &other)
        { cn(&other); err_map_symbol_string_modify_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &modify (err_map_symbol_string_t const *other)
        { cn(other); err_map_symbol_string_modify_map (it(), other->it()); return *this; }

#endif

    /* set */

    err_map_symbol_string_t  &set (err_symbol_t  i, char const *  v)
        { cn(); err_map_symbol_string_set (it(), i, v); return *this; }

    err_map_symbol_string_t  &set_map (err_map_symbol_string_t const &other)
        { cn(&other); err_map_symbol_string_set_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &set_map (err_map_symbol_string_t const *other)
        { cn(other); err_map_symbol_string_set_map (it(), other->it()); return *this; }


#if ERR_MAP_SYMBOL_STRING_DIRECT_RECURSION == 0
    err_map_symbol_string_t  &set (err_map_symbol_string_t const &other)
        { cn(&other); err_map_symbol_string_set_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &set (err_map_symbol_string_t const *other)
        { cn(other); err_map_symbol_string_set_map (it(), other->it()); return *this; }

#endif

    /* remove */
    char * remove (err_symbol_t  i)
        { nocn(); return err_map_symbol_string_remove (it(), i); }

    err_map_symbol_string_t &remove_map (err_map_symbol_string_t const &other)
        { nocn(&other); err_map_symbol_string_remove_map (it(), other.it()); return *this; }

    err_map_symbol_string_t &remove_map (err_map_symbol_string_t const *other)
        { nocn(other); err_map_symbol_string_remove_map (it(), other->it()); return *this; }

    int remove_if (err_map_symbol_string_feature_t f, bool value = true)
    {
        nocn();
        return err_map_symbol_string_remove_if (it(), f, value);
    }

    /* erase */
    err_map_symbol_string_t  &erase (err_symbol_t  i)
        { nocn(); err_map_symbol_string_erase (it(), i); return *this; }

    err_map_symbol_string_t  &erase_map (err_map_symbol_string_t const &other)
        { nocn(&other); err_map_symbol_string_erase_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &erase_map (err_map_symbol_string_t const *other)
        { nocn(other); err_map_symbol_string_erase_map (it(), other->it()); return *this; }

#if ERR_MAP_SYMBOL_STRING_DIRECT_RECURSION == 0
    err_map_symbol_string_t  &erase (err_map_symbol_string_t const &other)
        { nocn(other); err_map_symbol_string_erase_map (it(), other.it()); return *this; }

    err_map_symbol_string_t  &erase (err_map_symbol_string_t const *other)
        { nocn(other); err_map_symbol_string_erase_map (it(), other->it()); return *this; }

#endif

    int erase_if (err_map_symbol_string_feature_t f, bool value = true)
    {
        nocn();
        return err_map_symbol_string_erase_if (it(), f, value);
    }

    err_map_symbol_string_t &intersect (err_map_symbol_string_t const &other)
        { nocn(&other); err_map_symbol_string_intersect (it(), other.it()); return *this; }

    err_map_symbol_string_t &intersect (err_map_symbol_string_t const *other)
        { nocn(other); err_map_symbol_string_intersect (it(), other->it()); return *this; }

    err_map_symbol_string_t &intersect_no_resize (err_map_symbol_string_t const &other)
        { nocn(&other); err_map_symbol_string_intersect_no_resize (it(), other.it()); return *this; }

    err_map_symbol_string_t &intersect_no_resize (err_map_symbol_string_t const *other)
        { nocn(other); err_map_symbol_string_intersect_no_resize (it(), other->it()); return *this; }


    /* others */
    err_symbol_t  find_key (err_symbol_t  i) const { nocn(); return err_map_symbol_string_find_key (it(), i); }

    char const *  zero(void) const { nocn(); return err_map_symbol_string_zero (it()); }

    err_symbol_t  ensure (err_symbol_t  k)
        { cn(); return err_map_symbol_string_ensure (it(), k); }

    err_symbol_t  ensure_no_icopy (err_symbol_t  k)
        { cn(); return err_map_symbol_string_ensure_no_icopy (it(), k); }

    err_symbol_t  operator() (err_symbol_t  k)
        { cn(); return err_map_symbol_string_ensure (it(), k); }

    err_map_symbol_string_t &poke (
        err_symbol_t *kp, char * *vo,
        err_symbol_t  k, char const *  v,
        bool aintroduce ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true),
        bool aoverwrite ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true))
    {
        cn();
        err_map_symbol_string_poke (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    err_map_symbol_string_t &poke_no_icopy (
        err_symbol_t *kp, char * *vo,
        err_symbol_t  k, char const *  v,
        bool aintroduce ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true),
        bool aoverwrite ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true))
    {
        cn();
        err_map_symbol_string_poke_no_icopy (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    err_map_symbol_string_t &poke_no_ocopy (
        err_symbol_t *kp, char * *vo,
        err_symbol_t  k, char *  v,
        bool aintroduce ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true),
        bool aoverwrite ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true))
    {
        cn();
        err_map_symbol_string_poke_no_ocopy (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    err_map_symbol_string_t &poke_no_icopy_no_ocopy (
        err_symbol_t *kp, char * *vo,
        err_symbol_t  k, char *  v,
        bool aintroduce ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true),
        bool aoverwrite ERR_MAP_SYMBOL_STRING_DEFAULT_ARG(true))
    {
        cn();
        err_map_symbol_string_poke_no_icopy_no_ocopy (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    /* clear */
    err_map_symbol_string_t &clear (void)
    {
        nocn();
        err_map_symbol_string_clear (it());
        return *this;
    }

    err_map_symbol_string_t &clear_no_resize (void)
    {
        nocn();
        err_map_symbol_string_clear_no_resize (it());
        return *this;
    }

    err_map_symbol_string_t &clear (bool k, bool v)
    {
        nocn();
        err_map_symbol_string_clear_flags (it(), k, v);
        return *this;
    }

    int   nentries (void) const                  { nocn(); return err_map_symbol_string_nentries (it()); }
    bool  empty (void) const                     { nocn(); return ERR_ERWIN_TO_BOOL(err_map_symbol_string_empty (it())); }
    bool  non_empty (void) const                 { nocn(); return !err_map_symbol_string_empty (it()); }

    err_symbol_t          *get_keys   (void) const      { nocn(); return err_map_symbol_string_get_keys (it()); }
    static void delete_keys        (err_symbol_t          *k) { err_map_symbol_string_delete_keys (k); }

    err_map_symbol_string_pair_t     *get_entries (void) const     { nocn(); return err_map_symbol_string_get_entries (it()); }
    err_map_symbol_string_pair_ptr_t *get_entries_ptr (void) const { nocn(); return err_map_symbol_string_get_entries_ptr (it()); }
    char const *          *get_values (void) const      { nocn(); return err_map_symbol_string_get_values (it()); }

    static void delete_entries_ptr (err_map_symbol_string_pair_ptr_t *k) { err_map_symbol_string_delete_entries_ptr (k); }
    static void delete_entries     (err_map_symbol_string_pair_t     *k) { err_map_symbol_string_delete_entries (k); }
    static void delete_values      (char const *          *k) { err_map_symbol_string_delete_values (k); }

    int     hash_size (void) const            { nocn(); return err_map_symbol_string_hash_size (it()); }
    err_map_symbol_string_t &rehash (int n)                     { nocn(); err_map_symbol_string_rehash (it(), n); return *this;}
    double  average_line_length (void) const  { nocn(); return err_map_symbol_string_average_line_length (it()); }
    double  variance_line_length (void) const { nocn(); return err_map_symbol_string_variance_line_length (it()); }
#ifdef HAVE_SQRT
    double  deviation_line_length (void) const { nocn(); return err_map_symbol_string_deviation_line_length (it()); }
#endif
    int     max_line_length (void) const      { nocn(); return err_map_symbol_string_max_line_length (it()); }
    int     min_line_length (void) const      { nocn(); return err_map_symbol_string_min_line_length (it()); }

    void    dump (FILE *f) const              { nocn(); err_map_symbol_string_dump (f, it()); }

#ifdef ERR_ERWIN_PROFILE
    int     nrehash_ops (void) const          { nocn(); return err_map_symbol_string_nrehash_ops (it()); }
    int     nrehash (void) const              { nocn(); return err_map_symbol_string_nrehash (it()); }
    int     ninsert (void) const              { nocn(); return err_map_symbol_string_ninsert (it()); }
    int     nremove (void) const              { nocn(); return err_map_symbol_string_nremove (it()); }
    int     nfind (void) const                { nocn(); return err_map_symbol_string_nfind (it()); }
    int     nops(void) const                  { nocn(); return err_map_symbol_string_nops (it()); }
#endif

    err_hashval_t hash_raw(void) const { nocn(); return err_map_symbol_string_hash_raw (it()); }
    err_hashval_t hash(void) const     { nocn(); return err_map_symbol_string_hash     (it()); }

    bool equal(err_map_symbol_string_t const *other) const
    {
        if (this == NULL || other == NULL) /* must be NULL-safe */
            return this == other;
        return ERR_ERWIN_TO_BOOL(err_map_symbol_string_equal (it(), other->it()));
    }

    bool equal(err_map_symbol_string_t const &other) const
    {
        return equal (&other);
    }

    int cmp (err_map_symbol_string_t const *other) const
    {
        if (this == NULL)
            return other == NULL ? 0 : -1;
        if (other == NULL)
            return +1;
        return err_map_symbol_string_cmp (it(), other->it());
    }

    int cmp (err_map_symbol_string_t const &other) const { nocn(); return cmp (&other); }

    bool operator== (err_map_symbol_string_t const &b) const { nocn(); return equal(b); }    /* see equal() */
    bool operator== (err_map_symbol_string_t const *b) const { nocn(); return equal(b); }    /* see equal() */

    bool operator!= (err_map_symbol_string_t const &b) const { nocn(); return !equal(b); }   /* see equal() */
    bool operator!= (err_map_symbol_string_t const *b) const { nocn(); return !equal(b); }   /* see equal() */

    bool operator<= (err_map_symbol_string_t const &b) const { nocn(); return cmp(b) <= 0; } /* see cmp() */
    bool operator<= (err_map_symbol_string_t const *b) const { nocn(); return cmp(b) <= 0; } /* see cmp() */

    bool operator>= (err_map_symbol_string_t const &b) const { nocn(); return cmp(b) >= 0; } /* see cmp() */
    bool operator>= (err_map_symbol_string_t const *b) const { nocn(); return cmp(b) >= 0; } /* see cmp() */

    bool operator<  (err_map_symbol_string_t const &b) const { nocn(); return cmp(b) < 0; }  /* see cmp() */
    bool operator<  (err_map_symbol_string_t const *b) const { nocn(); return cmp(b) < 0; }  /* see cmp() */

    bool operator>  (err_map_symbol_string_t const &b) const { nocn(); return cmp(b) > 0; }  /* see cmp() */
    bool operator>  (err_map_symbol_string_t const *b) const { nocn(); return cmp(b) > 0; }  /* see cmp() */

    /* Type defs */
    typedef char const * ValueType;

    typedef err_symbol_t KeyType;

/* BEGIN: Generated automatically by makeforall.pl (part of Erwin2) */

/* Note: The err_map_symbol_string_pair_cmp_t argument to the next_user_... functions is useful only
 *       to type check the user's comparison function.  The compiler hopefully
 *       throws it away.
 *
 * Further Note:
 *       The iteration member functions are internal.  They should not be
 *       used directly.  They might change whenever changes to the forall macros
 *       become necessary.
 */

    static void init_iterator (void const *map, err_map_iterator_t *iter)
    {
        err_map_symbol_string_init_iterator (((ErrMapSymbolString const *)map)->it(), iter);
    }

    bool next (err_map_iterator_t &iter, err_symbol_t &k, char const * &v) const
    {
        return err_map_symbol_string_next_iteration (it(), &iter, &k, &v) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_key (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_key (((ErrMapSymbolString const *)map)->it(), iter);
    }

    bool next_sorted (err_map_iterator_sorted_t &iter, err_symbol_t &k, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted (it(), &iter, &k, &v) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_value (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_value (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_key_and_value (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_key_and_value (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_value_and_key (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_value_and_key (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_user (void const *map, err_map_iterator_sorted_t *iter, err_map_symbol_string_void_pair_cmp_t u)
    {
        err_map_symbol_string_init_iterator_sorted_by_user (((ErrMapSymbolString const *)map)->it(), iter, (err_map_symbol_string_pair_cmp_t)u);
    }

    bool next_user_sorted (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, err_symbol_t &k, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted (it(), &iter, &k, &v) != ERR_ERWIN_FALSE;
    }

    bool next_ptr (err_map_iterator_t &iter, err_symbol_t &k, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_ptr (it(), &iter, &k, &V) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_key (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_key (((ErrMapSymbolString const *)map)->it(), iter);
    }

    bool next_sorted_ptr (err_map_iterator_sorted_t &iter, err_symbol_t &k, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_ptr (it(), &iter, &k, &V) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_value (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_value (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_key_and_value (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_value_and_key (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_user (void const *map, err_map_iterator_sorted_t *iter, err_map_symbol_string_void_pair_cmp_t U)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_user (((ErrMapSymbolString const *)map)->it(), iter, (err_map_symbol_string_pair_ptr_cmp_t)U);
    }

    bool next_user_sorted_ptr (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_cmp_t, err_symbol_t &k, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_ptr (it(), &iter, &k, &V) != ERR_ERWIN_FALSE;
    }

    bool next_key (err_map_iterator_t &iter, err_symbol_t &k) const
    {
        return err_map_symbol_string_next_iteration_keys (it(), &iter, &k) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_key (err_map_iterator_sorted_t &iter, err_symbol_t &k) const
    {
        return err_map_symbol_string_next_iteration_sorted_keys (it(), &iter, &k) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_key (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, err_symbol_t &k) const
    {
        return err_map_symbol_string_next_iteration_sorted_keys (it(), &iter, &k) != ERR_ERWIN_FALSE;
    }

    bool next_value (err_map_iterator_t &iter, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_values (it(), &iter, &v) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_value (err_map_iterator_sorted_t &iter, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted_values (it(), &iter, &v) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_value (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted_values (it(), &iter, &v) != ERR_ERWIN_FALSE;
    }

    bool next_value_ptr (err_map_iterator_t &iter, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_values_ptr (it(), &iter, &V) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_value_ptr (err_map_iterator_sorted_t &iter, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_values_ptr (it(), &iter, &V) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_value_ptr (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_cmp_t, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_values_ptr (it(), &iter, &V) != ERR_ERWIN_FALSE;
    }

    bool next_pair (err_map_iterator_t &iter, err_map_symbol_string_pair_t &p) const
    {
        return err_map_symbol_string_next_iteration_pairs (it(), &iter, &p) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_pair (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_t &p) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs (it(), &iter, &p) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_pair (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, err_map_symbol_string_pair_t &p) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs (it(), &iter, &p) != ERR_ERWIN_FALSE;
    }

    bool next_pair_ptr (err_map_iterator_t &iter, err_map_symbol_string_pair_ptr_t &P) const
    {
        return err_map_symbol_string_next_iteration_pairs_ptr (it(), &iter, &P) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_pair_ptr (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_t &P) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs_ptr (it(), &iter, &P) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_pair_ptr (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_cmp_t, err_map_symbol_string_pair_ptr_t &P) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs_ptr (it(), &iter, &P) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_key_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_key_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    bool next_sorted_reverse (err_map_iterator_sorted_t &iter, err_symbol_t &k, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted_reverse (it(), &iter, &k, &v) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_value_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_value_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_key_and_value_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_key_and_value_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_value_and_key_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_sorted_by_value_and_key_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_user_reverse (void const *map, err_map_iterator_sorted_t *iter, err_map_symbol_string_void_pair_cmp_t u)
    {
        err_map_symbol_string_init_iterator_sorted_by_user_reverse (((ErrMapSymbolString const *)map)->it(), iter, (err_map_symbol_string_pair_cmp_t)u);
    }

    bool next_user_sorted_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, err_symbol_t &k, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted_reverse (it(), &iter, &k, &v) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_key_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_key_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    bool next_sorted_ptr_reverse (err_map_iterator_sorted_t &iter, err_symbol_t &k, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_ptr_reverse (it(), &iter, &k, &V) != ERR_ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_value_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_value_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_key_and_value_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_value_and_key_reverse (void const *map, err_map_iterator_sorted_t *iter)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key_reverse (((ErrMapSymbolString const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_user_reverse (void const *map, err_map_iterator_sorted_t *iter, err_map_symbol_string_void_pair_cmp_t U)
    {
        err_map_symbol_string_init_iterator_ptr_sorted_by_user_reverse (((ErrMapSymbolString const *)map)->it(), iter, (err_map_symbol_string_pair_ptr_cmp_t)U);
    }

    bool next_user_sorted_ptr_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_cmp_t, err_symbol_t &k, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_ptr_reverse (it(), &iter, &k, &V) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_key_reverse (err_map_iterator_sorted_t &iter, err_symbol_t &k) const
    {
        return err_map_symbol_string_next_iteration_sorted_keys_reverse (it(), &iter, &k) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_key_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, err_symbol_t &k) const
    {
        return err_map_symbol_string_next_iteration_sorted_keys_reverse (it(), &iter, &k) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_value_reverse (err_map_iterator_sorted_t &iter, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted_values_reverse (it(), &iter, &v) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_value_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, char const * &v) const
    {
        return err_map_symbol_string_next_iteration_sorted_values_reverse (it(), &iter, &v) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_value_ptr_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_values_ptr_reverse (it(), &iter, &V) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_value_ptr_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_cmp_t, err_map_symbol_string_element_ptr_t &V) const
    {
        return err_map_symbol_string_next_iteration_sorted_values_ptr_reverse (it(), &iter, &V) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_pair_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_t &p) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs_reverse (it(), &iter, &p) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_pair_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_cmp_t, err_map_symbol_string_pair_t &p) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs_reverse (it(), &iter, &p) != ERR_ERWIN_FALSE;
    }

    bool next_sorted_pair_ptr_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_t &P) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs_ptr_reverse (it(), &iter, &P) != ERR_ERWIN_FALSE;
    }

    bool next_user_sorted_pair_ptr_reverse (err_map_iterator_sorted_t &iter, err_map_symbol_string_pair_ptr_cmp_t, err_map_symbol_string_pair_ptr_t &P) const
    {
        return err_map_symbol_string_next_iteration_sorted_pairs_ptr_reverse (it(), &iter, &P) != ERR_ERWIN_FALSE;
    }

/* END: Generated automatically */

/*--END-CLASS--*/
#endif /* __cplusplus */
};

#ifdef __cplusplus


/* some nasty global functions that are useful e.g. for forall.  Note that these
 * are not local to one vector but will be overloaded by all different vector
 * instantiations. */
extern "C++" {
ERWIN_WRAPPER
err_map_symbol_string_t *err_erwin_ptr_of(err_map_symbol_string_t *x) { return x;  }

ERWIN_WRAPPER
err_map_symbol_string_t *err_erwin_ptr_of(err_map_symbol_string_t &x) { return &x; }

ERWIN_WRAPPER
err_map_symbol_string_t const *err_erwin_ptr_const_of (err_map_symbol_string_t const *x) { return x;  }

ERWIN_WRAPPER
err_map_symbol_string_t const *err_erwin_ptr_const_of (err_map_symbol_string_t const &x) { return &x; }
} /* extern "C++" */


/*
 * For the sorted iteration you must provide ERR_ERR_SYMBOL_T_CMP and ERR_CHAR_CONST_P_CMP resp.  Otherwise, you
 * will get run-time errors when using these macros.
 */
#if defined (ERR_ERWIN_REQUIRE_DETERMINISM) && !defined (ERR_ERWIN_WEAK_DETERMINISM)
/* Force forall macros that allow deterministic sort order if user required determinism.
 * When _sorted_by_user functions are given the NULL function, they will still
 * sort the map if that is required.
 */
#  ifndef err_map_forall
#    define err_map_forall(h,k,v) err_map_forall_copy(h,k,v)
/* Operator for hash iteration in C++.  This iterates over keys and values.  You do not
 * need any additional structure when using C++ since this is declared automatically.
 * Use it as follows.
 *    : MapIntCharP m;
 *    : ...
 *    : int i;
 *    : char *s;
 *    : map_forall (m, i, s) {
 *    :     printf ("key=%d, value=%s\n", i, s);
 *    : }
 *
 *
 * The macro also accepts pointers to maps.  So you could also have used:
 *    : ...
 *    : map_forall (&m, i, s)
 *    : ...
 *
 * It might be interesting to compare this to the C version err_map_symbol_string_forall.
 *
 * Other variants for C++ are available.  In addition to the C macros, the
 * C++ macros allow sorted iteration (..._sorted_by_... variants).
 *
 * All C++ macros support determinism by possibly pre-sorting the map.
 *
 * For convenience, the non-deterministic iterators are available for C++, too.
 * These are the ..._nondet variants.
 *
 * Further, all sorted versions and the copied versions (..._copy) allow you
 * to arbitrarily modify (err_map_symbol_string_erase, err_map_symbol_string_insert, err_map_symbol_string_modify) the map while you
 * iterate it.  These changes are not reflected during that loop, however.
 *
 * Iteration is allowed on points to values, too.  These are the ...ptr
 * variants.  This way, you can modify values on the fly.  You need not use
 * the copied functions for this to work.  There is no way of modifying keys
 * on the fly, since this needs restructuring of the internal hash table.
 * Use err_map_symbol_string_erase and err_map_symbol_string_insert for this.
 *
 * The following is the complete list of C++ iteration macros, which should be
 * self-explained, since naming is completely regular.
 *
 *    : err_map_forall(h,k,v)
 *    : err_map_forall_copy(h,k,v)
 *    : err_map_forall_nondet(h,k,v)
 *    : err_map_forall_sorted_by_key(h,k,v)
 *    : err_map_forall_sorted_by_value(h,k,v)
 *    : err_map_forall_sorted_by_key_and_value(h,k,v)
 *    : err_map_forall_sorted_by_value_and_key(h,k,v)
 *    : err_map_forall_sorted_by_user(h,u,k,v)
 *    : err_map_forall_ptr(h,k,V)
 *    : err_map_forall_ptr_copy(h,k,V)
 *    : err_map_forall_ptr_nondet(h,k,V)
 *    : err_map_forall_ptr_sorted_by_key(h,k,V)
 *    : err_map_forall_ptr_sorted_by_value(h,k,V)
 *    : err_map_forall_ptr_sorted_by_key_and_value(h,k,V)
 *    : err_map_forall_ptr_sorted_by_value_and_key(h,k,V)
 *    : err_map_forall_ptr_sorted_by_user(h,U,k,V)
 *    : err_map_forall_keys(h,k)
 *    : err_map_forall_keys_copy(h,k)
 *    : err_map_forall_keys_nondet(h,k)
 *    : err_map_forall_keys_sorted_by_key(h,k)
 *    : err_map_forall_keys_sorted_by_value(h,k)
 *    : err_map_forall_keys_sorted_by_key_and_value(h,k)
 *    : err_map_forall_keys_sorted_by_value_and_key(h,k)
 *    : err_map_forall_keys_sorted_by_user(h,u,k)
 *    : err_map_forall_values(h,v)
 *    : err_map_forall_values_copy(h,v)
 *    : err_map_forall_values_nondet(h,v)
 *    : err_map_forall_values_sorted_by_key(h,v)
 *    : err_map_forall_values_sorted_by_value(h,v)
 *    : err_map_forall_values_sorted_by_key_and_value(h,v)
 *    : err_map_forall_values_sorted_by_value_and_key(h,v)
 *    : err_map_forall_values_sorted_by_user(h,u,v)
 *    : err_map_forall_values_ptr(h,V)
 *    : err_map_forall_values_ptr_copy(h,V)
 *    : err_map_forall_values_ptr_nondet(h,V)
 *    : err_map_forall_values_ptr_sorted_by_key(h,V)
 *    : err_map_forall_values_ptr_sorted_by_value(h,V)
 *    : err_map_forall_values_ptr_sorted_by_key_and_value(h,V)
 *    : err_map_forall_values_ptr_sorted_by_value_and_key(h,V)
 *    : err_map_forall_values_ptr_sorted_by_user(h,U,V)
 *    : err_map_forall_pairs(h,p)
 *    : err_map_forall_pairs_copy(h,p)
 *    : err_map_forall_pairs_nondet(h,p)
 *    : err_map_forall_pairs_sorted_by_key(h,p)
 *    : err_map_forall_pairs_sorted_by_value(h,p)
 *    : err_map_forall_pairs_sorted_by_key_and_value(h,p)
 *    : err_map_forall_pairs_sorted_by_value_and_key(h,p)
 *    : err_map_forall_pairs_sorted_by_user(h,u,p)
 *    : err_map_forall_pairs_ptr(h,P)
 *    : err_map_forall_pairs_ptr_copy(h,P)
 *    : err_map_forall_pairs_ptr_nondet(h,P)
 *    : err_map_forall_pairs_ptr_sorted_by_key(h,P)
 *    : err_map_forall_pairs_ptr_sorted_by_value(h,P)
 *    : err_map_forall_pairs_ptr_sorted_by_key_and_value(h,P)
 *    : err_map_forall_pairs_ptr_sorted_by_value_and_key(h,P)
 *    : err_map_forall_pairs_ptr_sorted_by_user(h,U,P)
 *
 */
#  endif

#  ifndef err_map_forall_ptr
#    define err_map_forall_ptr(h,k,v) err_map_forall_ptr_copy(h,k,v)
#  endif

#  ifndef err_map_forall_keys
#    define err_map_forall_keys(h,k) err_map_forall_keys_copy(h,k)
#  endif

#  ifndef err_map_forall_values
#    define err_map_forall_values(h,v) err_map_forall_values_copy(h,v)
#  endif

#  ifndef err_map_forall_values_ptr
#    define err_map_forall_values_ptr(h,v) err_map_forall_values_ptr_copy(h,v)
#  endif

#  ifndef err_map_forall_pairs
#    define err_map_forall_pairs(h,p) err_map_forall_pairs_copy(h,p)
#  endif

#  ifndef err_map_forall_pairs_ptr
#    define err_map_forall_pairs_ptr(h,p) err_map_forall_pairs_ptr_copy(h,p)
#  endif

#else

#  ifndef err_map_forall
#    define err_map_forall(h,k,v) err_map_forall_nondet(h,k,v)
#  endif

#  ifndef err_map_forall_ptr
#    define err_map_forall_ptr(h,k,v) err_map_forall_ptr_nondet(h,k,v)
#  endif

#  ifndef err_map_forall_keys
#    define err_map_forall_keys(h,k) err_map_forall_keys_nondet(h,k)
#  endif

#  ifndef err_map_forall_values
#    define err_map_forall_values(h,v) err_map_forall_values_nondet(h,v)
#  endif

#  ifndef err_map_forall_values_ptr
#    define err_map_forall_values_ptr(h,v) err_map_forall_values_ptr_nondet(h,v)
#  endif

#  ifndef err_map_forall_pairs
#    define err_map_forall_pairs(h,p) err_map_forall_pairs_nondet(h,p)
#  endif

#  ifndef err_map_forall_pairs_ptr
#    define err_map_forall_pairs_ptr(h,p) err_map_forall_pairs_ptr_nondet(h,p)
#  endif

#endif

/*
 * The following are convenience macros for iterating over a copy of the map
 * in order to allow modification during iteration. */
#ifndef err_map_forall_copy
#  define err_map_forall_copy(h,k,v) err_map_forall_sorted_by_user(h,NULL,k,v)
#endif

#ifndef err_map_forall_ptr_copy
#  define err_map_forall_ptr_copy(h,k,v) err_map_forall_ptr_sorted_by_user(h,NULL,k,v)
#endif

#ifndef err_map_forall_keys_copy
#  define err_map_forall_keys_copy(h,k) err_map_forall_keys_sorted_by_user(h,NULL,k)
#endif

#ifndef err_map_forall_values_copy
#  define err_map_forall_values_copy(h,v) err_map_forall_values_sorted_by_user(h,NULL,v)
#endif

#ifndef err_map_forall_values_ptr_copy
#  define err_map_forall_values_ptr_copy(h,v) err_map_forall_values_ptr_sorted_by_user(h,NULL,v)
#endif

#ifndef err_map_forall_pairs_copy
#  define err_map_forall_pairs_copy(h,p) err_map_forall_pairs_sorted_by_user(h,NULL,p)
#endif

#ifndef err_map_forall_pairs_ptr_copy
#  define err_map_forall_pairs_ptr_copy(h,p) err_map_forall_pairs_ptr_sorted_by_user(h,NULL,p)
#endif

/* BEGIN: Generated automatically by makeforall.pl (part of Erwin2) */

/* Note: While iterating over a map with a non-sorting err_map_forall*
 *       function, you may not alter the contents of the map!
 *
 *       All sorting functions allow altering, because the map has to be
 *       copied completely to enable sorted iteration.  You will iterate over
 *       the old contents, i.e, the modifications do not become visible to the
 *       iterator.
 *
 *       If you want non-sorted iteration with the possibility of altering the
 *       map, use the err_map_forall_*sorted_by_user family.
 */

#ifndef err_map_forall_nondet
#   define err_map_forall_nondet(h,k,v) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_key
#   define err_map_forall_sorted_by_key(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_value
#   define err_map_forall_sorted_by_value(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_key_and_value
#   define err_map_forall_sorted_by_key_and_value(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_value_and_key
#   define err_map_forall_sorted_by_value_and_key(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_user
#   define err_map_forall_sorted_by_user(h,u,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted(ERWIN_GENSYM(erwin_local_i), u,k,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_ptr_nondet
#   define err_map_forall_ptr_nondet(h,k,V) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_key
#   define err_map_forall_ptr_sorted_by_key(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_value
#   define err_map_forall_ptr_sorted_by_value(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_key_and_value
#   define err_map_forall_ptr_sorted_by_key_and_value(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_value_and_key
#   define err_map_forall_ptr_sorted_by_value_and_key(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_user
#   define err_map_forall_ptr_sorted_by_user(h,U,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user, \
                    (void const *)err_erwin_ptr_of(h), (err_map_symbol_string_void_pair_cmp_t)U); \
            err_erwin_ptr_of(h)->next_user_sorted_ptr(ERWIN_GENSYM(erwin_local_i), U,k,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_keys_nondet
#   define err_map_forall_keys_nondet(h,k) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_key
#   define err_map_forall_keys_sorted_by_key(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_value
#   define err_map_forall_keys_sorted_by_value(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_key_and_value
#   define err_map_forall_keys_sorted_by_key_and_value(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_value_and_key
#   define err_map_forall_keys_sorted_by_value_and_key(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_user
#   define err_map_forall_keys_sorted_by_user(h,u,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_key(ERWIN_GENSYM(erwin_local_i), u,k); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_values_nondet
#   define err_map_forall_values_nondet(h,v) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_key
#   define err_map_forall_values_sorted_by_key(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_value
#   define err_map_forall_values_sorted_by_value(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_key_and_value
#   define err_map_forall_values_sorted_by_key_and_value(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_value_and_key
#   define err_map_forall_values_sorted_by_value_and_key(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_user
#   define err_map_forall_values_sorted_by_user(h,u,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_value(ERWIN_GENSYM(erwin_local_i), u,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_values_ptr_nondet
#   define err_map_forall_values_ptr_nondet(h,V) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_key
#   define err_map_forall_values_ptr_sorted_by_key(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_value
#   define err_map_forall_values_ptr_sorted_by_value(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_key_and_value
#   define err_map_forall_values_ptr_sorted_by_key_and_value(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_value_and_key
#   define err_map_forall_values_ptr_sorted_by_value_and_key(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_user
#   define err_map_forall_values_ptr_sorted_by_user(h,U,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user, \
                    (void const *)err_erwin_ptr_of(h), (err_map_symbol_string_void_pair_cmp_t)U); \
            err_erwin_ptr_of(h)->next_user_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), U,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_pairs_nondet
#   define err_map_forall_pairs_nondet(h,p) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_key
#   define err_map_forall_pairs_sorted_by_key(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_value
#   define err_map_forall_pairs_sorted_by_value(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_key_and_value
#   define err_map_forall_pairs_sorted_by_key_and_value(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_value_and_key
#   define err_map_forall_pairs_sorted_by_value_and_key(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_user
#   define err_map_forall_pairs_sorted_by_user(h,u,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_pair(ERWIN_GENSYM(erwin_local_i), u,p); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_pairs_ptr_nondet
#   define err_map_forall_pairs_ptr_nondet(h,P) \
        for(err_map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_key
#   define err_map_forall_pairs_ptr_sorted_by_key(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_value
#   define err_map_forall_pairs_ptr_sorted_by_value(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_key_and_value
#   define err_map_forall_pairs_ptr_sorted_by_key_and_value(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_value_and_key
#   define err_map_forall_pairs_ptr_sorted_by_value_and_key(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_user
#   define err_map_forall_pairs_ptr_sorted_by_user(h,U,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user, \
                    (void const *)err_erwin_ptr_of(h), (err_map_symbol_string_void_pair_cmp_t)U); \
            err_erwin_ptr_of(h)->next_user_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), U,P); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_sorted_by_key_reverse
#   define err_map_forall_sorted_by_key_reverse(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_value_reverse
#   define err_map_forall_sorted_by_value_reverse(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_key_and_value_reverse
#   define err_map_forall_sorted_by_key_and_value_reverse(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_value_and_key_reverse
#   define err_map_forall_sorted_by_value_and_key_reverse(h,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_sorted_by_user_reverse
#   define err_map_forall_sorted_by_user_reverse(h,u,k,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_reverse(ERWIN_GENSYM(erwin_local_i), u,k,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_ptr_sorted_by_key_reverse
#   define err_map_forall_ptr_sorted_by_key_reverse(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_value_reverse
#   define err_map_forall_ptr_sorted_by_value_reverse(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_key_and_value_reverse
#   define err_map_forall_ptr_sorted_by_key_and_value_reverse(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_value_and_key_reverse
#   define err_map_forall_ptr_sorted_by_value_and_key_reverse(h,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_ptr_sorted_by_user_reverse
#   define err_map_forall_ptr_sorted_by_user_reverse(h,U,k,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_of(h), (err_map_symbol_string_void_pair_cmp_t)U); \
            err_erwin_ptr_of(h)->next_user_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), U,k,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_keys_sorted_by_key_reverse
#   define err_map_forall_keys_sorted_by_key_reverse(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_value_reverse
#   define err_map_forall_keys_sorted_by_value_reverse(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_key_and_value_reverse
#   define err_map_forall_keys_sorted_by_key_and_value_reverse(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_value_and_key_reverse
#   define err_map_forall_keys_sorted_by_value_and_key_reverse(h,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef err_map_forall_keys_sorted_by_user_reverse
#   define err_map_forall_keys_sorted_by_user_reverse(h,u,k) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), u,k); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_values_sorted_by_key_reverse
#   define err_map_forall_values_sorted_by_key_reverse(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_value_reverse
#   define err_map_forall_values_sorted_by_value_reverse(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_key_and_value_reverse
#   define err_map_forall_values_sorted_by_key_and_value_reverse(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_value_and_key_reverse
#   define err_map_forall_values_sorted_by_value_and_key_reverse(h,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_sorted_by_user_reverse
#   define err_map_forall_values_sorted_by_user_reverse(h,u,v) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), u,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_values_ptr_sorted_by_key_reverse
#   define err_map_forall_values_ptr_sorted_by_key_reverse(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_value_reverse
#   define err_map_forall_values_ptr_sorted_by_value_reverse(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_key_and_value_reverse
#   define err_map_forall_values_ptr_sorted_by_key_and_value_reverse(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_value_and_key_reverse
#   define err_map_forall_values_ptr_sorted_by_value_and_key_reverse(h,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef err_map_forall_values_ptr_sorted_by_user_reverse
#   define err_map_forall_values_ptr_sorted_by_user_reverse(h,U,V) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_of(h), (err_map_symbol_string_void_pair_cmp_t)U); \
            err_erwin_ptr_of(h)->next_user_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), U,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_pairs_sorted_by_key_reverse
#   define err_map_forall_pairs_sorted_by_key_reverse(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_value_reverse
#   define err_map_forall_pairs_sorted_by_value_reverse(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_key_and_value_reverse
#   define err_map_forall_pairs_sorted_by_key_and_value_reverse(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_value_and_key_reverse
#   define err_map_forall_pairs_sorted_by_value_and_key_reverse(h,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_const_of(h)); \
            err_erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_sorted_by_user_reverse
#   define err_map_forall_pairs_sorted_by_user_reverse(h,u,p) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_const_of(h), (err_map_symbol_string_void_pair_cmp_t)u); \
            err_erwin_ptr_const_of(h)->next_user_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), u,p); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_key_reverse
#   define err_map_forall_pairs_ptr_sorted_by_key_reverse(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_value_reverse
#   define err_map_forall_pairs_ptr_sorted_by_value_reverse(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_key_and_value_reverse
#   define err_map_forall_pairs_ptr_sorted_by_key_and_value_reverse(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_value_and_key_reverse
#   define err_map_forall_pairs_ptr_sorted_by_value_and_key_reverse(h,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key_reverse, \
                    (void const *)err_erwin_ptr_of(h)); \
            err_erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef err_map_forall_pairs_ptr_sorted_by_user_reverse
#   define err_map_forall_pairs_ptr_sorted_by_user_reverse(h,U,P) \
        for(err_map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(err_erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user_reverse, \
                    (void const *)err_erwin_ptr_of(h), (err_map_symbol_string_void_pair_cmp_t)U); \
            err_erwin_ptr_of(h)->next_user_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), U,P); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

/* END: Generated automatically */

#endif /* defined(__cplusplus) */

#endif /* !defined(ERWIN_ERR_MAP_SYMBOL_STRING_h) */

