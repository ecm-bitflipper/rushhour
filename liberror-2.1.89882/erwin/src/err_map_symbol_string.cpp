/* -*- Mode: C -*- */
/*
 * Author: Henrik Theiling
 *
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifndef ERR_MAP_SYMBOL_STRING_IMPLEMENTATION
#define ERR_MAP_SYMBOL_STRING_IMPLEMENTATION
#endif

#include "error/erwin/defs.h"

#include "error/erwin/forwards.h"

#include "error/err_map_symbol_string_d.h"
#include "error/err_map_symbol_string.h"
#include "error/err_map_symbol_string_i.h"

#ifdef ERR_ERWIN_COMPILING
#  include "error/erwin/stdinc.h"
#else
#  include <error/erwin/stdinc.h>
#endif

#ifndef ERR_ERR_SYMBOL_T_BEING_USED
#define ERR_ERR_SYMBOL_T_BEING_USED 1
#endif

#ifndef ERR_CHAR_CONST_P_BEING_USED
#define ERR_CHAR_CONST_P_BEING_USED 1
#endif

#include "error/erwin/needed.h"



/*
 * This must be re-done: */

#ifdef ERR_MAP_ERR_ASSERTIONFAILED
#define E_ASSERTIONFAILED ERR_MAP_ERR_ASSERTIONFAILED
#endif

#ifdef ERR_ERWIN_BOOL
#define E_BOOL ERR_ERWIN_BOOL
#endif

#ifdef ERR_ERWIN_COMPAT_2_0_264
#define E_COMPAT_2_0_264 ERR_ERWIN_COMPAT_2_0_264
#endif

#ifdef ERR_ERWIN_COMPILING
#define E_COMPILING ERR_ERWIN_COMPILING
#endif

#ifdef ERR_ERWIN_DEFAULT_NEW_DELETE
#define E_DEFAULT_NEW_DELETE ERR_ERWIN_DEFAULT_NEW_DELETE
#endif

#ifdef ERR_MAP_WARN_EMPTY
#define E_EMPTY ERR_MAP_WARN_EMPTY
#endif

#ifdef err_erwininternalmaperrno
#define e_erwininternalmaperrno err_erwininternalmaperrno
#endif

#ifdef ERR_MAP_WARN_EXISTINGKEY
#define E_EXISTINGKEY ERR_MAP_WARN_EXISTINGKEY
#endif

#ifdef ERR_ERWIN_FALSE
#define E_FALSE ERR_ERWIN_FALSE
#endif

#ifdef ERR_ERWIN_FILE_IDS
#define E_FILE_IDS ERR_ERWIN_FILE_IDS
#endif

#ifdef ERR_ERWIN_GLOBAL_ERRNO
#define E_GLOBAL_ERRNO ERR_ERWIN_GLOBAL_ERRNO
#endif

#ifdef ERR_ERWIN_HASH_INIT
#define E_HASH_INIT ERR_ERWIN_HASH_INIT
#endif

#define e_hash_into err_erwin_hash_into

#define e_hash_state_t err_erwin_hash_state_t

#define e_hashval_t err_hashval_t

#ifdef err_erwin_init
#define e_init err_erwin_init
#endif

#ifdef err_init
#define e_init err_init
#endif

#ifdef err_int_hash
#define e_int_hash err_int_hash
#endif

#define e_iterator_sorted_t err_map_iterator_sorted_t

#define e_iterator_t err_map_iterator_t

#ifdef ERR_MAP_WARN_KEYNOTFOUND
#define E_KEYNOTFOUND ERR_MAP_WARN_KEYNOTFOUND
#endif

#define e_mapinitialised err_erwin_mapinitialised

#define e_merge_sort err_erwin_merge_sort

#ifdef ERR_ERWIN_NO_LINKER_TRICKS
#define E_NO_LINKER_TRICKS ERR_ERWIN_NO_LINKER_TRICKS
#endif

#ifdef ERR_MAP_ERR_NOMEM
#define E_NOMEM ERR_MAP_ERR_NOMEM
#endif

#ifdef ERR_MAP_WARN_NOMOREELEMS
#define E_NOMOREELEMS ERR_MAP_WARN_NOMOREELEMS
#endif

#ifdef ERR_MAP_OK
#define E_OK ERR_MAP_OK
#endif

#ifdef ERR_ERWIN_PREFER_TDELETE
#define E_PREFER_TDELETE ERR_ERWIN_PREFER_TDELETE
#endif

#ifdef ERR_ERWIN_PREFER_TNEW
#define E_PREFER_TNEW ERR_ERWIN_PREFER_TNEW
#endif

#ifdef ERR_ERWIN_PROFILE
#define E_PROFILE ERR_ERWIN_PROFILE
#endif

#ifdef ERR_MAP_REHASH_DUPLICATEKEY
#define E_REHASH_DUPLICATEKEY ERR_MAP_REHASH_DUPLICATEKEY
#endif

#ifdef ERR_MAP_REHASH_NOMEM
#define E_REHASH_NOMEM ERR_MAP_REHASH_NOMEM
#endif

#ifdef ERR_MAP_REHASH_RECURSION
#define E_REHASH_RECURSION ERR_MAP_REHASH_RECURSION
#endif

#define e_require_determinism err_erwin_require_determinism

#ifdef ERR_ERWIN_REQUIRE_DETERMINISM
#define E_REQUIRE_DETERMINISM ERR_ERWIN_REQUIRE_DETERMINISM
#endif

#ifdef ERR_ERWIN_SET_PTR
#define E_SET_PTR ERR_ERWIN_SET_PTR
#endif

#ifdef ERR_ERWIN_STATE_GET_HASHVAL
#define E_STATE_GET_HASHVAL ERR_ERWIN_STATE_GET_HASHVAL
#endif

#ifdef ERR_ERWIN_STATE_INIT_WITH
#define E_STATE_INIT_WITH ERR_ERWIN_STATE_INIT_WITH
#endif

#ifdef ERR_ERWIN_STATE_MIX_UNORDERED2
#define E_STATE_MIX_UNORDERED2 ERR_ERWIN_STATE_MIX_UNORDERED2
#endif

#ifdef ERR_ERWIN_STATE_MIX_UNORDERED
#define E_STATE_MIX_UNORDERED ERR_ERWIN_STATE_MIX_UNORDERED
#endif

#ifdef ERR_ERWIN_THING_CNEW_ARRAY
#define E_THING_CNEW_ARRAY ERR_ERWIN_THING_CNEW_ARRAY
#endif

#ifdef ERR_ERWIN_THING_DELETE1
#define E_THING_DELETE1 ERR_ERWIN_THING_DELETE1
#endif

#ifdef ERR_ERWIN_THING_DELETE_ARRAY
#define E_THING_DELETE_ARRAY ERR_ERWIN_THING_DELETE_ARRAY
#endif

#ifdef ERR_ERWIN_THING_DELETE_ATOMS
#define E_THING_DELETE_ATOMS ERR_ERWIN_THING_DELETE_ATOMS
#endif

#ifdef ERR_ERWIN_THING_NEW1
#define E_THING_NEW1 ERR_ERWIN_THING_NEW1
#endif

#ifdef ERR_ERWIN_THING_NEW_ARRAY
#define E_THING_NEW_ARRAY ERR_ERWIN_THING_NEW_ARRAY
#endif

#ifdef ERR_ERWIN_THING_NEW_ATOMS
#define E_THING_NEW_ATOMS ERR_ERWIN_THING_NEW_ATOMS
#endif

#ifdef ERR_ERWIN_THREAD_SAFE
#define E_THREAD_SAFE ERR_ERWIN_THREAD_SAFE
#endif

#ifdef ERR_ERWIN_TO_BOOL
#define E_TO_BOOL ERR_ERWIN_TO_BOOL
#endif

#ifdef ERR_ERWIN_TRUE
#define E_TRUE ERR_ERWIN_TRUE
#endif

#ifdef ERR_ERWIN_USE_MUTABLE
#define E_USE_MUTABLE ERR_ERWIN_USE_MUTABLE
#endif

#ifdef ERR_ERWIN_WEAK_DETERMINISM
#define E_WEAK_DETERMINISM ERR_ERWIN_WEAK_DETERMINISM
#endif

#ifdef ERR_ERWIN_WEAK_STORAGE
#define E_WEAK_STORAGE ERR_ERWIN_WEAK_STORAGE
#endif

#ifdef ERR_ERR_SYMBOL_T_BEING_USED
#define IBEING_USED ERR_ERR_SYMBOL_T_BEING_USED
#endif

#ifdef ERR_ERR_SYMBOL_T_CMP
#define ICMP ERR_ERR_SYMBOL_T_CMP
#endif

#ifdef ERR_ERR_SYMBOL_T_ICOPY
#define ICOPY ERR_ERR_SYMBOL_T_ICOPY
#endif

#ifdef ERR_ERR_SYMBOL_T_ICOPY_PROVIDED
#define ICOPY_PROVIDED ERR_ERR_SYMBOL_T_ICOPY_PROVIDED
#endif

#ifdef ERR_ERR_SYMBOL_T_DETCMP
#define IDETCMP ERR_ERR_SYMBOL_T_DETCMP
#endif

#ifdef ERR_ERR_SYMBOL_T_DETCMP_PROVIDED
#define IDETCMP_PROVIDED ERR_ERR_SYMBOL_T_DETCMP_PROVIDED
#endif

#ifdef ERR_ERR_SYMBOL_T_EQUAL
#define IEQUAL ERR_ERR_SYMBOL_T_EQUAL
#endif

#ifdef ERR_ERR_SYMBOL_T_EQUAL_PROVIDED
#define IEQUAL_PROVIDED ERR_ERR_SYMBOL_T_EQUAL_PROVIDED
#endif

#ifdef ERR_ERR_SYMBOL_T_IFREE
#define IFREE ERR_ERR_SYMBOL_T_IFREE
#endif

#ifdef ERR_ERR_SYMBOL_T_IFREE_PROVIDED
#define IFREE_PROVIDED ERR_ERR_SYMBOL_T_IFREE_PROVIDED
#endif

#ifdef ERR_ERR_SYMBOL_T_HASH
#define IHASH ERR_ERR_SYMBOL_T_HASH
#endif

#ifdef ERR_ERR_SYMBOL_T_PRINT
#define IPRINT ERR_ERR_SYMBOL_T_PRINT
#endif

#ifdef ERR_ERR_SYMBOL_T_ZERO
#define IZERO ERR_ERR_SYMBOL_T_ZERO
#endif

#ifdef ERR_CHAR_CONST_P_BEING_USED
#define OBEING_USED ERR_CHAR_CONST_P_BEING_USED
#endif

#ifdef ERR_CHAR_CONST_P_CMP
#define OCMP ERR_CHAR_CONST_P_CMP
#endif

#ifdef ERR_CHAR_CONST_P_OCOPY
#define OCOPY ERR_CHAR_CONST_P_OCOPY
#endif

#ifdef ERR_CHAR_CONST_P_OCOPY_PROVIDED
#define OCOPY_PROVIDED ERR_CHAR_CONST_P_OCOPY_PROVIDED
#endif

#ifdef ERR_CHAR_CONST_P_DETCMP
#define ODETCMP ERR_CHAR_CONST_P_DETCMP
#endif

#ifdef ERR_CHAR_CONST_P_DETCMP_PROVIDED
#define ODETCMP_PROVIDED ERR_CHAR_CONST_P_DETCMP_PROVIDED
#endif

#ifdef ERR_CHAR_CONST_P_EQUAL
#define OEQUAL ERR_CHAR_CONST_P_EQUAL
#endif

#ifdef ERR_CHAR_CONST_P_OFREE
#define OFREE ERR_CHAR_CONST_P_OFREE
#endif

#ifdef ERR_CHAR_CONST_P_OFREE_PROVIDED
#define OFREE_PROVIDED ERR_CHAR_CONST_P_OFREE_PROVIDED
#endif

#ifdef ERR_CHAR_CONST_P_HASH
#define OHASH ERR_CHAR_CONST_P_HASH
#endif

#ifdef ERR_CHAR_CONST_P_PRINT
#define OPRINT ERR_CHAR_CONST_P_PRINT
#endif

#ifdef ERR_CHAR_CONST_P_ZERO
#define OZERO ERR_CHAR_CONST_P_ZERO
#endif



#ifndef CHAR_CONST_P_IS_PTR
#define CHAR_CONST_P_IS_PTR 1
#endif /* !defined CHAR_CONST_P_IS_PTR */

#if defined(ERR_SYMBOL_T_IS_PTR) && ERR_SYMBOL_T_IS_PTR
#  define E_SET_KEY(X,Y)  E_SET_PTR(X,Y)
#else
#  define E_SET_KEY(X,Y)  ((X)=(Y))
#endif

#if defined(CHAR_CONST_P_IS_PTR) && CHAR_CONST_P_IS_PTR
#  define E_SET_VALUE(X,Y)  E_SET_PTR(X,Y)
#else
#  define E_SET_VALUE(X,Y)  ((X)=(Y))
#endif

#if ERR_MAP_SYMBOL_STRING_INITIAL_SIZE < 0
#  error ERR_MAP_SYMBOL_STRING_INITIAL_SIZE < 0
#endif

#if ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE < 0
#  error ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE < 0
#endif

#if ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE == 0
#  define ERR_MAP_SYMBOL_STRING_ZERO_SIZE         1
#  define ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1 1
#elif ERR_MAP_SYMBOL_STRING_INITIAL_SIZE == 0
#  define ERR_MAP_SYMBOL_STRING_ZERO_SIZE         1
#  define ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1 ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE
#else
#  define ERR_MAP_SYMBOL_STRING_ZERO_SIZE         0
#  define ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1 ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE
#endif

#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE

#  define HAS_HEAP_TABLE_AUX(hashsize)    ((hashsize) > 1)

#  define GET_SLOT(table,hashsize,i)      (HAS_HEAP_TABLE_AUX(hashsize) ? \
                                              (table[(i)])                \
                                            : *((err_map_symbol_string_hashlist_t**)(&(table)))     \
                                          )
#  define return_if_bad_table(self)
#  define return_val_if_bad_table(self,x)
#  define return_if_bad_table_pC(self,x)

#else

#  define HAS_HEAP_TABLE_AUX(hashsize)    ERR_ERWIN_TRUE
#  define GET_SLOT(table,hashsize,i)      (table[(i)])

#  define return_if_bad_table(self)       return_if_null_pp     ((self)->m_table, self)
#  define return_val_if_bad_table(self,x) return_val_if_null_pp ((self)->m_table, x, self)
#  define return_if_bad_table_pC(self,x)  return_if_null_ppC    ((self)->m_table, self, x)

#endif

#define HAS_HEAP_TABLE(self)            HAS_HEAP_TABLE_AUX((self)->m_hashsize)
#define SLOT(self,i)                    GET_SLOT((self)->m_table, (self)->m_hashsize, i)


#define FREE_TABLE(self)                do{                                                      \
                                            if (HAS_HEAP_TABLE(self))                            \
                                                ERR_ERWIN_THING_DELETE_ARRAY (self->m_table); \
                                        }while(0)

#if defined(CHAR_CONST_P_IS_PTR) && !CHAR_CONST_P_IS_PTR
#  define VALUE_NEW_ARRAY      ERR_ERWIN_THING_NEW_ATOMS
#  define VALUE_DELETE_ARRAY   ERR_ERWIN_THING_DELETE_ATOMS
#else
#  define VALUE_NEW_ARRAY      ERR_ERWIN_THING_NEW_ARRAY
#  define VALUE_DELETE_ARRAY   ERR_ERWIN_THING_DELETE_ARRAY
#endif

#if defined(ERR_SYMBOL_T_IS_PTR) && !ERR_SYMBOL_T_IS_PTR
#  define KEY_NEW_ARRAY        ERR_ERWIN_THING_NEW_ATOMS
#  define KEY_DELETE_ARRAY     ERR_ERWIN_THING_DELETE_ATOMS
#else
#  define KEY_NEW_ARRAY        ERR_ERWIN_THING_NEW_ARRAY
#  define KEY_DELETE_ARRAY     ERR_ERWIN_THING_DELETE_ARRAY
#endif

#if defined(ERR_SYMBOL_T_IS_PTR) && defined(CHAR_CONST_P_IS_PTR) && !ERR_SYMBOL_T_IS_PTR && !CHAR_CONST_P_IS_PTR
#  define PAIR_NEW_ARRAY       ERR_ERWIN_THING_NEW_ATOMS
#  define PAIR_DELETE_ARRAY    ERR_ERWIN_THING_DELETE_ATOMS
#else
#  define PAIR_NEW_ARRAY       ERR_ERWIN_THING_NEW_ARRAY
#  define PAIR_DELETE_ARRAY    ERR_ERWIN_THING_DELETE_ARRAY
#endif


#if !E_GLOBAL_ERRNO
#  if E_USE_MUTABLE
#      define e_errno (self->m_errno)
#  else
#      define e_errno (ERWIN_CONST_CAST(err_map_symbol_string_t*,self)->m_errno)
#  endif
#else
#  define e_errno err_erwininternalmaperrno
#endif

#define SET_ERRNO(X)       do{ e_errno= (X); }while(0)
#define PASS_ERRNO(X)      (e_errno= (X))

#ifndef assert
#define assert(X)         false_if_fail(X)
#endif /* !defined assert */

/* false_if_reached_pt */
/* false_if_reached_pk */

#define ASSERTION_FAILED   PASS_ERRNO(E_ASSERTIONFAILED)

#if ERR_MAP_SYMBOL_STRING_HAVE_SIG
#  define return_if_bad(self) \
      return_if_fail_ppxxt(self->m_sig == ERR_MAP_SYMBOL_STRING_SIG, self, self->m_sig, ERR_MAP_SYMBOL_STRING_SIG, "Structure was probably overwritten");
#  define return_val_if_bad(self, val) \
      return_val_if_fail_ppxxt(self->m_sig == ERR_MAP_SYMBOL_STRING_SIG, val, self, self->m_sig, ERR_MAP_SYMBOL_STRING_SIG, "Structure was probably overwritten");
#  define return_if_bad_pC(self, prog) \
      return_if_fail_ppxxtC(self->m_sig == ERR_MAP_SYMBOL_STRING_SIG, self, self->m_sig, ERR_MAP_SYMBOL_STRING_SIG, "Structure was probably overwritten", prog);
#else
#  define return_if_bad(self)
#  define return_val_if_bad(self, val)
#  define return_if_bad_pC(self, prog)
#endif

#define return_if_null_or_bad(self) \
    return_if_null(self);           \
    return_if_bad (self);

#define return_val_if_null_or_bad(self, val) \
    return_val_if_null(self, val);           \
    return_val_if_bad (self, val);

#define return_if_null_or_bad_pC(self, prog) \
    return_if_null_pC(self, prog);           \
    return_if_bad_pC (self, prog);

#define return_if_null2i_or_bad(self) \
    return_if_null_or_bad(self);      \
    return_if_bad_table(self);

#define return_val_if_null2i_or_bad(self, val) \
    return_val_if_null_or_bad(self, val);      \
    return_val_if_bad_table(self, val);

#define return_if_null2i_or_bad_pC(self, prog) \
    return_if_null_or_bad_pC(self, prog);      \
    return_if_bad_table_pC(self, prog);

#define return0_if_bad(self)           return_val_if_bad(self, 0);
#define return0_if_bad_table(self)     return_val_if_bad_table(self, 0);
#define return0_if_null_or_bad(self)   return_val_if_null_or_bad(self, 0);
#define return0_if_null2i_or_bad(self) return_val_if_null2i_or_bad(self, 0);

#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A)    \
            ASSERTION_FAILED;                       \
            ERR_MAP_SYMBOL_STRING_ASSERTION_FAILED_HANDLER(FI,L,FU,A)
#endif

#ifdef E_FILE_IDS
static char const * const map_cvs_id= "$""Id: none$";
#endif

/*
 * This file contains ugly macros.  Their purpose is to debug code, and
 * to be a substitute for assert.h.  This file should compile under any compiler
 * with all (sensible) compiler settings and #defines.  This is meant to be ANSI
 * code with GNUC extensions if we compile under GNUC.  It should under no
 * circumstances produce compiler errors and under GNUC it should not produce
 * any warnings.
 * So if it fails to compile, it is a severe bug.  Please report this to
 * henrik@theiling.de.  To temporarily circumvent the problem, you can comment
 * out the following line. */

/* #define ASSERT_IS_BROKEN */

#ifndef ASSERT_IS_BROKEN

/*
 * Additional user provided assertion failure, warning,
 * and error handlers.
 */
#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_ERROR_HANDLER
#define USER_ERROR_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_WARNING_HANDLER
#define USER_WARNING_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifdef __GNUC__

#define ASSERT_NORETURN  __attribute__((__noreturn__))

#if defined __cplusplus && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95))
#define ASSERT_CAST_VOID static_cast<void>
   /* for compiler warning -Wold-style-cast */
#endif

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   __PRETTY_FUNCTION__
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  (ASSERT_CAST_VOID(0)) /* To get rid of warnings. */
 /* FIXME: CHECK: do we need the different versions of ASSERT_NO_EFFECT? */
#endif

#else

#define ASSERT_NORETURN

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   "-unknown-"
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  0
#endif

#endif

#ifndef ASSERT_CAST_VOID
#define ASSERT_CAST_VOID (void)
#endif

#ifndef NDEBUG
#define ASSERT_DEBUG_CODE(X) X
#else
#define ASSERT_DEBUG_CODE(X)
#endif

#if defined(__KERNEL__)

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#elif defined(HAVE_LIBERROR)

#ifndef IN_LIBERROR_COMPILE
#include <liberror.h>
#endif

#ifndef ASSERT_ABORT
#define ASSERT_ABORT err_crash()
#endif

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (eprintf (C_TAG_ASSERT | 0, 0, ERR_CALLBACKS_ONLY))
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT
#endif

#else /* !defined HAVE_LIBERROR */

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (ERR_ERWIN_ERROR_PRINT (ERR_ERWIN_ERROR_STREAM,  "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (ERR_ERWIN_ERROR_PRINT (ERR_ERWIN_ERROR_STREAM,  "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (ERR_ERWIN_ERROR_PRINT (ERR_ERWIN_ERROR_STREAM,  "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (ERR_ERWIN_ERROR_PRINT (ERR_ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (ERR_ERWIN_ERROR_PRINT (ERR_ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#endif /* !defined HAVE_LIBERROR */

#ifndef ASSERT_ABORT
#define ASSERT_ABORT abort()
#endif

#ifndef ASSERT_NONNEGATIVE
#ifdef erwin_nonnegative
#define ASSERT_NONNEGATIVE(X) erwin_nonnegative(X)
#else
#define ASSERT_NONNEGATIVE(X) ((X) >= 0)
#endif
#endif

#ifndef ASSERT_UNLIKELY
#ifdef ERWIN_UNLIKELY
#define ASSERT_UNLIKELY(X) ERWIN_UNLIKELY(X)
#else
#define ASSERT_UNLIKELY(X) (X)
#endif
#endif


#ifndef NDEBUG
/*
 * The following macros are only available for debugging.  There will not
 * be an error_..._if_crash since a) that is weird, b) the macros
 * do not work on many platforms and should, therefore, not handle normal
 * control flow, c) we have to define helper data and functions. */

/*
 * In order to get the necessary #definitions automatically from a GNU
 * configure script, be sure to have the following lines in configure.in:

--- BEGIN configure.failure ---

AC_CHECK_HEADERS(signal.h)
AC_CHECK_HEADERS(setjmp.h)
AC_CHECK_FUNCS(setjmp)
AC_TYPE_SIGNAL

dnl The following might make the output nicer, but are not required:

AC_CHECK_HEADERS(unistd.h)
AC_DECL_SYS_SIGLIST

--- END configure.failure ---

 * Note that this file does not believe the configure settings if you compile
 * with -ansi (i.e. __STRICT_ANSI__ is defined).  This is a convenience
 * setting for gcc compilation tests when you do not want to call configure
 * again.

 * And either add the following lines to config.h.in:

--- BEGIN config.h.in.failure ---
#undef HAVE_SIGNAL_H
#undef HAVE_SETJMP_H
#undef HAVE_UNISTD_H
#undef RETSIGTYPE
#undef SYS_SIGLIST_DECLARED
--- END config.h.in.failure ---

 * And be sure to include your configuration header file before this file.
 */

#if defined(HAVE_SIGNAL_H) && defined(HAVE_SETJMP_H) && defined(HAVE_SETJMP) && defined(RETSIGTYPE) && !defined(__KERNEL__)

/* We have signals and debugging is enabled here.  And we are not in __KERNEL__ mode.*/

#include <signal.h>
#include <setjmp.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if defined(SYS_SIGLIST_DECLARED) && !defined(__STRICT_ANSI__)
#define ASSERT_STRSIGNAL(X) (sys_siglist[X])
#else
#define ASSERT_STRSIGNAL(X) "unknown"
#endif

static jmp_buf assert_jmp_buf;
static volatile int assert_signal_caught;
static volatile int assert_caught_no;

#if defined(SIGSEGV) || defined(_SIGSEGV)
static RETSIGTYPE (*assert_old_sigsegv)(int);
#endif
#if defined(SIGBUS) || defined(_SIGBUS)
static RETSIGTYPE (*assert_old_sigbus)(int);
#endif
#if defined(SIGABRT) || defined(_SIGABRT)
static RETSIGTYPE (*assert_old_sigabrt)(int);
#endif
#if defined(SIGFPE) || defined(_SIGFPE)
static RETSIGTYPE (*assert_old_sigfpe)(int);
#endif
#if defined(SIGILL) || defined(_SIGILL)
static RETSIGTYPE (*assert_old_sigill)(int);
#endif
#if defined(SIGHUP) || defined(_SIGHUP)
static RETSIGTYPE (*assert_old_sighup)(int);
#endif

static RETSIGTYPE assert_catch_signal (int) ASSERT_NORETURN;
static RETSIGTYPE assert_catch_signal (int which)
{
    assert_signal_caught= 1;
    assert_caught_no= which;
    longjmp (assert_jmp_buf, 1);
}

static void assert_begin_signals (void)
{
    assert_signal_caught= 0;

#if defined(_SIGSEGV)
    assert_old_sigsegv= signal (_SIGSEGV, &assert_catch_signal);
#elif defined(SIGSEGV)
    assert_old_sigsegv= signal (SIGSEGV, &assert_catch_signal);
#endif

#if defined(_SIGBUS)
    assert_old_sigbus= signal (_SIGBUS, &assert_catch_signal);
#elif defined(SIGBUS)
    assert_old_sigbus= signal (SIGBUS, &assert_catch_signal);
#endif

#if defined(_SIGABRT)
    assert_old_sigabrt= signal (_SIGABRT, &assert_catch_signal);
#elif defined(SIGABRT)
    assert_old_sigabrt= signal (SIGABRT, &assert_catch_signal);
#endif

#if defined(_SIGFPE)
    assert_old_sigfpe= signal (_SIGFPE, &assert_catch_signal);
#elif defined(SIGFPE)
    assert_old_sigfpe= signal (SIGFPE, &assert_catch_signal);
#endif

#if defined(_SIGILL)
    assert_old_sigill= signal (_SIGILL, &assert_catch_signal);
#elif defined(SIGILL)
    assert_old_sigill= signal (SIGILL, &assert_catch_signal);
#endif

#if defined(_SIGHUP)
    assert_old_sighup= signal (_SIGHUP, &assert_catch_signal);
#elif defined(SIGHUP)
    assert_old_sighup= signal (SIGHUP, &assert_catch_signal);
#endif
}

static void assert_end_signals (void)
{
#if defined(_SIGSEGV)
    signal (_SIGSEGV, assert_old_sigsegv);
#elif defined(SIGSEGV)
    signal (SIGSEGV, assert_old_sigsegv);
#endif

#if defined(_SIGBUS)
    signal (_SIGBUS, assert_old_sigbus);
#elif defined(SIGBUS)
    signal (SIGBUS, assert_old_sigbus);
#endif

#if defined(_SIGABRT)
    signal (_SIGABRT, assert_old_sigabrt);
#elif defined(SIGABRT)
    signal (SIGABRT, assert_old_sigabrt);
#endif

#if defined(_SIGFPE)
    signal (_SIGFPE, assert_old_sigfpe);
#elif defined(SIGFPE)
    signal (SIGFPE, assert_old_sigfpe);
#endif

#if defined(_SIGILL)
    signal (_SIGILL, assert_old_sigill);
#elif defined(SIGILL)
    signal (SIGILL, assert_old_sigill);
#endif

#if defined(_SIGHUP)
    signal (_SIGHUP, assert_old_sighup);
#elif defined(SIGHUP)
    signal (SIGHUP, assert_old_sighup);
#endif
}

/*
 * This is not nestable. */
#define ASSERT_TRY_COMMAND(X)                 \
        do {                                  \
            assert_begin_signals ();          \
            if (!setjmp (assert_jmp_buf)) {   \
                X;                            \
            }                                 \
            assert_end_signals ();            \
        } while (0)

#define ASSERT_NO_SIGNAL_CAUGHT (assert_signal_caught == 0)

#else

/* No signals, debugging enabled. */
#define ASSERT_TRY_COMMAND(X) do { X; } while (0)
        /* this *is* a crash test, so do it even if catching the error is
         * not possible on this machine... */
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X) "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* defined(HAVE_SIGNAL_H) ... */

#else

/* No signals, debugging disabled. */
#define ASSERT_TRY_COMMAND(X)
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X)  "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* DEBUG */


/*
 * Please note that this does not have any do { ... } while(0) protection.  This is because
 * continue_if_fail and break_if_fail would do wrong things in that case. */
#ifndef raw_do_if_fail
#define raw_do_if_fail(P,A1,A2,A3,W,F1,F2) \
        if (ASSERT_UNLIKELY(!(A1))) { \
            ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                     ""P" function '%s':\n" \
                     ASSERT_INDENT W " failed: '%s'\n" \
                     ASSERT_INDENT "Pre-processed: '%s'\n" \
                             , ASSERT_FUNCTION, \
                             A3 \
                             ,A2 \
                             ); \
            F1; \
            USER_ASSERTION_FAILED_HANDLER(__FILE__,__LINE__,ASSERT_FUNCTION, A); \
            F2; \
        } \
        else { ; }
#endif

/*
 * If you write your USER_ASSERTION_FAILED_HANDLER in such a way that it is an expression,
 * you can use the false_if_fail, null_if_fail, etc. */
#ifndef raw_value_if_fail
#define raw_value_if_fail(P,A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        (ASSERT_UNLIKELY(!(A1)) ? ((\
                     ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                          ""P" function '%s':\n" \
                          ASSERT_INDENT W" failed: '%s'\n" \
                          ASSERT_INDENT "Pre-processed: '%s'\n" \
                          , ASSERT_FUNCTION, \
                          A3 \
                          ,#A2 \
                          )), \
                  (F1), \
                  (USER_ASSERTION_FAILED_HANDLER(__FILE__, __LINE__, ASSERT_FUNCTION, A)), \
                  (FAILVAL)) \
                : (GOODVAL))
#endif

#ifndef NDEBUG

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("In",A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("In",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#else

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) (GOODVAL)
#endif

#endif

#ifndef warn_do_if_fail
#define warn_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Warning in",A1,A2,A3,W,F1,F2)
#endif

#ifndef warn_value_if_fail
#define warn_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Warning in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef error_do_if_fail
#define error_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Error in",A1,A2,A3,W,F1,F2)
#endif

#ifndef error_value_if_fail
#define error_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Error in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3) \
	 { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;break;;); } 
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pts
#define error_exit_if_fail_pts(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pts
#define error_exit_if_null_pts(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pts
#define error_exit_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached() \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pts
#define error_exit_if_reached_pts(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_return0_if_fail
#define error_return0_if_fail(A1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_pC
#define error_return0_if_fail_pC(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_pi
#define error_return0_if_fail_pi(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_pii
#define error_return0_if_fail_pii(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_piit
#define error_return0_if_fail_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_pit
#define error_return0_if_fail_pit(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_pt
#define error_return0_if_fail_pt(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_fail_pts
#define error_return0_if_fail_pts(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null
#define error_return0_if_null(A1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_pC
#define error_return0_if_null_pC(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_pi
#define error_return0_if_null_pi(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_pii
#define error_return0_if_null_pii(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_piit
#define error_return0_if_null_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_pit
#define error_return0_if_null_pit(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_pt
#define error_return0_if_null_pt(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_null_pts
#define error_return0_if_null_pts(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds
#define error_return0_if_out_of_bounds(A1,M) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_pC
#define error_return0_if_out_of_bounds_pC(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_pi
#define error_return0_if_out_of_bounds_pi(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_pii
#define error_return0_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_piit
#define error_return0_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_pit
#define error_return0_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_pt
#define error_return0_if_out_of_bounds_pt(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_out_of_bounds_pts
#define error_return0_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached
#define error_return0_if_reached() \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_pC
#define error_return0_if_reached_pC(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_pi
#define error_return0_if_reached_pi(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_pii
#define error_return0_if_reached_pii(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_piit
#define error_return0_if_reached_piit(X1,X2,X3) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_pit
#define error_return0_if_reached_pit(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_pt
#define error_return0_if_reached_pt(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef error_return0_if_reached_pts
#define error_return0_if_reached_pts(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pts
#define exit1_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pts
#define exit1_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pts
#define exit1_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached
#define exit1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pts
#define exit1_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pts
#define exit_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null
#define exit_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pts
#define exit_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pts
#define exit_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached
#define exit_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pts
#define exit_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef false_if_fail
#define false_if_fail(A1) \
	 ( value_if_fail(A1,A1,""#A1,"Assertion",(ASSERT_NO_EFFECT,ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) \
	 ( value_if_fail(0,0,"""0","Control flow",(ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n"),ASSERT_EPRINTF_MORE_1 ("%s\n", #X1),ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pts
#define nothing_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pts
#define nothing_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pts
#define nothing_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached
#define nothing_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_2 (""#X1"=%d ('%c')\n", (X1), (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pts
#define nothing_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2) \
	 do { \
	ASSERT_TRY_COMMAND(A1;);\
	do_if_fail(ASSERT_NO_SIGNAL_CAUGHT,A1;,""#A1,"Execution",ASSERT_EPRINTF_MORE_1 ("Signal number: %d\n", assert_caught_no);ASSERT_EPRINTF_MORE_1 ("Signal name: %s\n", ASSERT_STRSIGNAL(assert_caught_no));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));X3;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pts
#define return0_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null
#define return0_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A4) != NULL,(A4) != NULL,"("#A4") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pts
#define return0_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pts
#define return0_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached
#define return0_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pts
#define return0_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pts
#define return1_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null
#define return1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pts
#define return1_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pts
#define return1_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached
#define return1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pts
#define return1_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return_if_fail
#define return_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));X3;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%lu\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%lu\n", (unsigned long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));X5;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pts
#define return_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null
#define return_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); \
	do_if_fail((A1->A2) != NULL,(A1->A2) != NULL,"("#A1"->"#A2") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pts
#define return_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pts
#define return_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached
#define return_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pts
#define return_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pts
#define return_m1_if_fail_pts(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pts
#define return_m1_if_null_pts(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pts
#define return_m1_if_out_of_bounds_pts(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pts
#define return_m1_if_reached_pts(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%ld\n", (long)(X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pts
#define return_val_if_fail_pts(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pts
#define return_val_if_null_pts(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pts
#define return_val_if_out_of_bounds_pts(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pts
#define return_val_if_reached_pts(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"='%s'\n", ((X2) == NULL) ? "<NULL>" : ((char const *)((X2))));;,ASSERT_END;return (O);;); } while (0) 
#endif


#else /* !defined(ASSERT_IS_BROKEN) */

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1)
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1)
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1)
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1)
#endif

#ifndef error_exit_if_fail_pts
#define error_exit_if_fail_pts(A1,X1,X2)
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1)
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1)
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1)
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1)
#endif

#ifndef error_exit_if_null_pts
#define error_exit_if_null_pts(A1,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M)
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pts
#define error_exit_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached()
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1)
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1)
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2)
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2)
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1)
#endif

#ifndef error_exit_if_reached_pts
#define error_exit_if_reached_pts(X1,X2)
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1)
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2)
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef error_return0_if_fail
#define error_return0_if_fail(A1)
#endif

#ifndef error_return0_if_fail_pC
#define error_return0_if_fail_pC(A1,X1)
#endif

#ifndef error_return0_if_fail_pi
#define error_return0_if_fail_pi(A1,X1)
#endif

#ifndef error_return0_if_fail_pii
#define error_return0_if_fail_pii(A1,X1,X2)
#endif

#ifndef error_return0_if_fail_piit
#define error_return0_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef error_return0_if_fail_pit
#define error_return0_if_fail_pit(A1,X1,X2)
#endif

#ifndef error_return0_if_fail_pt
#define error_return0_if_fail_pt(A1,X1)
#endif

#ifndef error_return0_if_fail_pts
#define error_return0_if_fail_pts(A1,X1,X2)
#endif

#ifndef error_return0_if_null
#define error_return0_if_null(A1)
#endif

#ifndef error_return0_if_null_pC
#define error_return0_if_null_pC(A1,X1)
#endif

#ifndef error_return0_if_null_pi
#define error_return0_if_null_pi(A1,X1)
#endif

#ifndef error_return0_if_null_pii
#define error_return0_if_null_pii(A1,X1,X2)
#endif

#ifndef error_return0_if_null_piit
#define error_return0_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef error_return0_if_null_pit
#define error_return0_if_null_pit(A1,X1,X2)
#endif

#ifndef error_return0_if_null_pt
#define error_return0_if_null_pt(A1,X1)
#endif

#ifndef error_return0_if_null_pts
#define error_return0_if_null_pts(A1,X1,X2)
#endif

#ifndef error_return0_if_out_of_bounds
#define error_return0_if_out_of_bounds(A1,M)
#endif

#ifndef error_return0_if_out_of_bounds_pC
#define error_return0_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef error_return0_if_out_of_bounds_pi
#define error_return0_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef error_return0_if_out_of_bounds_pii
#define error_return0_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef error_return0_if_out_of_bounds_piit
#define error_return0_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef error_return0_if_out_of_bounds_pit
#define error_return0_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef error_return0_if_out_of_bounds_pt
#define error_return0_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef error_return0_if_out_of_bounds_pts
#define error_return0_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef error_return0_if_reached
#define error_return0_if_reached()
#endif

#ifndef error_return0_if_reached_pC
#define error_return0_if_reached_pC(X1)
#endif

#ifndef error_return0_if_reached_pi
#define error_return0_if_reached_pi(X1)
#endif

#ifndef error_return0_if_reached_pii
#define error_return0_if_reached_pii(X1,X2)
#endif

#ifndef error_return0_if_reached_piit
#define error_return0_if_reached_piit(X1,X2,X3)
#endif

#ifndef error_return0_if_reached_pit
#define error_return0_if_reached_pit(X1,X2)
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2)
#endif

#ifndef error_return0_if_reached_pt
#define error_return0_if_reached_pt(X1)
#endif

#ifndef error_return0_if_reached_pts
#define error_return0_if_reached_pts(X1,X2)
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1)
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1)
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1)
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1)
#endif

#ifndef exit1_if_fail_pts
#define exit1_if_fail_pts(A1,X1,X2)
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1)
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1)
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1)
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2)
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2)
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1)
#endif

#ifndef exit1_if_null_pts
#define exit1_if_null_pts(A1,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M)
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pts
#define exit1_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef exit1_if_reached
#define exit1_if_reached()
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1)
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1)
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2)
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2)
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1)
#endif

#ifndef exit1_if_reached_pts
#define exit1_if_reached_pts(X1,X2)
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1)
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1)
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1)
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2)
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1)
#endif

#ifndef exit_if_fail_pts
#define exit_if_fail_pts(A1,X1,X2)
#endif

#ifndef exit_if_null
#define exit_if_null(A1)
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1)
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1)
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2)
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2)
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1)
#endif

#ifndef exit_if_null_pts
#define exit_if_null_pts(A1,X1,X2)
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M)
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pts
#define exit_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef exit_if_reached
#define exit_if_reached()
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1)
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1)
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2)
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2)
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1)
#endif

#ifndef exit_if_reached_pts
#define exit_if_reached_pts(X1,X2)
#endif

#ifndef false_if_fail
#define false_if_fail(A1) (!0)
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) (!0)
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1)
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1)
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1)
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2)
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2)
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1)
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef nothing_if_fail_pts
#define nothing_if_fail_pts(A1,X1,X2)
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1)
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1)
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1)
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2)
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2)
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1)
#endif

#ifndef nothing_if_null_pts
#define nothing_if_null_pts(A1,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M)
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pts
#define nothing_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef nothing_if_reached
#define nothing_if_reached()
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1)
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2)
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1)
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2)
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3)
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2)
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1)
#endif

#ifndef nothing_if_reached_pts
#define nothing_if_reached_pts(X1,X2)
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1)
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1)
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1)
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2)
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4)
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1)
#endif

#ifndef return0_if_fail_pts
#define return0_if_fail_pts(A1,X1,X2)
#endif

#ifndef return0_if_null
#define return0_if_null(A1)
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2)
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2)
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3)
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3)
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2)
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4)
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1)
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1)
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2)
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2)
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1)
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2)
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2)
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1)
#endif

#ifndef return0_if_null_pts
#define return0_if_null_pts(A1,X1,X2)
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M)
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pts
#define return0_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef return0_if_reached
#define return0_if_reached()
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1)
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1)
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2)
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3)
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2)
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1)
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1)
#endif

#ifndef return0_if_reached_pts
#define return0_if_reached_pts(X1,X2)
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1)
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1)
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1)
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1)
#endif

#ifndef return1_if_fail_pts
#define return1_if_fail_pts(A1,X1,X2)
#endif

#ifndef return1_if_null
#define return1_if_null(A1)
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1)
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1)
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2)
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2)
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1)
#endif

#ifndef return1_if_null_pts
#define return1_if_null_pts(A1,X1,X2)
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M)
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pts
#define return1_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef return1_if_reached
#define return1_if_reached()
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1)
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1)
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2)
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2)
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1)
#endif

#ifndef return1_if_reached_pts
#define return1_if_reached_pts(X1,X2)
#endif

#ifndef return_if_fail
#define return_if_fail(A1)
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1)
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1)
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1)
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2)
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2)
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4)
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5)
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1)
#endif

#ifndef return_if_fail_pts
#define return_if_fail_pts(A1,X1,X2)
#endif

#ifndef return_if_null
#define return_if_null(A1)
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2)
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2)
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1)
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1)
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2)
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2)
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1)
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2)
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2)
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1)
#endif

#ifndef return_if_null_pts
#define return_if_null_pts(A1,X1,X2)
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M)
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pts
#define return_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef return_if_reached
#define return_if_reached()
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1)
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1)
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2)
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2)
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2)
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1)
#endif

#ifndef return_if_reached_pts
#define return_if_reached_pts(X1,X2)
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1)
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1)
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1)
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1)
#endif

#ifndef return_m1_if_fail_pts
#define return_m1_if_fail_pts(A1,X1,X2)
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1)
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1)
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1)
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1)
#endif

#ifndef return_m1_if_null_pts
#define return_m1_if_null_pts(A1,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M)
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pts
#define return_m1_if_out_of_bounds_pts(A1,M,X1,X2)
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached()
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1)
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1)
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2)
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2)
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1)
#endif

#ifndef return_m1_if_reached_pts
#define return_m1_if_reached_pts(X1,X2)
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O)
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1)
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1)
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1)
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1)
#endif

#ifndef return_val_if_fail_pts
#define return_val_if_fail_pts(A1,O,X1,X2)
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O)
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O)
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2)
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1)
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1)
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1)
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1)
#endif

#ifndef return_val_if_null_pts
#define return_val_if_null_pts(A1,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O)
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3)
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pts
#define return_val_if_out_of_bounds_pts(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O)
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1)
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1)
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2)
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3)
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2)
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1)
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1)
#endif

#ifndef return_val_if_reached_pts
#define return_val_if_reached_pts(O,X1,X2)
#endif

#endif /* !defined(ASSERT_IS_BROKEN) */


/* ********************************************************************** */

#define TOOSMALL(X,Y) (((X) * ERR_MAP_SYMBOL_STRING_TRIGGER_DENOMINATOR) > ((Y) * ERR_MAP_SYMBOL_STRING_TRIGGER_NUMERATOR))

#define TOOLARGE(X,Y) (((Y) >= ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE) && \
                       (((X) * ERR_MAP_SYMBOL_STRING_TRIGGER_DENOMINATOR) < (((Y) * ERR_MAP_SYMBOL_STRING_TRIGGER_NUMERATOR)/4)))


/* Dynamic zero element?
 * Be careful with stupid compilers that choke on casts from A to A in C++.  Only
 * use casts if necessary.
 */
#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
#    define ZERO(SELF)    ((char const *)((SELF)->m_zero))
#  define ZEROVAR(SELF) ((SELF)->m_zero)
#else
#    define ZERO(SELF)    ((char const *)(OZERO))
#    define ZEROVAR(SELF) OCOPY(OZERO,NULL)
#endif

#define IZEROVAR    ICOPY(IZERO,NULL)

#define SORTITER_VOLATILE  ((e_iterator_sorted_t volatile *)iter)

#define ITER               ((err_map_symbol_string_internal_Iterator*)iter)
#define SORTITER           ((err_map_symbol_string_internal_sorted_Iterator*)iter)
#define SORTITERPTR        ((err_map_symbol_string_internal_sorted_ptr_Iterator*)iter)

#ifdef E_PROFILE
typedef union {
   err_map_symbol_string_t       *mapt;
   err_map_symbol_string_t const *mapconstt;
} hack_no_const;
#endif

/* We need all user types that may be a result type as simple type names,
 * because untemplatize cannot parse all C types.
 *
 * Some are now available globally, too:
 *    err_map_symbol_string_index_t == i_type_t
 *    err_map_symbol_string_value_t == o_type_t
 */
typedef char const *       o_type_t;
typedef char const *  o_type_result_t;
typedef char *    o_type_var_t;
typedef err_symbol_t       i_type_t;
typedef err_symbol_t  i_type_result_t;

#define SPLIT_SECTIONS ERR_MAP_SYMBOL_STRING_SPLIT

#if SPLIT_SECTIONS
#  define CODE_SECTION(X) ATTR_SECTION(X)
#else
#  define CODE_SECTION(X)
#endif

/* Check that ERR_MAP_SYMBOL_STRING_ALLOW_NULL and ERR_ERWIN_THREAD_SAFE are not used at
 * the same time.  It is not possible to do that since the error code is
 * stored in the data structure.  If the pointer to that is NULL, no error
 * codes can be returned. */
#if 0
/* FIXME: NYI */
#if ERR_MAP_SYMBOL_STRING_ALLOW_NULL && defined(ERR_ERWIN_THREAD_SAFE)
#  error "Cannot use ERR_MAP_SYMBOL_STRING_ALLOW_NULL and ERR_ERWIN_THREAD_SAFE at the same time."
#endif
#endif

#if ERR_MAP_SYMBOL_STRING_NOMEM_IS_FATAL
#define MAP_NOMEM    error_exit_if_reached_pt("Fatal: Memory exhausted.")
#define MAP_NOMEM_R  error_exit_if_reached_pt("Fatal: Memory exhausted.")
#else
#define MAP_NOMEM    SET_ERRNO(E_NOMEM)
#define MAP_NOMEM_R  SET_ERRNO(E_REHASH_NOMEM)
#endif

#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
#  define err_map_symbol_string_init_internal_q(SE,Z,SI)  err_map_symbol_string_init_internal(SE,Z,SI)
#else
#  define err_map_symbol_string_init_internal_q(SE,Z,SI) err_map_symbol_string_init_internal(SE,SI)
#endif



#  define feature_q(K,V)                feature(K,V)
#  define err_map_symbol_string_hashlist_new_q(K,V)               err_map_symbol_string_hashlist_new(K,V)
#  define err_map_symbol_string_find_any_pair_q(K,V,SE)   err_map_symbol_string_find_any_pair(K,V,SE)
#  define err_map_symbol_string_insert_q(SE,K,V)          err_map_symbol_string_insert(SE,K,V)

#  define err_map_symbol_string_insert_no_copy_no_rehash_q(SE,K,V) \
                                        err_map_symbol_string_insert_no_copy_no_rehash(SE,K,V)

#  define err_map_symbol_string_poke_internal_q(KO,VO,SE,K,KC,DK,V,VK,DV,I,O) \
                                        err_map_symbol_string_poke_internal(KO,VO,SE,K,KC,DK,V,VK,DV,I,O)

#  define err_map_symbol_string_poke_q(KO,VO,SE,K,V,I,O)  err_map_symbol_string_poke(KO,VO,SE,K,V,I,O)

#  define err_map_symbol_string_poke_no_icopy_q(KO,VO,SE,K,V,I,O)  \
                                        err_map_symbol_string_poke_no_icopy(KO,VO,SE,K,V,I,O)

#  define err_map_symbol_string_remove_internal_no_resize_q(SE,K,R) \
                                        err_map_symbol_string_remove_internal_no_resize(SE,K,R)

#  define err_map_symbol_string_remove_internal_q(SE,K,R) err_map_symbol_string_remove_internal(SE,K,R)



#ifdef TYPE_INFO_T

static
TYPE_STRUCT_T(err_map_symbol_string_hashlist_t)=
    TYPE_STRUCT_BEGIN(err_map_symbol_string_hashlist_t)
        TYPE_STRUCT_SLOT(err_map_symbol_string_hashlist_t, err_symbol_t, key)
        TYPE_STRUCT_SLOT(err_map_symbol_string_hashlist_t, char_p, value)
        TYPE_STRUCT_SLOT(err_map_symbol_string_hashlist_t, err_map_symbol_string_hashlist_t_p,        next)
    TYPE_STRUCT_END
;


TYPE_INFO_T(err_map_symbol_string_hashlist_t)= TYPE_INFO_STRUCT (err_map_symbol_string_hashlist_t, err_map_symbol_string_hashlist_t);


TYPE_INFO_T(err_map_symbol_string_hashlist_t_p)= TYPE_INFO_POINTER (err_map_symbol_string_hashlist_t *, err_map_symbol_string_hashlist_t);


TYPE_INFO_T(err_map_symbol_string_hashlist_t_const_p)= TYPE_INFO_POINTER (err_map_symbol_string_hashlist_t const *, err_map_symbol_string_hashlist_t);


TYPE_INFO_T(err_map_symbol_string_content)= TYPE_INFO_VECTOR (err_map_symbol_string_content, err_map_symbol_string_hashlist_t_p, err_map_symbol_string_t, m_hashsize);


TYPE_INFO_T(err_map_symbol_string_content_p)= TYPE_INFO_POINTER (err_map_symbol_string_content *, err_map_symbol_string_content);

static
TYPE_STRUCT_T(err_map_symbol_string_internal_Iterator)=
    TYPE_STRUCT_BEGIN(err_map_symbol_string_internal_Iterator)
        TYPE_STRUCT_SLOT(err_map_symbol_string_internal_Iterator, err_map_symbol_string_hashlist_t_p, cnode)
        TYPE_STRUCT_SLOT(err_map_symbol_string_internal_Iterator, int,      cslot)
    TYPE_STRUCT_END
;


TYPE_INFO_T(err_map_symbol_string_internal_Iterator)=
    TYPE_INFO_STRUCT (err_map_symbol_string_internal_Iterator, err_map_symbol_string_internal_Iterator);

static
TYPE_STRUCT_T(err_map_symbol_string_t)=
    TYPE_STRUCT_BEGIN(err_map_symbol_string_t)
#ifdef  ERR_MAP_SYMBOL_STRING_SUPER_TYPE
        TYPE_SUPER(err_map_symbol_string_t, ERR_MAP_SYMBOL_STRING_SUPER_CLASS),
#endif
        ERR_MAP_SYMBOL_STRING_TYPE_INFO_STD_MEMBERS
        err_map_symbol_string_record_sig     (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_sig))
        err_map_symbol_string_record_table   (TYPE_STRUCT_SLOT(err_map_symbol_string_t, err_map_symbol_string_content_p,   m_table))
        err_map_symbol_string_record_sizes   (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_hashsize))
        err_map_symbol_string_record_sizes   (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_nentries))
        err_map_symbol_string_record_errno   (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_errno))
        err_map_symbol_string_record_zero    (TYPE_STRUCT_SLOT(err_map_symbol_string_t, char_p, m_zero))
        err_map_symbol_string_record_compat  (TYPE_STRUCT_SLOT(err_map_symbol_string_t, err_map_symbol_string_internal_Iterator, compat1_iter))
        err_map_symbol_string_record_profile (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_nrehash))
        err_map_symbol_string_record_profile (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_nrehashops))
        err_map_symbol_string_record_profile (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_nfind))
        err_map_symbol_string_record_profile (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_ninsert))
        err_map_symbol_string_record_profile (TYPE_STRUCT_SLOT(err_map_symbol_string_t, int,             m_ndelete))
    TYPE_STRUCT_END
;


TYPE_INFO_T(err_map_symbol_string_t)= TYPE_INFO_STRUCT (err_map_symbol_string_t, err_map_symbol_string_t);


TYPE_INFO_T(err_map_symbol_string_t_p)= TYPE_INFO_POINTER (err_map_symbol_string_t *, err_map_symbol_string_t);


TYPE_INFO_T(err_map_symbol_string_t_const_p)= TYPE_INFO_POINTER (err_map_symbol_string_t const *, err_map_symbol_string_t);

#endif /* defined(TYPE_INFO_T) */


ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_new_q")
err_map_symbol_string_hashlist_t * err_map_symbol_string_hashlist_new_q
        (err_symbol_t  key, char *  value)
{
    err_map_symbol_string_hashlist_t *self;
    E_SET_PTR(self, ERR_ERWIN_THING_NEW1 (err_map_symbol_string_hashlist_t));
    if (ERWIN_UNLIKELY(self == NULL))
        return NULL;
    E_SET_KEY   (self->key,   key);
    E_SET_VALUE (self->value, value);
    E_SET_PTR   (self->next,  NULL);
    return self;
}


ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete")
void err_map_symbol_string_hashlist_delete
        (err_map_symbol_string_hashlist_t *list)
{
    err_map_symbol_string_hashlist_t *next;

    while (list) {
        IFREE (list->key);
        OFREE (list->value);
        E_SET_PTR(next, list->next);
        ERR_ERWIN_THING_DELETE1 (list, err_map_symbol_string_hashlist_t);
        E_SET_PTR(list, next);
    }
}


ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete_flags")
void err_map_symbol_string_hashlist_delete_flags
        (err_map_symbol_string_hashlist_t *list, ERR_ERWIN_BOOL keys, ERR_ERWIN_BOOL values)
{
    err_map_symbol_string_hashlist_t *next;

    while (list) {
        if (keys && IFREE_PROVIDED)   { IFREE (list->key); }
        if (values && OFREE_PROVIDED) { OFREE (list->value); }
        E_SET_PTR(next, list->next);
        ERR_ERWIN_THING_DELETE1 (list, err_map_symbol_string_hashlist_t);
        E_SET_PTR(list, next);
    }
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete_no_child_delete")
void err_map_symbol_string_hashlist_delete_no_child_delete
        (err_map_symbol_string_hashlist_t *list)
{
    err_map_symbol_string_hashlist_t *next;

    while (list) {
        E_SET_PTR(next, list->next);
        ERR_ERWIN_THING_DELETE1 (list, err_map_symbol_string_hashlist_t);
        E_SET_PTR(list, next);
    }
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete_cell")
void err_map_symbol_string_hashlist_delete_cell
        (err_map_symbol_string_hashlist_t *list)
{
    ERR_ERWIN_THING_DELETE1 (list, err_map_symbol_string_hashlist_t);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_length")
int err_map_symbol_string_hashlist_length
        (err_map_symbol_string_hashlist_t *list)
{
    int result= 0;
    while (list) {
        result++;
        E_SET_PTR(list, list->next);
    }
    return result;
}
            

#if !E_GLOBAL_ERRNO
CODE_SECTION(".text.errno")
int err_map_symbol_string_errno
        (err_map_symbol_string_t const *self)
{
    return_val_if_null_or_bad (self, E_ASSERTIONFAILED);
    return e_errno;
}

CODE_SECTION(".text.clear_errno")
void err_map_symbol_string_clear_errno
        (err_map_symbol_string_t const *self)
{
    return_if_null_or_bad (self);
    SET_ERRNO(E_OK);
}
#endif /* !E_GLOBAL_ERRNO */


ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_internal_q")
ERR_ERWIN_BOOL err_map_symbol_string_init_internal_q
        (err_map_symbol_string_t *self, char const *  zero, int nelem)
{
    int size;
#ifndef NDEBUG
    int err= 0;
    static int tested= 0;
            /* See vector.cd for a comment */
#endif

    size= nelem;
    if (nelem >= 0) { /* Compute hash size from expected number of elements: */
        size= ((nelem * ERR_MAP_SYMBOL_STRING_TRIGGER_DENOMINATOR + ERR_MAP_SYMBOL_STRING_TRIGGER_NUMERATOR - 1) / /* round up */
                ERR_MAP_SYMBOL_STRING_TRIGGER_NUMERATOR * 2
              ) + 1;
    }

    if (size < 0)
        size= ERR_MAP_SYMBOL_STRING_INITIAL_SIZE;

#if  ERR_MAP_SYMBOL_STRING_HAVE_SIG
    self->m_sig= ERR_MAP_SYMBOL_STRING_SIG;
#endif

    if (size <= 0)
        size= 1;
#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE
    if (size == 1)    /* this means that the slot table is missing and we have a single list. */
        E_SET_PTR(self->m_table, NULL); /* empty list! */
    else {
        E_SET_PTR(self->m_table, ERR_ERWIN_THING_CNEW_ARRAY (err_map_symbol_string_content, (unsigned)size));

        if (ERWIN_UNLIKELY(self->m_table == NULL)) {
            MAP_NOMEM;
            return ERR_ERWIN_FALSE;
        }
    }
#else
    E_SET_PTR(self->m_table, ERR_ERWIN_THING_CNEW_ARRAY (err_map_symbol_string_content, (unsigned)size));

    if (ERWIN_UNLIKELY(self->m_table == NULL)) {
        MAP_NOMEM;
        return ERR_ERWIN_FALSE;
    }
#endif


    self->m_hashsize= size;
    self->m_nentries= 0;

#ifdef E_PROFILE
    self->m_nrehash= 0;
    self->m_nrehashops= 0;
    self->m_nfind= 0;
    self->m_ninsert= 0;
    self->m_ndelete= 0;
#endif

#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        return0_if_crash_ppt (
            (void)OCOPY (zero, NULL),
            self,
            "OCOPY crashes for zero element when ERR is NULL.");
    }
#endif

    E_SET_VALUE (self->m_zero, OCOPY (zero, NULL));
#endif

#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        /* Check that constraints about the copy functions hold.  These are typical bugs. */
        return0_if_crash_ppt (
            (void)ICOPY (IZERO, &err),
            self,
            "ICOPY crashes for zero element.");

        err= 0;
        (void)ICOPY (IZERO, &err);
        return0_if_fail_ppti (err == 0,
            self,
            "ICOPY seems to set error flag for zero element",
            err);

        err= 17;
        (void)ICOPY (IZERO, &err);
        return0_if_fail_ppti (err == 17,
            self,
            "ICOPY seems to overwrite error flag for zero element (the previous value of 17 was destroyed)",
            err);

        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), &err),
            self,
            "OCOPY crashes for zero element.");

        return0_if_fail_ppt  (
            IEQUAL((ICOPY (IZERO, &err)), IZERO),
            self,
            "ICOPY must not copy zero element.");

#ifdef OEQUAL
        return0_if_fail_ppt  (
            OEQUAL ((OCOPY (ZERO (self), &err)), ZERO (self)),
            self,
            "OCOPY must not copy zero element.");
#endif

        return0_if_crash_ppt (
            (void)ICOPY (IZERO, NULL),
            self,
            "ICOPY crashes when ERR is NULL.");

        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), NULL),
            self,
            "OCOPY crashes when ERR is NULL.");

        err= 0;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 0,
            self,
            "OCOPY seems to set error flag for zero element",
            err);

        err= 17;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 17,
            self,
            "OCOPY seems to overwrite error flag for zero element (the previous value of 17 was destroyed)",
            err);

        /* Check that the deletion function do not crash on zero elements. */
        return0_if_crash_ppt (
            IFREE (ICOPY (IZERO,  &err)),
            self,
            "IFREE crashes for zero element.");

        return0_if_crash_ppt (
            OFREE (ZEROVAR (self)),
            self,
            "OFREE crashes for zero element.");

        tested= 1;
    }
#endif

    return ERR_ERWIN_TRUE;
}

CODE_SECTION(".text.init")
int err_map_symbol_string_init
        (err_map_symbol_string_t *self)
{
    err_map_symbol_string_init_internal_q (self, OZERO, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
    return e_errno;
}

CODE_SECTION(".text.init_with_initial_size")
int err_map_symbol_string_init_with_initial_size
        (err_map_symbol_string_t *self, int size)
{
    err_map_symbol_string_init_internal_q (self, OZERO, size);
    return e_errno;
}

#if ERR_MAP_SYMBOL_STRING_DYN_ZERO

CODE_SECTION(".text.init_with_zero_and_initial_size")
int err_map_symbol_string_init_with_zero_and_initial_size
        (err_map_symbol_string_t *self, char const *  zero, int size)
{
    err_map_symbol_string_init_internal_q (self, zero, size);
    return e_errno;
}

/*
 * The general function for creating a new hash table.
 */
CODE_SECTION(".text.new_with_zero_and_initial_size")
err_map_symbol_string_t * err_map_symbol_string_new_with_zero_and_initial_size
        (char const *  zero, int size)
{
    err_map_symbol_string_t *self;

    E_SET_PTR(self, ERR_ERWIN_THING_NEW1 (err_map_symbol_string_t));
    SET_ERRNO(E_OK);

    if (ERWIN_UNLIKELY(self == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(err_map_symbol_string_init_internal_q (self, zero, size)))
       return self;

    ERR_ERWIN_THING_DELETE1 (self, err_map_symbol_string_t);
    return NULL;
}

/*
 * Special frontends for the generic hash creation function
 */
CODE_SECTION(".text.new_with_zero")
err_map_symbol_string_t * err_map_symbol_string_new_with_zero
        (char const *  zero)
{
    return err_map_symbol_string_new_with_zero_and_initial_size (zero, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
}

#endif /* ERR_MAP_SYMBOL_STRING_DYN_ZERO */

#if ERR_MAP_SYMBOL_STRING_CONSTANT_ZERO
#define err_map_symbol_string_new_with_zero_and_initial_size(Z,S) err_map_symbol_string_new_with_initial_size(S)
#define err_map_symbol_string_new_with_zero(Z)                    err_map_symbol_string_new()
#endif

/*
 * The general function for creating a new hash table.
 */
CODE_SECTION(".text.new_with_initial_size")
err_map_symbol_string_t * err_map_symbol_string_new_with_initial_size
        (int size)
{
    err_map_symbol_string_t *self;

    E_SET_PTR(self, ERR_ERWIN_THING_NEW1 (err_map_symbol_string_t));

    if (ERWIN_UNLIKELY(self == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(err_map_symbol_string_init_internal_q (self, OZERO, size)))
       return self;

    ERR_ERWIN_THING_DELETE1 (self, err_map_symbol_string_t);
    return NULL;
}

CODE_SECTION(".text.new")
err_map_symbol_string_t * err_map_symbol_string_new
        (void)
{
    return err_map_symbol_string_new_with_zero_and_initial_size (OZERO, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
}


CODE_SECTION(".text.zero")
o_type_result_t err_map_symbol_string_zero
        (err_map_symbol_string_t const *self)
{
    (void)self; /*unused*/

    return ZERO(self);
}

/*
 * For use with copy constructors:
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.struct_copy")
void err_map_symbol_string_struct_copy
        (err_map_symbol_string_t *copy, err_map_symbol_string_t const *self)
{
    int i;

    for (i= 0; i < self->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR(lauf, SLOT(self,i));
       while (lauf) {
           err_map_symbol_string_insert_q (copy, lauf->key, lauf->value);
           E_SET_PTR(lauf, lauf->next);
       }
    }
}

/*
 * Copy a hash table
 */
CODE_SECTION(".text.copy")
err_map_symbol_string_t * err_map_symbol_string_copy
        (err_map_symbol_string_t const* self)
{
    err_map_symbol_string_t *copy;
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return NULL;
    }
    return0_if_null2i_or_bad (self);

    E_SET_PTR(copy, err_map_symbol_string_new_with_zero_and_initial_size (ZERO(self), self->m_nentries));
    err_map_symbol_string_struct_copy (copy, self);
    return copy;
}

CODE_SECTION(".text.copy_err")
err_map_symbol_string_t * err_map_symbol_string_copy_err
        (err_map_symbol_string_t const* self, int *err)
{
    err_map_symbol_string_t *result;

    E_SET_PTR(result, err_map_symbol_string_copy (self));

    if (ERWIN_UNLIKELY(err != NULL && e_errno != E_OK))
        *err= 1;

    return result;
}


/*
 * Get the size of the hash table.  NOT the number of elements
 * in the table, but the size of the internal map.  This is
 * useful for advanced users only.
 */
CODE_SECTION(".text.hash_size")
int err_map_symbol_string_hash_size
        (err_map_symbol_string_t const* self)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return0_if_null (self);

    return self->m_hashsize;
}


/*
 * Get the number of entries in the hash table.
 */
CODE_SECTION(".text.nentries")
int err_map_symbol_string_nentries
        (err_map_symbol_string_t const* self)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return0_if_null (self);

    return self->m_nentries;
}

CODE_SECTION(".text.empty")
ERR_ERWIN_BOOL err_map_symbol_string_empty
        (err_map_symbol_string_t const* self)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_TRUE;
#endif
    return0_if_null (self);

    return ERR_ERWIN_TO_BOOL (self->m_nentries == 0);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.clear_internal")
void err_map_symbol_string_clear_internal
        (err_map_symbol_string_t* self)
{
    int i;
    for (i=0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_delete (SLOT(self,i));
        E_SET_PTR(SLOT(self,i), NULL);
    }
}

CODE_SECTION(".text.clear_no_resize")
void err_map_symbol_string_clear_no_resize
        (err_map_symbol_string_t* self)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    return_if_null2i_or_bad (self);

    err_map_symbol_string_clear_internal (self);

    self->m_nentries= 0;
    SET_ERRNO(E_OK);
}

static
CODE_SECTION(".text.clear_internal_flags")
void err_map_symbol_string_clear_internal_flags
        (err_map_symbol_string_t* self, ERR_ERWIN_BOOL keys, ERR_ERWIN_BOOL values)
{
    int i;
    for (i=0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_delete_flags (SLOT(self,i), keys, values);
        E_SET_PTR (SLOT(self,i), NULL);
    }
}

/*
 * Remove all entries from the hash table but possibly do not delete them.
 */
CODE_SECTION(".text.clear_flags_no_resize")
void err_map_symbol_string_clear_flags_no_resize
        (err_map_symbol_string_t* self, ERR_ERWIN_BOOL keys, ERR_ERWIN_BOOL values)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    return_if_null2i_or_bad (self);

    err_map_symbol_string_clear_internal_flags (self, keys, values);
    self->m_nentries= 0;
    SET_ERRNO(E_OK);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.destroy_internal")
void err_map_symbol_string_destroy_internal
        (err_map_symbol_string_t* self)
{
    return_if_null2i_or_bad (self);

    err_map_symbol_string_clear_internal (self);
    FREE_TABLE(self);

#if ERR_MAP_SYMBOL_STRING_HAVE_SIG
    self->m_sig= 0;
#endif
}

CODE_SECTION(".text.xchg")
void err_map_symbol_string_xchg
        (err_map_symbol_string_t *self, err_map_symbol_string_t *other)
{
    err_map_symbol_string_record_table   (ERWIN_XCHG (err_map_symbol_string_content_p,   self->m_table,      other->m_table));
    err_map_symbol_string_record_sizes   (ERWIN_XCHG (int,             self->m_hashsize,   other->m_hashsize));
    err_map_symbol_string_record_sizes   (ERWIN_XCHG (int,             self->m_nentries,   other->m_nentries));
    err_map_symbol_string_record_errno   (ERWIN_XCHG (int,             self->m_errno,      other->m_errno));
    err_map_symbol_string_record_zero    (ERWIN_XCHG (char *,        self->m_zero,       other->m_zero));
    err_map_symbol_string_record_compat  (ERWIN_XCHG (map_iterator_t,  self->compat1_iter, other->compat1_iter));
    err_map_symbol_string_record_profile (ERWIN_XCHG (int,             self->m_nrehash,    other->m_nrehash));
    err_map_symbol_string_record_profile (ERWIN_XCHG (int,             self->m_nrehashops, other->m_nrehashops));
    err_map_symbol_string_record_profile (ERWIN_XCHG (int,             self->m_nfind,      other->m_nfind));
    err_map_symbol_string_record_profile (ERWIN_XCHG (int,             self->m_ninsert,    other->m_ninsert));
    err_map_symbol_string_record_profile (ERWIN_XCHG (int,             self->m_ndelete,    other->m_ndelete));
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.destroy_internal_flags")
void err_map_symbol_string_destroy_internal_flags
        (
    err_map_symbol_string_t* self,
    ERR_ERWIN_BOOL destroy_keys,
    ERR_ERWIN_BOOL destroy_values)
{
    return_if_null2i_or_bad (self);

    err_map_symbol_string_clear_internal_flags (self, destroy_keys, destroy_values);
    FREE_TABLE(self);

#if ERR_MAP_SYMBOL_STRING_HAVE_SIG
    self->m_sig= 0;
#endif
}

CODE_SECTION(".text.destroy")
void err_map_symbol_string_destroy
        (err_map_symbol_string_t* self)
{
    err_map_symbol_string_destroy_internal (self);
}

CODE_SECTION(".text.destroy_flags")
void err_map_symbol_string_destroy_flags
        (err_map_symbol_string_t* self, ERR_ERWIN_BOOL k, ERR_ERWIN_BOOL v)
{
    err_map_symbol_string_destroy_internal_flags (self, k, v);
}

/*
 * Free the whole hash table
 */
CODE_SECTION(".text.delete_flags")
void err_map_symbol_string_delete_flags
        (
    err_map_symbol_string_t* self, ERR_ERWIN_BOOL destroy_keys, ERR_ERWIN_BOOL destroy_values)
{
    if (self != NULL) {
        err_map_symbol_string_destroy_internal_flags (self, destroy_keys, destroy_values);
        ERR_ERWIN_THING_DELETE1 (self, err_map_symbol_string_t);
    }
}

CODE_SECTION(".text.delete")
void err_map_symbol_string_delete
        (err_map_symbol_string_t* self)
{
    if (self != NULL) {
        err_map_symbol_string_destroy_internal (self);
        ERR_ERWIN_THING_DELETE1 (self, err_map_symbol_string_t);
    }
}


CODE_SECTION(".text.expect_size")
ERR_ERWIN_BOOL err_map_symbol_string_expect_size
        (err_map_symbol_string_t *self, int newsize)
{
    int new_hash_size;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return ERR_ERWIN_FALSE;
    }
#endif
    return0_if_null2i_or_bad (self);

    new_hash_size= self->m_hashsize;
    return0_if_fail (newsize >= 0);

    if (TOOSMALL(newsize, new_hash_size)) {
        /* Slightly more general than grow_perhaps, but
         * we do not replace the code there because of the
         * overhead of checking self */
#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE
        if (new_hash_size <= 1) {
            /* up to a given size, we keep the single slot, despite TOOSMALL finding
             * this too small. :-) */
            if (newsize <= ERR_MAP_SYMBOL_STRING_PLAIN_LIST_LENGTH)
                return ERR_ERWIN_FALSE;
        }
#endif

        do {
            new_hash_size*= 2;
        } while(TOOSMALL(newsize, new_hash_size));

        err_map_symbol_string_rehash (self, new_hash_size);

        return ERR_ERWIN_TRUE;
    }

    if (TOOLARGE(newsize, new_hash_size)) {
        /* Slightly more general than shrink_perhaps, but
         * we do not replace the code there because of the
         * overhead of checking self */
#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE
        if (newsize <= ERR_MAP_SYMBOL_STRING_PLAIN_LIST_LENGTH)
            new_hash_size=1;
        else
#endif
        {
            do {
                new_hash_size/= 2;
            } while (TOOLARGE (newsize, new_hash_size));

            if (new_hash_size < ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1)
                new_hash_size= ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1;
        }

        err_map_symbol_string_rehash (self, new_hash_size);

        return ERR_ERWIN_TRUE;
    }

    return ERR_ERWIN_FALSE;
}

/*
 * Internal function: possibly rehashes the table if it is
 * too small
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.grow_perhaps")
ERR_ERWIN_BOOL err_map_symbol_string_grow_perhaps
        (err_map_symbol_string_t *self)
{
    return0_if_fail (self->m_hashsize > 0); /* must be, even for ZERO_SIZE */
#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE
    if (ERWIN_UNLIKELY(self->m_hashsize == 1)) {
        if (self->m_nentries+1 <= ERR_MAP_SYMBOL_STRING_PLAIN_LIST_LENGTH)
            return ERR_ERWIN_FALSE;
    }
#endif
    if (ERWIN_UNLIKELY(TOOSMALL ((self->m_nentries+1), self->m_hashsize))) {
        err_map_symbol_string_rehash (self, self->m_hashsize * 2);
        return ERR_ERWIN_TRUE;
    }
    return ERR_ERWIN_FALSE;
}

/*
 * Internal function: possibly shrinks the table if it is
 * too large
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.shrink_perhaps")
ERR_ERWIN_BOOL err_map_symbol_string_shrink_perhaps
        (err_map_symbol_string_t *self)
{
    if (ERWIN_UNLIKELY(TOOLARGE (self->m_nentries, self->m_hashsize))) {
        int newsize= self->m_hashsize;

#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE
        if (self->m_nentries <= ERR_MAP_SYMBOL_STRING_PLAIN_LIST_LENGTH)
            newsize= 1;
        else
#endif
        {
            do {
                newsize/= 2;
            } while (TOOLARGE (self->m_nentries, newsize));

            if (newsize < ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1)
                newsize= ERR_MAP_SYMBOL_STRING_MINIMAL_SIZE_OR_1;
        }

        err_map_symbol_string_rehash (self, newsize);

        return ERR_ERWIN_TRUE;
    }
    return ERR_ERWIN_FALSE;
}


/*
 * Remove all entries from the hash table but possibly do not delete them.
 */
CODE_SECTION(".text.clear_flags")
void err_map_symbol_string_clear_flags
        (err_map_symbol_string_t* self, ERR_ERWIN_BOOL keys, ERR_ERWIN_BOOL values)
{
    err_map_symbol_string_clear_flags_no_resize (self, keys, values);
    err_map_symbol_string_shrink_perhaps (self);
}

/*
 * Remove all entries from the hash table.  Somewhat equivalent with
 * delete() followed by new().
 */
CODE_SECTION(".text.clear")
void err_map_symbol_string_clear
        (err_map_symbol_string_t* self)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    err_map_symbol_string_clear_no_resize(self);
    err_map_symbol_string_shrink_perhaps (self);
    SET_ERRNO(E_OK);
}

/*
 * Internal function: get the slot in the hash table an element
 * falls into.
 * NOTE: This profits a lot from -DNDEBUG...
 */
ERWIN_STATIC_INLINE ATTR_ALWAYS_INLINE
CODE_SECTION(".text.slot_no")
unsigned err_map_symbol_string_slot_no
        (err_map_symbol_string_t const *self, err_symbol_t  key)
{
    int slot;
    return0_if_null (self);
    return0_if_fail_ppi (self->m_hashsize > 0, self, self->m_hashsize);

#if 0
    /* this breaks the DFS ordering of the modules.  It may not be invoked. */
    return0_if_fail_pptC (e_mapinitialised,
        self,
        "Please invoke err_erwin_init (&argc, &argv) in main().",
        err_erwin_init (NULL, NULL));
#else
    /* abort immediately because the library is instable in this state. */
    exit_if_fail_ppt (e_mapinitialised,
        self,
        "Please invoke err_erwin_init (&argc, &argv) in main().  If this "
        "Erwin library is part of a library, invoke err_init(&argc, &argv) "
        "instead (or the appropriate initialisation function of the library), "
        "which in turn will invoke err_erwin_init() probably among other "
        "things.");
#endif

    slot= e_hash_into (IHASH (key), self->m_hashsize);

    return0_if_fail_ppiit (slot >= 0 && slot < self->m_hashsize,
        self,
        slot,
        self->m_hashsize,
        "e_hash_into() does not work correctly.");
    return slot;
}


/*
 * Internal: Find a key in the hash table and return the pointer to the
 * pointer the list entry.  This allows for deletion and insertion.
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.find_internal_ptr")
err_map_symbol_string_hashlist_t ** err_map_symbol_string_find_internal_ptr
        (err_map_symbol_string_t const* self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t **lauf;
#ifdef E_PROFILE
    hack_no_const h;
#endif

#if ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif

    return0_if_null (self);

#ifdef E_PROFILE
    E_SET_PTR(h.mapconstt, self);
    h.mapt->m_nfind++;  /* this is a mutable entry */
#endif

    return0_if_bad_table (self);

    E_SET_PTR(lauf, &SLOT(self, err_map_symbol_string_slot_no (self, key)));
    while (*lauf) {
        if (IEQUAL (((*lauf)->key), key))
            return lauf;
        E_SET_PTR(lauf, &(*lauf)->next);
    }
    return lauf;
}


/*
 * Internal function: Find a key in the hash table.  Two versions depending
 * on whether optimising for speed or for size. */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.find_internal")
err_map_symbol_string_hashlist_t * err_map_symbol_string_find_internal
        (err_map_symbol_string_t const* self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t **result;

    E_SET_PTR(result, err_map_symbol_string_find_internal_ptr (self, key));
#if ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (result == NULL)
        return NULL;
#endif
    return0_if_null_pp (result, self);
    return *result;
}



/*
 * This looks disgusting but there are several versions depending on
 * wether char const * == char * or not. */
CODE_SECTION(".text.find_ptr")
err_map_symbol_string_element_ptr_t err_map_symbol_string_find_ptr
        (err_map_symbol_string_t const* self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t *lauf;

    E_SET_PTR(lauf, err_map_symbol_string_find_internal (self, key));
    if (lauf == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return NULL;
    }
    SET_ERRNO(E_OK);
    return ERWIN_SUPERFLUOUS_CAST (char const * const *, &lauf->value);
}



/*
 * This *must* be inlined, otherwise the code is aweful.
 *
 * poke_internal is most general.  It implements all _poke functions.
 * Note that for the following implementation it is (again) essential
 * that the COPY functions do not touch the zero elements.
 * This is written with the hope that the compiler optimises when inlining.
 * There are several issues that may seem to need optimisation, but due
 * to source code optimisation, I leave this to the compiler.
 *
 * FIXME: make this a macro for better optimisation (especially for
 *        err_map_symbol_string_ensure which currently evaluates ENSURE_VALUE to often).
 *
 * FIXME: change this to return `lauf' instead of errno.  Then find_ptr_ensure
 *        can use this function, too.
 *
 */
ERWIN_STATIC_INLINE_SPEED ATTR_ALWAYS_INLINE
CODE_SECTION(".text.poke_internal_q")
int err_map_symbol_string_poke_internal_q
        (
        err_symbol_t                *key_out,
        char *             *value_out,
        err_map_symbol_string_t                *self,
        err_symbol_t           key,
        err_symbol_t          givenkeycopy,
        ERR_ERWIN_BOOL     dokeycopy,
        char const *           value,
        char *          givenvaluecopy,
        ERR_ERWIN_BOOL     dovaluecopy,
        ERR_ERWIN_BOOL     introduce,
        ERR_ERWIN_BOOL     overwrite)
{
    int copyerror= ERR_ERWIN_FALSE;
    err_map_symbol_string_hashlist_t **lauf;

    /* Try to find the entry */
    E_SET_PTR(lauf, err_map_symbol_string_find_internal_ptr (self, key));
#if ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (lauf == NULL || *lauf == NULL)
#else
    return_val_if_null_ppC (lauf, ASSERTION_FAILED, self,
        (
            ((value_out == NULL) ? (void)0 : (void)E_SET_VALUE (*value_out, ZEROVAR (self))),
            ((key_out   == NULL) ? (void)0 : (void)E_SET_KEY (*key_out, IZERO))
        )
    );
    if (*lauf == NULL)
#endif
    {

        /* An old value did not exist. */
        if (value_out != NULL) E_SET_VALUE (*value_out, ZEROVAR (self));

        if (introduce) {
            return_val_if_null_pp (self, ASSERTION_FAILED, self);

            /* Possibly rehash.  Do it late so that checking the hash trigger is
             * performed less often.  Searching again hurts less because it's seldom. */
            if (err_map_symbol_string_grow_perhaps (self)) {
                E_SET_PTR(lauf, err_map_symbol_string_find_internal_ptr (self, key));
            }
            return_val_if_null_pp (lauf, ASSERTION_FAILED, self);
            return_val_if_fail_pp (*lauf == NULL, ASSERTION_FAILED, self);

            /* ********************************************************************** */
            /* This is long to help optimising compilers.  */
            if (dovaluecopy) {
                char * valuecopy;
                E_SET_VALUE (valuecopy, OCOPY (value, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror))
                    goto nomem;

                if (dokeycopy) {
                    err_symbol_t keycopy;
                    E_SET_KEY (keycopy, ICOPY (key, &copyerror));
                    if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror)) {
                        OFREE (valuecopy);
                        goto nomem;
                    }

                    if (key_out != NULL)
                        E_SET_KEY (*key_out, keycopy);

                    E_SET_PTR(*lauf, err_map_symbol_string_hashlist_new (keycopy, valuecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL)) {
                        IFREE (keycopy);
                        OFREE (valuecopy);
                        goto nomem;
                    }
                }
                else {
                    if (key_out != NULL)
                        E_SET_KEY (*key_out, givenkeycopy);

                    E_SET_PTR(*lauf, err_map_symbol_string_hashlist_new (givenkeycopy, valuecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL)) {
                        OFREE (valuecopy);
                        goto nomem;
                    }
                }
            }
            else
            {
                if (dokeycopy) {
                    err_symbol_t keycopy;
                    E_SET_KEY (keycopy, ICOPY (key, &copyerror));
                    if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror))
                        goto nomem;

                    if (key_out != NULL)
                        E_SET_KEY (*key_out, keycopy);

                    E_SET_PTR(*lauf, err_map_symbol_string_hashlist_new_q (keycopy, givenvaluecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL)) {
                        IFREE (keycopy);
                        goto nomem;
                    }
                }
                else {
                    if (key_out != NULL)
                        E_SET_KEY (*key_out, givenkeycopy);

                    E_SET_PTR(*lauf, err_map_symbol_string_hashlist_new_q (givenkeycopy, givenvaluecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL))
                        goto nomem;
                }
            }
            /* ********************************************************************** */

            /* update counter and return happily */
            self->m_nentries++;

            return PASS_ERRNO(E_OK);
        }
        else {
            if (key_out != NULL) E_SET_KEY (*key_out, IZERO);

            /* NOTE: We shall not copy the key (or value) but use the given one.
             *       We don't use either of them, so we have to deallocate them.
             *
             * The bug fix of this memory leak is dedicated to Michael Schmidt who
             * found it using dmalloc. :-) (Yes, someone does use poke_no_icopy...)
             */
            if (!dovaluecopy) {
                OFREE (givenvaluecopy);
            }
            if (!dokeycopy) {
                IFREE (givenkeycopy);
            }

            return PASS_ERRNO(E_KEYNOTFOUND);
        }
    }
    else {
        /* Return found key and value to caller */
        if (key_out != NULL)   E_SET_KEY   (*key_out,   (*lauf)->key);

        if (value_out != NULL) E_SET_VALUE (*value_out, (*lauf)->value);

        /* Same as before: we do not incorporate the given key
         * into the hash table, so we must free it. */
        if (!dokeycopy) {
            IFREE (givenkeycopy);
        }

        if (overwrite) {
#if OFREE_PROVIDED
            /* keep old copy for possibly deletion. */
            char * oldvalue;
            E_SET_VALUE (oldvalue, (*lauf)->value);
#endif


            if (dovaluecopy) {
                char * valuecopy;
                E_SET_VALUE (valuecopy, OCOPY (value, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror))
                    goto nomem;

                E_SET_VALUE ((*lauf)->value, valuecopy);
            }
            else
                E_SET_VALUE ((*lauf)->value, givenvaluecopy);

#if OFREE_PROVIDED
            /* delete old entry if caller does not want it */
            if (value_out == NULL) {
                OFREE (oldvalue);
            }
#endif

            /* return PASS_ERRNO(E_OK); */
            return PASS_ERRNO(E_EXISTINGKEY);
               /* important change!  This means that you get to know when
                * _set overwrites a value. */
        }
        else
        {
            /* We will report that the entry was not overwritten by an appropriate error code. */
            /* If neither overwrite nor introduce is set, return E_OK, since we were only
             * searching and that succeeded. */

            /* Same as before */
            if (!dovaluecopy) {
                OFREE (givenvaluecopy);
            }

            return PASS_ERRNO(introduce ? E_EXISTINGKEY : E_OK);
        }
    }

    return_val_if_reached_pp (ASSERTION_FAILED, self);
    return E_ASSERTIONFAILED;


    /* These are out of the way to improve execution performance in the normal case.
     * Fall through edges rock! */

nomem:
    MAP_NOMEM;
    return e_errno;
}

/*
 * User space poke functions */
CODE_SECTION(".text.poke_q")
int err_map_symbol_string_poke_q
        (   
    err_symbol_t *ko, char * *vo,
    err_map_symbol_string_t *self,
    err_symbol_t  k, char const *  v,
    ERR_ERWIN_BOOL i, ERR_ERWIN_BOOL o)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return err_map_symbol_string_poke_internal_q (ko,vo,self, k,IZEROVAR,ERR_ERWIN_TRUE, v,ZEROVAR(self),ERR_ERWIN_TRUE, i,o);
}

CODE_SECTION(".text.poke_no_icopy_q")
int err_map_symbol_string_poke_no_icopy_q
        (
    err_symbol_t *ko, char * *vo, err_map_symbol_string_t *self, err_symbol_t  k, char const *  v, ERR_ERWIN_BOOL i, ERR_ERWIN_BOOL o)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return err_map_symbol_string_poke_internal_q (ko,vo,self, k,k,ERR_ERWIN_FALSE, v,ZEROVAR(self),ERR_ERWIN_TRUE, i,o);
}

CODE_SECTION(".text.poke_no_ocopy")
int err_map_symbol_string_poke_no_ocopy
        (
    err_symbol_t *ko, char * *vo, err_map_symbol_string_t *self, err_symbol_t  k, char *  v, ERR_ERWIN_BOOL i, ERR_ERWIN_BOOL o)
{
    return err_map_symbol_string_poke_internal (ko,vo,self, k,IZEROVAR,ERR_ERWIN_TRUE, v,v,ERR_ERWIN_FALSE, i,o);
}

CODE_SECTION(".text.poke_no_icopy_no_ocopy")
int err_map_symbol_string_poke_no_icopy_no_ocopy
        (
    err_symbol_t *ko, char * *vo, err_map_symbol_string_t *self, err_symbol_t  k, char *  v, ERR_ERWIN_BOOL i, ERR_ERWIN_BOOL o)
{
    return err_map_symbol_string_poke_internal (ko, vo, self, k,k,ERR_ERWIN_FALSE, v,v,ERR_ERWIN_FALSE, i,o);
}



/*
 * For a given key, find the value in the hash table */
CODE_SECTION(".text.find")
o_type_result_t err_map_symbol_string_find
        (err_map_symbol_string_t const* self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t *lauf;

#if defined(ERR_MAP_SYMBOL_STRING_ALLOW_NULL) && ERR_MAP_SYMBOL_STRING_CONSTANT_ZERO
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return OZERO;
    }
#endif

    E_SET_PTR(lauf, err_map_symbol_string_find_internal (self, key));
    if (lauf == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ZERO(self);
    }
    SET_ERRNO(E_OK);

    return lauf->value;

}


CODE_SECTION(".text.find_ensure")
o_type_result_t err_map_symbol_string_find_ensure
        (err_map_symbol_string_t * self, err_symbol_t  key)
{
    err_map_symbol_string_element_ptr_t result;
    E_SET_PTR(result, err_map_symbol_string_find_ptr_ensure (self, key));
#if !ERR_MAP_SYMBOL_STRING_NOMEM_IS_FATAL
    if (result == NULL) /* do not trigger segmentation fault */
        return ZERO(self);
#endif
    return *result;
}


/*
 * For a given key, find the key in the hash table */
CODE_SECTION(".text.find_key")
i_type_result_t err_map_symbol_string_find_key
        (err_map_symbol_string_t const* self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t *lauf;
#if defined(ERR_MAP_SYMBOL_STRING_ALLOW_NULL)
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return IZERO;
    }
#endif
    E_SET_PTR(lauf, err_map_symbol_string_find_internal (self, key));
    if (lauf == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return IZERO;
    }
    SET_ERRNO(E_OK);
    return lauf->key;
}


/*
 * Modify an entry
 */
CODE_SECTION(".text.modify")
o_type_var_t err_map_symbol_string_modify
        (err_map_symbol_string_t *self, err_symbol_t  key, char const *  value)
{
    /* Does not work without a cast because poke_internal takes err_symbol_t ,
     * not err_symbol_t .
     * Modify is a special case, because it never inserts a new key.
     * Maybe we should generalise the interface of _poke_internal again or
     * maybe make it a huge macro...
     */
    char * result;
    return_val_if_null_or_bad (self, ZEROVAR(self));
    err_map_symbol_string_poke_internal (
            NULL, &result, self,
            key,
                                IZEROVAR,      ERR_ERWIN_TRUE,
            value,              ZEROVAR(self), ERR_ERWIN_TRUE,
            ERR_ERWIN_FALSE, ERR_ERWIN_TRUE);
    if (e_errno == E_EXISTINGKEY)
        SET_ERRNO(E_OK);
    return result;
}


/*
 * Insert or modify an entry
 */
CODE_SECTION(".text.set")
ATTR_FLATTEN
int err_map_symbol_string_set
        (err_map_symbol_string_t *self, err_symbol_t  key, char const *  value)
{
    return0_if_null (self);
    return err_map_symbol_string_poke_internal (
            NULL,NULL,self,
            key,   IZEROVAR, ERR_ERWIN_TRUE,
            value, ZEROVAR(self), ERR_ERWIN_TRUE,
            ERR_ERWIN_TRUE, ERR_ERWIN_TRUE);
}


CODE_SECTION(".text.find_ptr_ensure")
err_map_symbol_string_element_ptr_t err_map_symbol_string_find_ptr_ensure
        (err_map_symbol_string_t *self, err_symbol_t  key)
/* NOTE: This cannot be implemented with _poke_internal, since it
 *       returns a pointer to an internal structure. */
/* FIXME: extract common parts from err_map_symbol_string_ensure and err_map_symbol_string_find_ptr_ensure,
 *        which do essentially the same. */
{
    err_map_symbol_string_hashlist_t **lauf;
    return0_if_null (self);

    E_SET_PTR(lauf, err_map_symbol_string_find_internal_ptr (self, key));
    return0_if_null_pp (lauf, self);

    SET_ERRNO(E_OK);
    if (*lauf == NULL) {
        if (ERWIN_UNLIKELY(err_map_symbol_string_grow_perhaps (self))) {
            E_SET_PTR(lauf, err_map_symbol_string_find_internal_ptr (self, key));
            return0_if_null_pp (lauf, self);
            return0_if_fail_ppp (*lauf == NULL, self, lauf);
        }

        {
            int copyerror= ERR_ERWIN_FALSE;
            err_symbol_t keycopy;
            E_SET_KEY (keycopy, ICOPY (key, &copyerror));
            if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror)) {
                MAP_NOMEM;
                return NULL;
            }

            {
                char * valuecopy;
                E_SET_VALUE (valuecopy, ERR_MAP_SYMBOL_STRING_ENSURE_VALUE(self, key, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror)) {
                    IFREE (keycopy);
                    MAP_NOMEM;
                    return NULL;
                }

                E_SET_PTR(*lauf, err_map_symbol_string_hashlist_new (keycopy, valuecopy));
                if (ERWIN_UNLIKELY(*lauf == NULL)) {
                    IFREE (keycopy);
                    OFREE (valuecopy);
                    MAP_NOMEM;
                    return NULL;
                }
            }

            self->m_nentries++;
            SET_ERRNO(E_KEYNOTFOUND);
        }
    }

    return0_if_null_pp  (lauf,  self);
    return0_if_null_ppp (*lauf, self, lauf);

    return ERWIN_SUPERFLUOUS_CAST (char const * const *, &(*lauf)->value);
}


/*
 * Internal function: insert an element into the hash table
 * without copying the key or value, never doing a rehash and not
 * updating the profile insert counter.
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.insert_no_copy_no_rehash_q")
int err_map_symbol_string_insert_no_copy_no_rehash_q
        (
        err_map_symbol_string_t* self,
        err_symbol_t keycopy,
        char * valuecopy)
/* USE CAREFULLY!! PURELY INTERNAL!! */
/* NOTE: This cannot be implemented with _poke_internal, since it does not
 *       delete keycopy or valuecopy! */
{
    err_map_symbol_string_hashlist_t **lauf;

    E_SET_PTR(lauf, err_map_symbol_string_find_internal_ptr (self, keycopy));
    return_val_if_null_pp (lauf, ASSERTION_FAILED, self);

    if (*lauf != NULL)
        return PASS_ERRNO(E_EXISTINGKEY);

    E_SET_PTR(*lauf, err_map_symbol_string_hashlist_new_q (keycopy, valuecopy));

    if (ERWIN_UNLIKELY(*lauf == NULL)) {
        MAP_NOMEM;
        return e_errno;
    }

    self->m_nentries++;
    return PASS_ERRNO(E_OK);
}


/*
 * User space hash insertion function */
CODE_SECTION(".text.insert_q")
ATTR_FLATTEN
int err_map_symbol_string_insert_q
        (err_map_symbol_string_t* self, err_symbol_t  key, char const *  value)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return err_map_symbol_string_poke_internal_q (
                NULL, NULL, self,
                key,   IZEROVAR, ERR_ERWIN_TRUE,
                value, ZEROVAR(self), ERR_ERWIN_TRUE,
                ERR_ERWIN_TRUE, ERR_ERWIN_FALSE);
}


CODE_SECTION(".text.insert_map")
int err_map_symbol_string_insert_map
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int total_errno;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;

       E_SET_PTR(lauf, SLOT(other,i));
       while (lauf) {
           err_map_symbol_string_insert_q (self, lauf->key, lauf->value);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR(lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}

CODE_SECTION(".text.set_map")
int err_map_symbol_string_set_map
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int total_errno;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           err_map_symbol_string_set (self, lauf->key, lauf->value);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}


CODE_SECTION(".text.modify_map")
int err_map_symbol_string_modify_map
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int total_errno;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           err_map_symbol_string_modify (self, lauf->key, lauf->value);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}


CODE_SECTION(".text.erase_map")
int err_map_symbol_string_erase_map
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int total_errno;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
    if (self == NULL && other->m_nentries > 0)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           err_map_symbol_string_erase (self, lauf->key);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}

CODE_SECTION(".text.erase_map_no_resize")
int err_map_symbol_string_erase_map_no_resize
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int total_errno;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
    if (self == NULL && other->m_nentries > 0)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           err_map_symbol_string_erase_no_resize (self, lauf->key);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}

CODE_SECTION(".text.intersect_no_resize")
int err_map_symbol_string_intersect_no_resize
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int cnt;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return PASS_ERRNO(E_OK);
    if (other == NULL) {
        cnt= self->m_nentries;
        err_map_symbol_string_clear (self);
        return cnt;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    cnt= 0;
    for (i= 0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_t **lauf;
        E_SET_PTR (lauf, &SLOT(self,i));
        while (*lauf) {
            (void)err_map_symbol_string_find (other, (*lauf)->key);
            if (e_errno != E_OK) {
                 err_map_symbol_string_hashlist_t *cell;
                 E_SET_PTR (cell,  *lauf);
                 E_SET_PTR (*lauf, (*lauf)->next);

                 IFREE (cell->key);
                 OFREE (cell->value);
                 err_map_symbol_string_hashlist_delete_cell (cell);
                 self->m_nentries--;
                 cnt++;
            }
            else
                E_SET_PTR (lauf, &(*lauf)->next);
        }
    }

    SET_ERRNO(E_OK);
    return cnt;
}

CODE_SECTION(".text.intersect")
int err_map_symbol_string_intersect
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int cnt= err_map_symbol_string_intersect_no_resize (self, other);
    err_map_symbol_string_shrink_perhaps (self);
    return cnt;
}

/*
 * Ensure that an entry is contained in the table.
 * Do not use the implementation using poke since ENSURE_VALUE would be called
 * too often.  Additionally, the result would be copied too often.  Furthermore,
 * it cannot use insert_no_copy, since it needs the pointer to the list to be
 * able to return a pointer to that it err_symbol_t  has a `const &' appended.
 * Of course we could search again, but that's not fast.
 */
CODE_SECTION(".text.ensure")
i_type_result_t err_map_symbol_string_ensure
        (err_map_symbol_string_t *self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t **lauf;

    E_SET_PTR (lauf, err_map_symbol_string_find_internal_ptr (self, key));
    return_val_if_null_pp (lauf, IZERO, self);

    SET_ERRNO(E_EXISTINGKEY);

    if (*lauf == NULL) {
        int copyerror= ERR_ERWIN_FALSE;

        if (ERWIN_UNLIKELY(err_map_symbol_string_grow_perhaps (self))) {
            E_SET_PTR (lauf, err_map_symbol_string_find_internal_ptr (self, key));
            return_val_if_null_pp (lauf, IZERO, self);
            return_val_if_fail_pp (*lauf == NULL, IZERO, self);
        }

        {
            err_symbol_t keycopy;
            E_SET_KEY (keycopy, ICOPY (key, &copyerror));
            if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror)) {
                MAP_NOMEM;
                return IZERO;
            }

            {
                char * valuecopy;
                E_SET_VALUE (valuecopy, ERR_MAP_SYMBOL_STRING_ENSURE_VALUE(self, key, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror)) {
                    IFREE (keycopy);
                    MAP_NOMEM;
                    return IZERO;
                }

                E_SET_PTR (*lauf, err_map_symbol_string_hashlist_new_q (keycopy, valuecopy));
                if (ERWIN_UNLIKELY(*lauf == NULL)) {
                    IFREE (keycopy);
                    OFREE (valuecopy);
                    MAP_NOMEM;
                    return IZERO;
                }
            }
        }

        self->m_nentries++;
        SET_ERRNO(E_OK);
        /* NOTE: we *must* return the value directly from the map because char const * 
         *       might be a reference. */
    }

    return (*lauf)->key;
}


/*
 * Ensure that an entry is contained in the table.
 * Do not use the implementation using poke since ENSURE_VALUE would be called
 * too often.  Additionally, the result would be copied too often.  Furthermore,
 * it cannot use insert_no_copy, since it needs the pointer to the list to be
 * able to return a pointer to that it err_symbol_t  has a `const &' appended.
 * Of course we could search again, but that's not fast.
 */
CODE_SECTION(".text.ensure_no_icopy")
i_type_result_t err_map_symbol_string_ensure_no_icopy
        (err_map_symbol_string_t *self, err_symbol_t  key)
{
    err_map_symbol_string_hashlist_t **lauf;

    E_SET_PTR (lauf, err_map_symbol_string_find_internal_ptr (self, key));
    return_val_if_null_pp (lauf, IZERO, self);

    SET_ERRNO(E_EXISTINGKEY);

    if (*lauf == NULL) {
        if (ERWIN_UNLIKELY(err_map_symbol_string_grow_perhaps (self))) {
            E_SET_PTR (lauf, err_map_symbol_string_find_internal_ptr (self, key));
            return_val_if_null_pp (lauf, IZERO, self);
            return_val_if_fail_pp (*lauf == NULL, IZERO, self);
        }

        {
            int copyerror= ERR_ERWIN_FALSE;
            char * valuecopy;
            E_SET_VALUE (valuecopy, ERR_MAP_SYMBOL_STRING_ENSURE_VALUE(self, key, &copyerror));
            if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror)) {
                MAP_NOMEM;
                return IZERO;
            }

            E_SET_PTR (*lauf, err_map_symbol_string_hashlist_new_q (key, valuecopy));
            if (ERWIN_UNLIKELY(*lauf == NULL)) {
                OFREE (valuecopy);
                MAP_NOMEM;
                return IZERO;
            }
        }

        self->m_nentries++;
        SET_ERRNO(E_OK);
        /* NOTE: we *must* return the value directly from the map because char const * 
         *       might be a reference. */
    }
    else {
        IFREE (key);
    }

    return (*lauf)->key;
}


/*
 * Remove an element and return the old one.  Avoid returning char const * (ZERO(self)) to
 * char * here. */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.remove_internal_no_resize_q")
ERR_ERWIN_BOOL err_map_symbol_string_remove_internal_no_resize_q
        (
    err_map_symbol_string_t *self,
    err_symbol_t  key,
    char * *result)
{
    err_map_symbol_string_hashlist_t **lauf;
    err_map_symbol_string_hashlist_t *cell;

#ifdef E_PROFILE
    self->m_ndelete++;
#endif

    return0_if_null (self);
    return0_if_null_pp (result, self);

    /* Now, try to find the entry */
    E_SET_PTR (lauf, err_map_symbol_string_find_internal_ptr (self, key));
    return0_if_null_pp (lauf, self);

    E_SET_PTR (cell, *lauf);
    if (cell == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ERR_ERWIN_FALSE;
    }

    /* Unlink list cell */
    E_SET_PTR (*lauf, (*lauf)->next);

    /* Rrturn value to caller */
    E_SET_VALUE (*result, cell->value);

    /* Delete key and cell */
    IFREE (cell->key);
    err_map_symbol_string_hashlist_delete_cell (cell);

    /* Decrement number of elements */
    self->m_nentries--;

    /* Return the result */
    SET_ERRNO(E_OK);
    return ERR_ERWIN_TRUE;
}

/*
 * Remove an element and return the old one.  Avoid returning char const * (ZERO(self)) to
 * char * here. */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.remove_internal_q")
ERR_ERWIN_BOOL err_map_symbol_string_remove_internal_q
        (
    err_map_symbol_string_t *self,
    err_symbol_t  key,
    char * *result)
{
#ifdef E_PROFILE
    self->m_ndelete++;
#endif

    return0_if_null (self);
    /* Possibly shrink.  Do it before we get a pointer to the list entry.  Otherwise,
     * we would have to search again. */
    err_map_symbol_string_shrink_perhaps (self);

    return err_map_symbol_string_remove_internal_no_resize_q (self, key, result);
}

CODE_SECTION(".text.remove")
o_type_var_t err_map_symbol_string_remove
        (err_map_symbol_string_t *self, err_symbol_t  key)
{
    char * result;
#if defined(ERR_MAP_SYMBOL_STRING_ALLOW_NULL) && ERR_MAP_SYMBOL_STRING_CONSTANT_ZERO
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ZEROVAR(self);
    }
#endif
    if (err_map_symbol_string_remove_internal_q (self, key, &result))
        return result;
    return ZEROVAR(self);
}


CODE_SECTION(".text.remove_no_resize")
o_type_var_t err_map_symbol_string_remove_no_resize
        (err_map_symbol_string_t *self, err_symbol_t  key)
{
    char * result;
#if defined(ERR_MAP_SYMBOL_STRING_ALLOW_NULL) && ERR_MAP_SYMBOL_STRING_CONSTANT_ZERO
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ZEROVAR(self);
    }
#endif
    if (err_map_symbol_string_remove_internal_no_resize_q (self, key, &result))
        return result;
    return ZEROVAR(self);
}


CODE_SECTION(".text.remove_map")
int err_map_symbol_string_remove_map
        (err_map_symbol_string_t* self, err_map_symbol_string_t const *other)
{
    int i;
    int total_errno;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (other == NULL)
        return PASS_ERRNO(E_OK);
    if (self == NULL && other->m_nentries > 0)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           err_map_symbol_string_remove (self, lauf->key);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}


/*
 * Remove some entries according to a given predicate */
CODE_SECTION(".text.remove_if")
int err_map_symbol_string_remove_if
        (err_map_symbol_string_t *self, err_map_symbol_string_feature_t feature, ERR_ERWIN_BOOL value)
{
    int slot;
    int cnt= 0;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#else
    return0_if_null (self);
#endif
    return0_if_bad_table (self);
    return0_if_null_pp (feature, self);

    for (slot=0; slot < self->m_hashsize; slot++) {
        err_map_symbol_string_hashlist_t **lauf;
        E_SET_PTR (lauf, &SLOT(self,slot));
        while (*lauf) {
           if (ERR_ERWIN_TO_BOOL (feature ((*lauf)->key, (*lauf)->value) == value)) {
                err_map_symbol_string_hashlist_t *cell;
                E_SET_PTR (cell,  *lauf);
                E_SET_PTR (*lauf, (*lauf)->next);

                IFREE (cell->key);
                err_map_symbol_string_hashlist_delete_cell (cell);
                self->m_nentries--;
                cnt++;
            }
            else
                E_SET_PTR (lauf, &(*lauf)->next);
        }
    }

    err_map_symbol_string_shrink_perhaps (self);
    SET_ERRNO(E_OK);
    return cnt;
}


/*
 * Erase an entry (remove it and free value). */
CODE_SECTION(".text.erase")
int err_map_symbol_string_erase
        (err_map_symbol_string_t *self, err_symbol_t  key)
{
    char * result;
#if defined(ERR_MAP_SYMBOL_STRING_ALLOW_NULL) && ERR_MAP_SYMBOL_STRING_CONSTANT_ZERO
    if (self == NULL)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif
    if (err_map_symbol_string_remove_internal_q (self, key, &result)) {
        OFREE (result);
    }
    return e_errno;
}

/*
 * Erase an entry (remove it and free value). */
CODE_SECTION(".text.erase_no_resize")
int err_map_symbol_string_erase_no_resize
        (err_map_symbol_string_t *self, err_symbol_t  key)
{
    char * result;
#if defined(ERR_MAP_SYMBOL_STRING_ALLOW_NULL) && ERR_MAP_SYMBOL_STRING_CONSTANT_ZERO
    if (self == NULL)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif
    if (err_map_symbol_string_remove_internal_no_resize_q (self, key, &result)) {
        OFREE (result);
    }
    return e_errno;
}


/*
 * Erase some entries according to a given predicate */
CODE_SECTION(".text.erase_if")
int err_map_symbol_string_erase_if
        (err_map_symbol_string_t *self, err_map_symbol_string_feature_t feature, ERR_ERWIN_BOOL value)
{
    int slot;
    int cnt= 0;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#else
    return0_if_null (self);
#endif
    return0_if_bad_table (self);
    return0_if_null_pp (feature, self);

    for (slot=0; slot < self->m_hashsize; slot++) {
        err_map_symbol_string_hashlist_t **lauf;
        E_SET_PTR (lauf, &SLOT(self,slot));
        while (*lauf) {
           if (ERR_ERWIN_TO_BOOL (feature_q ((*lauf)->key, (*lauf)->value) == value)) {
                err_map_symbol_string_hashlist_t *cell;
                E_SET_PTR (cell,  *lauf);
                E_SET_PTR (*lauf, (*lauf)->next);

                IFREE (cell->key);
                OFREE (cell->value);
                err_map_symbol_string_hashlist_delete_cell (cell);
                self->m_nentries--;
                cnt++;
            }
            else
                E_SET_PTR (lauf, &(*lauf)->next);
        }
    }

    err_map_symbol_string_shrink_perhaps (self);
    SET_ERRNO(E_OK);
    return cnt;
}


/*
 * Rehash the hash table to a different size */
CODE_SECTION(".text.rehash")
void err_map_symbol_string_rehash
        (err_map_symbol_string_t* self, int newsize)
{
    return_if_null2i_or_bad (self);

#ifdef E_PROFILE
    self->m_nrehash+= self->m_nentries;
    self->m_nrehashops++;
#endif

    if (newsize <= 0)
        newsize= 1;
                                                     
    if (newsize != self->m_hashsize) {
        int i;
        err_map_symbol_string_content_p newtable;

#if ERR_MAP_SYMBOL_STRING_ZERO_SIZE
        if (newsize == 1) {
            E_SET_PTR (newtable, NULL);
        }
        else {
            E_SET_PTR (newtable, ERR_ERWIN_THING_CNEW_ARRAY (err_map_symbol_string_content, (unsigned)newsize));
            if (ERWIN_UNLIKELY(newtable == NULL)) {
                MAP_NOMEM_R;
                return;
            }
        }
#else
        E_SET_PTR (newtable, ERR_ERWIN_THING_CNEW_ARRAY (err_map_symbol_string_content, (unsigned)newsize));
        if (ERWIN_UNLIKELY(newtable == NULL)) {
            MAP_NOMEM_R;
            return;
        }
#endif


        /* Copy elements: */
        for (i=0; i < self->m_hashsize; i++) {
            err_map_symbol_string_hashlist_t *lauf;
            E_SET_PTR (lauf, SLOT(self,i));
            while (lauf != NULL) {
                err_map_symbol_string_hashlist_t *next;
                err_map_symbol_string_hashlist_t **newcell= &GET_SLOT(
                                      newtable,
                                      newsize,
                                      e_hash_into (IHASH (lauf->key), newsize));

                E_SET_PTR (next,       lauf->next);
                E_SET_PTR (lauf->next, *newcell);
                E_SET_PTR (*newcell,   lauf);
                E_SET_PTR (lauf,       next);
            }
        }

        /* Free own table: */
        FREE_TABLE(self);

        /* Use new table: */
        E_SET_PTR (self->m_table, newtable);
            /* This is even correct if newtable is not a slot table, but the
             * root of the only list (in case of ZERO_SIZE) */
        self->m_hashsize= newsize;
    }

    SET_ERRNO(E_OK);
}


/*
 * Internal function used for iterating over the hash table.
 */
static
CODE_SECTION(".text.first_internal")
err_map_symbol_string_hashlist_t * err_map_symbol_string_first_internal
        (err_map_symbol_string_t const *self, e_iterator_t *iter)
{
    if (self->m_nentries <= 0) {
        SET_ERRNO(E_EMPTY);
        return NULL;
    }

    ITER->cslot=0;
    while (SLOT(self,ITER->cslot) == NULL) {
        ITER->cslot++;
        return_val_if_fail_ppii (ITER->cslot < self->m_hashsize, NULL,
            self, ITER->cslot, self->m_hashsize);
           /* We MUST find an element here, because there are more than 0 elements. */
    }

    E_SET_PTR (ITER->cnode, SLOT(self,ITER->cslot));
    return ITER->cnode;
}


/*
 * Internal function used for iterating over the hash table.
 */
static
CODE_SECTION(".text.next_internal")
err_map_symbol_string_hashlist_t * err_map_symbol_string_next_internal
        (err_map_symbol_string_t const*self, e_iterator_t *iter)
{
    if (ERWIN_UNLIKELY(ITER->cslot == -1))
        return err_map_symbol_string_first_internal (self, iter);

    if (ERWIN_UNLIKELY(
           ITER->cslot < 0 || ITER->cslot >= self->m_hashsize || ITER->cnode == NULL))
    {
        SET_ERRNO(E_NOMOREELEMS);
        return NULL;
    }

    /* get next element in hashtable */
    E_SET_PTR (ITER->cnode, ITER->cnode->next);
    if (ITER->cnode != NULL) return ITER->cnode; /*!*/

    do {
        ITER->cslot++;
    } while (ITER->cslot < self->m_hashsize && SLOT(self,ITER->cslot) == NULL);

    /* did we find a next element? */
    if (ERWIN_UNLIKELY(ITER->cslot >= self->m_hashsize)) {
        SET_ERRNO(E_NOMOREELEMS);
        return NULL; /*!*/
    }
    else {
        E_SET_PTR (ITER->cnode, SLOT(self,ITER->cslot));
        return ITER->cnode; /*!*/
    }
}

/*
 * Initialisation of iterating over a hash table
 */
CODE_SECTION(".text.init_iterator")
void err_map_symbol_string_init_iterator
        (err_map_symbol_string_t const *self, e_iterator_t *iter)
{
    (void)self; /*unused*/

#ifndef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    return_if_null_or_bad (self);
#endif

    return_if_null_pp (iter, self);

    ITER->cslot= -1;
}


/*
 * I am sorry for the next functions. They are ugly. */
static
CODE_SECTION(".text.pair_cmp_keys")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_keys
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef ICMP
#define err_map_symbol_string_check_cmp_keys
#define err_map_symbol_string_check0_cmp_keys
    return ICMP ((((err_map_symbol_string_pair_t*)a)->key),(((err_map_symbol_string_pair_t*)b)->key));
#else
#define err_map_symbol_string_check_cmp_keys \
    return_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
#define err_map_symbol_string_check0_cmp_keys \
    return0_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.wrap_icmp")
ATTR_FUNC_UNUSED
int err_map_symbol_string_wrap_icmp
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef ICMP
#define err_map_symbol_string_check_cmp_keys
#define err_map_symbol_string_check0_cmp_keys
    return ICMP ((*((err_symbol_t *)a)),(*((err_symbol_t *)b)));
#else
#define err_map_symbol_string_check_cmp_keys \
    return_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
#define err_map_symbol_string_check0_cmp_keys \
    return0_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_keys_ptr")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_keys_ptr
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef ICMP
#define err_map_symbol_string_check_cmp_keys_ptr
#define err_map_symbol_string_check0_cmp_keys_ptr
    return ICMP ((((err_map_symbol_string_pair_ptr_t*)a)->key),(((err_map_symbol_string_pair_ptr_t*)b)->key));
#else
#define err_map_symbol_string_check_cmp_keys_ptr \
    return_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
#define err_map_symbol_string_check0_cmp_keys_ptr \
    return0_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_values")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_values
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef OCMP
#define err_map_symbol_string_check_cmp_values
#define err_map_symbol_string_check0_cmp_values
    return OCMP ((((err_map_symbol_string_pair_t*)a)->value),(((err_map_symbol_string_pair_t*)b)->value));
#else
#define err_map_symbol_string_check_cmp_values \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
#define err_map_symbol_string_check0_cmp_values \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_values_ptr")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_values_ptr
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef OCMP
#define err_map_symbol_string_check_cmp_values_ptr
#define err_map_symbol_string_check0_cmp_values_ptr
    return OCMP ((*(((err_map_symbol_string_pair_ptr_t*)a)->value)),(*(((err_map_symbol_string_pair_ptr_t*)b)->value)));
#else
#define err_map_symbol_string_check_cmp_values_ptr \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
#define err_map_symbol_string_check0_cmp_values_ptr \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_values_and_keys")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_values_and_keys
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define err_map_symbol_string_check_cmp_values_and_keys
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= OCMP ((((err_map_symbol_string_pair_t*)a)->value),(((err_map_symbol_string_pair_t*)b)->value));
    if (result == 0)
        result= ICMP ((((err_map_symbol_string_pair_t*)a)->key),(((err_map_symbol_string_pair_t*)b)->key));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define err_map_symbol_string_check_cmp_values_and_keys \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


static
CODE_SECTION(".text.pair_cmp_values_and_keys_ptr")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_values_and_keys_ptr
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define err_map_symbol_string_check_cmp_values_and_keys_ptr
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= OCMP ((*(((err_map_symbol_string_pair_ptr_t*)a)->value)),(*(((err_map_symbol_string_pair_ptr_t*)b)->value)));
    if (result == 0)
        result= ICMP ((((err_map_symbol_string_pair_ptr_t*)a)->key),(((err_map_symbol_string_pair_ptr_t*)b)->key));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define err_map_symbol_string_check_cmp_values_and_keys_ptr \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


static
CODE_SECTION(".text.pair_cmp_keys_and_values")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_keys_and_values
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define err_map_symbol_string_check_cmp_keys_and_values
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= ICMP ((((err_map_symbol_string_pair_t*)a)->key),(((err_map_symbol_string_pair_t*)b)->key));
    if (result == 0)
        result= OCMP ((((err_map_symbol_string_pair_t*)a)->value),(((err_map_symbol_string_pair_t*)b)->value));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define err_map_symbol_string_check_cmp_keys_and_values \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


static
CODE_SECTION(".text.pair_cmp_keys_and_values_ptr")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_cmp_keys_and_values_ptr
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define err_map_symbol_string_check_cmp_keys_and_values_ptr
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= ICMP ((((err_map_symbol_string_pair_ptr_t*)a)->key),(((err_map_symbol_string_pair_ptr_t*)b)->key));
    if (result == 0)
        result= OCMP ((*(((err_map_symbol_string_pair_ptr_t*)a)->value)),(*(((err_map_symbol_string_pair_ptr_t*)b)->value)));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define err_map_symbol_string_check_cmp_keys_and_values_ptr \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)

static
CODE_SECTION(".text.pair_detcmp_keys")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_detcmp_keys
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= IDETCMP ((*((err_symbol_t const*)a)), (*((err_symbol_t const*)b)));
#if defined(ICMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= ICMP ((*((err_symbol_t const*)a)), (*((err_symbol_t const*)b)));
#endif
    return result;
}

#if !IDETCMP_PROVIDED && !IEQUAL_PROVIDED
#  define err_map_symbol_string_detcmp_pairs     err_map_symbol_string_pair_cmp_keys
#  define err_map_symbol_string_detcmp_pairs_ptr err_map_symbol_string_pair_cmp_keys_ptr
#else
#  define ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED 1
#endif

#ifndef ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
#  define ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED 0
#endif

#if ODETCMP_PROVIDED || ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
#  define ERR_MAP_SYMBOL_STRING_ODET_REQUIRE 1
#endif

#ifndef ERR_MAP_SYMBOL_STRING_ODET_REQUIRE
#  define ERR_MAP_SYMBOL_STRING_ODET_REQUIRE 0
#endif


static
CODE_SECTION(".text.pair_detcmp_values")
ATTR_FUNC_UNUSED
int err_map_symbol_string_pair_detcmp_values
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
    result= ODETCMP (*((char const * const*)a), *((char const * const*)b));
#if defined(OCMP) && ODETCMP_PROVIDED
    if (result == 0)
        result= OCMP (*((char const * const*)a), *((char const * const*)b));
#endif
#elif defined(OCMP)
    result= OCMP (*((char const * const*)a), *((char const * const*)b));
#else
#define err_map_symbol_string_check_detcmp_values \
    return0_if_reached_pt ("Need ERR_CHAR_CONST_P_DETCMP or ERR_CHAR_CONST_P_CMP to enforce determinism on err_map_symbol_string.  Try to '#define ERR_CHAR_CONST_P_DETCMP(x,y) false_if_reached_pk(ERR_ERR_SYMBOL_T_DETCMP)' if you think you never invoke it.");
    result=0;
#endif

#ifndef err_map_symbol_string_check_detcmp_values
#define err_map_symbol_string_check_detcmp_values
#endif /* !defined err_map_symbol_string_check_detcmp_values */

    return result;
}


#if ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED

static
CODE_SECTION(".text.detcmp_pairs")
ATTR_FUNC_UNUSED
int err_map_symbol_string_detcmp_pairs
        (void const *a, void const *b)
{
    /* This uses paranoid paranoid, perhaps duplicate comparisons.  But the user
     * wants determinism and we try to enforce that in any way.  It may be slower,
     * but that does not hurt here.
     */
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= IDETCMP ((((err_map_symbol_string_pair_t*)a)->key),(((err_map_symbol_string_pair_t*)b)->key));

    if (result == 0)
        result= ODETCMP ((((err_map_symbol_string_pair_t*)a)->value),(((err_map_symbol_string_pair_t*)b)->value));

#if defined(ICMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= ICMP ((((err_map_symbol_string_pair_t*)a)->key),(((err_map_symbol_string_pair_t*)b)->key));
#endif

#if defined(OCMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= OCMP ((((err_map_symbol_string_pair_t*)a)->value),(((err_map_symbol_string_pair_t*)b)->value));
#endif

    return result;
}


static
CODE_SECTION(".text.detcmp_pairs_ptr")
ATTR_FUNC_UNUSED
int err_map_symbol_string_detcmp_pairs_ptr
        (void const *a, void const *b)
{
    /* This uses paranoid paranoid, perhaps duplicate comparisons.  But the user
     * wants determinism and we try to enforce that in any way.  It may be slower,
     * but that does not hurt here.
     */
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= IDETCMP ((((err_map_symbol_string_pair_ptr_t*)a)->key),(((err_map_symbol_string_pair_ptr_t*)b)->key));

    if (result == 0)
        result= ODETCMP ((*(((err_map_symbol_string_pair_ptr_t*)a)->value)),(*(((err_map_symbol_string_pair_ptr_t*)b)->value)));

#if defined(ICMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= ICMP ((((err_map_symbol_string_pair_ptr_t*)a)->key),(((err_map_symbol_string_pair_ptr_t*)b)->key));
#endif

#if defined(OCMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= OCMP ((*(((err_map_symbol_string_pair_ptr_t*)a)->value)),(*(((err_map_symbol_string_pair_ptr_t*)b)->value)));
#endif

    return result;
}

#endif /* ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED */

#endif /* defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM) */


#ifdef __cplusplus
#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)

ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.det_sort")
void err_map_symbol_string_det_sort
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    qsort ((void*)SORTITER->table,
           self->m_nentries,
           sizeof (err_map_symbol_string_pair_t),
           err_map_symbol_string_detcmp_pairs);
}


ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.det_sort_ptr")
void err_map_symbol_string_det_sort_ptr
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    qsort ((void*)SORTITERPTR->table,
           self->m_nentries,
           sizeof (err_map_symbol_string_pair_ptr_t),
           err_map_symbol_string_detcmp_pairs_ptr);
}


#endif /* defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM) */

/* In case REQUIRE_DETERMINISM is not set, we must define defaults. */
#ifndef ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
#  define ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED 0
#endif

#ifndef ERR_MAP_SYMBOL_STRING_ODET_REQUIRE
#  define ERR_MAP_SYMBOL_STRING_ODET_REQUIRE 0
#endif


static
CODE_SECTION(".text.free_sorted_iterator")
void err_map_symbol_string_free_sorted_iterator
        (void *iter)
{
    err_map_symbol_string_delete_entries (SORTITER->table);
}


static
CODE_SECTION(".text.free_sorted_iterator_ptr")
void err_map_symbol_string_free_sorted_iterator_ptr
        (void *iter)
{
    err_map_symbol_string_delete_entries_ptr (SORTITERPTR->table);
}


CODE_SECTION(".text.init_iterator_sorted_by_key")
void err_map_symbol_string_init_iterator_sorted_by_key
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
        return;
    }
#else
    return_if_null_or_bad (self);
#endif
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_keys;

    E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
    return_if_null_pp (SORTITER_VOLATILE->p, self);
        /* Need volatile here because of strict aliasing rules.  Change
         * to iter->p would otherwise not necessarily take effect. */
    return_if_fail_pp ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator, self);

#if ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
    /* If the sort orders _DETCMP and _CMP are the same, and if _CMP and _EQUAL
     * agree about equality, comparison on the keys with _CMP yields deterministic
     * sort orders since keys are unique.  If they are  not the same, _DETCMP might
     * not think that two keys are equal even if they are equal by _CMP.  So then,
     * we still need to pre-sort and use (the stable) merge sort.  */
    if (e_require_determinism ()) {
        err_map_symbol_string_det_sort (self, iter);
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_keys);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_keys);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_value")
void err_map_symbol_string_init_iterator_sorted_by_value
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_values;

    E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        err_map_symbol_string_det_sort (self, iter);
#endif
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_values);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_values);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_value_and_key")
void err_map_symbol_string_init_iterator_sorted_by_value_and_key
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_values_and_keys;

    E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator,
        SORTITER, self);

#if ERR_MAP_SYMBOL_STRING_ODET_REQUIRE
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        err_map_symbol_string_det_sort (self, iter);
#endif
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_values_and_keys);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_values_and_keys);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_key_and_value")
void err_map_symbol_string_init_iterator_sorted_by_key_and_value
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_keys_and_values;

    E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator,
        SORTITER, self);

#if ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
        err_map_symbol_string_det_sort (self, iter);
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_keys_and_values);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               err_map_symbol_string_pair_cmp_keys_and_values);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_user")
void err_map_symbol_string_init_iterator_sorted_by_user
        (
    err_map_symbol_string_t const *self,
    e_iterator_sorted_t *iter,
    err_map_symbol_string_pair_cmp_t u)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);

    E_SET_PTR (SORTITER->table, err_map_symbol_string_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, err_map_symbol_string_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        err_map_symbol_string_det_sort (self, iter);
#endif
        if (u != NULL)
            e_merge_sort ((void*)SORTITER->table,
                   self->m_nentries,
                   sizeof (err_map_symbol_string_pair_t),
                   (int(*)(void const*,void const*))u);
    }
    else
#endif
    {
        if (u != NULL)
            qsort ((void*)SORTITER->table,
                   self->m_nentries,
                   sizeof (err_map_symbol_string_pair_t),
                   (int(*)(void const*,void const*))u);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key")
void err_map_symbol_string_init_iterator_ptr_sorted_by_key
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_keys_ptr;

    E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator_ptr,
        SORTITER, self);

#if ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
    /* If the sort orders _DETCMP and _CMP are the same, and if _CMP and _EQUAL
     * agree about equality, comparison on the keys with _CMP yields deterministic
     * sort orders since keys are unique.  If they are  not the same, _DETCMP might
     * not think that two keys are equal even if they are equal by _CMP.  So then,
     * we still need to pre-sort and use (the stable) merge sort.  */
    if (e_require_determinism ()) {
        err_map_symbol_string_det_sort_ptr (self, iter);
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_keys_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_keys_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value")
void err_map_symbol_string_init_iterator_ptr_sorted_by_value
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_values_ptr;

    E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator_ptr,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        err_map_symbol_string_det_sort_ptr (self, iter);
#endif
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_values_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_values_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value_and_key")
void err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_values_and_keys_ptr;

    E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator_ptr,
        SORTITER, self);

#if ERR_MAP_SYMBOL_STRING_ODET_REQUIRE
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        err_map_symbol_string_det_sort_ptr (self, iter);
#endif
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_values_and_keys_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_values_and_keys_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key_and_value")
void err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    err_map_symbol_string_check_cmp_keys_and_values_ptr;

    E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator_ptr,
        SORTITER, self);

#if ERR_MAP_SYMBOL_STRING_DET_SORT_PROVIDED
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
        err_map_symbol_string_det_sort_ptr (self, iter);
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_keys_and_values_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               err_map_symbol_string_pair_cmp_keys_and_values_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_user")
void err_map_symbol_string_init_iterator_ptr_sorted_by_user
        (
    err_map_symbol_string_t const *self,
    e_iterator_sorted_t *iter,
    err_map_symbol_string_pair_ptr_cmp_t u)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);

    E_SET_PTR (SORTITERPTR->table, err_map_symbol_string_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, err_map_symbol_string_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)err_map_symbol_string_free_sorted_iterator_ptr,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        err_map_symbol_string_det_sort_ptr (self, iter);
#endif
        if (u != NULL)
            e_merge_sort ((void*)SORTITERPTR->table,
                   self->m_nentries,
                   sizeof (err_map_symbol_string_pair_ptr_t),
                   (int(*)(void const*,void const*))u);
    }
    else
#endif
    {
        if (u != NULL)
            qsort ((void*)SORTITERPTR->table,
                   self->m_nentries,
                   sizeof (err_map_symbol_string_pair_ptr_t),
                   (int(*)(void const*,void const*))u);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_key_reverse")
void err_map_symbol_string_init_iterator_sorted_by_key_reverse
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_sorted_by_key (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_value_reverse")
void err_map_symbol_string_init_iterator_sorted_by_value_reverse
        (err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_sorted_by_value (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_value_and_key_reverse")
void err_map_symbol_string_init_iterator_sorted_by_value_and_key_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_sorted_by_value_and_key (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_key_and_value_reverse")
void err_map_symbol_string_init_iterator_sorted_by_key_and_value_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_sorted_by_key_and_value (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_user_reverse")
void err_map_symbol_string_init_iterator_sorted_by_user_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_pair_cmp_t u)
{
    err_map_symbol_string_init_iterator_sorted_by_user (self, iter, u);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key_reverse")
void err_map_symbol_string_init_iterator_ptr_sorted_by_key_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_ptr_sorted_by_key (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value_reverse")
void err_map_symbol_string_init_iterator_ptr_sorted_by_value_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_ptr_sorted_by_value (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value_and_key_reverse")
void err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_ptr_sorted_by_value_and_key (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key_and_value_reverse")
void err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter)
{
    err_map_symbol_string_init_iterator_ptr_sorted_by_key_and_value (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_user_reverse")
void err_map_symbol_string_init_iterator_ptr_sorted_by_user_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_pair_ptr_cmp_t u)
{
    err_map_symbol_string_init_iterator_ptr_sorted_by_user (self, iter, u);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.next_iteration_sorted")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted
        (err_map_symbol_string_t const *self,
                                e_iterator_sorted_t *iter,
                                err_symbol_t *keyp,
                                char const * *valuep)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null2_pp3 (keyp, valuep, self, keyp, valuep);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERR_ERWIN_FALSE;

    E_SET_KEY   (*keyp,   SORTITER->table[SORTITER->lauf].key);
    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    SORTITER->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_ptr")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_ptr
        (err_map_symbol_string_t const *self,
                                e_iterator_sorted_t *iter,
                                err_symbol_t *keyp,
                                err_map_symbol_string_element_ptr_t *valuepp)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null2_pp3 (keyp, valuepp, self, keyp, valuepp);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf >= SORTITERPTR->count))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (*keyp,    SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    SORTITERPTR->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_keys")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_keys
        (err_map_symbol_string_t const *self,
                                e_iterator_sorted_t *iter,
                                err_symbol_t *keyp)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp2  (keyp, self, keyp);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (*keyp, SORTITER->table[SORTITER->lauf].key);
    SORTITER->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values
        (err_map_symbol_string_t const *self,
                                e_iterator_sorted_t *iter,
                                char const * *valuep)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp2  (valuep, self, valuep);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERR_ERWIN_FALSE;

    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    SORTITER->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values_ptr")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values_ptr
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_element_ptr_t *valuepp)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp2  (valuepp, self, valuepp);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf >= SORTITERPTR->count))
        return ERR_ERWIN_FALSE;

    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    SORTITERPTR->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs
        (err_map_symbol_string_t const *self,
                                e_iterator_sorted_t *iter,
                                err_map_symbol_string_pair_t *p)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp2  (p, self, p);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (p->key,   SORTITER->table[SORTITER->lauf].key);
    E_SET_KEY (p->value, SORTITER->table[SORTITER->lauf].value);
    SORTITER->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs_ptr")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs_ptr
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_pair_ptr_t *p)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp2  (p, self, p);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf >= SORTITERPTR->count))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (p->key,   SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (p->value, SORTITERPTR->table[SORTITERPTR->lauf].value);
    SORTITERPTR->lauf++;
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_symbol_t *keyp, char const * *valuep)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null2_pp3 (keyp, valuep, self, keyp, valuep);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_KEY   (*keyp,   SORTITER->table[SORTITER->lauf].key);
    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_ptr_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_ptr_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_symbol_t *keyp, err_map_symbol_string_element_ptr_t *valuepp)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null2_pp3 (keyp, valuepp, self, keyp, valuepp);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITERPTR->lauf--;

    E_SET_KEY (*keyp,    SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_keys_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_keys_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_symbol_t *keyp)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp   (keyp, self);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_KEY (*keyp, SORTITER->table[SORTITER->lauf].key);
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, char const * *valuep)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp   (valuep, self);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values_ptr_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_values_ptr_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_element_ptr_t *valuepp)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp   (valuepp, iter);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITERPTR->lauf--;

    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_pair_t *p)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp   (p, self);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_KEY   (p->key,   SORTITER->table[SORTITER->lauf].key);
    E_SET_VALUE (p->value, SORTITER->table[SORTITER->lauf].value);
    return ERR_ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs_ptr_reverse")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_sorted_pairs_ptr_reverse
        (
    err_map_symbol_string_t const *self, e_iterator_sorted_t *iter, err_map_symbol_string_pair_ptr_t *p)
{
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp   (p, self);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf <= 0))
        return ERR_ERWIN_FALSE;
    SORTITERPTR->lauf--;

    E_SET_KEY (p->key,   SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (p->value, SORTITERPTR->table[SORTITERPTR->lauf].value);
    return ERR_ERWIN_TRUE;
}

#endif /* defined(__cplusplus) */


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration
        (
    err_map_symbol_string_t const*self,
    e_iterator_t *iter,
    err_symbol_t *keyp,
    char const * *valuep)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif

    return0_if_null4_pp4 (self, iter, keyp, valuep, self, iter, keyp, valuep);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_KEY   (*keyp,   it->key);
    E_SET_VALUE (*valuep, it->value);
    return ERR_ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_values")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_values
        (
    err_map_symbol_string_t const *self,
    e_iterator_t *iter,
    char const * *valuep)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_pp3 (self, iter, valuep, self, iter, valuep);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_VALUE (*valuep, it->value);
    return ERR_ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table
 */
CODE_SECTION(".text.next_iteration_keys")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_keys
        (err_map_symbol_string_t const *self, e_iterator_t *iter, err_symbol_t *keyp)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif

    return0_if_null2_pp2 (self, keyp, self, keyp);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (*keyp, it->key);
    return ERR_ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_pairs")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_pairs
        (err_map_symbol_string_t const *self, e_iterator_t *iter, err_map_symbol_string_pair_t *pairp)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif

    return0_if_null3_pp3 (self, iter, pairp, self, iter, pairp);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_KEY   (pairp->key,   it->key);
    E_SET_VALUE (pairp->value, it->value);
    return ERR_ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_ptr")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_ptr
        (
    err_map_symbol_string_t const*self,
    e_iterator_t *iter,
    err_symbol_t *keyp,
    err_map_symbol_string_element_ptr_t *valuepp)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif

    return0_if_null4_pp4 (self, iter, keyp, valuepp, self, iter, keyp, valuepp);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (*keyp,    it->key);
    E_SET_PTR (*valuepp, &it->value);
    return ERR_ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_values_ptr")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_values_ptr
        (
    err_map_symbol_string_t const *self,
    e_iterator_t *iter,
    err_map_symbol_string_element_ptr_t *valuepp)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif
    return0_if_null3_pp3 (self, iter, valuepp, self, iter, valuepp);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_PTR (*valuepp, &it->value);
    return ERR_ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_pairs_ptr")
ERR_ERWIN_BOOL err_map_symbol_string_next_iteration_pairs_ptr
        (err_map_symbol_string_t const *self, e_iterator_t *iter, err_map_symbol_string_pair_ptr_t *pairp)
{
    err_map_symbol_string_hashlist_t *it;
#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL)
        return ERR_ERWIN_FALSE;
#endif

    return0_if_null3_pp3 (self, iter, pairp, self, iter, pairp);

    E_SET_PTR (it, err_map_symbol_string_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERR_ERWIN_FALSE;

    E_SET_KEY (pairp->key,   it->key);
    E_SET_PTR (pairp->value, &it->value);
    return ERR_ERWIN_TRUE;
}


/* Get all pairs of keys and values in the hash table */
CODE_SECTION(".text.get_entries")
err_map_symbol_string_pair_t * err_map_symbol_string_get_entries
        (err_map_symbol_string_t const *self)
{
    struct _err_map_symbol_string_pair_t *result, *rlauf;
    int    i;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, PAIR_NEW_ARRAY (err_map_symbol_string_pair_dynarray, 1));
        if (ERWIN_UNLIKELY(result == NULL)) {
            MAP_NOMEM;
            return NULL;
        }

        /* 0-termination */
        E_SET_KEY   (result->key,   IZERO);
        E_SET_VALUE (result->value, ZERO(self));
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, PAIR_NEW_ARRAY (err_map_symbol_string_pair_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_KEY   (rlauf->key,   lauf->key);
            E_SET_VALUE (rlauf->value, lauf->value);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }

    /* 0-termination */
    E_SET_KEY   (rlauf->key,   IZERO);
    E_SET_VALUE (rlauf->value, ZERO(self));

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ())
        qsort (result,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_t),
               (int(*)(void const *, void const *))err_map_symbol_string_detcmp_pairs);
#endif

    SET_ERRNO(E_OK);
    return result;
}


/*
 * Get all pairs of keys and values in the hash table
 */
CODE_SECTION(".text.get_entries_ptr")
err_map_symbol_string_pair_ptr_t * err_map_symbol_string_get_entries_ptr
        (err_map_symbol_string_t const*self)
{
    struct _err_map_symbol_string_pair_ptr_t *result, *rlauf;
    int    i;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, ERR_ERWIN_THING_NEW_ARRAY (err_map_symbol_string_pair_ptr_dynarray, 1));
        if (result == NULL) {
            MAP_NOMEM;
            return NULL;
        }
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, ERR_ERWIN_THING_NEW_ARRAY (err_map_symbol_string_pair_ptr_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_KEY (rlauf->key,   lauf->key);
            E_SET_PTR (rlauf->value, &lauf->value);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }
    E_SET_KEY (rlauf->key,   IZERO);
    E_SET_PTR (rlauf->value, NULL);

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ())
        qsort (result,
               self->m_nentries,
               sizeof (err_map_symbol_string_pair_ptr_t),
               (int(*)(void const *, void const *))err_map_symbol_string_detcmp_pairs_ptr);
#endif

    SET_ERRNO(E_OK);
    return result;
}


/* Get all values in the hash table */
CODE_SECTION(".text.get_values")
o_type_t * err_map_symbol_string_get_values
        (err_map_symbol_string_t const *self)
{
    char const * *result;
    char const * *rlauf;
    int   i;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, VALUE_NEW_ARRAY (err_map_symbol_string_value_dynarray, 1));
        if (ERWIN_UNLIKELY(result == NULL)) {
            MAP_NOMEM;
            return NULL;
        }
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, VALUE_NEW_ARRAY (err_map_symbol_string_value_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_VALUE (*rlauf, lauf->value);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }
    E_SET_VALUE (*rlauf, ZERO(self));

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ()) {
        err_map_symbol_string_check_detcmp_values;
        qsort (result,
               self->m_nentries,
               sizeof (char const *),
               (int(*)(void const *, void const *))err_map_symbol_string_pair_detcmp_values);
    }
#endif

    SET_ERRNO(E_OK);
    return result;
}


/*
 * Get all keys in the hash table
 */
CODE_SECTION(".text.get_keys")
i_type_t * err_map_symbol_string_get_keys
        (err_map_symbol_string_t const *self)
{
    err_symbol_t *result;
    err_symbol_t *rlauf;
    int   i;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, KEY_NEW_ARRAY (err_map_symbol_string_key_dynarray, 1));
        if (ERWIN_UNLIKELY(result == NULL)) {
            MAP_NOMEM;
            return NULL;
        }
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, KEY_NEW_ARRAY (err_map_symbol_string_key_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        err_map_symbol_string_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_KEY (*rlauf, lauf->key);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }
    E_SET_KEY (*rlauf, IZERO);

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ())
        qsort (result,
               self->m_nentries,
               sizeof (err_symbol_t),
               (int(*)(void const *, void const *))err_map_symbol_string_pair_detcmp_keys);
#endif

    SET_ERRNO(E_OK);
    return result;
}

CODE_SECTION(".text.delete_entries")
void err_map_symbol_string_delete_entries
        (err_map_symbol_string_pair_t *entries)
{
    PAIR_DELETE_ARRAY (entries);
}

CODE_SECTION(".text.delete_entries_ptr")
void err_map_symbol_string_delete_entries_ptr
        (err_map_symbol_string_pair_ptr_t *entries_ptr)
{
    ERR_ERWIN_THING_DELETE_ARRAY (entries_ptr);
}


CODE_SECTION(".text.delete_values")
void err_map_symbol_string_delete_values
        (char const * *values)
{
    VALUE_DELETE_ARRAY (values);
}


CODE_SECTION(".text.delete_keys")
void err_map_symbol_string_delete_keys
        (err_symbol_t *keys)
{
    KEY_DELETE_ARRAY (keys);
}

/*
 * Are two maps equal?  This is a deep comparison */
CODE_SECTION(".text.equal")
ERR_ERWIN_BOOL err_map_symbol_string_equal
        (err_map_symbol_string_t const *self, err_map_symbol_string_t const *other)
{
#if defined(OEQUAL) || defined(OCMP)
    e_iterator_t iter;
    err_symbol_t key;
    char const * value;
#endif

    if (self == NULL || other == NULL) {
        SET_ERRNO(E_OK);
        return ERR_ERWIN_TO_BOOL (self == other);
    }

    return0_if_null2_pp2 (self, other, self, other);

    if (self->m_nentries != other->m_nentries) {
        SET_ERRNO(E_OK);
        return ERR_ERWIN_FALSE;
    }

#if defined(OEQUAL) || defined(OCMP)

    err_map_symbol_string_forall_nondet (self, iter, key, value)
    {
        char const * const *value_ptr;
        E_SET_PTR (value_ptr, err_map_symbol_string_find_ptr (other, key));
        if (value_ptr == NULL)
            return ERR_ERWIN_FALSE;

#ifdef OEQUAL
        if (!(OEQUAL ((*value_ptr), value)))
            return ERR_ERWIN_FALSE;
#else
        if ((OCMP((*value_ptr), value)) != 0)
            return ERR_ERWIN_FALSE;
#endif
    }


    /* -> same element count /\ none missing /\ values equal => hash table equal */
    SET_ERRNO(E_OK);
    return ERR_ERWIN_TRUE;
#else
    error_return0_if_reached_ppt (
        self,
        "Because neither ERR_CHAR_CONST_P_EQUAL nor ERR_CHAR_CONST_P_CMP was #defined, err_map_symbol_string_equal could not be implemented.");
#endif
}


CODE_SECTION(".text.find_any_pair_q")
int err_map_symbol_string_find_any_pair_q
        (err_map_symbol_string_key_result_t *key_p, err_map_symbol_string_element_ptr_t *value_p, err_map_symbol_string_t const* self)
{
    int i;

#ifdef ERR_MAP_SYMBOL_STRING_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (self, (ASSERTION_FAILED,0));

    if (self->m_nentries == 0) {
        SET_ERRNO(E_KEYNOTFOUND);
        return 0;
    }

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    { /* Find smallest entry. */
        int first= 1;
        err_symbol_t last; /* Not uninitialised.  Protected by 'first'. */
        for (i= 0; i < self->m_hashsize; i++) {
           err_map_symbol_string_hashlist_t *lauf;
           E_SET_PTR (lauf, SLOT(self,i));
           while (lauf) {
               if (first || err_map_symbol_string_pair_detcmp_keys (&lauf->key, &last) < 0) {
                   first= 0;
                   E_SET_KEY (last, lauf->key);
                   if (key_p) E_SET_KEY (*key_p, lauf->key);

                   if (value_p)
                       E_SET_PTR (*value_p, ERWIN_SUPERFLUOUS_CAST (char const * const *, &lauf->value));
               }
               E_SET_PTR (lauf, lauf->next);
           }
        }

        if (!first) {
            SET_ERRNO(E_OK);
            return self->m_nentries;
        }
    }
#else
    for (i= 0; i < self->m_hashsize; i++) {
       err_map_symbol_string_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(self,i));
       if (lauf) {
           if (key_p) E_SET_KEY (*key_p, lauf->key);

           if (value_p) E_SET_PTR (*value_p, ERWIN_SUPERFLUOUS_CAST (char const * const *, &lauf->value));
           SET_ERRNO(E_OK);
           return self->m_nentries;
       }
    }
#endif

    return0_if_reached_pp(self); /* map non-empty, but no entry found!? */
    SET_ERRNO(E_KEYNOTFOUND);
    return 0;
}


CODE_SECTION(".text.find_any_key")
i_type_result_t err_map_symbol_string_find_any_key
        (err_map_symbol_string_t const *self)
{
    err_symbol_t result;
    int n= err_map_symbol_string_find_any_pair_q (&result, NULL, self);
    if (ERWIN_UNLIKELY(n == 0))
        return IZEROVAR;
    return result;
}


CODE_SECTION(".text.find_any_ptr")
err_map_symbol_string_element_ptr_t err_map_symbol_string_find_any_ptr
        (err_map_symbol_string_t const *self)
{
    err_map_symbol_string_element_ptr_t result;
    int n= err_map_symbol_string_find_any_pair (NULL, &result, self);
    if (ERWIN_UNLIKELY(n == 0))
        return NULL;
    return result;
}


CODE_SECTION(".text.find_any")
o_type_result_t err_map_symbol_string_find_any
        (err_map_symbol_string_t const *self)
{
    err_map_symbol_string_element_ptr_t result_p;
    int n= err_map_symbol_string_find_any_pair (NULL, &result_p, self);
    if (ERWIN_UNLIKELY(n == 0))
        return ZERO(self);
    return *result_p;
}


CODE_SECTION(".text.equal_keys")
ERR_ERWIN_BOOL err_map_symbol_string_equal_keys
        (err_map_symbol_string_t const *self, err_map_symbol_string_t const *other)
{
    e_iterator_t iter;
    err_symbol_t key;

    if (self == NULL || other == NULL) {
        SET_ERRNO(E_OK);
        return ERR_ERWIN_TO_BOOL (self == other);
    }

    return0_if_null2_pp2 (self, other, self, other);

    if (ERWIN_UNLIKELY(self->m_nentries != other->m_nentries)) {
        SET_ERRNO(E_OK);
        return ERR_ERWIN_FALSE;
    }

    /* FIXME: can be improved (idea by mschmidt): if the hashsizes are
     *        the same, we can check each slot instead of running a full
     *        search, so we need not hash the individual keys. */
    err_map_symbol_string_forall_keys_nondet (self, iter, key) {
        (void)err_map_symbol_string_find_ptr (other, key);
        if (e_errno != E_OK)
            return ERR_ERWIN_FALSE;
    }

    SET_ERRNO(E_OK);
    return ERR_ERWIN_TRUE;
}


/*
 * Compare two maps.  This is a deep comparison */
CODE_SECTION(".text.cmp")
int err_map_symbol_string_cmp
        (err_map_symbol_string_t const *self, err_map_symbol_string_t const *other)
/* must be NULL safe per definition! */
{
#if defined(ICMP) && defined(OCMP)
    err_map_symbol_string_pair_t *them1;
    err_map_symbol_string_pair_t *them2;
    int i;
    int result= 0;
    int cnt;
    err_map_symbol_string_check0_cmp_keys;
    err_map_symbol_string_check0_cmp_values;
#endif

    SET_ERRNO(E_OK);

    if (self == NULL)
        return (other == NULL) ? 0 : -1;

    if (other == NULL)
        return 1;

    return0_if_null2_pp2 (self, other, self, other);

    if (self->m_nentries < other->m_nentries)
        return -1;

    if (self->m_nentries > other->m_nentries)
        return +1;

#if defined(ICMP) && defined(OCMP)
    cnt= self->m_nentries; /* == other->m_nentries */

    E_SET_PTR (them1, err_map_symbol_string_get_entries (self));
    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return 0;

    E_SET_PTR (them2, err_map_symbol_string_get_entries (other));
    if (ERWIN_UNLIKELY(e_errno != E_OK)) {
        err_map_symbol_string_delete_entries (them1);
        return 0;
    }

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism()) {
        qsort ((void*)them1, cnt, sizeof (err_map_symbol_string_pair_t), err_map_symbol_string_pair_detcmp_keys);
        qsort ((void*)them2, cnt, sizeof (err_map_symbol_string_pair_t), err_map_symbol_string_pair_detcmp_keys);

        e_merge_sort ((void*)them1, cnt, sizeof (err_map_symbol_string_pair_t), err_map_symbol_string_pair_cmp_keys);
        e_merge_sort ((void*)them2, cnt, sizeof (err_map_symbol_string_pair_t), err_map_symbol_string_pair_cmp_keys);
    }
    else
#else
    {
        qsort ((void*)them1, cnt, sizeof (err_map_symbol_string_pair_t), err_map_symbol_string_pair_cmp_keys);
        qsort ((void*)them2, cnt, sizeof (err_map_symbol_string_pair_t), err_map_symbol_string_pair_cmp_keys);
    }
#endif

    for (i=0; i < cnt; i++) {
        result= err_map_symbol_string_pair_cmp_keys (them1 + i, them2 + i);
        if (result != 0)
            break;

        result= err_map_symbol_string_pair_cmp_values (them1 + i, them2 + i);
        if (result != 0)
            break;
    }

    err_map_symbol_string_delete_entries (them1);
    err_map_symbol_string_delete_entries (them2);

    SET_ERRNO(E_OK);
    return result;
#else
    error_return0_if_reached_ppt (
        self,
        "Because either ERR_ERR_SYMBOL_T_CMP or ERR_CHAR_CONST_P_CMP was not #defined, err_map_symbol_string_cmp could not be implemented.");
#endif
}


/*
 * Compare set of keys of two maps.  This is a deep comparison */
CODE_SECTION(".text.cmp_keys")
int err_map_symbol_string_cmp_keys
        (err_map_symbol_string_t const *self, err_map_symbol_string_t const *other)
/* must be NULL safe per definition! */
{
#if defined(ICMP) && defined(OCMP)
    err_symbol_t *them1;
    err_symbol_t *them2;
    int i;
    int result= 0;
    int cnt;
    err_map_symbol_string_check0_cmp_keys;
#endif

    SET_ERRNO(E_OK);

    if (self == NULL)
        return (other == NULL) ? 0 : -1;

    if (other == NULL)
        return 1;

    return0_if_null2_pp2 (self, other, self, other);

    if (self->m_nentries < other->m_nentries)
        return -1;

    if (self->m_nentries > other->m_nentries)
        return +1;

#if defined(ICMP) && defined(OCMP)
    cnt= self->m_nentries; /* == other->m_nentries */

    E_SET_PTR (them1, err_map_symbol_string_get_keys (self));
    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return 0;

    E_SET_PTR (them2, err_map_symbol_string_get_keys (other));
    if (ERWIN_UNLIKELY(e_errno != E_OK)) {
        err_map_symbol_string_delete_keys (them1);
        return 0;
    }

    qsort ((void*)them1, cnt, sizeof (err_symbol_t), err_map_symbol_string_wrap_icmp);
    qsort ((void*)them2, cnt, sizeof (err_symbol_t), err_map_symbol_string_wrap_icmp);

    for (i=0; i < cnt; i++) {
        result= ICMP ((them1[i]), (them2[i]));
        if (result != 0)
            break;
    }

    err_map_symbol_string_delete_keys (them1);
    err_map_symbol_string_delete_keys (them2);

    SET_ERRNO(E_OK);
    return result;
#else
    error_return0_if_reached_ppt (
        self,
        "Because either ERR_ERR_SYMBOL_T_CMP was not #defined, err_map_symbol_string_cmp_keys could not be implemented.");
#endif
}


/* Compute hash value for a map. */
CODE_SECTION(".text.hash_raw")
e_hashval_t err_map_symbol_string_hash_raw
        (err_map_symbol_string_t const *self)
/* must be NULL-safe */
{
#ifdef OHASH
    e_iterator_t iter;
    err_symbol_t key;
    char const * value;
    e_hash_state_t state;
#endif

    if (self == NULL) {
        SET_ERRNO(E_OK);
        return ERR_ERWIN_HASH_INIT;
    }

#ifdef OHASH
    ERR_ERWIN_STATE_INIT_WITH (state, err_int_hash(self->m_nentries));

    err_map_symbol_string_forall_nondet (self, iter, key, value) {
        ERR_ERWIN_STATE_MIX_UNORDERED2 (state, IHASH (key), OHASH (value));
    }

    SET_ERRNO(E_OK);
    return ERR_ERWIN_STATE_GET_HASHVAL (state);
#else
    error_return0_if_reached_ppt (
        self,
        "Because ERR_CHAR_CONST_P_HASH was not #defined, err_map_symbol_string_hash_raw could not be implemented.");
#endif
}


/*
 * **********************************************************************
 * C++ implementations
 * **********************************************************************
 */

#ifdef __cplusplus
#define self (this->it())

CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (void)
{
    ERR_ERWIN_BOOL ok= err_map_symbol_string_init_internal_q (it(), OZERO, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}

CODE_SECTION(".text._constructor")
void err_map_symbol_string_t::_constructor
        (void)
{
    ERR_ERWIN_BOOL ok= err_map_symbol_string_init_internal_q (it(), OZERO, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}

CODE_SECTION(".text.static_zero")
err_map_symbol_string_t const & err_map_symbol_string_t::static_zero
        ()
{
    static err_map_symbol_string_t const *z= NULL;
    if (ERWIN_UNLIKELY(!z))
        E_SET_PTR (z, new err_map_symbol_string_t);
    return *z;
}

#ifndef NDEBUG

CODE_SECTION(".text.cn")
void err_map_symbol_string_t::cn
        () const
{
    return_if_null_or_bad (this);
}

CODE_SECTION(".text.cn")
void err_map_symbol_string_t::cn
        (void const *p) const
{
    (void)p; /*unused*/
    return_if_null_or_bad (this);
    return_if_null_pp (p, this);
}
#endif /* !defined(NDEBUG) */


#if ERR_MAP_SYMBOL_STRING_HAVE_INT_CONSTRUCTOR
CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (int size)
{
    ERR_ERWIN_BOOL ok= err_map_symbol_string_init_internal_q (it(), OZERO, size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* ERR_MAP_SYMBOL_STRING_HAVE_INT_CONSTRUCTOR */


#if ERR_MAP_SYMBOL_STRING_DYN_ZERO
CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (char const *  zeroval)
{
    ERR_ERWIN_BOOL ok= err_map_symbol_string_init_internal_q (it(), zeroval, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}

CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (char const *  zeroval, int size)
{
    ERR_ERWIN_BOOL ok= err_map_symbol_string_init_internal_q (it(), zeroval, size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* ERR_MAP_SYMBOL_STRING_DYN_ZERO */


CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (err_map_symbol_string_t const &other)
{
#ifdef ERWIN_DOS
    if (other.it()->m_table == NULL && other.it()->m_nentries == 0) {
        /* See copy constructor for vectors for explanation. */
        err_map_symbol_string_init_internal_q (it(), OZERO, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
    }
    else
#endif
    {
        err_map_symbol_string_init_internal_q (it(), ZERO(other.it()), other.it()->m_nentries);
        err_map_symbol_string_struct_copy (it(), other.it());
    }
}


#ifdef ERR_ERWIN_COMPAT_2_0_264
CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (err_map_symbol_string_t const *other)
{
    err_map_symbol_string_init_internal_q (it(), ZERO(other), other->m_nentries);
    err_map_symbol_string_struct_copy (it(), other);
}
#endif /* defined(ERR_ERWIN_COMPAT_2_0_264) */


CODE_SECTION(".text.t")
 err_map_symbol_string_t::err_map_symbol_string_t
        (err_map_symbol_string_t const *other)
{
    err_map_symbol_string_init_internal_q (it(), ZERO(other->it()), other->it()->m_nentries);
    err_map_symbol_string_struct_copy (it(), other->it());
}


CODE_SECTION(".text.err_map_symbol_string_t")
 err_map_symbol_string_t::~err_map_symbol_string_t
        ()
{
    err_map_symbol_string_destroy_internal (it());
}


CODE_SECTION(".text._destructor")
void err_map_symbol_string_t::_destructor
        ()
{
    err_map_symbol_string_destroy_internal (it());
}

#if !ERR_ERWIN_DEFAULT_NEW_DELETE

CODE_SECTION(".text.operatornew")
void * err_map_symbol_string_t::operator new
        (size_t s)
{
    return ERR_ERWIN_PREFER_TNEW (void, s);
}

CODE_SECTION(".text.operatordelete")
void err_map_symbol_string_t::operator delete
        (void *p, size_t s)
{
    (void)s; /*unused*/
    ERR_ERWIN_PREFER_TDELETE (p, void, s);
}

CODE_SECTION(".text.operatornew")
void * err_map_symbol_string_t::operator new[]
        (size_t s)
{
    return ERR_ERWIN_PREFER_TNEW (void, s);
}

CODE_SECTION(".text.operatordelete")
void err_map_symbol_string_t::operator delete[]
        (void *p, size_t s)
{
    (void)s; /*unused*/
    ERR_ERWIN_PREFER_TDELETE (p, void, s);
}

#endif /* !ERR_ERWIN_DEFAULT_NEW_DELETE */

CODE_SECTION(".text.operator")
err_map_symbol_string_t & err_map_symbol_string_t::operator=
        (err_map_symbol_string_t const *other)
{
    err_map_symbol_string_clear_no_resize (it());
    err_map_symbol_string_expect_size (it(), other->it()->m_nentries); /* realloc to good size */
    err_map_symbol_string_struct_copy (it(), other->it());
    return *this;
}


CODE_SECTION(".text.operator")
err_map_symbol_string_t & err_map_symbol_string_t::operator=
        (err_map_symbol_string_t const &other)
{
#ifdef ERWIN_DOS
    if (other.it()->m_table == NULL && other.it()->m_nentries == 0) {
        /* See copy constructor for vectors for explanation. */
        err_map_symbol_string_init_internal_q (it(), OZERO, ERR_MAP_SYMBOL_STRING_INITIAL_SIZE);
    }
    else
#endif
    {
        err_map_symbol_string_clear_no_resize (it());
        err_map_symbol_string_expect_size (it(), other.it()->m_nentries); /* realloc to good size */
        err_map_symbol_string_struct_copy (it(), other.it());
    }
    return *this;
}

#undef self
#endif /* defined(__cplusplus) */

/*
 * **********************************************************************
 * Section: Statistics and debugging.
 * **********************************************************************
 */

CODE_SECTION(".text.average_line_length")
double err_map_symbol_string_average_line_length
        (err_map_symbol_string_t const *self)
{
    double sum = 0.0;
    int i;
    for (i=0; i < self->m_hashsize; i++)
        sum+= err_map_symbol_string_hashlist_length (SLOT(self,i));
    return sum / (double)(self->m_hashsize);
}

CODE_SECTION(".text.variance_line_length")
double err_map_symbol_string_variance_line_length
        (err_map_symbol_string_t const *self)
{
    double average= err_map_symbol_string_average_line_length (self);
    double sum2= 0.0;
    int i;
    for (i=0; i < self->m_hashsize; i++) {
        double diff= err_map_symbol_string_hashlist_length (SLOT(self,i)) - average;
        sum2+= diff*diff;
    }
    return sum2 / (double)(self->m_hashsize - 1);
}

CODE_SECTION(".text.max_line_length")
int err_map_symbol_string_max_line_length
        (err_map_symbol_string_t const *self)
{
    int i;
    int max = 0;
    for (i=0; i < self->m_hashsize; i++) {
        int len= err_map_symbol_string_hashlist_length (SLOT(self,i));
        if (len > max) max= len;
    }
    return max;
}

CODE_SECTION(".text.min_line_length")
int err_map_symbol_string_min_line_length
        (err_map_symbol_string_t const *self)
{
    int i;
    int min= 0; /* shut up, gcc */
    for (i=0; i < self->m_hashsize; i++) {
        int len= err_map_symbol_string_hashlist_length (SLOT(self,i));
        if (i==0 || len < min) min= len;
    }
    return min;
}

#ifdef HAVE_SQRT
CODE_SECTION(".text.deviation_line_length")
double err_map_symbol_string_deviation_line_length
        (err_map_symbol_string_t const *self)
{
    return sqrt (err_map_symbol_string_variance_line_length (self));
}
#endif /* defined(HAVE_SQRT) */


CODE_SECTION(".text.dump")
void err_map_symbol_string_dump
        (FILE *thefile, err_map_symbol_string_t const *self)
{
    int i;
    fprintf (thefile, "(err_map_symbol_string_dump):\n");
    fprintf (thefile, "global e_errno=%d\n", e_errno);
    fprintf (thefile, "hashsize=%d\n", self->m_hashsize);
    fprintf (thefile, "nentries=%d\n", self->m_nentries);

#ifdef E_PROFILE
    fprintf (thefile, "nrehash=%d\n", self->m_nrehash);
    fprintf (thefile, "nrehashops=%d\n", self->m_nrehashops);
    fprintf (thefile, "nfind=%d\n", self->m_nfind);
    fprintf (thefile, "ninsert=%d\n", self->m_ninsert);
    fprintf (thefile, "ndelete=%d\n", self->m_ndelete);
#endif /* E_PROFILE */

#ifdef OPRINT
    fprintf (thefile, "zero=");
    {
        char const * z;
        E_SET_VALUE (z, ZERO(self)); /* prevent a warning about reading through NULL pointer by
                                      * using this help variable */
        OPRINT (thefile, z);
    }
    fprintf (thefile, "\n");
#endif /* OPRINT */

    for (i= 0; i < self->m_hashsize; i++) {
        int length= 0;
        err_map_symbol_string_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));

        if (lauf) {
            fprintf (thefile, "table[%d]:\n  ", i);
            while (lauf) {
                fprintf (thefile, "%p: ", lauf);

#ifdef IPRINT
                fprintf (thefile, " ");
                IPRINT (thefile, lauf->key);
#endif /* IPRINT */

#ifdef OPRINT
                fprintf (thefile, "=");
                OPRINT (thefile, lauf->value);
#endif /* OPRINT */

                fprintf (thefile, "\n  ");
                E_SET_PTR (lauf, lauf->next);
                length++;
            }
            fprintf (thefile, "(length %d)\n", length);
        }
    }
    fprintf (thefile, "END\n");
}

#ifdef E_PROFILE


CODE_SECTION(".text.nrehash")
int err_map_symbol_string_nrehash
        (err_map_symbol_string_t const *self)
{
    return self->m_nrehash;
}


CODE_SECTION(".text.nrehash_ops")
int err_map_symbol_string_nrehash_ops
        (err_map_symbol_string_t const *self)
{
    return self->m_nrehashops;
}


CODE_SECTION(".text.ninsert")
int err_map_symbol_string_ninsert
        (err_map_symbol_string_t const *self)
{
    return self->m_ninsert;
}


CODE_SECTION(".text.nfind")
int err_map_symbol_string_nfind
        (err_map_symbol_string_t const *self)
{
    return self->m_nfind;
}


CODE_SECTION(".text.nremove")
int err_map_symbol_string_nremove
        (err_map_symbol_string_t const *self)
{
    return self->m_ndelete;
}


CODE_SECTION(".text.nops")
int err_map_symbol_string_nops
        (err_map_symbol_string_t const *self)
{
    return self->m_ninsert + self->m_ndelete + self->m_nfind;
}


#endif /* defined(E_PROFILE) */


#undef ERR_MAP_SYMBOL_STRING_IMPLEMENTATION
#undef ASSERTION_FAILED
#undef MAP_NOMEM
#undef MAP_NOMEM_R
#undef ITER
#undef SORTITER
#undef SORTITERPTR

#undef IZEROVAR
#undef errstream
#undef errprint

#undef E_ASSERTIONFAILED
#undef E_BOOL
#undef E_COMPAT_2_0_264
#undef E_COMPILING
#undef E_DEFAULT_NEW_DELETE
#undef E_EMPTY
#undef e_erwininternalmaperrno
#undef E_EXISTINGKEY
#undef E_FALSE
#undef E_FILE_IDS
#undef E_GLOBAL_ERRNO
#undef E_HASH_INIT
#undef e_hash_into
#undef e_hash_state_t
#undef e_hashval_t
#undef e_init
#undef e_init
#undef e_int_hash
#undef e_iterator_sorted_t
#undef e_iterator_t
#undef E_KEYNOTFOUND
#undef e_mapinitialised
#undef e_merge_sort
#undef E_NO_LINKER_TRICKS
#undef E_NOMEM
#undef E_NOMOREELEMS
#undef E_OK
#undef E_PREFER_TDELETE
#undef E_PREFER_TNEW
#undef E_PROFILE
#undef E_REHASH_DUPLICATEKEY
#undef E_REHASH_NOMEM
#undef E_REHASH_RECURSION
#undef e_require_determinism
#undef E_REQUIRE_DETERMINISM
#undef E_SET_PTR
#undef E_STATE_GET_HASHVAL
#undef E_STATE_INIT_WITH
#undef E_STATE_MIX_UNORDERED2
#undef E_STATE_MIX_UNORDERED
#undef E_THING_CNEW_ARRAY
#undef E_THING_DELETE1
#undef E_THING_DELETE_ARRAY
#undef E_THING_DELETE_ATOMS
#undef E_THING_NEW1
#undef E_THING_NEW_ARRAY
#undef E_THING_NEW_ATOMS
#undef E_THREAD_SAFE
#undef E_TO_BOOL
#undef E_TRUE
#undef E_USE_MUTABLE
#undef E_WEAK_DETERMINISM
#undef E_WEAK_STORAGE
#undef IBEING_USED
#undef ICMP
#undef ICOPY
#undef ICOPY_PROVIDED
#undef IDETCMP
#undef IDETCMP_PROVIDED
#undef IEQUAL
#undef IEQUAL_PROVIDED
#undef IFREE
#undef IFREE_PROVIDED
#undef IHASH
#undef IPRINT
#undef IZERO
#undef OBEING_USED
#undef OCMP
#undef OCOPY
#undef OCOPY_PROVIDED
#undef ODETCMP
#undef ODETCMP_PROVIDED
#undef OEQUAL
#undef OFREE
#undef OFREE_PROVIDED
#undef OHASH
#undef OPRINT
#undef OZERO

