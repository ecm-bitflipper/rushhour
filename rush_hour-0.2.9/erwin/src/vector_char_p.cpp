/* -*- Mode: C -*- */

/* Author: Henrik Theiling
 *
 * Description: Implementation of vectors.
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifndef COMPAT_ERROR
#define COMPAT_ERROR 0
#endif

#ifndef VECTOR_CHAR_P_IMPLEMENTATION
#define VECTOR_CHAR_P_IMPLEMENTATION
#endif

#ifndef PASS2

#ifdef HAVE_MATH_H
#  include <math.h>
#endif

#include "erwin/defs.h"

#include "erwin/forwards.h"

#include "vector_char_p_d.h"
#include "vector_char_p.h"
#include "vector_char_p_i.h"

#ifdef ERWIN_COMPILING
#  include "erwin/stdinc.h"
#else
#  include <erwin/stdinc.h>
#endif

#ifndef CHAR_P_BEING_USED
#define CHAR_P_BEING_USED 1
#endif

#include "erwin/needed.h"



/* Convenience definitions */
/* FIXME: these should be untemplatize-level defined.  But untemplatize does not
 *        know about whole-word-only replacements. */
#ifdef VECTOR_ERR_ASSERTIONFAILED
#define E_ASSERTIONFAILED VECTOR_ERR_ASSERTIONFAILED
#endif

#ifdef ERWIN_BOOL
#define E_BOOL ERWIN_BOOL
#endif

#define e_char_is_cr0 char_is_cr0

#define e_char_is_digit char_is_digit

#define e_char_is_print char_is_print

#define e_char_is_space0 char_is_space0

#define e_char_is_xdigit char_is_xdigit

#define e_char_to_lower char_to_lower

#define e_char_to_upper char_to_upper

#ifdef ERWIN_COMPAT_2_0_264
#define E_COMPAT_2_0_264 ERWIN_COMPAT_2_0_264
#endif

#ifdef ERWIN_COMPILING
#define E_COMPILING ERWIN_COMPILING
#endif

#ifdef ERWIN_DEFAULT_NEW_DELETE
#define E_DEFAULT_NEW_DELETE ERWIN_DEFAULT_NEW_DELETE
#endif

#ifdef VECTOR_WARN_EMPTY
#define E_EMPTY VECTOR_WARN_EMPTY
#endif

#ifdef ERWIN_ERROR_PRINT
#define E_ERROR_PRINT ERWIN_ERROR_PRINT
#endif

#ifdef ERWIN_ERROR_STREAM
#define E_ERROR_STREAM ERWIN_ERROR_STREAM
#endif

#ifdef erwininternalvectorerrno
#define e_erwininternalvectorerrno erwininternalvectorerrno
#endif

#ifdef ERWIN_FALSE
#define E_FALSE ERWIN_FALSE
#endif

#ifdef ERWIN_FILE_IDS
#define E_FILE_IDS ERWIN_FILE_IDS
#endif

#ifdef FO_CENTER
#define E_FO_CENTER FO_CENTER
#endif

#ifdef FO_CHECK
#define E_FO_CHECK FO_CHECK
#endif

#ifdef FO_DO_USE_SEP
#define E_FO_DO_USE_SEP FO_DO_USE_SEP
#endif

#ifdef FO_GET_RADIX
#define E_FO_GET_RADIX FO_GET_RADIX
#endif

#ifdef FO_GET_SEP_AT
#define E_FO_GET_SEP_AT FO_GET_SEP_AT
#endif

#ifdef FO_GET_USE_SEP
#define E_FO_GET_USE_SEP FO_GET_USE_SEP
#endif

#ifdef FO_QUOTE_MASK
#define E_FO_QUOTE_MASK FO_QUOTE_MASK
#endif

#ifdef FO_QUOTE_USER1
#define E_FO_QUOTE_USER1 FO_QUOTE_USER1
#endif

#ifdef FO_QUOTE_USER2
#define E_FO_QUOTE_USER2 FO_QUOTE_USER2
#endif

#ifdef FO_QUOTE_USER3
#define E_FO_QUOTE_USER3 FO_QUOTE_USER3
#endif

#ifdef FO_QUOTE_USER_MAX
#define E_FO_QUOTE_USER_MAX FO_QUOTE_USER_MAX
#endif

#ifdef FO_QUOTE_USER_MIN
#define E_FO_QUOTE_USER_MIN FO_QUOTE_USER_MIN
#endif

#ifdef FO_SIGNED
#define E_FO_SIGNED FO_SIGNED
#endif

#ifdef FO_SPECIAL
#define E_FO_SPECIAL FO_SPECIAL
#endif

#ifdef FO_S_TYPE_MASK
#define E_FO_S_TYPE_MASK FO_S_TYPE_MASK
#endif

#ifdef FO_UPCASE
#define E_FO_UPCASE FO_UPCASE
#endif

#ifdef FO_VECTOR
#define E_FO_VECTOR FO_VECTOR
#endif

#ifdef FO_VOID_P
#define E_FO_VOID_P FO_VOID_P
#endif

#ifdef ERWIN_GLOBAL_ERRNO
#define E_GLOBAL_ERRNO ERWIN_GLOBAL_ERRNO
#endif

#ifdef ERWIN_HASH_INIT
#define E_HASH_INIT ERWIN_HASH_INIT
#endif

#define e_hash_state_t erwin_hash_state_t

#define e_hashval_t hashval_t

#ifdef int_hash
#define e_int_hash int_hash
#endif

#ifdef VECTOR_ERR_IO
#define E_IO VECTOR_ERR_IO
#endif

#define e_merge_sort erwin_merge_sort

#ifdef erwin_next_power2_minus1
#define e_next_power2_minus1 erwin_next_power2_minus1
#endif

#ifdef VECTOR_ERR_NOMEM
#define E_NOMEM VECTOR_ERR_NOMEM
#endif

#ifdef VECTOR_ERR_NOTCOMPILED
#define E_NOTCOMPILED VECTOR_ERR_NOTCOMPILED
#endif

#ifdef VECTOR_OK
#define E_OK VECTOR_OK
#endif

#ifdef ERWIN_OPERATOR_NEW_CLEARS_MEMORY
#define E_OPERATOR_NEW_CLEARS_MEMORY ERWIN_OPERATOR_NEW_CLEARS_MEMORY
#endif

#ifdef VECTOR_ERR_OUTOFRANGE
#define E_OUTOFRANGE VECTOR_ERR_OUTOFRANGE
#endif

#ifdef ERWIN_PREFER_TDELETE
#define E_PREFER_TDELETE ERWIN_PREFER_TDELETE
#endif

#ifdef ERWIN_PREFER_TNEW
#define E_PREFER_TNEW ERWIN_PREFER_TNEW
#endif

#ifdef ERWIN_SET_PTR
#define E_SET_PTR ERWIN_SET_PTR
#endif

#ifdef ERWIN_STATE_GET_HASHVAL
#define E_STATE_GET_HASHVAL ERWIN_STATE_GET_HASHVAL
#endif

#ifdef ERWIN_STATE_INIT_WITH
#define E_STATE_INIT_WITH ERWIN_STATE_INIT_WITH
#endif

#ifdef ERWIN_STATE_MIX_ORDERED
#define E_STATE_MIX_ORDERED ERWIN_STATE_MIX_ORDERED
#endif

#ifdef ERWIN_TFREE1
#define E_TFREE1 ERWIN_TFREE1
#endif

#ifdef ERWIN_TFREE_ARRAY
#define E_TFREE_ARRAY ERWIN_TFREE_ARRAY
#endif

#ifdef ERWIN_TFREE_ATOMS
#define E_TFREE_ATOMS ERWIN_TFREE_ATOMS
#endif

#ifdef ERWIN_THING_DELETE1
#define E_THING_DELETE1 ERWIN_THING_DELETE1
#endif

#ifdef ERWIN_THING_DELETE_ARRAY
#define E_THING_DELETE_ARRAY ERWIN_THING_DELETE_ARRAY
#endif

#ifdef ERWIN_THING_DELETE_ATOMS
#define E_THING_DELETE_ATOMS ERWIN_THING_DELETE_ATOMS
#endif

#ifdef ERWIN_THING_NEW1
#define E_THING_NEW1 ERWIN_THING_NEW1
#endif

#ifdef ERWIN_THING_NEW_ARRAY
#define E_THING_NEW_ARRAY ERWIN_THING_NEW_ARRAY
#endif

#ifdef ERWIN_THING_NEW_ATOMS
#define E_THING_NEW_ATOMS ERWIN_THING_NEW_ATOMS
#endif

#ifdef ERWIN_THING_RENEW_ARRAY
#define E_THING_RENEW_ARRAY ERWIN_THING_RENEW_ARRAY
#endif

#ifdef ERWIN_THING_RENEW_ATOMS
#define E_THING_RENEW_ATOMS ERWIN_THING_RENEW_ATOMS
#endif

#ifdef ERWIN_THREAD_SAFE
#define E_THREAD_SAFE ERWIN_THREAD_SAFE
#endif

#ifdef ERWIN_TMALLOC1
#define E_TMALLOC1 ERWIN_TMALLOC1
#endif

#ifdef ERWIN_TMALLOC_ARRAY
#define E_TMALLOC_ARRAY ERWIN_TMALLOC_ARRAY
#endif

#ifdef ERWIN_TMALLOC_ATOMS
#define E_TMALLOC_ATOMS ERWIN_TMALLOC_ATOMS
#endif

#ifdef ERWIN_TO_BOOL
#define E_TO_BOOL ERWIN_TO_BOOL
#endif

#ifdef VECTOR_ERR_TOOLARGE
#define E_TOOLARGE VECTOR_ERR_TOOLARGE
#endif

#ifdef ERWIN_TREALLOC_ARRAY
#define E_TREALLOC_ARRAY ERWIN_TREALLOC_ARRAY
#endif

#ifdef ERWIN_TREALLOC_ATOMS
#define E_TREALLOC_ATOMS ERWIN_TREALLOC_ATOMS
#endif

#ifdef ERWIN_TRUE
#define E_TRUE ERWIN_TRUE
#endif

#ifdef ERWIN_USE_MUTABLE
#define E_USE_MUTABLE ERWIN_USE_MUTABLE
#endif

#ifdef ERWIN_VERBOSE
#define E_VERBOSE ERWIN_VERBOSE
#endif

#ifdef CHAR_P_BEING_USED
#define OBEING_USED CHAR_P_BEING_USED
#endif

#ifdef CHAR_P_CMP
#define OCMP CHAR_P_CMP
#endif

#ifdef CHAR_P_CONSTRUCTOR
#define OCONSTRUCTOR CHAR_P_CONSTRUCTOR
#endif

#ifdef CHAR_P_OCOPY
#define OCOPY CHAR_P_OCOPY
#endif

#ifdef CHAR_P_OCOPY_PROVIDED
#define OCOPY_PROVIDED CHAR_P_OCOPY_PROVIDED
#endif

#ifdef CHAR_P_DESTRUCTOR
#define ODESTRUCTOR CHAR_P_DESTRUCTOR
#endif

#ifdef CHAR_P_EQUAL
#define OEQUAL CHAR_P_EQUAL
#endif

#ifdef CHAR_P_OFREE
#define OFREE CHAR_P_OFREE
#endif

#ifdef CHAR_P_OFREE_PROVIDED
#define OFREE_PROVIDED CHAR_P_OFREE_PROVIDED
#endif

#ifdef CHAR_P_HASH
#define OHASH CHAR_P_HASH
#endif

#ifdef CHAR_P_PRIORITY_CMP
#define OPRIORITY_CMP CHAR_P_PRIORITY_CMP
#endif

#ifdef CHAR_P_UPDATE_POS2
#define OUPDATE_POS2 CHAR_P_UPDATE_POS2
#endif

#ifdef CHAR_P_UPDATE_POS
#define OUPDATE_POS CHAR_P_UPDATE_POS
#endif

#ifdef CHAR_P_ZERO
#define OZERO CHAR_P_ZERO
#endif

/* #undef errno */
/* #define errno   __I_THINK_YOU_MEAN__e_errno__
 *     ERWIN_STRERRNO is used, so this is no good...
 */


#ifndef CHAR_P_IS_PTR
#define CHAR_P_IS_PTR 1
#endif /* !defined CHAR_P_IS_PTR */

#if defined(CHAR_P_IS_PTR) && CHAR_P_IS_PTR
#  define E_SET_VALUE(X,Y)     E_SET_PTR(X,Y)
#else
#  define E_SET_VALUE(X,Y)     ((X)=(Y))
#endif

#define QUOTATION_METHOD_CNT 16

#if !E_GLOBAL_ERRNO
#  if E_USE_MUTABLE
#      define e_errno          (self->m_errno)
#  else
#      define e_errno          (ERWIN_CONST_CAST(vector_char_p_t*,self)->m_errno)
#  endif
#else
#  define e_errno              erwininternalvectorerrno
#endif

#define SET_ERRNO(X)           do{ e_errno= (X); }while(0)
#define PASS_ERRNO(X)          (e_errno= (X))


#if VECTOR_CHAR_P_INITIAL_SIZE < 0
#error VECTOR_CHAR_P_INITIAL_SIZE < 0
#endif

#if VECTOR_CHAR_P_MINIMAL_SIZE < 0
#error VECTOR_CHAR_P_MINIMAL_SIZE < 0
#endif


/* Note: Pay attention to INLINE_STORE, too, because if we use an inline
 *       store, we don't need the ZERO_SIZE stuff -- the INLINE_STORE
 *       implementation implements something similar automatically.
 *
 * Note: With INLINE_STORE, we do not know whether INLINE_CNT is > 0 or
 *       not.  So some code that needs special care with ZERO_SIZE also
 *       needs special care with INLINE_STORE.
 */
#if VECTOR_CHAR_P_INLINE_STORE
#  define VECTOR_CHAR_P_ZERO_SIZE 0
#elif VECTOR_CHAR_P_MINIMAL_SIZE == 0 || VECTOR_CHAR_P_INITIAL_SIZE == 0
#  define VECTOR_CHAR_P_ZERO_SIZE 1
#else
#  define VECTOR_CHAR_P_ZERO_SIZE 0
#endif

/* Handling of element array:
 * This is tricky due to INLINE_STORE, LOW_MEM, and ZERO_SIZE stuff */

#define VECTOR_CHAR_P_DUMMY_TABLE ((char **)(void*)&vector_char_p_dummy_table)
   /* This hopefully disables the type-punned pointer warning of gcc,
    * which is otherwise hard to eliminate.  The pointer is never
    * dereferenced, so the warning may be ignored. */

#if VECTOR_CHAR_P_LOW_MEM
#  define vector_char_p_ensure_table_size_force   vector_char_p_ensure_size
#else
#  define vector_char_p_ensure_table_size_force   vector_char_p_ensure_table_size
#endif

#define ADD_MINUS_1(A,B)        ((B) > 0 ? ((A) + (B) - 1) : (A))

#define NEED_GROW(N,T)          ((N) > (T))

#if VECTOR_CHAR_P_INLINE_STORE

#  define VECTOR_CHAR_P_INLINE_CNT     ((vector_char_p_cnt_t)(sizeof(vector_char_p_content_p) / sizeof(vector_char_p_content)))

#  define HAVE_INLINE_STORE     (VECTOR_CHAR_P_INLINE_CNT > 0)

#  if VECTOR_CHAR_P_LOW_MEM
#    define HAS_HEAP_TABLE(X)   ((X) && ((X)->m_nentries > VECTOR_CHAR_P_INLINE_CNT))
#  else
#    define HAS_HEAP_TABLE(X)   ((X) && ((X)->m_tablesize> VECTOR_CHAR_P_INLINE_CNT))
#  endif

#  define INLINE_TABLE(X)       ((vector_char_p_content_p)(&((X)->m_table)))

#  define TABLE(X)              (HAS_HEAP_TABLE(X) ? (X)->m_table : INLINE_TABLE(X))

#  define GET_MINIMAL_SIZE      (HAVE_INLINE_STORE ? VECTOR_CHAR_P_INLINE_CNT : VECTOR_CHAR_P_MINIMAL_SIZE)
#  define GET_INITIAL_SIZE      (HAVE_INLINE_STORE ? VECTOR_CHAR_P_INLINE_CNT : VECTOR_CHAR_P_INITIAL_SIZE)

#  define CLAMP_MINIMAL(N)      ((N) <= VECTOR_CHAR_P_INLINE_CNT ?      \
                                    VECTOR_CHAR_P_INLINE_CNT            \
                                  : (N) <= VECTOR_CHAR_P_MINIMAL_SIZE ? \
                                    VECTOR_CHAR_P_MINIMAL_SIZE          \
                                  : (N)                          \
                                )

#define NEED_SHRINK_MIN(N,T,MIN)  ((N) <= ((T)>>2) && (ADD_MINUS_1(T,MIN) >> 1) >= (MIN))
#define NEED_SHRINK(N,T)          NEED_SHRINK_MIN(N, T, GET_MINIMAL_SIZE)
#define ADJUST_SHRUNK(T)          CLAMP_MINIMAL(T)

#define ADJUST_GROWN(T)           CLAMP_MINIMAL(T)

#else

#  define VECTOR_CHAR_P_INLINE_CNT     0

#  if VECTOR_CHAR_P_ZERO_SIZE
#    define HAS_HEAP_TABLE(X)   ((X) && (X)->m_table != VECTOR_CHAR_P_DUMMY_TABLE)
#  else
#    define HAS_HEAP_TABLE(X)   1
#  endif

#  define TABLE(X)              ((X)->m_table)

#  define GET_MINIMAL_SIZE      VECTOR_CHAR_P_MINIMAL_SIZE
#  define GET_INITIAL_SIZE      VECTOR_CHAR_P_INITIAL_SIZE

#  define CLAMP_MINIMAL(N)      ((N) <= VECTOR_CHAR_P_MINIMAL_SIZE ? \
                                    VECTOR_CHAR_P_MINIMAL_SIZE       \
                                  : (N)                       \
                                )

#define NEED_SHRINK_MIN(N,T,MIN)  ((N) <= ((T)>>2) && ((T) >> 1) >= (MIN))
#define NEED_SHRINK(N,T)          NEED_SHRINK_MIN(N, T, GET_MINIMAL_SIZE)
#define ADJUST_SHRUNK(T)          (T)

#define ADJUST_GROWN(T)           (T)

#endif

/* Regarding NEED_GROW and NEED_SHRINK:
 *
 * Now, shrinking is obviously more elaborated than growing.
 * Why?
 *
 * The problem is the vector_char_p_shrink() function that might resize to a non-power of 2
 * (or better, non-power of two multiple of MINIMAL_SIZE).
 * For growing, this is not considered a problem, but if we reach smaller sizes in
 * the order of MINIMAL_SIZE, we will need to 'realign' the table size to get a good
 * performance, especially if we have an inline store.  E.g. consider:
 *
 *    new element count    current tablesize        inline_cnt
 *    1                    5                        4
 *
 * In this situation, if we only checked whener 5/2 was >= inline_cnt, we'd not
 * resize at all, leaving the array on the heap forever.  But what we want is to
 * resize to 2 and then realign to size 4 to get optimal usage of the inline store.
 *
 * OTOH, in a situation like this:
 *
 *    new element count    current tablesize        inline_cnt
 *    1                    4                        4
 *
 * we do not want to first shrink to 2 and then realign to 4, but we want to
 * know immediately that we're at the limit already.
 *
 * To achieve both, we need to round the current table size up when we divide it
 * by 2, for which ADD_MINUS_1 is used.  Thus with MIN=4, we get:
 *
 *     (5 + 4 - 1)/2 >= 4    => shrink one more (and ofter that, clamp to minimum)
 * but
 *     (4 + 4 - 1)/2 <  4    => no need to shrink
 *
 * growshrink.pl shows what happens when we start with an unalign table size.
 *
 * We might optimise this and switch the resizing depending on whether we have
 * an inline store or not (in the above example, to resize from 5 to 4 on the
 * heap would be slightly silly)
 */

/* We need all user types that may be a result type as simple type names,
 * because untemplatize cannot parse all C types. */
typedef char *       o_type_t;
typedef char *  o_type_result_t;
typedef char *    o_type_var_t;

#define SPLIT_SECTIONS VECTOR_CHAR_P_SPLIT

#if SPLIT_SECTIONS
#  define CODE_SECTION(X) ATTR_SECTION(X)
#else
#  define CODE_SECTION(X)
#endif

#define ASSERTION_FAILED PASS_ERRNO(E_ASSERTIONFAILED)

#define return_if_invalid(self) \
    return_if_fail_ppi (VALID_NENTRIES(self->m_nentries), self, self->m_nentries);
#define return_val_if_invalid(self, val) \
    return_val_if_fail_ppi (VALID_NENTRIES(self->m_nentries), val, self, self->m_nentries);
#define return_if_invalid_pC(self, prog) \
    return_if_fail_ppiC (VALID_NENTRIES(self->m_nentries), self, self->m_nentries, prog);

#if VECTOR_CHAR_P_HAVE_SIG

#  define return_if_bad(self) \
      return_if_fail_ppxxt(self->m_sig == VECTOR_CHAR_P_SIG, self, self->m_sig, VECTOR_CHAR_P_SIG, "Structure was probably overwritten"); \
      return_if_invalid(self);
#  define return_val_if_bad(self, val) \
      return_val_if_fail_ppxxt(self->m_sig == VECTOR_CHAR_P_SIG, val, self, self->m_sig, VECTOR_CHAR_P_SIG, "Structure was probably overwritten"); \
      return_val_if_invalid(self, val);
#  define return_if_bad_pC(self, prog) \
      return_if_fail_ppxxtC(self->m_sig == VECTOR_CHAR_P_SIG, self, self->m_sig, VECTOR_CHAR_P_SIG, "Structure was probably overwritten", prog); \
      return_if_invalid_pC(self, prog);

#else

#  define return_if_bad(self) \
      return_if_invalid(self);
#  define return_val_if_bad(self, val) \
      return_val_if_invalid(self, val);
#  define return_if_bad_pC(self, prog) \
      return_if_invalid_pC(self, prog);

#endif

#define return_if_null_or_bad(self) \
    return_if_null(self); \
    return_if_bad (self);

#define return_val_if_null_or_bad(self, val) \
    return_val_if_null(self, val); \
    return_val_if_bad (self, val);

#define return_if_null_or_bad_pC(self, prog) \
    return_if_null_pC(self, prog); \
    return_if_bad_pC (self, prog); \
    return_if_fail_ppiC (VALID_NENTRIES(self->m_nentries), self, self->m_nentries, prog);

#define return_if_null2i_or_bad(self) \
    return_if_null(self); \
    return_if_bad (self); \
    return_if_fail_pp(!HAS_HEAP_TABLE(self) || (self->m_table != NULL), self);

#define return_val_if_null2i_or_bad(self, val) \
    return_val_if_null(self, val); \
    return_val_if_bad (self, val); \
    return_val_if_fail_pp(!HAS_HEAP_TABLE(self) || (self->m_table != NULL), val, self);

#define return_if_null2i_or_bad_pC(self, prog) \
    return_if_null_pC(self, prog); \
    return_if_bad_pC (self, prog); \
    return_if_fail_ppC(!HAS_HEAP_TABLE(self) || (self->m_table != NULL), self, prog);

#define return0_if_bad(self)           return_val_if_bad(self, 0);
#define return0_if_null_or_bad(self)   return_val_if_null_or_bad(self, 0);
#define return0_if_null2i_or_bad(self) return_val_if_null2i_or_bad(self, 0);

#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A)       \
            ASSERTION_FAILED;                          \
            VECTOR_CHAR_P_ASSERTION_FAILED_HANDLER(FI,L,FU,A)
#endif

#if VECTOR_CHAR_P_SIZE_INDEX_DIFF
#  define VALID_SIZE(A)          (((vector_char_p_cnt_t)(vector_char_p_size_t)(A)) == ((vector_char_p_cnt_t)(A)))
#  define VALID_NENTRIES(A)      1
#else
#  define VALID_SIZE(A)          1
#  define VALID_NENTRIES(A)      (((vector_char_p_cnt_t)(A)) >= 0)
#endif

#if VECTOR_CHAR_P_MAY_BE_INVALID
#  define VALID_SIZE_GT(A,B)     (VALID_SIZE(A) && VALID_SIZE(B) && VALID_NENTRIES(B) && (A) < (B))
#  define VALID_SIZE_PLUS(A,B)   (VALID_SIZE(B) && VALID_SIZE_GT(A, (A)+(B)))
#else
#  define VALID_SIZE_GT(A,B)     VALID_NENTRIES(B)
#  define VALID_SIZE_PLUS(A,B)   VALID_SIZE_GT(A, (A)+(B))
#endif

#ifndef FATAL_ERROR
#define FATAL_ERROR(X,Y,Z,I,N)                                     \
            do {                                                   \
                SET_ERRNO(X);                                      \
                nothing_if_fail_ptii(ERWIN_FALSE, Z, I, N); \
                Y;                                                 \
            } while(0)
#endif

#ifndef FATAL_ERROR_MIN
#define FATAL_ERROR_MIN(X,Y,Z,I)                               \
            do {                                               \
                SET_ERRNO(X);                                  \
                nothing_if_fail_pti(ERWIN_FALSE, Z, I); \
                Y;                                             \
            } while(0)
#endif

#ifdef E_FILE_IDS
static char const * const vector_cvs_id= "$""Id: none$";
#endif

/*
 * This file contains ugly macros.  Their purpose is to debug code, and
 * to be a substitute for assert.h.  This file should compile under any compiler
 * with all (sensible) compiler settings and #defines.  This is meant to be ANSI
 * code with GNUC extensions if we compile under GNUC.  It should under no
 * circumstances produce compiler errors and under GNUC it should not produce
 * any warnings.
 * So if it fails to compile, it is a severe bug.  Please report this to
 * henrik@theiling.de.  To temporarily circumvent the problem, you can comment
 * out the following line. */

/* #define ASSERT_IS_BROKEN */

#ifndef ASSERT_IS_BROKEN

/*
 * Additional user provided assertion failure, warning,
 * and error handlers.
 */
#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_ERROR_HANDLER
#define USER_ERROR_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_WARNING_HANDLER
#define USER_WARNING_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifdef __GNUC__

#define ASSERT_NORETURN  __attribute__((__noreturn__))

#if defined __cplusplus && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95))
#define ASSERT_CAST_VOID static_cast<void>
   /* for compiler warning -Wold-style-cast */
#endif

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   __PRETTY_FUNCTION__
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  (ASSERT_CAST_VOID(0)) /* To get rid of warnings. */
 /* FIXME: CHECK: do we need the different versions of ASSERT_NO_EFFECT? */
#endif

#else

#define ASSERT_NORETURN

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   "-unknown-"
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  0
#endif

#endif

#ifndef ASSERT_CAST_VOID
#define ASSERT_CAST_VOID (void)
#endif

#ifndef NDEBUG
#define ASSERT_DEBUG_CODE(X) X
#else
#define ASSERT_DEBUG_CODE(X)
#endif

#if defined(__KERNEL__)

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#elif defined(HAVE_LIBERROR)

#ifndef IN_LIBERROR_COMPILE
#include <liberror.h>
#endif

#ifndef ASSERT_ABORT
#define ASSERT_ABORT err_crash()
#endif

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (eprintf (C_TAG_ASSERT | 0, 0, ERR_CALLBACKS_ONLY))
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT
#endif

#else /* !defined HAVE_LIBERROR */

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#endif /* !defined HAVE_LIBERROR */

#ifndef ASSERT_ABORT
#define ASSERT_ABORT abort()
#endif

#ifndef ASSERT_NONNEGATIVE
#ifdef erwin_nonnegative
#define ASSERT_NONNEGATIVE(X) erwin_nonnegative(X)
#else
#define ASSERT_NONNEGATIVE(X) ((X) >= 0)
#endif
#endif

#ifndef ASSERT_UNLIKELY
#ifdef ERWIN_UNLIKELY
#define ASSERT_UNLIKELY(X) ERWIN_UNLIKELY(X)
#else
#define ASSERT_UNLIKELY(X) (X)
#endif
#endif


#ifndef NDEBUG
/*
 * The following macros are only available for debugging.  There will not
 * be an error_..._if_crash since a) that is weird, b) the macros
 * do not work on many platforms and should, therefore, not handle normal
 * control flow, c) we have to define helper data and functions. */

/*
 * In order to get the necessary #definitions automatically from a GNU
 * configure script, be sure to have the following lines in configure.in:

--- BEGIN configure.failure ---

AC_CHECK_HEADERS(signal.h)
AC_CHECK_HEADERS(setjmp.h)
AC_CHECK_FUNCS(setjmp)
AC_TYPE_SIGNAL

dnl The following might make the output nicer, but are not required:

AC_CHECK_HEADERS(unistd.h)
AC_DECL_SYS_SIGLIST

--- END configure.failure ---

 * Note that this file does not believe the configure settings if you compile
 * with -ansi (i.e. __STRICT_ANSI__ is defined).  This is a convenience
 * setting for gcc compilation tests when you do not want to call configure
 * again.

 * And either add the following lines to config.h.in:

--- BEGIN config.h.in.failure ---
#undef HAVE_SIGNAL_H
#undef HAVE_SETJMP_H
#undef HAVE_UNISTD_H
#undef RETSIGTYPE
#undef SYS_SIGLIST_DECLARED
--- END config.h.in.failure ---

 * And be sure to include your configuration header file before this file.
 */

#if defined(HAVE_SIGNAL_H) && defined(HAVE_SETJMP_H) && defined(HAVE_SETJMP) && defined(RETSIGTYPE) && !defined(__KERNEL__)

/* We have signals and debugging is enabled here.  And we are not in __KERNEL__ mode.*/

#include <signal.h>
#include <setjmp.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if defined(SYS_SIGLIST_DECLARED) && !defined(__STRICT_ANSI__)
#define ASSERT_STRSIGNAL(X) (sys_siglist[X])
#else
#define ASSERT_STRSIGNAL(X) "unknown"
#endif

static jmp_buf assert_jmp_buf;
static volatile int assert_signal_caught;
static volatile int assert_caught_no;

#if defined(SIGSEGV) || defined(_SIGSEGV)
static RETSIGTYPE (*assert_old_sigsegv)(int);
#endif
#if defined(SIGBUS) || defined(_SIGBUS)
static RETSIGTYPE (*assert_old_sigbus)(int);
#endif
#if defined(SIGABRT) || defined(_SIGABRT)
static RETSIGTYPE (*assert_old_sigabrt)(int);
#endif
#if defined(SIGFPE) || defined(_SIGFPE)
static RETSIGTYPE (*assert_old_sigfpe)(int);
#endif
#if defined(SIGILL) || defined(_SIGILL)
static RETSIGTYPE (*assert_old_sigill)(int);
#endif
#if defined(SIGHUP) || defined(_SIGHUP)
static RETSIGTYPE (*assert_old_sighup)(int);
#endif

static RETSIGTYPE assert_catch_signal (int) ASSERT_NORETURN;
static RETSIGTYPE assert_catch_signal (int which)
{
    assert_signal_caught= 1;
    assert_caught_no= which;
    longjmp (assert_jmp_buf, 1);
}

static void assert_begin_signals (void)
{
    assert_signal_caught= 0;

#if defined(_SIGSEGV)
    assert_old_sigsegv= signal (_SIGSEGV, &assert_catch_signal);
#elif defined(SIGSEGV)
    assert_old_sigsegv= signal (SIGSEGV, &assert_catch_signal);
#endif

#if defined(_SIGBUS)
    assert_old_sigbus= signal (_SIGBUS, &assert_catch_signal);
#elif defined(SIGBUS)
    assert_old_sigbus= signal (SIGBUS, &assert_catch_signal);
#endif

#if defined(_SIGABRT)
    assert_old_sigabrt= signal (_SIGABRT, &assert_catch_signal);
#elif defined(SIGABRT)
    assert_old_sigabrt= signal (SIGABRT, &assert_catch_signal);
#endif

#if defined(_SIGFPE)
    assert_old_sigfpe= signal (_SIGFPE, &assert_catch_signal);
#elif defined(SIGFPE)
    assert_old_sigfpe= signal (SIGFPE, &assert_catch_signal);
#endif

#if defined(_SIGILL)
    assert_old_sigill= signal (_SIGILL, &assert_catch_signal);
#elif defined(SIGILL)
    assert_old_sigill= signal (SIGILL, &assert_catch_signal);
#endif

#if defined(_SIGHUP)
    assert_old_sighup= signal (_SIGHUP, &assert_catch_signal);
#elif defined(SIGHUP)
    assert_old_sighup= signal (SIGHUP, &assert_catch_signal);
#endif
}

static void assert_end_signals (void)
{
#if defined(_SIGSEGV)
    signal (_SIGSEGV, assert_old_sigsegv);
#elif defined(SIGSEGV)
    signal (SIGSEGV, assert_old_sigsegv);
#endif

#if defined(_SIGBUS)
    signal (_SIGBUS, assert_old_sigbus);
#elif defined(SIGBUS)
    signal (SIGBUS, assert_old_sigbus);
#endif

#if defined(_SIGABRT)
    signal (_SIGABRT, assert_old_sigabrt);
#elif defined(SIGABRT)
    signal (SIGABRT, assert_old_sigabrt);
#endif

#if defined(_SIGFPE)
    signal (_SIGFPE, assert_old_sigfpe);
#elif defined(SIGFPE)
    signal (SIGFPE, assert_old_sigfpe);
#endif

#if defined(_SIGILL)
    signal (_SIGILL, assert_old_sigill);
#elif defined(SIGILL)
    signal (SIGILL, assert_old_sigill);
#endif

#if defined(_SIGHUP)
    signal (_SIGHUP, assert_old_sighup);
#elif defined(SIGHUP)
    signal (SIGHUP, assert_old_sighup);
#endif
}

/*
 * This is not nestable. */
#define ASSERT_TRY_COMMAND(X)                 \
        do {                                  \
            assert_begin_signals ();          \
            if (!setjmp (assert_jmp_buf)) {   \
                X;                            \
            }                                 \
            assert_end_signals ();            \
        } while (0)

#define ASSERT_NO_SIGNAL_CAUGHT (assert_signal_caught == 0)

#else

/* No signals, debugging enabled. */
#define ASSERT_TRY_COMMAND(X) do { X; } while (0)
        /* this *is* a crash test, so do it even if catching the error is
         * not possible on this machine... */
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X) "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* defined(HAVE_SIGNAL_H) ... */

#else

/* No signals, debugging disabled. */
#define ASSERT_TRY_COMMAND(X)
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X)  "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* DEBUG */


/*
 * Please note that this does not have any do { ... } while(0) protection.  This is because
 * continue_if_fail and break_if_fail would do wrong things in that case. */
#ifndef raw_do_if_fail
#define raw_do_if_fail(P,A1,A2,A3,W,F1,F2) \
        if (ASSERT_UNLIKELY(!(A1))) { \
            ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                     ""P" function '%s':\n" \
                     ASSERT_INDENT W " failed: '%s'\n" \
                     ASSERT_INDENT "Pre-processed: '%s'\n" \
                             , ASSERT_FUNCTION, \
                             A3 \
                             ,A2 \
                             ); \
            F1; \
            USER_ASSERTION_FAILED_HANDLER(__FILE__,__LINE__,ASSERT_FUNCTION, A); \
            F2; \
        } \
        else { ; }
#endif

/*
 * If you write your USER_ASSERTION_FAILED_HANDLER in such a way that it is an expression,
 * you can use the false_if_fail, null_if_fail, etc. */
#ifndef raw_value_if_fail
#define raw_value_if_fail(P,A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        (ASSERT_UNLIKELY(!(A1)) ? ((\
                     ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                          ""P" function '%s':\n" \
                          ASSERT_INDENT W" failed: '%s'\n" \
                          ASSERT_INDENT "Pre-processed: '%s'\n" \
                          , ASSERT_FUNCTION, \
                          A3 \
                          ,#A2 \
                          )), \
                  (F1), \
                  (USER_ASSERTION_FAILED_HANDLER(__FILE__, __LINE__, ASSERT_FUNCTION, A)), \
                  (FAILVAL)) \
                : (GOODVAL))
#endif

#ifndef NDEBUG

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("In",A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("In",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#else

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) (GOODVAL)
#endif

#endif

#ifndef warn_do_if_fail
#define warn_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Warning in",A1,A2,A3,W,F1,F2)
#endif

#ifndef warn_value_if_fail
#define warn_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Warning in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef error_do_if_fail
#define error_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Error in",A1,A2,A3,W,F1,F2)
#endif

#ifndef error_value_if_fail
#define error_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Error in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3) \
	 { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;break;;); } 
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached() \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached
#define exit1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null
#define exit_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached
#define exit_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef false_if_fail
#define false_if_fail(A1) \
	 ( value_if_fail(A1,A1,""#A1,"Assertion",(ASSERT_NO_EFFECT,ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) \
	 ( value_if_fail(0,0,"""0","Control flow",(ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n"),ASSERT_EPRINTF_MORE_1 ("%s\n", #X1),ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached
#define nothing_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_2 (""#X1"=%d ('%c')\n", (X1), (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2) \
	 do { \
	ASSERT_TRY_COMMAND(A1;);\
	do_if_fail(ASSERT_NO_SIGNAL_CAUGHT,A1;,""#A1,"Execution",ASSERT_EPRINTF_MORE_1 ("Signal number: %d\n", assert_caught_no);ASSERT_EPRINTF_MORE_1 ("Signal name: %s\n", ASSERT_STRSIGNAL(assert_caught_no));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));X3;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null
#define return0_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A4) != NULL,(A4) != NULL,"("#A4") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached
#define return0_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null
#define return1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached
#define return1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return_if_fail
#define return_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));X3;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%lu\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%lu\n", (unsigned long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));X5;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null
#define return_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); \
	do_if_fail((A1->A2) != NULL,(A1->A2) != NULL,"("#A1"->"#A2") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached
#define return_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%ld\n", (long)(X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif


#else /* !defined(ASSERT_IS_BROKEN) */

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1)
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1)
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1)
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1)
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1)
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1)
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1)
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1)
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M)
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached()
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1)
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1)
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2)
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2)
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1)
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1)
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2)
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2)
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1)
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1)
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1)
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1)
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1)
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1)
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1)
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2)
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2)
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1)
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M)
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit1_if_reached
#define exit1_if_reached()
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1)
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1)
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2)
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2)
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1)
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1)
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1)
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1)
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2)
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1)
#endif

#ifndef exit_if_null
#define exit_if_null(A1)
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1)
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1)
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2)
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2)
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1)
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M)
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit_if_reached
#define exit_if_reached()
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1)
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1)
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2)
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2)
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1)
#endif

#ifndef false_if_fail
#define false_if_fail(A1) (!0)
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) (!0)
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1)
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1)
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1)
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2)
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2)
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1)
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1)
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1)
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1)
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2)
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2)
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1)
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M)
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef nothing_if_reached
#define nothing_if_reached()
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1)
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2)
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1)
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2)
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3)
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2)
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1)
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1)
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1)
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1)
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2)
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4)
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1)
#endif

#ifndef return0_if_null
#define return0_if_null(A1)
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2)
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2)
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3)
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3)
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2)
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4)
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1)
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1)
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2)
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2)
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1)
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2)
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2)
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1)
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M)
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return0_if_reached
#define return0_if_reached()
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1)
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1)
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2)
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3)
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2)
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1)
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1)
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1)
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1)
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1)
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1)
#endif

#ifndef return1_if_null
#define return1_if_null(A1)
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1)
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1)
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2)
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2)
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1)
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M)
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return1_if_reached
#define return1_if_reached()
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1)
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1)
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2)
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2)
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1)
#endif

#ifndef return_if_fail
#define return_if_fail(A1)
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1)
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1)
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1)
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2)
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2)
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4)
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5)
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1)
#endif

#ifndef return_if_null
#define return_if_null(A1)
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2)
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2)
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1)
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1)
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2)
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2)
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1)
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2)
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2)
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1)
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M)
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_if_reached
#define return_if_reached()
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1)
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1)
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2)
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2)
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2)
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1)
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1)
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1)
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1)
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1)
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1)
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1)
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1)
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1)
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M)
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached()
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1)
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1)
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2)
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2)
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1)
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O)
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1)
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1)
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1)
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1)
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O)
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O)
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2)
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1)
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1)
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1)
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1)
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O)
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3)
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1)
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O)
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1)
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1)
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2)
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3)
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2)
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1)
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1)
#endif

#endif /* !defined(ASSERT_IS_BROKEN) */


/* Check that VECTOR_CHAR_P_ALLOW_NULL and ERWIN_THREAD_SAFE are not used at
 * the same time.  It is not possible to do that since the error code is
 * stored in the data structure.  If the pointer to that is NULL, no error
 * codes can be returned. */
#if VECTOR_CHAR_P_ALLOW_NULL && defined(ERWIN_THREAD_SAFE)
#error "Cannot use VECTOR_CHAR_P_ALLOW_NULL and ERWIN_THREAD_SAFE at the same time."
#endif

#ifdef ERWIN_VERBOSE
#  define errstream    ERWIN_ERROR_STREAM
#  define errprint(X)  ((void)(ERWIN_ERROR_PRINT X))
#else
#  define errstream
#  define errprint(X)  ((void)0)
#endif

#define E_MAX_REP        16
#define E_HELP_BUFF_SIZE 256

#ifdef __cplusplus
    /* Theoretically, we *must* use operator new/delete in C++, otherwise, key
     * and value members might not be correctly initialised when stored unboxed.
     *
     * Unfortunately, reallocate is not available (for good reasons, btw), so
     * we use a mixed mode C/C++ memory allocation model.  All the structures
     * that do not need resizing use the native model, all others always use
     * the C model.  For this model, we need OCONSTRUCTOR and ODESTRUCTOR to
     * correctly initialise data structures.
     *
     * NOTE: This model assumes that there are no pointers to yourself in your
     *       data structures!  It is quite instable, it works for Erwin data
     *       structures but might not work for others.  Be extremely careful
     *       and try to always use pointers instead, as they are more stable.
     *
     * The only thing that needs reallocation, btw, is TABLE(self).
     */


#endif

/*
 * #define thing_new(t)               (new t)
 * #define thing_free(x)              delete (x)
 *
 * We must not use new and delete even if we compile this in C++ since
 * the functions that invoke new/delete are the C language
 * allocator/deallocator functions vector_char_p_new/vector_char_p_delete.  If
 * we used new/delete there, these would in turn invoke the C++
 * con-/destructors, which is badly wrong: we would e.g. try to
 * allocate and deallocate the table twice!
 *
 * So: in C, we use thing_new/thing_delete and invoke the C con-/destructors
 *     vector_char_p_init/vector_char_p_destroy manually.
 *     in C++, C++ handles allocation and the C++ con-/destructors invoke
 *     the C level functions _init/_delete.
 */

#if VECTOR_CHAR_P_DYN_ZERO
#    define ZERO(SELF)    ((SELF)->m_zero)
#  define ZEROVAR(SELF) ((SELF)->m_zero)
#else
#    define ZERO(SELF)    OZERO
#    define ZEROVAR(SELF) OZERO
#endif

#if VECTOR_CHAR_P_C_MM

#  define VECTOR_CHAR_P_NEW                    ERWIN_TMALLOC1
#  define VECTOR_CHAR_P_DELETE                 ERWIN_TFREE1

#  if defined(CHAR_P_IS_PTR) && !CHAR_P_IS_PTR
#    define VECTOR_CHAR_P_NEW_ARRAY            ERWIN_TMALLOC_ATOMS
#    define VECTOR_CHAR_P_DELETE_ARRAY         ERWIN_TFREE_ATOMS
#ifdef ERWIN_TREALLOC_ATOMS
#    define VECTOR_CHAR_P_RENEW_ARRAY          ERWIN_TREALLOC_ATOMS
#endif /* defined ERWIN_TREALLOC_ATOMS */
#  else
#    define VECTOR_CHAR_P_NEW_ARRAY            ERWIN_TMALLOC_ARRAY
#    define VECTOR_CHAR_P_DELETE_ARRAY         ERWIN_TFREE_ARRAY
#ifdef ERWIN_TREALLOC_ARRAY
#    define VECTOR_CHAR_P_RENEW_ARRAY          ERWIN_TREALLOC_ARRAY
#endif /* defined ERWIN_TREALLOC_ARRAY */
#  endif

#else

#  define VECTOR_CHAR_P_NEW                    ERWIN_THING_NEW1
#  define VECTOR_CHAR_P_DELETE                 ERWIN_THING_DELETE1

#  if defined(CHAR_P_IS_PTR) && !CHAR_P_IS_PTR
#    define VECTOR_CHAR_P_NEW_ARRAY            ERWIN_THING_NEW_ATOMS
#    define VECTOR_CHAR_P_DELETE_ARRAY         ERWIN_THING_DELETE_ATOMS
#ifdef ERWIN_THING_RENEW_ATOMS
#    define VECTOR_CHAR_P_RENEW_ARRAY          ERWIN_THING_RENEW_ATOMS
#endif /* defined ERWIN_THING_RENEW_ATOMS */
#  else
#    define VECTOR_CHAR_P_NEW_ARRAY            ERWIN_THING_NEW_ARRAY
#    define VECTOR_CHAR_P_DELETE_ARRAY         ERWIN_THING_DELETE_ARRAY
#ifdef ERWIN_THING_RENEW_ARRAY
#    define VECTOR_CHAR_P_RENEW_ARRAY          ERWIN_THING_RENEW_ARRAY
#endif /* defined ERWIN_THING_RENEW_ARRAY */
#  endif

#endif

#if VECTOR_CHAR_P_LOW_MEM

#  define VECTOR_CHAR_P_SOME_BIGGER_NUMBER(X)  erwin_next_power2_minus1(X)

#  define VECTOR_CHAR_P_ALIGN_TABLESIZE(X) \
             do { (X)= VECTOR_CHAR_P_SOME_BIGGER_NUMBER(X); } while(0)

#  define VECTOR_CHAR_P_GET_TABLESIZE(X) \
             ((vector_char_p_cnt_t)VECTOR_CHAR_P_SOME_BIGGER_NUMBER (CLAMP_MINIMAL((X)->m_nentries+1)))
          /* Ensure that one additional element can always be stored in the
           * vector by using nentries+1.  This is needed for nth_char and as_array. */

#  define VECTOR_CHAR_P_SET_TABLESIZE(X,Y) do {} while(0)

#else

#  define VECTOR_CHAR_P_ALIGN_TABLESIZE(X) do {} while(0)
#  define VECTOR_CHAR_P_GET_TABLESIZE(X)   ((X)->m_tablesize)
#  define VECTOR_CHAR_P_SET_TABLESIZE(X,Y) do { (X)->m_tablesize= (Y); } while(0)

#endif

#define IS_ZERO(X,SELF)   (OEQUAL((X),ZERO(SELF)))
#define ISNT_ZERO(X,SELF) (!IS_ZERO(X,SELF))

#define EXTEND_X(out_u,out_s,data,input_size,unsigned_p)                   \
        ((unsigned_p) ?                                                    \
            (out_u)(ERWIN_CONCAT_TOKEN(ERWIN_UB,input_size))(data)         \
        :   (out_u)(out_s)(ERWIN_CONCAT_TOKEN(ERWIN_SB,input_size))(data))

#define EXTEND(data,size,up)   EXTEND_X(unsigned long,            signed long,     data, size, up)
#define EXTEND_L(data,size,up) EXTEND_X(ERWIN_UNSIGNED_LONG_LONG, ERWIN_LONG_LONG, data, size, up)

/* ******************************************************************************** */

#if VECTOR_CHAR_P_NOMEM_IS_FATAL
#define VECTOR_NOMEM        error_exit_if_reached_pt("Fatal: Memory exhausted.")
#else
#define VECTOR_NOMEM        SET_ERRNO(E_NOMEM)
#endif

#if VECTOR_CHAR_P_OUTOFRANGE_IS_FATAL

#  define vector_char_p_if_outofrange(X)                                \
          error_exit_unless_fail_pt (X, "Fatal: Out Of Range."); \
          if (0)

#  define vector_char_p_if_outofrange_minmax(X,I,N)                             \
          error_exit_unless_fail_ptii (X, "Fatal: Out Of Range.", I, N); \
          if (0)

#  define vector_char_p_if_outofrange_min(X,I)                              \
          error_exit_unless_fail_pti (X, "Fatal: Out Of Range.", I); \
          if (0)

#elif VECTOR_CHAR_P_RANGE_CHECK
#  define vector_char_p_if_outofrange(X)             if (ERWIN_UNLIKELY(X))
#  define vector_char_p_if_outofrange_minmax(X,I,N)  if (ERWIN_UNLIKELY(X))
#  define vector_char_p_if_outofrange_min(X,I)       if (ERWIN_UNLIKELY(X))
#else
#  define vector_char_p_if_outofrange(X)             if (0)
#  define vector_char_p_if_outofrange_minmax(X,I,N)  if (0)
#  define vector_char_p_if_outofrange_min(X,I)       if (0)
#endif


/* ********************************************************************** */

#if !defined(CHAR_P_UPDATE_POS)

#  define VECTOR_CHAR_P_UPDATE_POS_SET(SELF, I)
#  define VECTOR_CHAR_P_UPDATE_POS_SET_MANY(SELF, A, N)

#  define VECTOR_CHAR_P_UPDATE_POS_RESET(SELF, I)
#  define VECTOR_CHAR_P_UPDATE_POS_RESET_MANY(SELF, A, N)

#  define VECTOR_CHAR_P_UPDATE_POS_SET2(SELF, I1, V1, I2, V2)

#else

#  define VECTOR_CHAR_P_UPDATE_POS_SET(SELF, I)                           \
          do {                                                     \
              CHAR_P_UPDATE_POS(SELF, &(TABLE(SELF)[I]), I); \
          } while(0)

#  define VECTOR_CHAR_P_UPDATE_POS_RESET(SELF, I)                          \
          do {                                                      \
              CHAR_P_UPDATE_POS(SELF, &(TABLE(SELF)[I]), -1); \
          } while(0)

#  define VECTOR_CHAR_P_UPDATE_POS_SET_MANY(SELF, I0, IN)        \
          do {                                            \
              vector_char_p_index_t i;                           \
              for (i=(I0); i < (vector_char_p_index_t)(IN); i++) \
                  VECTOR_CHAR_P_UPDATE_POS_SET(SELF, i);         \
          } while(0)

#  define VECTOR_CHAR_P_UPDATE_POS_RESET_MANY(SELF, I0, IN)      \
          do {                                            \
              vector_char_p_index_t i;                           \
              for (i=(I0); i < (vector_char_p_index_t)(IN); i++) \
                  VECTOR_CHAR_P_UPDATE_POS_RESET(SELF, i);       \
          } while(0)

#  if !defined(CHAR_P_UPDATE_POS2)

#    define VECTOR_CHAR_P_UPDATE_POS_SET2(SELF, I1, V1, I2, V2) \
            do {                                         \
                VECTOR_CHAR_P_UPDATE_POS_SET(SELF, I1);         \
                VECTOR_CHAR_P_UPDATE_POS_SET(SELF, I2);         \
            } while(0)

#  else

#    define VECTOR_CHAR_P_UPDATE_POS_SET2(SELF, I1, V1, I2, V2)                   \
            do {                                                           \
                CHAR_P_UPDATE_POS2(                                  \
                    SELF, &(TABLE(SELF)[I1]), V1, &(TABLE(SELF)[I2]), V2); \
            } while(0)

#  endif

#endif

#if VECTOR_CHAR_P_POSITION_POINTER && !VECTOR_CHAR_P_MANUAL_POSITION
#    define POS(SELF)             ((SELF)->m_pos)
#    define SET_POS(SELF,N)       do{ (SELF)->m_pos= (N); }while(0)
#    define ADD_POS_AT(SELF,A,N)  do{ if ((A)<POS(SELF)) SET_POS(SELF, POS(SELF) + (N)); }while(0)
#    define SUB_POS_AT(SELF,A,N)  do{ if ((A)<POS(SELF)) SET_POS(SELF, POS(SELF) - (N)); }while(0)
#else
#    define POS(SELF)             0
#    define SET_POS(SELF,N)       do{}while(0)
#    define ADD_POS(SELF,N)       do{}while(0)
#    define SUB_POS(SELF,N)       do{}while(0)
#    define ADD_POS_AT(SELF,A,N)  do{}while(0)
#    define SUB_POS_AT(SELF,A,N)  do{}while(0)
#endif


#define VECTOR_CHAR_P_UPDATE_POS_INSERT(SELF, I)   \
        do {                                \
            ADD_POS_AT(SELF, I, 1);         \
            VECTOR_CHAR_P_UPDATE_POS_SET(SELF, I); \
        }while(0)

#define VECTOR_CHAR_P_UPDATE_POS_INSERT_MANY(SELF, I0, IN)   \
        do {                                          \
            ADD_POS_AT(SELF, I0, (IN)-(I0));          \
            VECTOR_CHAR_P_UPDATE_POS_SET_MANY(SELF, I0, IN); \
        }while(0)

#define VECTOR_CHAR_P_UPDATE_POS_ERASE(SELF, I)      \
        do {                                  \
            VECTOR_CHAR_P_UPDATE_POS_RESET(SELF, I); \
            SUB_POS_AT(SELF, I, 1);           \
        }while(0)

#define VECTOR_CHAR_P_UPDATE_POS_ERASE_MANY(SELF, I0, IN)      \
        do {                                            \
            VECTOR_CHAR_P_UPDATE_POS_RESET_MANY(SELF, I0, IN); \
            SUB_POS_AT(SELF, I0, (IN)-(I0));            \
        }while(0)

/* ******************************************************************************** */

#define VECTOR_CHAR_P_EQ_USE_ARG(X) X != ERWIN_FALSE
#define vector_char_p_overwrite_copy_aux_q(A,B,C,D,E)    vector_char_p_overwrite_copy_aux(A,B,C,D,E)
#define vector_char_p_overwrite_no_copy_aux_q(A,B,C,D,E) vector_char_p_overwrite_no_copy_aux(A,B,C,D,E)
#define vector_char_p_erase_aux_q(A,B,C,D,E)             vector_char_p_erase_aux(A,B,C,D,E)
#define vector_char_p_erase_flags_q(A,B,C,D,E)           vector_char_p_erase_flags(A,B,C,D,E)
#define vector_char_p_erase_if_flags_q(A,B,C,D,E)        vector_char_p_erase_if_flags(A,B,C,D,E)
#define vector_char_p_swap_erase_aux_q(A,B,C,D,E)        vector_char_p_swap_erase_aux(A,B,C,D,E)
#define vector_char_p_swap_erase_flags_q(A,B,C,D,E)      vector_char_p_swap_erase_flags(A,B,C,D,E)
#define vector_char_p_swap_erase_if_flags_q(A,B,C,D,E)   vector_char_p_swap_erase_if_flags(A,B,C,D,E)
#define vector_char_p_chop_flags_q(A,B,C,D)              vector_char_p_chop_flags(A,B,C,D)

#if VECTOR_CHAR_P_DYN_ZERO
#  define vector_char_p_init_internal_q(SE,Z,SI)         vector_char_p_init_internal(SE,Z,SI)
#  define vector_char_p_init_from_q(SE,C,S,A,Z)          vector_char_p_init_from_aux(SE,C,S,A,Z)
#else
#  define vector_char_p_init_internal_q(SE,Z,SI)         vector_char_p_init_internal(SE,SI)
#  define vector_char_p_init_from_q(SE,C,S,A,Z)          vector_char_p_init_from_aux(SE,C,S,A)
#endif

#define VECTOR_CHAR_P_DIGIT_SHR_AND(X,N,B) \
          ((char *)(unsigned char)vector_char_p_hex_digit[(((unsigned Tchar)(X)) >> ((B)*(N))) & ((1U<<(B))-1)])

#define VECTOR_CHAR_P_HEX_DIGIT(X,N) VECTOR_CHAR_P_DIGIT_SHR_AND(X,N,4)
#define VECTOR_CHAR_P_OCT_DIGIT(X,N) VECTOR_CHAR_P_DIGIT_SHR_AND(X,N,3)
#define VECTOR_CHAR_P_BIN_DIGIT(X,N) VECTOR_CHAR_P_DIGIT_SHR_AND(X,N,1)


/* ******************************************************************************** */
/* ******************************************************************************** */

static
int vector_char_p_dummy_table;
    /* THREAD SAFE: never written, just a dummy */

#ifdef TYPE_INFO_T

static
TYPE_STRUCT_T(vector_char_p_t)=
    TYPE_STRUCT_BEGIN(vector_char_p_t)
#ifdef  VECTOR_CHAR_P_SUPER_TYPE
        TYPE_SUPER(vector_char_p_t, VECTOR_CHAR_P_SUPER_CLASS),
#endif
        VECTOR_CHAR_P_TYPE_INFO_STD_MEMBERS
        vector_char_p_record_sig       (TYPE_STRUCT_SLOT (vector_char_p_t, int,              m_sig))
        vector_char_p_record_table     (TYPE_STRUCT_SLOT (vector_char_p_t, vector_char_p_content_p, m_table))
        vector_char_p_record_tablesize (TYPE_STRUCT_SLOT (vector_char_p_t, vector_char_p_size_t,    m_tablesize))
        vector_char_p_record_nentries  (TYPE_STRUCT_SLOT (vector_char_p_t, vector_char_p_size_t,    m_nentries))
        vector_char_p_record_pos       (TYPE_STRUCT_SLOT (vector_char_p_t, vector_char_p_index_t,   m_pos))
        vector_char_p_record_errno     (TYPE_STRUCT_SLOT (vector_char_p_t, int,              m_errno))
        vector_char_p_record_zero      (TYPE_STRUCT_SLOT (vector_char_p_t, char_p,  m_zero))
    TYPE_STRUCT_END
;


TYPE_INFO_T(vector_char_p_size_t)= TYPE_INFO_UINT (vector_char_p_size_t);


TYPE_INFO_T(vector_char_p_cnt_t)= TYPE_INFO_SINT (vector_char_p_cnt_t);


TYPE_INFO_T(vector_char_p_index_t)= TYPE_INFO_SINT (vector_char_p_index_t);


TYPE_INFO_T(vector_char_p_t)= TYPE_INFO_STRUCT (vector_char_p_t, vector_char_p_t);


TYPE_INFO_T(vector_char_p_t_p)= TYPE_INFO_POINTER (vector_char_p_t *, vector_char_p_t);


TYPE_INFO_T(vector_char_p_t_const_p)= TYPE_INFO_POINTER (vector_char_p_t const *, vector_char_p_t);


TYPE_INFO_T(vector_char_p_content)=
    TYPE_INFO_VECTOR (vector_char_p_content, char_p, vector_char_p_t, m_nentries);


TYPE_INFO_T(vector_char_p_content_p)= TYPE_INFO_POINTER (vector_char_p_content *, vector_char_p_content);

#endif /* defined(TYPE_INFO_T) */

#if !E_GLOBAL_ERRNO
CODE_SECTION(".text.errno")
int vector_char_p_errno
        (vector_char_p_t const *self)
{
    return_val_if_null_or_bad (self, VECTOR_ERR_ASSERTIONFAILED);
    return e_errno;
}

CODE_SECTION(".text.clear_errno")
void vector_char_p_clear_errno
        (vector_char_p_t const *self)
{
    return_if_bad (self);
    SET_ERRNO(E_OK);
}
#endif /* !E_GLOBAL_ERRNO */

ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_internal_q")
E_BOOL vector_char_p_init_internal_q
        (vector_char_p_t *self, char *  zero, vector_char_p_cnt_t size)
{
#ifndef NDEBUG
    int err;
    static int tested= 0;
        /* This is not threadsafe, but at worst, each thread makes its own
         * checks instead of the program performing one global test.
         * We're not running into inconsistent states, so that's ok.
         * The 'tested=1' code is at the very end to ensure that task
         * switches don't prevent any test to be performed (there are
         * two if-statements that can come to different opinions about
         * the state of 'tested' in one thread). */
#endif

    SET_ERRNO(E_OK);

    if (ERWIN_UNLIKELY(size < 0 || !VALID_SIZE(size)))
        size= CLAMP_MINIMAL(0);

    VECTOR_CHAR_P_ALIGN_TABLESIZE (size);

    vector_char_p_record_sig (self->m_sig= VECTOR_CHAR_P_SIG);

#if VECTOR_CHAR_P_INLINE_STORE

    if (size > VECTOR_CHAR_P_INLINE_CNT) {
        E_SET_PTR(self->m_table, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, size));

        if (ERWIN_UNLIKELY(self->m_table == NULL)) {
            VECTOR_NOMEM;
            return E_FALSE;
        }

        VECTOR_CHAR_P_SET_TABLESIZE (self, size);
    }
    else {
        VECTOR_CHAR_P_SET_TABLESIZE (self, VECTOR_CHAR_P_INLINE_CNT);
            /* Mark table as non-allocated. */
            /* With LOW_MEM, this is a nop (and thus correct). */
    }

#else /* !INLINE_STORE */

#if VECTOR_CHAR_P_ZERO_SIZE
    if (size == 0)
        E_SET_PTR(self->m_table, VECTOR_CHAR_P_DUMMY_TABLE);
    else
        E_SET_PTR(self->m_table, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, size));
#else /* !ZERO_SIZE */
    if (size <= 0)
        size= 1;
    E_SET_PTR(self->m_table, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, size));
#endif

    if (ERWIN_UNLIKELY(TABLE(self) == NULL)) {
        VECTOR_NOMEM;
        return E_FALSE;
    }

    VECTOR_CHAR_P_SET_TABLESIZE (self, size);

#endif /* !INLINE_STORE */


#if defined(OCONSTRUCTOR) && VECTOR_CHAR_P_C_MM
    /* C model for table */
    {
        vector_char_p_cnt_t i;
        for (i=0; i < size; i++)
            OCONSTRUCTOR (TABLE(self)[i]);
    }
#endif


#if VECTOR_CHAR_P_DYN_ZERO
#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        return0_if_crash_ppt (
            (void)OCOPY (zero, NULL),
            self,
            "OCOPY crashes for zero element when ERR is NULL.");
    }
#endif

    E_SET_VALUE (self->m_zero, OCOPY (zero, NULL));
#endif /* DYN_ZERO */

    self->m_nentries= 0;
    SET_POS (self, 0);

#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        /* Check copying (typical bugs). */
        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), &err),
            self,
            "OCOPY crashes for zero element.");

        return0_if_fail_ppt  (
            OEQUAL (OCOPY (ZERO (self), &err), ZERO (self)),
            self,
            "OCOPY must not copy zero element.");

        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), NULL),
            self,
            "OCOPY crashes when ERR is NULL.");

        return0_if_crash_ppt (
            OFREE (OCOPY (ZERO (self), &err)),
            self,
            "OFREE crashes for zero element.");

        err= 0;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 0,
            self,
            "OCOPY seems to set error flag for zero element",
            err);

        err= 17;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 17,
            self,
            "OCOPY seems to overwrite error flag for zero element (the previous value of 17 was destroyed)",
            err);

        return0_if_fail_ppii (sizeof(vector_char_p_size_t) <= sizeof(vector_char_p_cnt_t),
           self,
           sizeof(vector_char_p_size_t), sizeof(vector_char_p_cnt_t));

        return0_if_fail_ppii (sizeof(vector_char_p_index_t) == sizeof(vector_char_p_cnt_t),
           self,
           sizeof(vector_char_p_index_t), sizeof(vector_char_p_cnt_t));

        tested= 1;
    }
#endif

    return E_TRUE;
}

CODE_SECTION(".text.init")
int vector_char_p_init
        (vector_char_p_t *self)
{
    vector_char_p_init_internal_q (self, OZERO, GET_INITIAL_SIZE);
    return e_errno;
}

CODE_SECTION(".text.init_with_initial_size")
int vector_char_p_init_with_initial_size
        (vector_char_p_t *self, vector_char_p_cnt_t size)
{
    vector_char_p_init_internal_q (self, OZERO, size);
    return e_errno;
}

#if VECTOR_CHAR_P_DYN_ZERO
CODE_SECTION(".text.init_with_zero_and_initial_size")
int vector_char_p_init_with_zero_and_initial_size
        (vector_char_p_t *self, char *  zero, vector_char_p_cnt_t size)
{
    vector_char_p_init_internal_q (self, zero, size);
    return e_errno;
}
#endif /* VECTOR_CHAR_P_DYN_ZERO */

CODE_SECTION(".text.delete_array")
void vector_char_p_delete_array
        (vector_char_p_element_ptr_t array)
{
    /* No special case for VECTOR_CHAR_P_INLINE_STORE, because those arrays
     * allowed to be deleted with this functions will be assured to
     * be allocated on the heap. */

#if VECTOR_CHAR_P_ZERO_SIZE
    if (array == VECTOR_CHAR_P_DUMMY_TABLE)
        return;
#endif

    VECTOR_CHAR_P_DELETE_ARRAY (array);
}

CODE_SECTION(".text.detach")
void vector_char_p_detach
        (vector_char_p_t *self)
{
    return_if_null2i_or_bad (self);

    VECTOR_CHAR_P_UPDATE_POS_ERASE_MANY(self, 0, self->m_nentries);
    SET_POS (self, 0); /* really reset to 0 */

    self->m_nentries= 0;

    /* C model for table */
#if VECTOR_CHAR_P_INLINE_STORE
    E_SET_PTR (self->m_table, NULL); /* just to be sure to overwrite a dangling pointer */
    VECTOR_CHAR_P_SET_TABLESIZE (self, VECTOR_CHAR_P_INLINE_CNT);
#elif VECTOR_CHAR_P_ZERO_SIZE
    E_SET_PTR (self->m_table, VECTOR_CHAR_P_DUMMY_TABLE);
    VECTOR_CHAR_P_SET_TABLESIZE (self, 0);
#else
    E_SET_PTR (self->m_table, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, 1));
    VECTOR_CHAR_P_SET_TABLESIZE (self, 1);

#if defined(OCONSTRUCTOR) && VECTOR_CHAR_P_C_MM
    OCONSTRUCTOR (TABLE(self)[0]);
#endif

#endif
}

CODE_SECTION(".text.detach_as_is")
void vector_char_p_detach_as_is
        (vector_char_p_t *self)
{
    return_if_null2i_or_bad (self);

    self->m_nentries= 0;
    SET_POS (self, 0);

    /* C model for table */
#if VECTOR_CHAR_P_INLINE_STORE
    E_SET_PTR (self->m_table, NULL); /* just to be sure to overwrite a dangling pointer */
    VECTOR_CHAR_P_SET_TABLESIZE (self, VECTOR_CHAR_P_INLINE_CNT);
#elif VECTOR_CHAR_P_ZERO_SIZE
    E_SET_PTR(self->m_table, VECTOR_CHAR_P_DUMMY_TABLE);
    VECTOR_CHAR_P_SET_TABLESIZE (self, 0);
#else
    E_SET_PTR(self->m_table, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, 1));
    VECTOR_CHAR_P_SET_TABLESIZE (self, 1);

#if defined(OCONSTRUCTOR) && VECTOR_CHAR_P_C_MM
    OCONSTRUCTOR (TABLE(self)[0]);
#endif

#endif
}


#if VECTOR_CHAR_P_DYN_ZERO
CODE_SECTION(".text.new_with_zero_and_initial_size")
vector_char_p_t * vector_char_p_new_with_zero_and_initial_size
        (char *  zero, vector_char_p_cnt_t size)
{
    vector_char_p_t *self;
    E_SET_PTR(self, VECTOR_CHAR_P_NEW (vector_char_p_t));
    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(vector_char_p_init_internal_q (self, zero, size)))
       return self;

    VECTOR_CHAR_P_DELETE (self, vector_char_p_t);
    return NULL;
}

CODE_SECTION(".text.new_with_zero")
vector_char_p_t * vector_char_p_new_with_zero
        (char *  zero)
{
    return vector_char_p_new_with_zero_and_initial_size (zero, GET_INITIAL_SIZE);
}
#endif /* VECTOR_CHAR_P_DYN_ZERO */


#if VECTOR_CHAR_P_CONSTANT_ZERO
#  define vector_char_p_new_with_zero_and_initial_size(Z,S) vector_char_p_new_with_initial_size(S)
#  define vector_char_p_new_with_zero(Z)                    vector_char_p_new()
#endif


CODE_SECTION(".text.new_with_initial_size")
vector_char_p_t * vector_char_p_new_with_initial_size
        (vector_char_p_cnt_t size)
{
    vector_char_p_t *self;
    E_SET_PTR(self, VECTOR_CHAR_P_NEW (vector_char_p_t));

    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(vector_char_p_init_internal_q (self, OZERO, size)))
        return self;

    VECTOR_CHAR_P_DELETE (self, vector_char_p_t);
    return NULL;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_from_q")
E_BOOL vector_char_p_init_from_q
        (
    vector_char_p_t *self, char * *contents, vector_char_p_cnt_t nentries, vector_char_p_cnt_t allocsize, char *  zero)
{
    if (allocsize < nentries)
        allocsize= nentries;

    /* We don't align the allocsize here since this is done in vector_char_p_init_internal_q,
     * and we do only store it here, which needs no alignment (since when
     * alignment is done, it is not stored). */

    if (contents == NULL || allocsize == 0)
        return vector_char_p_init_internal_q (self, OZERO, allocsize);

    vector_char_p_record_sig (self->m_sig= VECTOR_CHAR_P_SIG);
    SET_POS (self, 0);

    return_val_if_fail_ppi (VALID_SIZE (nentries), E_FALSE, self, nentries);
    self->m_nentries=  nentries;
    VECTOR_CHAR_P_SET_TABLESIZE (self, allocsize);

#if VECTOR_CHAR_P_INLINE_STORE
    if (HAS_HEAP_TABLE(self))
        E_SET_PTR(self->m_table, contents);
    else {
        vector_char_p_cnt_t i;
        for (i=0; i < nentries; i++)
            E_SET_VALUE (TABLE(self)[i], contents[i]);
    }
#else
    E_SET_PTR(TABLE(self), contents);
#endif


#if VECTOR_CHAR_P_DYN_ZERO
    E_SET_VALUE (self->m_zero, OCOPY (zero, NULL));
#endif
    SET_ERRNO(E_OK);

    VECTOR_CHAR_P_UPDATE_POS_INSERT_MANY(self, 0, nentries);

    return E_TRUE;
}

CODE_SECTION(".text.new_from_raw")
vector_char_p_t * vector_char_p_new_from_raw
        (char * *contents, vector_char_p_cnt_t nentries, vector_char_p_cnt_t allocsize)
{
    vector_char_p_t *self;
    E_SET_PTR(self, VECTOR_CHAR_P_NEW (vector_char_p_t));
    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(vector_char_p_init_from_q (self, contents, nentries, allocsize, OZERO)))
        return self;

    VECTOR_CHAR_P_DELETE (self, vector_char_p_t);
    return NULL;
}

#if VECTOR_CHAR_P_DYN_ZERO
CODE_SECTION(".text.new_from_raw_with_zero")
vector_char_p_t * vector_char_p_new_from_raw_with_zero
        (char * *contents, vector_char_p_cnt_t nentries, vector_char_p_cnt_t allocsize, char *  zero)
{
    vector_char_p_t *self;
    E_SET_PTR(self, VECTOR_CHAR_P_NEW (vector_char_p_t));

    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }
    
    if (ERWIN_LIKELY(vector_char_p_init_from_q (self, contents, nentries, allocsize, zero)))
        return self;

    VECTOR_CHAR_P_DELETE(self, vector_char_p_t);
    return NULL;
}
#endif /* VECTOR_CHAR_P_DYN_ZERO */

CODE_SECTION(".text.new_from_vector")
vector_char_p_t * vector_char_p_new_from_vector
        (vector_char_p_t *other)
{
    vector_char_p_t *self;
    vector_char_p_size_t ts;

    if (other == NULL)
        return vector_char_p_new ();

    E_SET_PTR(self, VECTOR_CHAR_P_NEW (vector_char_p_t));
    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

#if VECTOR_CHAR_P_LOW_MEM       
    ts= other->m_nentries;   /* will be aligned later */
#else
    ts= other->m_tablesize;
#endif
    if (ERWIN_LIKELY(
            vector_char_p_init_from_q (self,
                TABLE(other),
                other->m_nentries,
                ts,
                other->m_zero)))
    {
        vector_char_p_detach_as_is (other);
            /* The position has not changed: it was exported from vector to vector,
             * so use _as_is version */
        return self;
    }

    VECTOR_CHAR_P_DELETE (self, vector_char_p_t);
    return NULL;
}

CODE_SECTION(".text.new")
vector_char_p_t * vector_char_p_new
        (void)
{
    return vector_char_p_new_with_initial_size (GET_INITIAL_SIZE);
}

CODE_SECTION(".text.zero")
o_type_result_t vector_char_p_zero
        (vector_char_p_t const *self)
{
    (void)self; /*unused*/

    return ZERO(self);
}

/* #define COPY_SIZE(X) (X->m_tablesize) */
        /* This is a bad idea! (E.g. if you have a non-shrinking global variable
         * as a buffer which you copy from time to time, the copies will always
         * allocate as much memory as the longest previous vector.  That's too
         * bad. */

/* #define COPY_SIZE(X) (X->m_nentries) */
        /* According to a good heuristics, as_array() will be called next, so
         * we'll use the following version that adds one: */

#define COPY_SIZE(X) ((X)->m_nentries+1)
        /* I hope this is the best solution */

CODE_SECTION(".text.copy")
vector_char_p_t * vector_char_p_copy
        (vector_char_p_t const* self)
{
    vector_char_p_t *copy;
    if (self == NULL) { /* copy() *must* be NULL safe!  Regardless of VECTOR_CHAR_P_ALLOW_NULL. */
        SET_ERRNO(E_OK);
        return NULL;
    }

    return0_if_null2i_or_bad (self);

    E_SET_PTR(copy, vector_char_p_new_with_zero_and_initial_size (ZERO(self), COPY_SIZE (self)));
    vector_char_p_insert_vector (copy, 0, self);

    return copy;
}

CODE_SECTION(".text.copy_err")
vector_char_p_t * vector_char_p_copy_err
        (vector_char_p_t const* self, int *err)
{
    vector_char_p_t *copy;
    E_SET_PTR(copy, vector_char_p_copy (self));

    if (ERWIN_UNLIKELY(err != NULL && e_errno != E_OK))
        *err= 1;

    return copy;
}

CODE_SECTION(".text.table_size")
vector_char_p_cnt_t vector_char_p_table_size
        (vector_char_p_t const *self)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return VECTOR_CHAR_P_GET_TABLESIZE (self);
}

CODE_SECTION(".text.nentries")
vector_char_p_cnt_t vector_char_p_nentries
        (vector_char_p_t const *self)
{                 
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return0_if_null (self);
    return self->m_nentries;
}

CODE_SECTION(".text.empty")
E_BOOL vector_char_p_empty
        (vector_char_p_t const *self)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return E_TRUE;
#endif
    return1_if_null (self);
    return ERWIN_TO_BOOL (self->m_nentries == 0);
}

ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.clear_no_resize_aux")
void vector_char_p_clear_no_resize_aux
        (vector_char_p_t *self, vector_char_p_cnt_t new_size)
{
#if OFREE_PROVIDED
    vector_char_p_size_t i;
#endif

    (void)self;     /*unused*/
    (void)new_size; /*unused*/

    VECTOR_CHAR_P_UPDATE_POS_ERASE_MANY (self, new_size, self->m_nentries);

#if OFREE_PROVIDED
    for (i= new_size; i < self->m_nentries; i++) {
        OFREE (TABLE(self)[i]);
    }
#endif
}

CODE_SECTION(".text.xchg")
void vector_char_p_xchg
        (vector_char_p_t *self, vector_char_p_t *other)
{
    vector_char_p_record_table     (ERWIN_XCHG (vector_char_p_content_p, self->m_table,     other->m_table));
    vector_char_p_record_tablesize (ERWIN_XCHG (vector_char_p_size_t,    self->m_tablesize, other->m_tablesize));
    vector_char_p_record_nentries  (ERWIN_XCHG (vector_char_p_size_t,    self->m_nentries,  other->m_nentries));
    vector_char_p_record_pos       (ERWIN_XCHG (vector_char_p_index_t,   self->m_pos,       other->m_pos));
    vector_char_p_record_errno     (ERWIN_XCHG (int,              self->m_errno,     other->m_errno));
    vector_char_p_record_zero      (ERWIN_XCHG (char *,         self->m_zero,      other->m_zero));
}

CODE_SECTION(".text.destroy")
void vector_char_p_destroy
        (vector_char_p_t *self)
{
    if (self == NULL ||
        (TABLE(self) == NULL && self->m_nentries == 0))
        return;
        /* This is all a bit obscure.  In a certain test program, gcc seems to `forget'(?)
         * a constructor call so that operator= is invoked with TABLE(self) and
         * self->m_nentries==0, which is not allowed.  Therefore, we make _destroy() robust
         * against this case which is the first function invoked in operator=.
         *
         * Further, self == NULL should be ok anyway. */

    return_if_null_pp (TABLE(self), self);

    vector_char_p_clear_no_resize_aux (self, 0);

    {
        /* C model for table */
#if defined(ODESTRUCTOR) && VECTOR_CHAR_P_C_MM
        vector_char_p_cnt_t i;
        vector_char_p_cnt_t ts= VECTOR_CHAR_P_GET_TABLESIZE (self);
        for (i=0; i < ts; i++) {
            ODESTRUCTOR (TABLE(self)[i]);
        }
#endif

#if VECTOR_CHAR_P_HAVE_SIG
        self->m_sig= 0;
#endif
        if (HAS_HEAP_TABLE(self))
            VECTOR_CHAR_P_DELETE_ARRAY (TABLE(self));
    }
}

CODE_SECTION(".text.delete")
void vector_char_p_delete
        (vector_char_p_t *self)
{
    if (self == NULL) /* It must handle NULL to be nestable! */
        return;
    return_if_null_or_bad (self);
    vector_char_p_destroy (self);
    VECTOR_CHAR_P_DELETE (self, vector_char_p_t);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.reallocate")
E_BOOL vector_char_p_reallocate
        (vector_char_p_t *self, vector_char_p_cnt_t newtablesize)
/* This is very ugly.  I know.
 * NOTE: newtablesize must be aligned (for LOW_MEM)
 */
{
    vector_char_p_cnt_t oldtablesize=      VECTOR_CHAR_P_GET_TABLESIZE (self);
    E_BOOL       old_is_heap_table= HAS_HEAP_TABLE(self);
    char *    *oldtable;
    char *    *newtable;

    E_SET_PTR(newtable, VECTOR_CHAR_P_DUMMY_TABLE);
    E_SET_PTR(oldtable, TABLE(self));

    (void)oldtablesize; /*unused*/

    if (ERWIN_UNLIKELY(!VALID_SIZE(newtablesize))) {
        SET_ERRNO(E_TOOLARGE);
        return E_FALSE;
    }

    /* C model for table */
#if defined(ODESTRUCTOR) && VECTOR_CHAR_P_C_MM
    {
        vector_char_p_cnt_t i;
        for (i=newtablesize; i < oldtablesize; i++)
            ODESTRUCTOR (oldtable[i]);
    }
#endif

#if VECTOR_CHAR_P_INLINE_STORE
    /* ** INLINE STORE ************************************************** */

    if (newtablesize <= VECTOR_CHAR_P_INLINE_CNT) {
        /* inline,heap > inline */
        newtablesize= VECTOR_CHAR_P_INLINE_CNT; /* this is the minimum */

        VECTOR_CHAR_P_SET_TABLESIZE (self, VECTOR_CHAR_P_INLINE_CNT);
            /* mark missing table: this is no-op for LOW_MEM */

        E_SET_PTR(newtable, INLINE_TABLE(self));

        if (old_is_heap_table) {
            /* heap > inline */
#ifdef VECTOR_CHAR_P_RENEW_ARRAY
            /* If RENEW_ARRAY is not defined, copying is done later anyway. */
            {
                vector_char_p_cnt_t i;
                for (i=0; i < oldtablesize && i < newtablesize; i++)
                    E_SET_VALUE (newtable[i], oldtable[i]);
            }
#endif
            VECTOR_CHAR_P_DELETE_ARRAY (oldtable);
            old_is_heap_table= 0; /* prevent double delete when RENEW_ARRAY exists (see below) */
        }
    }
    else
    if (old_is_heap_table) {
        /* heap > heap: standard operation */
#ifdef VECTOR_CHAR_P_RENEW_ARRAY
        E_SET_PTR(newtable,
            VECTOR_CHAR_P_RENEW_ARRAY (oldtable, vector_char_p_content, newtablesize, oldtablesize));
        old_is_heap_table= 0; /* reallocated => invalidated */
#else
        E_SET_PTR(newtable,
            VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, newtablesize));
#endif

        VECTOR_CHAR_P_SET_TABLESIZE (self, newtablesize);
        E_SET_PTR(self->m_table, newtable);
    }
    else {
        /* inline > heap */
        E_SET_PTR(newtable,
            VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, newtablesize));

#ifdef VECTOR_CHAR_P_RENEW_ARRAY
        /* Copy manually from old inline store to now heap store. */
        /* If RENEW_ARRAY is not defined, copying is done later anyway. */
        {
            vector_char_p_cnt_t i;
            for (i=0; i < oldtablesize && i < newtablesize; i++)
                E_SET_VALUE (newtable[i], oldtable[i]);
        }
#endif

        VECTOR_CHAR_P_SET_TABLESIZE (self, newtablesize);
        E_SET_PTR(self->m_table, newtable);
    }

#elif VECTOR_CHAR_P_ZERO_SIZE
    /* ** ZERO SIZE ***************************************************** */

    if (newtablesize == 0) {
        if (old_is_heap_table) {
            VECTOR_CHAR_P_DELETE_ARRAY (oldtable);
            old_is_heap_table= 0; /* prevent double delete when RENEW_ARRAY exists (see below) */
        }
        E_SET_PTR(newtable, VECTOR_CHAR_P_DUMMY_TABLE);
    }
    else
    if (old_is_heap_table) {
#ifdef VECTOR_CHAR_P_RENEW_ARRAY
        E_SET_PTR(newtable,
            VECTOR_CHAR_P_RENEW_ARRAY (oldtable, vector_char_p_content, newtablesize, oldtablesize));
        old_is_heap_table= 0;
#else
        E_SET_PTR(newtable, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, newtablesize));
#endif
    }
    else
        E_SET_PTR(newtable, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, newtablesize));

    VECTOR_CHAR_P_SET_TABLESIZE (self, newtablesize);
    E_SET_PTR(self->m_table, newtable);

#else /* !ZERO_SIZE */
    /* ** NORMAL MODE *************************************************** */

    return0_if_fail_ppi (newtablesize > 0, self, newtablesize);

    /* FIXME: If the type cannot be realloced (like almost everything),
     *        then use the real C++ method of reallocation: new array,
     *        copy old into new, throw old one away.
     *
     * NOTE: Erwin structures themselves are NOT capable of being copied
     *       like this!  So this is urgent!
     */
#ifdef VECTOR_CHAR_P_RENEW_ARRAY
    E_SET_PTR(newtable,
        VECTOR_CHAR_P_RENEW_ARRAY (oldtable, vector_char_p_content, newtablesize, oldtablesize));
    old_is_heap_table= 0;
#else
//fprintf(stderr, "entering E_SET_PTR\n");
    E_SET_PTR(newtable, VECTOR_CHAR_P_NEW_ARRAY (vector_char_p_content, newtablesize));
//fprintf(stderr, "returned from E_SET_PTR\n");
#endif

    VECTOR_CHAR_P_SET_TABLESIZE (self, newtablesize);
    E_SET_PTR(self->m_table, newtable);

#endif /* !ZERO_SIZE */

    /* ** COMMON CODE: old and new tables are now allocated *************** */

    if (newtable == NULL) {
#if defined(OCONSTRUCTOR) && VECTOR_CHAR_P_C_MM
        {   /* Re-initialise destroyed elements. Unlikely to be performed, though, as
             * out-of-memory errors are expected when growing only. */
            vector_char_p_cnt_t i;
            for (i=newtablesize; i < oldtablesize; i++)
                OCONSTRUCTOR (oldtable[i]);
        }
#endif
        VECTOR_NOMEM;
        return E_FALSE;
    }

#ifndef VECTOR_CHAR_P_RENEW_ARRAY
    /* If we don't have a reallocation, we have to copy the elements manually
     * into the new vector. */
    {
        vector_char_p_cnt_t i;
        for (i=0; i < oldtablesize && i < newtablesize; i++)
            E_SET_VALUE (newtable[i], oldtable[i]);
    }
#endif

#if defined(OCONSTRUCTOR) && VECTOR_CHAR_P_C_MM
    {
        vector_char_p_cnt_t i;
        for (i=self->oldtablesize; i < newtablesize; i++)
            OCONSTRUCTOR (newtable[i]);
    }
#endif

#ifndef VECTOR_CHAR_P_RENEW_ARRAY
    /* If there is no realloc, throw away old vector now, unless it is already gone. */
    if (old_is_heap_table)
        VECTOR_CHAR_P_DELETE_ARRAY (oldtable);
#endif

    return E_TRUE;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.ensure_size_sub_aux_force")
E_BOOL vector_char_p_ensure_size_sub_aux_force
        (vector_char_p_t *self, vector_char_p_cnt_t newsize)
  /* may leave elements uninitialized! */
  /* ensures that SIZE many elements go into THEM without problem. */
{
    vector_char_p_cnt_t tablesize= VECTOR_CHAR_P_GET_TABLESIZE (self);

#if VECTOR_CHAR_P_LOW_MEM
    vector_char_p_cnt_t newtablesize= VECTOR_CHAR_P_SOME_BIGGER_NUMBER (CLAMP_MINIMAL(newsize));
    if (ERWIN_UNLIKELY(tablesize != newtablesize))
        return vector_char_p_reallocate (self, newtablesize);
#else
    /* Does not shrink below size 2 unless newsize == 0. */
    if (ERWIN_UNLIKELY(NEED_SHRINK(newsize, tablesize))) {
        do {
            tablesize>>=1;
#if VECTOR_CHAR_P_ZERO_SIZE || VECTOR_CHAR_P_INLINE_STORE
            if (tablesize == 0)
                break;
#endif
        } while (ERWIN_UNLIKELY(NEED_SHRINK(newsize, tablesize)));
        return0_if_fail (newsize <= tablesize);
        return vector_char_p_reallocate (self, ADJUST_SHRUNK(tablesize));
    }
#endif
    return E_TRUE;
}

#if VECTOR_CHAR_P_AUTO_SHRINK
#  define vector_char_p_ensure_size_sub_aux(A,B) vector_char_p_ensure_size_sub_aux_force(A,B)
#else
#  define vector_char_p_ensure_size_sub_aux(A,B) E_TRUE
#endif

ERWIN_STATIC_INLINE
CODE_SECTION(".text.ensure_size_add_aux")
E_BOOL vector_char_p_ensure_size_add_aux
        (vector_char_p_t *self, vector_char_p_cnt_t newsize)
  /* May leave elements uninitialized! */
  /* Ensures that SIZE many elements go into THEM without problem. */
  /* The 'newsize' is assumed to be the new number of nentries to be set soon,
   * so for LOW_MEM, this *always* resizes, i.e., also shrinks, if the
   * tablesize would be different (because with LOW_MEM, the tablesize is
   * derived from the size).  So for LOW_MEM, you might have special cases
   * if you only want to resize the table without resetting the number of
   * elements.
   */
{
    vector_char_p_cnt_t  tablesize= VECTOR_CHAR_P_GET_TABLESIZE (self);

#if VECTOR_CHAR_P_LOW_MEM
    vector_char_p_cnt_t  newtablesize= VECTOR_CHAR_P_SOME_BIGGER_NUMBER (CLAMP_MINIMAL(newsize));
    if (ERWIN_UNLIKELY(tablesize != newtablesize))
        return vector_char_p_reallocate (self, newtablesize);

#else /* !VECTOR_CHAR_P_LOW_MEM */
    vector_char_p_size_t tn;
    if (ERWIN_UNLIKELY(NEED_GROW(newsize, tablesize))) {
        if (ERWIN_UNLIKELY(!VALID_SIZE(newsize))) {
            SET_ERRNO(E_TOOLARGE);
            return E_FALSE;
        }

#if VECTOR_CHAR_P_ZERO_SIZE || VECTOR_CHAR_P_INLINE_STORE
        if (tablesize == 0) {
            tablesize= 1;
            goto rein;
        }
#endif
        return0_if_fail_ppi (tablesize > 0, self, tablesize);
        do {
            tn= tablesize << 1;

#if !VECTOR_CHAR_P_LOW_MEM && VECTOR_CHAR_P_SIZE_INDEX_DIFF
            /* cull at MAX(vector_char_p_size_t)-1 */
            if (tn < tablesize && tn != ((vector_char_p_size_t)-1))
                tn= ((vector_char_p_size_t)-1);
#endif

            if (ERWIN_UNLIKELY(!VALID_SIZE_GT(tablesize, (vector_char_p_cnt_t)tn))) {
                SET_ERRNO(E_TOOLARGE);
                return E_FALSE;
            }

            tablesize= tn;
#if VECTOR_CHAR_P_ZERO_SIZE || VECTOR_CHAR_P_INLINE_STORE
        rein:;
#endif
        } while (ERWIN_UNLIKELY(NEED_GROW(newsize, tablesize)));
        /* in LOW_MEM mode, tablesize is aligned since we only mul by 2 and assign 1. */
//fprintf(stderr, "entering reallocate\n");
E_BOOL dkb = vector_char_p_reallocate(self, ADJUST_GROWN(tablesize));
//fprintf(stderr, "returned from reallocate %d\n", dkb);
return dkb;


//        return vector_char_p_reallocate(self, ADJUST_GROWN(tablesize));
    }

#endif /* !VECTOR_CHAR_P_LOW_MEM */
    return E_TRUE;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.ensure_size_add_plus")
E_BOOL vector_char_p_ensure_size_add_plus
        (vector_char_p_t *self, vector_char_p_cnt_t newsize, vector_char_p_cnt_t add)
{
   if (ERWIN_UNLIKELY(!VALID_SIZE_PLUS (newsize, add))) {
       SET_ERRNO(E_TOOLARGE);
       return E_FALSE;
   }
   return vector_char_p_ensure_size_add_aux (self, newsize + add);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_tail")
void vector_char_p_init_tail
        (vector_char_p_t *self, vector_char_p_cnt_t newsize)
{
    vector_char_p_cnt_t ii;
    for (ii= self->m_nentries; ii < newsize; ii++)
        E_SET_VALUE (TABLE(self)[ii], ZEROVAR(self));
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.grow_plus")
E_BOOL vector_char_p_grow_plus
        (vector_char_p_t *self, vector_char_p_cnt_t oldsize, vector_char_p_cnt_t plus)
{
    vector_char_p_cnt_t newsize= oldsize + plus;
    if (ERWIN_UNLIKELY(newsize > (vector_char_p_cnt_t)self->m_nentries)) {
        if (ERWIN_UNLIKELY(!vector_char_p_ensure_size_add_plus (self, oldsize, plus)))
            return E_FALSE;

        vector_char_p_init_tail (self, newsize);

        return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
        self->m_nentries= newsize;
    }
    return E_TRUE;
}

CODE_SECTION(".text.ensure_size")
int vector_char_p_ensure_size
        (vector_char_p_t *self, vector_char_p_cnt_t newsize)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    vector_char_p_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (ERWIN_UNLIKELY(newsize > (vector_char_p_cnt_t)self->m_nentries)) {
        if (ERWIN_LIKELY(!vector_char_p_ensure_size_add_aux (self, newsize)))
            return e_errno;

        vector_char_p_init_tail (self, newsize);

        return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
        self->m_nentries= newsize;
    }
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.ensure_size_with")
int vector_char_p_ensure_size_with
        (vector_char_p_t *self, vector_char_p_cnt_t newsize, char *  elem)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    vector_char_p_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_OUTOFRANGE);

    if (ERWIN_UNLIKELY(newsize > (vector_char_p_cnt_t)self->m_nentries))
        return vector_char_p_make_gap_with (self, self->m_nentries, elem, newsize - self->m_nentries);

    return PASS_ERRNO(E_OK);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.setsize_noinit_add")
E_BOOL vector_char_p_setsize_noinit_add
        (vector_char_p_t *self, vector_char_p_cnt_t newsize)
{
    if (ERWIN_LIKELY(!vector_char_p_ensure_size_add_aux (self, newsize)))
        return E_FALSE;
    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return E_TRUE;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.setsize_noinit_sub")
E_BOOL vector_char_p_setsize_noinit_sub
        (vector_char_p_t *self, vector_char_p_cnt_t newsize, E_BOOL resize)
{
    if (resize) {
        if (ERWIN_UNLIKELY(!vector_char_p_ensure_size_sub_aux (self, newsize)))
            return E_FALSE;
    }
    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return E_TRUE;
}

CODE_SECTION(".text.clear")
void vector_char_p_clear
        (vector_char_p_t *self)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    vector_char_p_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
    vector_char_p_ensure_size_sub_aux (self, 0);
}

CODE_SECTION(".text.clear_keep")
void vector_char_p_clear_keep
        (vector_char_p_t *self, vector_char_p_cnt_t min)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    vector_char_p_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
    vector_char_p_ensure_size_sub_aux (self, min);
}

CODE_SECTION(".text.clear_flags")
void vector_char_p_clear_flags
        (vector_char_p_t *self, E_BOOL resize, E_BOOL del)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    if (del)
        vector_char_p_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
    if (resize) vector_char_p_ensure_size_sub_aux (self, 0);
}

CODE_SECTION(".text.clear_no_resize")
void vector_char_p_clear_no_resize
        (vector_char_p_t *self)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    vector_char_p_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
}

CODE_SECTION(".text.modify")
o_type_var_t vector_char_p_modify
        (vector_char_p_t *self, vector_char_p_index_t key, char *  value)
{
    int copyerror= E_FALSE;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE

    vector_char_p_if_outofrange_min (key < 0, key) {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return ZEROVAR(self), "index out of range (1)", key);
    }

    if (ERWIN_UNLIKELY(!vector_char_p_grow_plus (self, key, 1)))
        return ZERO(self);

#else
    vector_char_p_if_outofrange_minmax (
        key < 0 || key >= (vector_char_p_cnt_t)self->m_nentries, key, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return ZEROVAR(self), "index out of range (1)",
            key, self->m_nentries);
    }
#endif

    return_val_if_null_pp (TABLE(self), ZEROVAR(self), self);

    {
        char * valuecopy;
        E_SET_VALUE(valuecopy, OCOPY (value, &copyerror));

        if (ERWIN_LIKELY(copyerror == E_FALSE)) {
            char * result;

            VECTOR_CHAR_P_UPDATE_POS_RESET (self, key);
            E_SET_VALUE (result, TABLE(self)[key]);

            E_SET_VALUE (TABLE(self)[key], valuecopy);
            VECTOR_CHAR_P_UPDATE_POS_SET (self, key);

            SET_ERRNO(E_OK);
            return result;
        }
        else {
            VECTOR_NOMEM;
            return ZEROVAR(self);
        }
    }
}

CODE_SECTION(".text.set")
int vector_char_p_set
        (vector_char_p_t *self, vector_char_p_index_t key, char *  value)
/* table==NULL is ok */
{
    int copyerror= E_FALSE;

    return_val_if_null_or_bad (self, ASSERTION_FAILED);

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (key < 0, key)
    {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return e_errno, "index out of range", key);
    }
    if (ERWIN_UNLIKELY(!vector_char_p_grow_plus (self, key, 1)))
        return e_errno;
#else
    vector_char_p_if_outofrange_minmax (
        key < 0 || key >= (vector_char_p_cnt_t)self->m_nentries, key, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return e_errno, "index out of range",
            key, self->m_nentries);
    }
#endif

    return_val_if_null_pp (TABLE(self), ASSERTION_FAILED, self);

    {
        char * valuecopy;
        E_SET_VALUE (valuecopy, OCOPY (value, &copyerror));

        if (ERWIN_LIKELY(copyerror == E_FALSE)) {
            VECTOR_CHAR_P_UPDATE_POS_RESET (self, key);
            OFREE (TABLE(self)[key]);

            E_SET_VALUE (TABLE(self)[key], valuecopy);
            VECTOR_CHAR_P_UPDATE_POS_SET (self, key);

            return PASS_ERRNO(E_OK);
        }
        else {
            VECTOR_NOMEM;
            return e_errno;
        }
   }
}

CODE_SECTION(".text.swap")
void vector_char_p_swap
        (vector_char_p_t *self, vector_char_p_index_t key1, vector_char_p_index_t key2)
/* table==NULL is ok */
{
    char * help;

    return_if_null_or_bad (self);

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (key1 < 0, key1) {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return, "index out of range", key1);
    }
    vector_char_p_if_outofrange_min (key2 < 0, key2) {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return, "index out of range", key2);
    }

    if (ERWIN_UNLIKELY(!vector_char_p_grow_plus (self, key1, 1) || !vector_char_p_grow_plus (self, key2, 1)))
        return;
#else
    vector_char_p_if_outofrange_minmax (
        key1 < 0 || key1 >= (vector_char_p_cnt_t)self->m_nentries, key1, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return, "index out of range",
            key1, self->m_nentries);
    }
    vector_char_p_if_outofrange_minmax (
        key2 < 0 || key2 >= (vector_char_p_cnt_t)self->m_nentries, key2, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return, "index out of range",
            key2, self->m_nentries);
    }
#endif

    return_if_null_pp (TABLE(self), self);

    E_SET_VALUE (help, TABLE(self)[key1]);
    E_SET_VALUE (TABLE(self)[key1], TABLE(self)[key2]);
    E_SET_VALUE (TABLE(self)[key2], help);
    VECTOR_CHAR_P_UPDATE_POS_SET2 (self, key1, key1, key2, key2);
}

CODE_SECTION(".text.reverse")
void vector_char_p_reverse
        (vector_char_p_t *self)
{
    char * help;
    vector_char_p_index_t i;
    vector_char_p_index_t n1;
    vector_char_p_index_t n_2;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    return_if_null_or_bad (self);

    n1=  self->m_nentries - 1;
    n_2= self->m_nentries / 2;
    for (i=0; i < n_2; i++) {
        E_SET_VALUE (help, TABLE(self)[i]);
        E_SET_VALUE (TABLE(self)[i], TABLE(self)[n1-i]);
        E_SET_VALUE (TABLE(self)[n1-i], help);
        VECTOR_CHAR_P_UPDATE_POS_SET2 (self, i, i, n1-i, n1-i);
    }
}

CODE_SECTION(".text.init_iterator")
void vector_char_p_init_iterator
        (vector_char_p_t const *self, vector_char_p_index_t *key)
{
    (void)self; /*unused*/
    return_if_null_pp (key, self);

    *key= -1; /* if you change this, change the C++ forall macros as well! */
}

CODE_SECTION(".text.next_iteration")
E_BOOL vector_char_p_next_iteration
        (vector_char_p_t const *self, vector_char_p_index_t *key, char * *valuep)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return0_if_null_or_bad (self);
    return0_if_null3_pp3 (TABLE(self), key, valuep, self, key, valuep);

    (*key)++;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (vector_char_p_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_VALUE (*valuep, TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr")
E_BOOL vector_char_p_next_iteration_ptr
        (vector_char_p_t *self, vector_char_p_index_t *key, char * **valuepp)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return0_if_null_or_bad (self);
    return0_if_null3_pp3 (TABLE(self), key, valuepp, self, key, valuepp);

    (*key)++;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (vector_char_p_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_PTR(*valuepp, &TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr_const")
E_BOOL vector_char_p_next_iteration_ptr_const
        (vector_char_p_t const *self, vector_char_p_index_t *key, char * const **valuepp)
{
    return vector_char_p_next_iteration_ptr((vector_char_p_t *)self, key, (char * **)valuepp);
}

CODE_SECTION(".text.init_iterator_reverse")
void vector_char_p_init_iterator_reverse
        (vector_char_p_t const *self, vector_char_p_index_t *key)
{
    return_if_null_pp (key, self);

    *key= self->m_nentries; /* if you change this, change the C++ forall macros as well! */
}

CODE_SECTION(".text.next_iteration_reverse")
E_BOOL vector_char_p_next_iteration_reverse
        (vector_char_p_t const *self, vector_char_p_index_t *key, char * *valuep)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return_val_if_null  (self, E_FALSE);
    return_val_if_null3_pp3 (TABLE(self), key, valuep, E_FALSE, self, key, valuep);

    (*key)--;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (vector_char_p_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_VALUE (*valuep, TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr_reverse")
E_BOOL vector_char_p_next_iteration_ptr_reverse
        (
    vector_char_p_t *self, vector_char_p_index_t *key, char * **valuepp)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return_val_if_null  (self, E_FALSE);
    return_val_if_null3_pp3 (TABLE(self), key, valuepp, E_FALSE, self, key, valuepp);

    (*key)--;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (vector_char_p_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_PTR(*valuepp, &TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr_const_reverse")
E_BOOL vector_char_p_next_iteration_ptr_const_reverse
        (vector_char_p_t const *self, vector_char_p_index_t *key, char * const **valuepp)
{
    return vector_char_p_next_iteration_ptr_reverse((vector_char_p_t *)self, key, (char * **)valuepp);
}


CODE_SECTION(".text.set_size")
int vector_char_p_set_size
        (vector_char_p_t *self, vector_char_p_cnt_t newsize) /* this is user-proof. */
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    vector_char_p_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!vector_char_p_ensure_size_add_aux (self, newsize) ||
        !vector_char_p_ensure_size_sub_aux (self, newsize))
    {
        return e_errno;
    }

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_TOOLARGE);

    vector_char_p_clear_no_resize_aux (self, newsize); /* in case of shrinking */
    vector_char_p_init_tail (self, newsize);           /* in case of growth */

    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.set_size_with")
int vector_char_p_set_size_with
        (vector_char_p_t *self, vector_char_p_cnt_t newsize, char *  elem)
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    if (newsize > (vector_char_p_cnt_t)self->m_nentries)
        return vector_char_p_ensure_size_with (self, newsize, elem);
    else
        return vector_char_p_set_size (self, newsize);
}

CODE_SECTION(".text.set_size_no_resize")
int vector_char_p_set_size_no_resize
        (vector_char_p_t *self, vector_char_p_cnt_t newsize) /* this is user-proof. */
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    vector_char_p_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!vector_char_p_ensure_size_add_aux (self, newsize))
        return e_errno;

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_TOOLARGE);

    vector_char_p_clear_no_resize_aux (self, newsize); /* in case of shrinking */
    vector_char_p_init_tail (self, newsize);           /* in case of growth */

    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.set_size_raw")
int vector_char_p_set_size_raw
        (vector_char_p_t *self, vector_char_p_cnt_t newsize) /* this is user-proof. */
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    vector_char_p_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!vector_char_p_ensure_size_add_aux (self, newsize))
        return e_errno;

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_TOOLARGE);

    vector_char_p_clear_no_resize_aux (self, newsize); /* in case of shrinking */

    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.shrink")
void vector_char_p_shrink
        (vector_char_p_t *self, E_BOOL tight)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    return_if_null_or_bad_pC (self, (void)ASSERTION_FAILED);

    (void)self;  /*unused*/
    (void)tight; /*unused*/

#if !VECTOR_CHAR_P_LOW_MEM
    if (tight) {
        vector_char_p_cnt_t ts= VECTOR_CHAR_P_GET_TABLESIZE (self);
        return_if_fail_ppii ((vector_char_p_cnt_t)self->m_nentries <= ts,
            self, self->m_nentries, ts);

        if (ERWIN_LIKELY((vector_char_p_cnt_t)self->m_nentries < ts)) {
            vector_char_p_cnt_t newsize= CLAMP_MINIMAL(self->m_nentries);
            VECTOR_CHAR_P_ALIGN_TABLESIZE (newsize);
            if (!vector_char_p_reallocate (self, newsize))
                return;
        }
    }
    else
    if (!vector_char_p_ensure_size_sub_aux_force (self, self->m_nentries))
        return;
#endif

    SET_ERRNO(E_OK);
}

CODE_SECTION(".text.ensure_table_size")
int vector_char_p_ensure_table_size
        (vector_char_p_t *self, vector_char_p_cnt_t newsize)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    (void)self;    /*unused*/
    (void)newsize; /*unused*/

#if !VECTOR_CHAR_P_LOW_MEM
    if (newsize > 0 && newsize > (vector_char_p_cnt_t)self->m_nentries) {
        if (!vector_char_p_ensure_size_add_aux (self, newsize))
            return e_errno;
    }
#endif

    return PASS_ERRNO(E_OK);
}

//long dkcount = 0;

CODE_SECTION(".text.append")
int vector_char_p_append
        (vector_char_p_t *self, char *  newvalue)
{
//fprintf(stderr, "entering append\n");
    int copyerror= E_FALSE;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    if (!vector_char_p_ensure_size_add_plus (self, self->m_nentries, 1))
        return e_errno;

    {
        char * valuecopy;
        E_SET_VALUE (valuecopy, OCOPY (newvalue, &copyerror));

        if (ERWIN_LIKELY(copyerror == E_FALSE)) {
            self->m_nentries++; /* TABLE(self) uses self->m_nentries in LOW_MEM mode! */
            E_SET_VALUE (TABLE(self)[self->m_nentries-1], valuecopy);
//dkcount = dkcount + 1;
//if (dkcount >= 1000000) return PASS_ERRNO(E_NOMEM);
//if (dkcount % 100000 == 0) fprintf(stderr, "%ld\n", dkcount);
            VECTOR_CHAR_P_UPDATE_POS_INSERT (self, self->m_nentries-1);
//fprintf(stderr, "returning from append\n");
            return PASS_ERRNO(E_OK);
        }
        else {
            VECTOR_NOMEM;
            return e_errno;
        }
    }
}

/*
 * Insert empty elements into the vector
 * Already updates POS(SELF).
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.make_gap_aux")
void vector_char_p_make_gap_aux
        (vector_char_p_t *self, vector_char_p_index_t start, vector_char_p_cnt_t count)
{
    vector_char_p_cnt_t i;
    vector_char_p_cnt_t nentries;

    nentries= self->m_nentries;
#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (count < 0, count) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }
    vector_char_p_if_outofrange_min (start < 0, start) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    if (count > 0 && !vector_char_p_grow_plus (self, start, 1))
        return;

#else
    vector_char_p_if_outofrange_min (count < 0, count) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }
    vector_char_p_if_outofrange_minmax (start < 0 || start > nentries, start, nentries) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }
#endif

    if (!vector_char_p_ensure_size_add_plus (self, nentries, count))
        return;

    /* Copy elements up */
    for (i=0; i < nentries - start; i++) {
        E_SET_VALUE (TABLE(self) [nentries + count - 1 - i], TABLE(self) [nentries - 1 - i]);
        VECTOR_CHAR_P_UPDATE_POS_SET (self, nentries - 1 - i);
    }

    /* Set new size */
    self->m_nentries= nentries + count;
    ADD_POS_AT (self, start, count);

    SET_ERRNO(E_OK);
}

/*
 * Insert empty elements into the vector
 */
CODE_SECTION(".text.make_gap_with")
int vector_char_p_make_gap_with
        (vector_char_p_t *self, vector_char_p_index_t start, char *  elem, vector_char_p_cnt_t count)
{
    vector_char_p_cnt_t i;
    int    copyerror= E_FALSE;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    vector_char_p_make_gap_aux (self, start, count); /* updates POS */

    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return e_errno;

    /* Fill the gap. */
    for (i=0; i < count; i++) {
        E_SET_VALUE (TABLE(self) [start + i], OCOPY (elem, &copyerror));
        if (ERWIN_UNLIKELY(copyerror != E_FALSE)) {  /* reset to sane state */
            VECTOR_NOMEM;
            return vector_char_p_erase_flags_q (self, start, count, E_FALSE, E_FALSE);
            /* FIXME: memory leak.  The correct behaviour would be to
             *        clear the non-filled positions and then to
             *        deallocate. */
        }
        VECTOR_CHAR_P_UPDATE_POS_SET (self, start + i);
    }

    return e_errno;
}

/*
 * Insert empty elements into the vector
 */
CODE_SECTION(".text.make_gap")
int vector_char_p_make_gap
        (vector_char_p_t *self, vector_char_p_index_t start, vector_char_p_cnt_t count)
{
    vector_char_p_cnt_t i;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    vector_char_p_make_gap_aux (self, start, count);

    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return e_errno;

    /* Blank out duplicates in gap */
    for (i=0; i < count; i++)
        E_SET_VALUE (TABLE(self) [start + i], ZEROVAR(self));

    return e_errno;
}

/*
 *  sub vectors */
CODE_SECTION(".text.insert_subvector")
int vector_char_p_insert_subvector
        (
    vector_char_p_t *self,
    vector_char_p_index_t self_start,
    vector_char_p_t const *other,
    vector_char_p_index_t start,
    vector_char_p_cnt_t count,
    E_BOOL docopy)
{

#if VECTOR_CHAR_P_ALLOW_NULL
    if (other == NULL && count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null_or_bad (other, ASSERTION_FAILED);

    if (count < 0)
        count= other->m_nentries - start;

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (start < 0, start) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
    vector_char_p_if_outofrange_min (count < 0, count) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }

    if (start >= (vector_char_p_cnt_t)other->m_nentries)
        count= 0;
    else
    if (start + count > (vector_char_p_cnt_t)other->m_nentries)
        count= other->m_nentries - start;

#else
    vector_char_p_if_outofrange_min (start < 0, start) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
    vector_char_p_if_outofrange_min (count < 0, count) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
    vector_char_p_if_outofrange_minmax (
        (start + count) > (vector_char_p_cnt_t)other->m_nentries, start + count, other->m_nentries)
    {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
#endif

    if (count > 0) {
        return_val_if_null_or_bad (self, ASSERTION_FAILED);
        if (docopy)
            return vector_char_p_insert_raw (self, self_start, TABLE(other) + start, count);
        else
            return vector_char_p_insert_no_copy (self, self_start, TABLE(other) + start, count);
    }

    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.subvector")
vector_char_p_t * vector_char_p_subvector
        (vector_char_p_t const *self,
                            vector_char_p_index_t start,
                            vector_char_p_cnt_t count,
                            E_BOOL docopy)
{
    vector_char_p_t *result;
    vector_char_p_cnt_t pre_alloc;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL && count <= 0)
        return NULL;
#endif
    return0_if_null_or_bad (self);

    pre_alloc= (vector_char_p_cnt_t)self->m_nentries - start;
    if (pre_alloc < 0)
        pre_alloc= 0;
    if (count > 0 && pre_alloc > count)
        pre_alloc= count;

#if VECTOR_CHAR_P_DYN_ZERO
    E_SET_PTR(result, vector_char_p_new_with_zero_and_initial_size (ZERO(self), pre_alloc));
#else
    E_SET_PTR(result, vector_char_p_new_with_initial_size (pre_alloc));
#endif
    if (ERWIN_UNLIKELY(
           vector_char_p_insert_subvector (result, 0, self, start, count, docopy) != E_OK))
    {
        vector_char_p_delete (result);
        return NULL;
    }

    return result;
}

/*
 * Overwrite entries in the vector
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.overwrite_copy_aux_q")
int vector_char_p_overwrite_copy_aux_q
        (
        vector_char_p_t *self,
        vector_char_p_index_t       start_self,
        char * const *other_table,
        vector_char_p_cnt_t       count,
        E_BOOL dealloc)
{
    vector_char_p_cnt_t i;
    int copyerror= E_FALSE;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /*
     * Special case for convenient handling of ill-formed calls like other_table == NULL.
     */
    if (count == 0)
        return PASS_ERRNO(E_OK);

    return_val_if_null_pp (other_table, ASSERTION_FAILED, self);

    /*
     * Out of range errors:
     */
#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (count < 0, count)
        return PASS_ERRNO(E_OUTOFRANGE);
    vector_char_p_if_outofrange_min (start_self < 0, start_self)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!vector_char_p_grow_plus (self, start_self, 1) ||
        !vector_char_p_grow_plus (self, start_self, count))
    {
        return e_errno;
    }

#else
    vector_char_p_if_outofrange_minmax (count < 0 ||
        start_self < 0 ||
        (vector_char_p_cnt_t)self->m_nentries - start_self < (vector_char_p_cnt_t)count ||
        start_self >= (vector_char_p_cnt_t)self->m_nentries, start_self, self->m_nentries)
        return PASS_ERRNO(E_OUTOFRANGE);
#endif

    /*
     * Ok, do it.
     */
    SET_ERRNO(E_OK);
    for (i=0; i < count; i++) {
        char * old;
        E_SET_VALUE (old, TABLE(self)[start_self + i]);
        E_SET_VALUE (TABLE(self)[start_self + i], OCOPY (other_table[i], &copyerror));

        if (ERWIN_LIKELY(copyerror != E_FALSE)) {
            E_SET_VALUE (TABLE(self) [start_self + i], old);
            return e_errno;
        }
        VECTOR_CHAR_P_UPDATE_POS_SET (self, start_self + i);

        if (VECTOR_CHAR_P_EQ_USE_ARG(dealloc)) {
            OFREE (old);
        }
    }

    return e_errno;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.overwrite_no_copy_aux_q")
int vector_char_p_overwrite_no_copy_aux_q
        (
    vector_char_p_t       *self,
    vector_char_p_index_t  start_self,
    char * const *other_table,
    vector_char_p_cnt_t    count,
    E_BOOL dealloc)
{
    vector_char_p_cnt_t i;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /*
     * Special case for convenient handling of ill-formed calls like other_table == NULL.
     */
    if (count == 0)
        return PASS_ERRNO(E_OK);

    return_val_if_null_pp (other_table, ASSERTION_FAILED, self);

    /*
     * Out of range errors:
     */
#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (count < 0, count)
        return PASS_ERRNO(E_OUTOFRANGE);
    vector_char_p_if_outofrange_min (start_self < 0, start_self)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!vector_char_p_grow_plus (self, start_self, 1) ||
        !vector_char_p_grow_plus (self, start_self, count))
    {
        return e_errno;
    }

#else
    vector_char_p_if_outofrange_minmax (
        count < 0 ||
           start_self < 0 ||
           (vector_char_p_cnt_t)self->m_nentries - start_self < count ||
           start_self >= (vector_char_p_cnt_t)self->m_nentries,
        start_self,
        self->m_nentries)
    {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
#endif

    /*
     * Ok, do it.
     */
    SET_ERRNO(E_OK);
    for (i=0; i < count; i++) {
        char * old;
        E_SET_VALUE (old, TABLE(self)[start_self + i]);

        E_SET_VALUE (TABLE(self)[start_self + i], other_table[i]);

        VECTOR_CHAR_P_UPDATE_POS_SET (self, start_self + i);

        if (VECTOR_CHAR_P_EQ_USE_ARG(dealloc)) {
            OFREE (old);
        }
    }

    return e_errno;
}

/*
 * Overwrite entries in the vector
 */
CODE_SECTION(".text.overwrite_raw")
int vector_char_p_overwrite_raw
        (vector_char_p_t *self,
                          vector_char_p_index_t       start_self,
                          char * const *other_table,
                          vector_char_p_cnt_t       count)
{
    return vector_char_p_overwrite_copy_aux_q (
            self,
            start_self,
            other_table,
            count,
            E_TRUE);
}

CODE_SECTION(".text.overwrite_string")
int vector_char_p_overwrite_string
        (
    vector_char_p_t *self,
    vector_char_p_index_t       start_self,
    char * const *other_table)
{
    /* return_val_if_null (other_table, ASSERTION_FAILED); */
    /* other_table == NULL is explicitly allowed. */

    return vector_char_p_overwrite_copy_aux_q (self,
                                 start_self,
                                 other_table,
                                 vector_char_p_string_length (self, other_table),
                                 E_TRUE);
}

CODE_SECTION(".text.overwrite_vector")
int vector_char_p_overwrite_vector
        (
    vector_char_p_t *self,
    vector_char_p_index_t       start_self,
    vector_char_p_t const *other)
{
    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);

    return vector_char_p_overwrite_copy_aux_q (self,
                                 start_self,
                                 TABLE(other),
                                 other->m_nentries,
                                 E_TRUE);
}

CODE_SECTION(".text.overwrite_flags")
int vector_char_p_overwrite_flags
        (
        vector_char_p_t *self,
        vector_char_p_index_t       start_self,
        char * const *other_table,
        vector_char_p_cnt_t       count,
        E_BOOL      copy,
        E_BOOL      del)
{
    return copy ?
         vector_char_p_overwrite_copy_aux_q (self, start_self, other_table, count, del)
       : vector_char_p_overwrite_no_copy_aux_q (
                 self,
                 start_self,
                 ERWIN_SUPERFLUOUS_CAST (char * const*, other_table),
                 count,
                 del);
}


/*
 * Overwrite entries in the vector
 */
CODE_SECTION(".text.overwrite")
int vector_char_p_overwrite
        (vector_char_p_t *self,
                      vector_char_p_index_t       start_self,
                      vector_char_p_t const *other,
                      vector_char_p_index_t       start_other,
                      vector_char_p_cnt_t       maxcount)
{
    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);

    /*
     * Copy of both other->m_nentries - start_other and maxcount
     */
    if (maxcount > (vector_char_p_cnt_t)other->m_nentries - start_other)
        maxcount= (vector_char_p_cnt_t)other->m_nentries - start_other;

    /*
     * Errors not handled by vector_char_p_overwrite_raw
     */
#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    vector_char_p_if_outofrange_min (start_other < 0, start_other)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (start_other >= (vector_char_p_cnt_t)other->m_nentries)
        return PASS_ERRNO(E_OK);

#else
    /* Range check */
    vector_char_p_if_outofrange_minmax (
        start_other < 0 ||
            start_other >= (vector_char_p_cnt_t)other->m_nentries,
        start_other,
        other->m_nentries)
        return PASS_ERRNO(E_OUTOFRANGE);
#endif

    /*
     * Do it
     */
    return vector_char_p_overwrite_raw (
               self,
               start_self,
               TABLE(other) + start_other,
               maxcount);
}


/*
 * Get the length of a given null-terminated string
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.string_length_aux")
vector_char_p_cnt_t vector_char_p_string_length_aux
        (vector_char_p_t const *self, char * const *values)
{
    vector_char_p_cnt_t count;

    (void)self; /*unused*/

    if (values == NULL) /* Allow NULL pointer to represent 0 element arrays. */
        return 0;

    return0_if_null_or_bad (self);

    count= 0;
    while (ISNT_ZERO (values[count], self))
        count++;

    return count;
}


/*
 * User side frontend to the string length function
 */
CODE_SECTION(".text.string_length")
vector_char_p_cnt_t vector_char_p_string_length
        (vector_char_p_t const *self, char * const *values)
{
    return vector_char_p_string_length_aux (self, values);
}


/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert_raw")
int vector_char_p_insert_raw
        (vector_char_p_t *self, vector_char_p_index_t start, char * const *values, vector_char_p_cnt_t count)
{
    /* return_val_if_null2 (self, values); -- already done by callees */

    if (ERWIN_UNLIKELY(vector_char_p_make_gap (self, start, count) != E_OK))
        return e_errno;

    vector_char_p_overwrite_raw (self, start, values, count);

    return e_errno;
}

CODE_SECTION(".text.insert_no_copy")
int vector_char_p_insert_no_copy
        (vector_char_p_t *self, vector_char_p_index_t start, char * const *values, vector_char_p_cnt_t count)
{
    /* return_val_if_null2 (self, values); -- already done by callees */

    if (ERWIN_UNLIKELY(vector_char_p_make_gap (self, start, count) != E_OK))
        return e_errno;

    vector_char_p_overwrite_no_copy_aux_q (self, start, values, count, E_FALSE);

    return e_errno;
}


/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert_vector")
int vector_char_p_insert_vector
        (vector_char_p_t *self, vector_char_p_index_t start, vector_char_p_t const *other)
{
    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return vector_char_p_insert_raw (self, start, TABLE(other), (vector_char_p_cnt_t)other->m_nentries);
}

/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert")
int vector_char_p_insert
        (vector_char_p_t *self, vector_char_p_index_t start, char *  value)
{
    return vector_char_p_insert_raw (self, start, &value, 1);
}


/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert_string")
int vector_char_p_insert_string
        (vector_char_p_t *self, vector_char_p_index_t start, char * const *values)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    return vector_char_p_insert_raw (
               self,
               start,
               values,
               vector_char_p_string_length_aux (self, values));
}


/*
 * Append some elements at the end of the vector
 */
CODE_SECTION(".text.append_raw")
int vector_char_p_append_raw
        (vector_char_p_t *self, char * const *values, vector_char_p_cnt_t count)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return vector_char_p_insert_raw (self, (vector_char_p_cnt_t)self->m_nentries, values, count);
}

CODE_SECTION(".text.append_no_copy")
int vector_char_p_append_no_copy
        (vector_char_p_t *self, char * const *values, vector_char_p_cnt_t count)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return vector_char_p_insert_no_copy (self, (vector_char_p_cnt_t)self->m_nentries, values, count);
}


/*
 * Append a null-terminated string at the end of the vector
 */
CODE_SECTION(".text.append_vector")
int vector_char_p_append_vector
        (vector_char_p_t *self, vector_char_p_t const *other)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return vector_char_p_insert_vector (self, (vector_char_p_cnt_t)self->m_nentries, other);
}


/*
 * Append a null-terminated string at the end of the vector
 */
CODE_SECTION(".text.append_string")
int vector_char_p_append_string
        (vector_char_p_t *self, char * const *values)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return vector_char_p_insert_raw (
               self,
               (vector_char_p_cnt_t)self->m_nentries,
               values,
               vector_char_p_string_length_aux (self, values));
}

/* Cut a portion out of the vector. */
static
CODE_SECTION(".text.erase_aux_q")
int vector_char_p_erase_aux_q
        (
        vector_char_p_t *self,
        vector_char_p_index_t start,
        vector_char_p_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    vector_char_p_cnt_t i;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /* Adjust boundaries */
#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (start < 0) {
        if (count > 0)
            count+= start; /* e.g. start=-2, count=5 -> start=0, count=3 */
        start= 0;
    }
#endif

    if (count == 0)
        return PASS_ERRNO(E_OK);

    if (count < 0)
        count= (vector_char_p_cnt_t)self->m_nentries - start;

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (start >= (vector_char_p_cnt_t)self->m_nentries || count <= 0)
        return PASS_ERRNO(E_OK);
    if ((start + count) > (vector_char_p_cnt_t)self->m_nentries)
        count= self->m_nentries - start;
#endif

    /* Check that both start and end are within bounds: */
    return_val_if_out_of_bounds_pp (start,         (vector_char_p_cnt_t)self->m_nentries, ASSERTION_FAILED, self);
    return_val_if_out_of_bounds_pp (start+count-1, (vector_char_p_cnt_t)self->m_nentries, ASSERTION_FAILED, self);

    VECTOR_CHAR_P_UPDATE_POS_ERASE_MANY (self, start, start + count);

    if (VECTOR_CHAR_P_EQ_USE_ARG(dealloc)) {
        /* Free elements */
        for (i= 0; i < count; i++) {
            OFREE (TABLE(self) [i+start]);
        }
    }

    /* Move elements */
    for (i=0; i < (vector_char_p_cnt_t)self->m_nentries - start - count; i++) {
        E_SET_VALUE (TABLE(self) [i + start], TABLE(self) [i + start + count]);
        VECTOR_CHAR_P_UPDATE_POS_SET (self, i + start);
    }

    /* Resize the table */
    if (ERWIN_UNLIKELY(
            !vector_char_p_setsize_noinit_sub(self, (vector_char_p_cnt_t)self->m_nentries - count, resize)))
        return e_errno;

    return PASS_ERRNO(E_OK);
}

/*
 * Cut a portion out of the vector.
 */
CODE_SECTION(".text.erase_flags_q")
int vector_char_p_erase_flags_q
        (
        vector_char_p_t *self,
        vector_char_p_index_t start,
        vector_char_p_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    return vector_char_p_erase_aux_q (self, start, count, resize, dealloc);
}

CODE_SECTION(".text.erase")
int vector_char_p_erase
        (vector_char_p_t *self, vector_char_p_index_t start, vector_char_p_cnt_t count)
{
    return vector_char_p_erase_aux_q (self, start, count, E_TRUE, E_TRUE);
}

/* Cut a portion out of the vector. */
static
CODE_SECTION(".text.swap_erase_aux_q")
int vector_char_p_swap_erase_aux_q
        (
        vector_char_p_t *self,
        vector_char_p_index_t start,
        vector_char_p_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    vector_char_p_cnt_t i;
    vector_char_p_cnt_t n;
    vector_char_p_cnt_t end;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /* Adjust boundaries */
#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (start < 0) {
        if (count > 0)
            count+= start; /* e.g. start=-2, count=5 -> start=0, count=3 */
        start= 0;
    }
#endif

    if (count == 0)
        return PASS_ERRNO(E_OK);

    n= self->m_nentries;

    if (count < 0)
        count= n - start;

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (start >= n || count <= 0)
        return PASS_ERRNO(E_OK);
    if (start + count > n)
        count= n - start;
#endif

    /* Check that both start and end are within bounds: */
    return_val_if_out_of_bounds_pp (start,         (vector_char_p_cnt_t)n, ASSERTION_FAILED, self);
    return_val_if_out_of_bounds_pp (start+count-1, (vector_char_p_cnt_t)n, ASSERTION_FAILED, self);

    VECTOR_CHAR_P_UPDATE_POS_ERASE_MANY (self, start, start + count);

    if (VECTOR_CHAR_P_EQ_USE_ARG(dealloc)) {
        /* Free elements */
        for (i= 0; i < count; i++) {
            OFREE (TABLE(self) [i+start]);
        }
    }

    /* Move elements */
    /*       [0  1  2  3 (4  5  6) 7]
     *   ->  [0  1  2  3  7]
     *                    ^-=start    ^-= n = self->nentries
     *                             ^-=start+count
     *                       ^-=end
     */
    end= self->m_nentries - count;
    for (i=0; i < count; i++) {
        vector_char_p_cnt_t j_from;
        vector_char_p_cnt_t j_to= start + i;
        return_val_if_fail_ppi ((vector_char_p_index_t)j_to >= 0, ASSERTION_FAILED, self, j_to);
        if (ERWIN_UNLIKELY(j_to >= end))
            break;

        j_from= self->m_nentries - 1 - i;
        return_val_if_fail_ppi ((vector_char_p_index_t)j_from >= 0, ASSERTION_FAILED, self, j_from);
        return_val_if_fail_ppiii ((vector_char_p_index_t)j_from >= start + count, ASSERTION_FAILED,
           self, j_from, start, count);

        E_SET_VALUE (TABLE(self) [j_to], TABLE(self)[j_from]);
        VECTOR_CHAR_P_UPDATE_POS_SET (self, j_to);
    }

    /* Resize the table */
    if (ERWIN_UNLIKELY(
            !vector_char_p_setsize_noinit_sub(self, (vector_char_p_cnt_t)self->m_nentries - count, resize)))
        return e_errno;

    return PASS_ERRNO(E_OK);
}

/*
 * Cut a portion out of the vector.
 */
CODE_SECTION(".text.swap_erase_flags_q")
int vector_char_p_swap_erase_flags_q
        (
        vector_char_p_t *self,
        vector_char_p_index_t start,
        vector_char_p_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    return vector_char_p_swap_erase_aux_q (self, start, count, resize, dealloc);
}

CODE_SECTION(".text.swap_erase")
int vector_char_p_swap_erase
        (vector_char_p_t *self, vector_char_p_index_t start, vector_char_p_cnt_t count)
{
    return vector_char_p_swap_erase_aux_q (self, start, count, E_TRUE, E_TRUE);
}

CODE_SECTION(".text.erase_if_flags_q")
vector_char_p_cnt_t vector_char_p_erase_if_flags_q
        (
        vector_char_p_t *self,
        vector_char_p_feature_t f,
        E_BOOL value,
        E_BOOL resize,
        E_BOOL dealloc)
{
    vector_char_p_index_t rp, wp;
    vector_char_p_cnt_t cnt;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);
    return_val_if_null_pp (f, ASSERTION_FAILED, self);

    value= ERWIN_TO_BOOL (value);

    cnt= self->m_nentries;
    rp= wp= 0;
    while (rp < cnt) {
        if (value == ERWIN_TO_BOOL (f(TABLE(self)[rp]))) {
            VECTOR_CHAR_P_UPDATE_POS_ERASE (self, rp);
            if (VECTOR_CHAR_P_EQ_USE_ARG (dealloc)) {
                OFREE (TABLE(self)[rp]);
            }
        }
        else {
            E_SET_VALUE (TABLE(self)[wp], TABLE(self)[rp]);
            VECTOR_CHAR_P_UPDATE_POS_SET (self, wp);
            wp++;
        }
        rp++;
    }

    vector_char_p_setsize_noinit_sub (self, wp, resize);

    return rp - wp;
}

CODE_SECTION(".text.erase_if")
vector_char_p_cnt_t vector_char_p_erase_if
        (vector_char_p_t *self, vector_char_p_feature_t f, E_BOOL value)
{
    return vector_char_p_erase_if_flags_q (self, f, value, E_TRUE, E_TRUE);
}

CODE_SECTION(".text.erase_zero")
vector_char_p_cnt_t vector_char_p_erase_zero
        (vector_char_p_t *self)
{
    vector_char_p_index_t rp, wp;
    vector_char_p_cnt_t cnt;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    cnt= self->m_nentries;
    rp= wp= 0;
    while (rp < cnt) {
        if (IS_ZERO(TABLE(self)[rp], self)) {
            VECTOR_CHAR_P_UPDATE_POS_ERASE (self, rp);
            OFREE (TABLE(self)[rp]);
        }
        else {
            E_SET_VALUE (TABLE(self)[wp], TABLE(self)[rp]);
            VECTOR_CHAR_P_UPDATE_POS_SET (self, wp);
            wp++;
        }
        rp++;
    }

    vector_char_p_setsize_noinit_sub (self, wp, E_TRUE);

    return rp - wp;
}

/*
 * Chop off end of vector
 */
CODE_SECTION(".text.chop")
int vector_char_p_chop
        (vector_char_p_t *self, vector_char_p_cnt_t count)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif

    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return vector_char_p_erase (self, (vector_char_p_index_t)self->m_nentries - count, count);
}

/*
 * Chop off end of vector
 */
CODE_SECTION(".text.chop_flags_q")
int vector_char_p_chop_flags_q
        (
        vector_char_p_t *self,
        vector_char_p_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return vector_char_p_erase_flags_q (
            self,
            (vector_char_p_cnt_t)self->m_nentries - count,
            count,
            resize,
            dealloc);
}

/* Chop off end of vector and return the last element*/
CODE_SECTION(".text.last_chop1")
o_type_var_t vector_char_p_last_chop1
        (vector_char_p_t *self)
{
    char * result;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (self->m_nentries == 0)
        return ZEROVAR(self);
#endif

    E_SET_VALUE (result, TABLE(self)[self->m_nentries - 1]);
    vector_char_p_erase_aux_q (self, (vector_char_p_cnt_t)self->m_nentries - 1, 1, E_TRUE, E_FALSE);
       /* resize, but don't delete, since we're going to return the element. */

    return result;
}

/* Chop off end of vector and return the last element*/
CODE_SECTION(".text.first_swap_chop1")
o_type_var_t vector_char_p_first_swap_chop1
        (vector_char_p_t *self)
{
    char * result;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (self->m_nentries == 0)
        return ZEROVAR(self);
#endif

    E_SET_VALUE (result, TABLE(self)[0]);
    vector_char_p_swap_erase_aux_q (self, 0, 1, E_TRUE, E_FALSE);
       /* resize, but don't delete, since we're going to return the element. */

    return result;
}

/* Nth element */
CODE_SECTION(".text.nth")
o_type_result_t vector_char_p_nth
        (vector_char_p_t const*self, vector_char_p_index_t idx)
/* table==NULL is ok */
{
    exit_if_null (self);
       /* FATAL: no return value can be generated in case this
        * assertion fails (ZERO(self) would be appropriate,
        * but since self is NULL...) */

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx >= (vector_char_p_cnt_t)self->m_nentries)) {
# if VECTOR_CHAR_P_ALLOW_OUTOFRANGE == 0
        errprint ((errstream, "in vector_char_p_nth: index out of range (0 <= %d < %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return ZERO(self), "index out of range",
            idx, self->m_nentries);
# endif
        return ZERO(self);
    }
#endif

    return_val_if_null_pp (TABLE(self), ZERO(self), self);

    return TABLE(self)[idx];
}


/*
 * Nth element, reference to just after the array is allowed */
CODE_SECTION(".text.nth_char")
o_type_result_t vector_char_p_nth_char
        (vector_char_p_t const*self, vector_char_p_index_t idx)
/* m_table==NULL is ok */
{
    exit_if_null (self);
       /* FATAL: no return value can be generated in case this
        * assertion fails (ZERO(self) would be appropriate,
        * but since self is NULL...) */

    if (ERWIN_UNLIKELY(idx == (vector_char_p_cnt_t)self->m_nentries))
        return ZERO(self);

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx > (vector_char_p_cnt_t)self->m_nentries)) {
# if VECTOR_CHAR_P_ALLOW_OUTOFRANGE == 0
        errprint ((errstream, "in vector_char_p_nth: index out of range (0 <= %d <= %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return ZERO(self), "index out of range",
            idx, self->m_nentries);
# endif
        return ZERO(self);
    }
#endif

    return_val_if_null_pp (TABLE(self), ZERO(self), self);

    return TABLE(self)[idx];
}


/*
 * First element
 */
CODE_SECTION(".text.first")
o_type_result_t vector_char_p_first
        (vector_char_p_t const *self)
/* m_table==NULL is ok */
{
    return vector_char_p_nth (self, 0);
}


/*
 * Last element
 */
CODE_SECTION(".text.last")
o_type_result_t vector_char_p_last
        (vector_char_p_t const *self)
/* m_table==NULL is ok */
{
    exit_if_null (self);
       /* FATAL: no return value can be generated in case this
        * assertion fails (ZERO(self) would be appropriate,
        * since self is NULL...) */

    return vector_char_p_nth (self, (vector_char_p_index_t)(self->m_nentries - 1));
}

/*
 * Pointer to nth element
 */
CODE_SECTION(".text.nth_ptr")
vector_char_p_element_ptr_t vector_char_p_nth_ptr
        (vector_char_p_t *self, vector_char_p_index_t idx)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0))
        return NULL;

    if (ERWIN_UNLIKELY(idx >= (vector_char_p_cnt_t)self->m_nentries)) {
# if VECTOR_CHAR_P_ALLOW_OUTOFRANGE != 0
        if (!vector_char_p_grow_plus (self, idx, 1))
            return NULL;
# else
        return NULL;
# endif
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);

    return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, &TABLE(self)[idx]);
}

/*
 * Pointer to nth element with check.
 */
CODE_SECTION(".text.nth_ptr_check")
vector_char_p_element_ptr_t vector_char_p_nth_ptr_check
        (vector_char_p_t *self, vector_char_p_index_t idx)
/* m_table==NULL is ok */
{
    return_val_if_null (self, NULL);

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx >= (vector_char_p_cnt_t)self->m_nentries)) {
# if VECTOR_CHAR_P_ALLOW_OUTOFRANGE != 0
        if (ERWIN_UNLIKELY(!vector_char_p_grow_plus (self, idx, 1)))
            return NULL;
# else
        errprint ((errstream, "in vector_char_p_nth: index out of range (0 <= %d < %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return NULL, "index out of range",
            idx, self->m_nentries);
# endif
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);

    return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, &TABLE(self)[idx]);
}

/*
 * Pointer to nth element with check, allowing a reference
 * just after the vector's end.
 */
CODE_SECTION(".text.nth_ptr_char")
vector_char_p_element_ptr_t vector_char_p_nth_ptr_char
        (vector_char_p_t *self, vector_char_p_index_t idx)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);

    /* Always terminate it, just like with as_array().  This way,
     * as_array() + 5  === nth_ptr_char (5), which is what
     * people probably expect (apart from the fact that the former
     * performs no checks).
     */

#if !VECTOR_CHAR_P_LOW_MEM
    /* We only want an additional element, which is already allocated for LOW_MEM.
     * And since we do not change nentries, reallocation would leave us with a
     * table that has a non-consistient size. */
    if (ERWIN_UNLIKELY(!vector_char_p_ensure_size_add_plus (self, self->m_nentries, 1)))
        return NULL;
#endif

    E_SET_VALUE (TABLE(self)[self->m_nentries], ZEROVAR(self));
        /* Ensure this always reads back as 0 */

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE != 0
    if (ERWIN_UNLIKELY(idx < 0 || idx >= (vector_char_p_cnt_t)self->m_nentries)) {
        if (ERWIN_UNLIKELY(!vector_char_p_grow_plus (self, idx, 1)))
            return NULL;
    }
#elif VECTOR_CHAR_P_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx > (vector_char_p_cnt_t)self->m_nentries)) {
        errprint ((errstream, "in vector_char_p_nth: index out of range (0 <= %d <= %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return NULL, "index out of range",
            idx, self->m_nentries);
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);

    return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, &TABLE(self)[idx]);
}

/*
 * Pointer to first element
 */
CODE_SECTION(".text.first_ptr")
vector_char_p_element_ptr_t vector_char_p_first_ptr
        (vector_char_p_t *self)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK
    if (ERWIN_UNLIKELY(0 >= (vector_char_p_cnt_t)self->m_nentries)) {
# if VECTOR_CHAR_P_ALLOW_OUTOFRANGE != 0
        if (ERWIN_UNLIKELY(!vector_char_p_grow_plus (self, 0, 1)))
            return NULL;
# else
        return NULL;
# endif
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);
    return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, &TABLE(self)[0]);
}

/*
 * Pointer to nth element
 */
CODE_SECTION(".text.last_ptr")
vector_char_p_element_ptr_t vector_char_p_last_ptr
        (vector_char_p_t *self)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);
    return vector_char_p_nth_ptr (self, self->m_nentries - 1);
}

CODE_SECTION(".text.as_array")
vector_char_p_element_ptr_t vector_char_p_as_array
        (vector_char_p_t const *self_const)
/* self==NULL    is ok: NULL is returned then.
 * m_table==NULL is ok, "" is returned then. */
{
    vector_char_p_t *self;
    E_SET_PTR(self, ERWIN_CONST_CAST(vector_char_p_t*, self_const));
    if (self == NULL)
        return NULL;
    return0_if_null_or_bad (self);

#if !VECTOR_CHAR_P_LOW_MEM
    /* see vector_char_p_nth_ptr_char */
    if (ERWIN_UNLIKELY(!vector_char_p_ensure_size_add_plus (self, self->m_nentries, 1)))
        return NULL;
#endif

    E_SET_VALUE (TABLE(self)[self->m_nentries], ZEROVAR(self));

    return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, TABLE(self));
}

CODE_SECTION(".text.ensure_heap_storage")
void vector_char_p_ensure_heap_storage
        (vector_char_p_t *self)
{
    (void)self; /*unused*/

    return_if_null_or_bad (self);

    /* Ensure that the contents are stored on the heap so that _detach
     * does not destroy the vector. */
#if VECTOR_CHAR_P_INLINE_STORE
    vector_char_p_ensure_table_size_force (self, VECTOR_CHAR_P_INLINE_CNT + 1);
#endif
}

CODE_SECTION(".text.has_heap_storage")
ERWIN_BOOL vector_char_p_has_heap_storage
        (vector_char_p_t const *self)
{
    (void)self; /*unused*/

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null_or_bad (self);
    return HAS_HEAP_TABLE(self);
}

CODE_SECTION(".text.inline_store_cnt")
vector_char_p_cnt_t vector_char_p_inline_store_cnt
        (void)
{
    return VECTOR_CHAR_P_INLINE_CNT;
}

CODE_SECTION(".text.as_array_detach")
vector_char_p_element_ptr_t vector_char_p_as_array_detach
        (vector_char_p_t *self)
{
    vector_char_p_element_ptr_t result;

    vector_char_p_ensure_heap_storage (self);
    result= vector_char_p_as_array (self);
    vector_char_p_detach (self);

    return result;
}

CODE_SECTION(".text.as_open_array")
vector_char_p_element_ptr_t vector_char_p_as_open_array
        (vector_char_p_t const *self)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif
    return0_if_null_or_bad (self);
#if VECTOR_CHAR_P_ZERO_SIZE
    if (TABLE(self) == VECTOR_CHAR_P_DUMMY_TABLE)
        return NULL;
#endif
    return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, TABLE(self));
}

CODE_SECTION(".text.as_open_array_detach")
vector_char_p_element_ptr_t vector_char_p_as_open_array_detach
        (vector_char_p_t *self)
{
    vector_char_p_element_ptr_t result;

    vector_char_p_ensure_heap_storage (self);
    result= vector_char_p_as_open_array(self);
    vector_char_p_detach (self);

    return result;
}

#ifdef OCMP
static
CODE_SECTION(".text.element_cmp")
int vector_char_p_element_cmp
        (char * const *a, char * const *b)
{
    return OCMP ((*a), (*b));
}
#endif /* defined(OCMP) */

#ifdef OPRIORITY_CMP
static
CODE_SECTION(".text.element_priority_cmp")
int vector_char_p_element_priority_cmp
        (char * const *a, char * const *b)
{
    return OPRIORITY_CMP ((*a), (*b));
}
#endif /* defined(OPRIORITY_CMP) */

CODE_SECTION(".text.heap_left")
vector_char_p_index_t vector_char_p_heap_left
        (vector_char_p_t const *self, vector_char_p_index_t father)
{
    vector_char_p_index_t child;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

    return_val_if_null_or_bad (self, -1);
    return_val_if_out_of_bounds_pp (father, (vector_char_p_cnt_t)self->m_nentries, -1, self);

    child= father * 2 + 1;
    if (child < (vector_char_p_cnt_t)self->m_nentries)
        return child;
    return -1;
}

CODE_SECTION(".text.heap_right")
vector_char_p_index_t vector_char_p_heap_right
        (vector_char_p_t const *self, vector_char_p_index_t father)
{
    vector_char_p_index_t child;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

    return_val_if_null_or_bad (self, -1);
    return_val_if_out_of_bounds_pp (father, (vector_char_p_cnt_t)self->m_nentries, -1, self);

    child= (father + 1) * 2;
    if (child < (vector_char_p_cnt_t)self->m_nentries)
        return child;
    return -1;
}

CODE_SECTION(".text.heap_father")
vector_char_p_index_t vector_char_p_heap_father
        (vector_char_p_t const *self, vector_char_p_index_t child)
{
    (void)self; /*unused*/

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

    return_val_if_null_or_bad (self, -1);
    return_val_if_out_of_bounds_pp (child, (vector_char_p_cnt_t)self->m_nentries, -1, self);

    if (child == 0)
        return -1; /* the root has no father */
    return (child - 1) / 2;
}

#ifndef NDEBUG

static
CODE_SECTION(".text.check_heap_property")
void vector_char_p_check_heap_property
        (vector_char_p_t const *self, vector_char_p_cmp_t cmp)
{
#if 0
    vector_char_p_size_t father;
#endif
    (void)self; /*unused*/
    (void)cmp;  /*unused*/
#if 0
    for (father=0; father < self->m_nentries; father++) {
        vector_char_p_index_t child= vector_char_p_heap_left (self, father);
        if (child >= 0) {
            return_if_fail_ppt (
                cmp (vector_char_p_nth_ptr_const (self, father), vector_char_p_nth_ptr_const (self, child)) >= 0,
                self,
                "The heap property is violated.");
        }
        child= vector_char_p_heap_right (self, father);
        if (child >= 0) {
            return_if_fail_ppt (
                cmp (vector_char_p_nth_ptr_const (self, father), vector_char_p_nth_ptr_const (self, child)) >= 0,
                self,
                "The heap property is violated.");
        }
    }
#endif
}
#endif /* !defined(NDEBUG) */

CODE_SECTION(".text.heap_sink")
void vector_char_p_heap_sink
        (vector_char_p_t *self, vector_char_p_index_t father, vector_char_p_cmp_t cmp)
{
    return_if_null_or_bad (self);
    return_if_out_of_bounds_pp (father, (vector_char_p_cnt_t)self->m_nentries, self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= vector_char_p_element_priority_cmp;
#endif
    return_if_null_pp (cmp, self);

    /* BEGIN MAIN */
    for (;;) {
        vector_char_p_index_t child, largest;

        largest= father;

        child= vector_char_p_heap_left (self, father);
        if (child >= 0) {
            if (cmp (vector_char_p_nth_ptr (self, child), vector_char_p_nth_ptr (self, largest)) > 0)
                largest= child;

            child= vector_char_p_heap_right (self, father);
            if (child >= 0 &&
                cmp (vector_char_p_nth_ptr (self, child), vector_char_p_nth_ptr (self, largest)) > 0)
                largest= child;
        }

        if (ERWIN_UNLIKELY(largest == father))
            break;

        vector_char_p_swap (self, largest, father);
        father= largest;
    }
    /* END MAIN */
}

CODE_SECTION(".text.make_heap")
void vector_char_p_make_heap
        (vector_char_p_t *self, vector_char_p_cmp_t cmp)
{
    vector_char_p_index_t largest_father;
    vector_char_p_index_t i;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null_or_bad (self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= vector_char_p_element_priority_cmp;
#endif
    return_if_null_pp (cmp, self);

    /* BEGIN MAIN */
    largest_father= vector_char_p_heap_father (self, self->m_nentries - 1);
    for (i= largest_father; i >= 0; i--)
        vector_char_p_heap_sink (self, i, cmp);
    /* END MAIN */

#ifndef NDEBUG
    vector_char_p_check_heap_property (self, cmp);
#endif
}

#ifndef NDEBUG

static
CODE_SECTION(".text.check_sort_order")
void vector_char_p_check_sort_order
        (vector_char_p_t const *self, vector_char_p_cmp_t cmp)
{
    vector_char_p_index_t i;
    for (i=0; i < (vector_char_p_index_t)self->m_nentries - 1; i++) {
        return_if_fail_ppt (
            cmp (vector_char_p_nth_ptr_const (self, i), vector_char_p_nth_ptr_const (self, i+1)) <= 0,
            self,
            "The vector is not sorted after a sort function was used.");
    }
}
#endif /* !defined(NDEBUG) */

CODE_SECTION(".text.heap_sort")
void vector_char_p_heap_sort
        (vector_char_p_t *self, vector_char_p_cmp_t cmp)
{
    vector_char_p_index_t i;
    vector_char_p_cnt_t n;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null_or_bad (self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= vector_char_p_element_priority_cmp;
#endif
    return_if_null_pp (cmp, self);

    /* BEGIN MAIN */
    vector_char_p_make_heap (self, cmp);

    n= self->m_nentries;
    for (i=n-1; i >= 1; i--) {
         vector_char_p_swap (self, 0, i);
         self->m_nentries= i;
         vector_char_p_heap_sink (self, 0, cmp);
    }

    self->m_nentries= n;
    /* END MAIN */

#ifndef NDEBUG
    vector_char_p_check_sort_order (self, cmp);
#endif
}

CODE_SECTION(".text.heap_extract")
o_type_var_t vector_char_p_heap_extract
        (vector_char_p_t *self, vector_char_p_cmp_t cmp)
{
    char * result;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= vector_char_p_element_priority_cmp;
#endif
    return_val_if_null_pp (cmp, ZEROVAR(self), self);

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_heap_property (self, cmp);
#endif

#if VECTOR_CHAR_P_ALLOW_OUTOFRANGE
    if (self->m_nentries == 0)
        return ZEROVAR(self);
#endif

    /* BEGIN MAIN */
    result= vector_char_p_first_swap_chop1 (self);
    if (self->m_nentries > 0)
        vector_char_p_heap_sink (self, 0, cmp);
    /* END MAIN */

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_heap_property (self, cmp);
#endif

    return result;
}

CODE_SECTION(".text.heap_raise")
void vector_char_p_heap_raise
        (vector_char_p_t *self, vector_char_p_index_t child, vector_char_p_cmp_t cmp)
{
    return_if_null_or_bad (self);
    return_if_out_of_bounds_pp (child, (vector_char_p_cnt_t)self->m_nentries, self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= vector_char_p_element_priority_cmp;
#endif
    return_if_null_pp (cmp,self);

    /* BEGIN MAIN */
    for (;;) {
        vector_char_p_index_t father= vector_char_p_heap_father (self, child);
        if (ERWIN_UNLIKELY(father < 0))
            break;

        if (cmp (vector_char_p_nth_ptr (self, father), vector_char_p_nth_ptr (self, child)) >= 0)
            break;

        vector_char_p_swap (self, father, child);
        child= father;
    }
    /* END MAIN */

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_heap_property (self, cmp);
#endif
}

CODE_SECTION(".text.heap_fix")
void vector_char_p_heap_fix
        (vector_char_p_t *self, vector_char_p_index_t father, vector_char_p_cmp_t cmp)
{
    vector_char_p_heap_sink  (self, father, cmp);
    vector_char_p_heap_raise (self, father, cmp);
}

CODE_SECTION(".text.heap_insert")
int vector_char_p_heap_insert
        (vector_char_p_t *self, char *  x, vector_char_p_cmp_t cmp)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_priority_cmp);
#endif
    return_val_if_null_pp (cmp, ASSERTION_FAILED, self);

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_heap_property (self, cmp);
#endif

    /* BEGIN MAIN */
    if (ERWIN_LIKELY(vector_char_p_append (self, x) == E_OK))
        vector_char_p_heap_raise (self, self->m_nentries - 1, cmp);
    /* END MAIN */

    return e_errno;
}

CODE_SECTION(".text.heap_erase")
void vector_char_p_heap_erase
        (vector_char_p_t *self, vector_char_p_index_t i, vector_char_p_cmp_t cmp)
{
    return_if_null_or_bad (self);
    return_if_out_of_bounds_pp (i, (vector_char_p_cnt_t)self->m_nentries,self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_priority_cmp);
#endif
    return_if_null_pp (cmp, self);

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_heap_property (self, cmp);
#endif

    /* BEGIN MAIN */
    vector_char_p_swap_erase (self, i, 1);
    if (i < (vector_char_p_cnt_t)self->m_nentries)
        vector_char_p_heap_sink  (self, i, cmp);
    /* END MAIN */

#ifndef NDEBUG
    vector_char_p_check_heap_property (self, cmp);
#endif
}

CODE_SECTION(".text.erase_equals")
vector_char_p_cnt_t vector_char_p_erase_equals
        (vector_char_p_t *self, vector_char_p_cmp_t cmp, vector_char_p_combine_t combine)
{
    vector_char_p_index_t rp, wp;
    vector_char_p_cnt_t cnt;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    if (self->m_nentries <= 1)
        return 0;
#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_cmp);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    cnt= self->m_nentries;
    rp= wp= 1; /* start at 1, not at 0, since we address wp-1 */
    while (rp < cnt) {
        if (cmp (&TABLE(self)[wp-1], &TABLE(self)[rp]) == 0) {
            VECTOR_CHAR_P_UPDATE_POS_ERASE (self, rp);
            if (combine != NULL)
                combine (&TABLE(self)[wp-1], &TABLE(self)[rp]);
            OFREE (TABLE(self)[rp]);
        }
        else {
            E_SET_VALUE (TABLE(self)[wp], TABLE(self)[rp]);
            VECTOR_CHAR_P_UPDATE_POS_SET (self, wp);
            wp++;
        }
        rp++;
    }

    vector_char_p_setsize_noinit_sub (self, wp, E_TRUE);

    return rp - wp;
}

CODE_SECTION(".text.qsort")
void vector_char_p_qsort
        (vector_char_p_t *self, vector_char_p_cmp_t cmp)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_cmp);
#endif
    return_if_null2i_or_bad (self);
    return_if_null_pp (cmp, self);

    qsort ((void*)TABLE(self),
           self->m_nentries,
           sizeof (char *),
           (int (*)(const void *, const void *))cmp);

    VECTOR_CHAR_P_UPDATE_POS_SET_MANY (self, 0, self->m_nentries);

#ifndef NDEBUG
    vector_char_p_check_sort_order (self, cmp);
#endif
}

CODE_SECTION(".text.sort")
void vector_char_p_sort
        (vector_char_p_t *self, vector_char_p_cmp_t cmp)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_cmp);
#endif
    return_if_null2i_or_bad (self);
    return_if_null_pp (cmp, self);

    e_merge_sort (
           (void*)TABLE(self),
           self->m_nentries,
           sizeof (char *),
           (int (*)(const void *, const void *))cmp);

    VECTOR_CHAR_P_UPDATE_POS_SET_MANY (self, 0, self->m_nentries);

#ifndef NDEBUG
    vector_char_p_check_sort_order (self, cmp);
#endif
}

CODE_SECTION(".text.bfind")
vector_char_p_index_t vector_char_p_bfind
        (vector_char_p_t const*self, char *  which, vector_char_p_cmp_t cmp)
{
    char * *result;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_cmp);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);
    return_val_if_null_pp (cmp, ASSERTION_FAILED, self);

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_sort_order (self, cmp);
#endif

    E_SET_PTR(result,
        (char **)
            bsearch ((void const *)&which,
                     TABLE(self),
                     self->m_nentries,
                     sizeof (char *),
                     (int (*)(const void *, const void *))cmp));

    if (result == NULL)
        return -1;

    return result - TABLE(self);
}

CODE_SECTION(".text.find")
vector_char_p_index_t vector_char_p_find
        (vector_char_p_t const *self, vector_char_p_index_t start, char *  needle)
{
    vector_char_p_index_t i;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);

    if (start < 0) {
        start= self->m_nentries + start;

        if (ERWIN_UNLIKELY(start < 0))
            return -1;
    }

    for (i=start; i < (vector_char_p_cnt_t)self->m_nentries; i++)
        if (OEQUAL ((TABLE(self)[i]), (needle)))
            return i;
    return -1;
}

CODE_SECTION(".text.find_ptr")
vector_char_p_element_ptr_t vector_char_p_find_ptr
        (vector_char_p_t const *self, vector_char_p_index_t start, char *  needle)
{
    vector_char_p_index_t i;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif
    return0_if_null2i_or_bad (self);

    if (start < 0) {
        start= self->m_nentries + start;

        if (ERWIN_UNLIKELY(start < 0))
            return NULL;
    }

    for (i=start; i < (vector_char_p_cnt_t)self->m_nentries; i++)
        if (OEQUAL ((TABLE(self)[i]), (needle)))
            return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, &TABLE(self)[i]);
    return NULL;
}

CODE_SECTION(".text.rfind")
vector_char_p_index_t vector_char_p_rfind
        (vector_char_p_t const *self, vector_char_p_index_t start, char *  needle)
{
    vector_char_p_index_t i;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start >= (vector_char_p_cnt_t)self->m_nentries))
        return -1;

    for (i=start; i >= 0; i--)
        if (OEQUAL ((TABLE(self)[i]), needle))
            return i;
    return -1;
}

CODE_SECTION(".text.rfind_ptr")
vector_char_p_element_ptr_t vector_char_p_rfind_ptr
        (vector_char_p_t const *self, vector_char_p_index_t start, char *  needle)
{
    vector_char_p_index_t i;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif
    return0_if_null2i_or_bad (self);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start >= (vector_char_p_cnt_t)self->m_nentries))
        return NULL;

    for (i=start; i >= 0; i--)
        if (OEQUAL ((TABLE(self)[i]), needle))
            return ERWIN_SUPERFLUOUS_CAST (vector_char_p_element_ptr_t, &TABLE(self)[i]);
    return NULL;
}

CODE_SECTION(".text.find_if")
vector_char_p_index_t vector_char_p_find_if
        (vector_char_p_t const *self, vector_char_p_index_t start, vector_char_p_feature_t feature, E_BOOL value)
{
    vector_char_p_index_t i;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (feature, -1, self);

    value= ERWIN_TO_BOOL (value); /* normalise boolean */

    if (start < 0) {
        start= self->m_nentries + start;

        if (ERWIN_UNLIKELY(start < 0))
            return -1;
    }

    for (i=start; i < (vector_char_p_cnt_t)self->m_nentries; i++)
        if (value == ERWIN_TO_BOOL (feature (TABLE(self)[i])))
            return i;
    return -1;
}

CODE_SECTION(".text.rfind_if")
vector_char_p_index_t vector_char_p_rfind_if
        (vector_char_p_t const *self, vector_char_p_index_t start, vector_char_p_feature_t feature, E_BOOL value)
{
    vector_char_p_index_t i;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (feature, -1, self);

    value= ERWIN_TO_BOOL (value);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start >= (vector_char_p_cnt_t)self->m_nentries))
        return -1;

    for (i=start; i >= 0; i--)
        if (value == ERWIN_TO_BOOL (feature (TABLE(self)[i])))
            return i;
    return -1;
}

CODE_SECTION(".text.is_equal_at")
E_BOOL vector_char_p_is_equal_at
        (vector_char_p_t const *self, vector_char_p_index_t start, char * const *needle, vector_char_p_cnt_t len)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL && start == 0 && len == 0)
        return E_TRUE;
#endif
    return0_if_null2i_or_bad (self);
    return0_if_null_pp (needle, self);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start < 0 || start+len > (vector_char_p_cnt_t)self->m_nentries))
        return E_FALSE;

    while (len > 0) {
        if (!(OEQUAL ((*needle), (TABLE(self)[start]))))
            return E_FALSE;
        needle++;
        start++;
        len--;
    }

    return E_TRUE;
}

CODE_SECTION(".text.find_raw")
vector_char_p_index_t vector_char_p_find_raw
        (vector_char_p_t const *self, vector_char_p_index_t start, char * const *needle, vector_char_p_cnt_t len)
{
    vector_char_p_cnt_t noch;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return (start == 0 && len == 0) ? 0 : -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (needle, -1, self);

    if (start < 0)
        start= self->m_nentries + start;

    noch= self->m_nentries - start - len + 1;
    while (noch > 0) {
        vector_char_p_index_t i= vector_char_p_find (self, start, *needle);

        if (i >= 0) {
            if (vector_char_p_is_equal_at (self, i, needle, len))
                return i;
            start= i + 1;
            noch= self->m_nentries - start - len + 1;
        }
        else {
            start++;
            noch--;
        }
    }

    return -1;
}

CODE_SECTION(".text.rfind_raw")
vector_char_p_index_t vector_char_p_rfind_raw
        (vector_char_p_t const *self, vector_char_p_index_t start, char * const *needle, vector_char_p_cnt_t len)
{
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return (start == 0 && len == 0) ? 0 : -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (needle, -1, self);

    if (start < 0)
        start= self->m_nentries + start;

    while (start >= 0) {
        vector_char_p_index_t i= vector_char_p_rfind (self, start, *needle);

        if (i >= 0) {
            if (vector_char_p_is_equal_at (self, i, needle, len))
                return i;
            start= i - 1;
        }
        else
            start--;
    }

    return -1;
}

CODE_SECTION(".text.ltrim_if")
void vector_char_p_ltrim_if
        (vector_char_p_t *self, vector_char_p_feature_t feature, E_BOOL value)
{
    vector_char_p_size_t count;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null2i_or_bad (self);

    value= ERWIN_TO_BOOL (value);

    count= 0;
    while (count < self->m_nentries &&
           value == ERWIN_TO_BOOL (feature(TABLE(self)[count])))
        count++;

    if (count != 0)
        vector_char_p_erase (self, 0, count);
}

CODE_SECTION(".text.rtrim_if")
void vector_char_p_rtrim_if
        (vector_char_p_t *self, vector_char_p_feature_t feature, E_BOOL value)
{
    vector_char_p_size_t count;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null2i_or_bad (self);

    value= ERWIN_TO_BOOL (value);

    count= 0;
    while (count < self->m_nentries &&
           value == ERWIN_TO_BOOL (feature (TABLE(self)[self->m_nentries - count - 1])))
        count++;

    if (count != 0)
        vector_char_p_chop (self, count);
}

CODE_SECTION(".text.trim_if")
void vector_char_p_trim_if
        (vector_char_p_t *self, vector_char_p_feature_t feature, E_BOOL value)
{
    vector_char_p_rtrim_if (self, feature, value);
    vector_char_p_ltrim_if (self, feature, value);
}

CODE_SECTION(".text.map")
void vector_char_p_map
        (vector_char_p_t *self, vector_char_p_map_t map)
{
    vector_char_p_size_t count;
#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    return_if_null2i_or_bad (self);

    count= 0;
    while (count < self->m_nentries) {
        vector_char_p_set (self, count, (*map) (TABLE(self)[count]));
        count++;
    }      
}

CODE_SECTION(".text.cmp")
int vector_char_p_cmp
        (vector_char_p_t const *a, vector_char_p_t const *b, vector_char_p_cmp_t cmp)
{
    char * const *alauf;
    char * const *blauf;
    vector_char_p_cnt_t count;

#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_cmp);
#endif

    if (a == b) return 0;

    if (a == NULL)
        return b == NULL ? 0 : -1;

    if (b == NULL)
        return 1;

#if !VECTOR_CHAR_P_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    E_SET_PTR(alauf, TABLE(a));
    E_SET_PTR(blauf, TABLE(b));
    for (count= (a->m_nentries < b->m_nentries) ? a->m_nentries : b->m_nentries;
         count > 0;
         alauf++, blauf++, count--)
    {
        int result= cmp (alauf, blauf);

        if (result != 0)
            return result;
    }

#if VECTOR_CHAR_P_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    return 0;
}


CODE_SECTION(".text.priority_cmp")
int vector_char_p_priority_cmp
        (vector_char_p_t const *a, vector_char_p_t const *b, vector_char_p_cmp_t cmp)
{
    char * const *alauf;
    char * const *blauf;
    vector_char_p_cnt_t count;

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        E_SET_PTR (cmp, vector_char_p_element_priority_cmp);
#endif

    if (a == b) return 0;

    if (a == NULL)
        return b == NULL ? 0 : -1;

    if (b == NULL)
        return 1;

#if !VECTOR_CHAR_P_PRIORITY_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    E_SET_PTR(alauf, TABLE(a));
    E_SET_PTR(blauf, TABLE(b));
    for (count= (a->m_nentries < b->m_nentries) ? a->m_nentries : b->m_nentries;
         count > 0;
         alauf++, blauf++, count--)
    {
        int result= cmp (alauf, blauf);

        if (result != 0)
            return result;
    }

#if VECTOR_CHAR_P_PRIORITY_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    return 0;
}


CODE_SECTION(".text.hash_raw")
e_hashval_t vector_char_p_hash_raw
        (vector_char_p_t const *self)
{
#ifdef OHASH
    char * const *alauf;
    e_hash_state_t state;
    char * *end;
#endif

    if (self == NULL || TABLE(self) == NULL)
        return ERWIN_HASH_INIT;

#ifdef OHASH
    ERWIN_STATE_INIT_WITH (state, int_hash (self->m_nentries));

    E_SET_PTR(alauf, TABLE(self));
    for (end= TABLE(self) + self->m_nentries;
                 /* don't use E_SET_PTR: this ptr is out of range (end = one behind last) */
         alauf < end;
         alauf++)
    {
        ERWIN_STATE_MIX_ORDERED(state, OHASH(*alauf));
    }

    return ERWIN_STATE_GET_HASHVAL(state);
#else
    error_return0_if_reached_ppt (
        self,
        "Because CHAR_P_HASH was not #defined, vector_char_p_hash_raw could not be implemented.");
#endif
}

/*
 * Locate an element's position even if it is not contained in the vector */
CODE_SECTION(".text.locate")
E_BOOL vector_char_p_locate
        (vector_char_p_index_t *idx,
                    vector_char_p_t const *self,
                    char *  element,
                    vector_char_p_cmp_t cmp,
                    int how)
/* table==NULL is ok */
{
    vector_char_p_cnt_t a, b;

#if VECTOR_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        *idx= (how > 0) ? -1 : 0;
        return E_FALSE;
    }
#endif

    return0_if_null_or_bad (self);
    nothing_if_fail_ppi (how >= -1 && how <= 1, self, how);

    if (self->m_nentries == 0) {
        *idx= (how > 0) ? -1 : 0;
        return E_FALSE;
    }

    return_val_if_null_pp (TABLE(self), E_FALSE, self);

#ifdef OCMP
    if (cmp == NULL)
        cmp= vector_char_p_element_cmp;
#endif

#if !defined(NDEBUG) && VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS
    vector_char_p_check_sort_order (self, cmp);
#endif

    a= 0;
    b= self->m_nentries;
    if (a < b) {
        vector_char_p_cnt_t a2;
        vector_char_p_cnt_t c;

        do {
            a2= a;
            c= (a + b) / 2;

            if (c >= (vector_char_p_cnt_t)self->m_nentries)
                b= c;  /* last iteration (in some cases), set up b appropriately */
            else {
                vector_char_p_index_t result= cmp (&TABLE(self)[c], &element);

                if (result > 0) b= c;   /* search in left half */
                else
                if (result < 0) a= c+1; /* search in right half */
                else {
                    if (how < 0) { /* return left most equal element */
                        while (c >= 1 &&
                               cmp (&TABLE(self)[c-1], &element) == 0)
                            c--;
                    }
                    else
                    if (how > 0) { /* return right most equal element */
                        while (c < ((vector_char_p_cnt_t)self->m_nentries - 1) &&
                               cmp (&TABLE(self)[c+1], &element) == 0)
                            c++;
                    }

                    *idx= c;
                    return E_TRUE;
                }
            }
        } while (a2 < c);
    }

    *idx= (how > 0) ? b-1 : b;
    return E_FALSE;
}

/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */
/*
 * Char specific routines
 */


#endif /* !defined(PASS2) */
#ifndef PASS1

#ifdef __cplusplus

#define self (this->it())


CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (void)
{
    E_BOOL ok= vector_char_p_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_ppt (ok, this, "vector_char_p_init_internal_q failed");
}

CODE_SECTION(".text._constructor")
void vector_char_p_t::_constructor
        (void)
{
    E_BOOL ok= vector_char_p_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_ppt (ok, this, "vector_char_p_init_internal_q failed");
}

CODE_SECTION(".text.static_zero")
vector_char_p_t const & vector_char_p_t::static_zero
        ()
{
    static vector_char_p_t const *z= NULL;
    if (ERWIN_UNLIKELY(!z))
        E_SET_PTR(z, new vector_char_p_t);
    return *z;
}

#if VECTOR_CHAR_P_HAVE_INT_CONSTRUCTOR
CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_cnt_t initial_size)
{
    if (initial_size < 0)
        initial_size= GET_INITIAL_SIZE;
                                                        
    E_BOOL ok= vector_char_p_init_internal_q (it(), OZERO, initial_size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* VECTOR_CHAR_P_HAVE_INT_CONSTRUCTOR */

#if VECTOR_CHAR_P_DYN_ZERO
CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (char *  z)
{
    E_BOOL ok= vector_char_p_init_internal_q (it(), z, GET_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}


CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (char *  z, vector_char_p_cnt_t initial_size)
{
    if (initial_size < 0)
        initial_size= GET_INITIAL_SIZE;

    E_BOOL ok= vector_char_p_init_internal_q (it(), z, initial_size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* VECTOR_CHAR_P_DYN_ZERO */


CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_t const &other, bool docopy)
{
    return_if_null_pp (&other, this);
#ifdef ERWIN_DOS
    if (TABLE(&other) == NULL && other.m_nentries == 0) {
        /* Because of the braindead Windos linker, object initialisation order
         * might be wrong, we must expect uninitialised m_zero elements here.
         * It does not help to sort the objects manually since the linker
         * reorders them (most notably: possibly in the wrong way) */
        vector_char_p_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    }
    else
#endif
    {
        vector_char_p_init_internal_q (it(), ZERO(other.it()), COPY_SIZE(other.it()));
        if (docopy)
            vector_char_p_insert_vector (it(), 0, other.it());
        else
            vector_char_p_insert_no_copy (it(), 0, TABLE(&other), other.m_nentries);
    }
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_t const *other, bool docopy)
{
    return_if_null_pp (other, this);
    vector_char_p_init_internal_q (it(), ZERO(other->it()), COPY_SIZE(other->it()));
    if (docopy)
        vector_char_p_insert_vector (it(), 0, other->it());
    else
        vector_char_p_insert_no_copy (it(), 0, TABLE(other), other->m_nentries);
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_t const &other, vector_char_p_index_t start, vector_char_p_cnt_t count, bool docopy)
{
    return_if_null_pp (&other, this);
    vector_char_p_init_internal_q (it(), ZERO(other.it()), COPY_SIZE(other.it()));
    vector_char_p_insert_subvector (it(), 0, other.it(), start, count, docopy);
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_t const *other, vector_char_p_index_t start, vector_char_p_cnt_t count, bool docopy)
{
    return_if_null_pp (other, this);
    vector_char_p_init_internal_q (it(), ZERO(other->it()), COPY_SIZE(other->it()));
    vector_char_p_insert_subvector (it(), 0, other->it(), start, count, docopy);
}

#ifdef ERWIN_COMPAT_2_0_264
CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_t const *other, vector_char_p_index_t start, vector_char_p_cnt_t count, bool docopy)
{
    return_if_null_pp (other, this);
    vector_char_p_init_internal_q (it(), ZERO(other), COPY_SIZE(other));
    vector_char_p_insert_subvector (it(), 0, other, start, count, docopy);
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (vector_char_p_t const *other, bool docopy)
{
    return_if_null_pp (other, this);
    vector_char_p_init_internal_q (it(), ZERO(other), COPY_SIZE(other));
    if (docopy)
        vector_char_p_insert_vector (it(), 0, other);
    else
        vector_char_p_insert_no_copy (it(), 0, TABLE(other), other->m_nentries);
}
#endif /* defined(ERWIN_COMPAT_2_0_264) */

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (char * const *other, bool docopy)
{
    /* other == NULL is explicitly allowed to represent an empty string. */
    vector_char_p_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    if (docopy)
        vector_char_p_insert_string (it(), 0, other);
    else
        vector_char_p_insert_no_copy (it(), 0, other, vector_char_p_string_length (it(), other));
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (char * const *other, vector_char_p_cnt_t n, bool docopy)
{
    /* other == NULL is explicitly allowed if n == 0. */
    vector_char_p_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    if (docopy)
        vector_char_p_insert_raw (it(), 0, other, n);
    else
        vector_char_p_insert_no_copy (it(), 0, other, n);
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (bool must_be_true, char * *other, vector_char_p_cnt_t count, vector_char_p_cnt_t alloc)
{
    (void)must_be_true; /*unused*/

    vector_char_p_init_from_q (it(), other, count, alloc, OZERO);
    return_if_fail_pp (must_be_true, this);
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (bool must_be_true, vector_char_p_t *other)
{
    (void)must_be_true; /*unused*/

    vector_char_p_init_from_q (it(),
        TABLE(other),
        other->nentries(),
        other->table_size(),
        other->zero());
    other->detach();
    return_if_fail_pp (must_be_true, this);
}

CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (bool must_be_true, vector_char_p_t &other)
{
    (void)must_be_true; /*unused*/

    vector_char_p_init_from_q (it(),
        TABLE(&other),
        other.nentries(),
        other.table_size(),
        other.zero());
    other.detach();
    return_if_fail_pp (must_be_true, this);
}

#if VECTOR_CHAR_P_DYN_ZERO
CODE_SECTION(".text.t")
 vector_char_p_t::vector_char_p_t
        (bool must_be_true, char * *other, vector_char_p_cnt_t count, vector_char_p_cnt_t alloc, char *  z)
{
    (void)must_be_true; /*unused*/

    vector_char_p_init_from_q (it(), other, count, alloc, z);
    return_if_fail_pp (must_be_true, this);
}
#endif /* VECTOR_CHAR_P_DYN_ZERO */



CODE_SECTION(".text.vector_char_p_t")
 vector_char_p_t::~vector_char_p_t
        ()
{
    vector_char_p_destroy (it());
}


CODE_SECTION(".text._destructor")
void vector_char_p_t::_destructor
        ()
{
    vector_char_p_destroy (it());
}

#if !ERWIN_DEFAULT_NEW_DELETE

CODE_SECTION(".text.operatornew")
void * vector_char_p_t::operator new
        (size_t s)
{
    return ERWIN_PREFER_TNEW(void, s);
}

CODE_SECTION(".text.operatordelete")
void vector_char_p_t::operator delete
        (void *p, size_t s)
{
    ERWIN_PREFER_TDELETE(p, void, s);
}

CODE_SECTION(".text.operatornew")
void * vector_char_p_t::operator new[]
        (size_t s)
{
    return ERWIN_PREFER_TNEW(void, s);
}

CODE_SECTION(".text.operatordelete")
void vector_char_p_t::operator delete[]
        (void *p, size_t s)
{
    ERWIN_PREFER_TDELETE(p, void, s);
}

#endif /* !ERWIN_DEFAULT_NEW_DELETE */

CODE_SECTION(".text.operator")
vector_char_p_t & vector_char_p_t::operator=
        (vector_char_p_t const &other)
{
    vector_char_p_destroy (it());
#ifdef ERWIN_DOS
    if (TABLE(&other) == NULL && other.m_nentries == 0) {
        /* See copy constructor for explanation */
        vector_char_p_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    }
    else
#endif
    {
        vector_char_p_init_internal_q (it(), vector_char_p_zero (other.it()), GET_INITIAL_SIZE);
        vector_char_p_insert_vector (it(), 0, other.it());
    }
    return *this;
}

CODE_SECTION(".text.operator")
vector_char_p_t & vector_char_p_t::operator=
        (vector_char_p_t const *other)
{
    vector_char_p_destroy (it());
    vector_char_p_init_internal_q (it(), vector_char_p_zero (other->it()), GET_INITIAL_SIZE);
    vector_char_p_insert_vector (it(), 0, other->it());
    return *this;
}

#ifdef ERWIN_COMPAT_2_0_264
CODE_SECTION(".text.operator")
vector_char_p_t & vector_char_p_t::operator=
        (vector_char_p_t const *other)
{
    vector_char_p_destroy (it());
    vector_char_p_init_internal_q (it(), vector_char_p_zero (other), GET_INITIAL_SIZE);
    vector_char_p_insert_vector (it(), 0, other);
    return *this;
}
#endif /* defined(ERWIN_COMPAT_2_0_264) */


#ifndef NDEBUG

CODE_SECTION(".text.cn")
void vector_char_p_t::cn
        () const
{
    return_if_null_or_bad (this);
}

CODE_SECTION(".text.cn")
void vector_char_p_t::cn
        (void const *p) const
{
    return_if_null_or_bad (this);
    return_if_null_pp (p, this);
}
#endif /* !defined(NDEBUG) */

#undef self

#endif /* defined(__cplusplus) */


#endif /* !defined(PASS1) */

#undef IS_ZERO
#undef ISNT_ZERO
#undef ZERO
#undef ZEROVAR
#undef ASSERTION_FAILED
#undef QUOTATION_METHOD_CNT
#undef VECTOR_NOMEM
#undef errno
#undef FATAL_ERROR
#undef COMPAT_ERROR
#undef vector_char_p_global_last_format
#undef errstream
#undef errprint
#undef PASS1
#undef PASS2

#undef E_ASSERTIONFAILED
#undef E_BOOL
#undef e_char_is_cr0
#undef e_char_is_digit
#undef e_char_is_print
#undef e_char_is_space0
#undef e_char_is_xdigit
#undef e_char_to_lower
#undef e_char_to_upper
#undef E_COMPAT_2_0_264
#undef E_COMPILING
#undef E_DEFAULT_NEW_DELETE
#undef E_EMPTY
#undef E_ERROR_PRINT
#undef E_ERROR_STREAM
#undef e_erwininternalvectorerrno
#undef E_FALSE
#undef E_FILE_IDS
#undef E_FO_CENTER
#undef E_FO_CHECK
#undef E_FO_DO_USE_SEP
#undef E_FO_GET_RADIX
#undef E_FO_GET_SEP_AT
#undef E_FO_GET_USE_SEP
#undef E_FO_QUOTE_MASK
#undef E_FO_QUOTE_USER1
#undef E_FO_QUOTE_USER2
#undef E_FO_QUOTE_USER3
#undef E_FO_QUOTE_USER_MAX
#undef E_FO_QUOTE_USER_MIN
#undef E_FO_SIGNED
#undef E_FO_SPECIAL
#undef E_FO_S_TYPE_MASK
#undef E_FO_UPCASE
#undef E_FO_VECTOR
#undef E_FO_VOID_P
#undef E_GLOBAL_ERRNO
#undef E_HASH_INIT
#undef e_hash_state_t
#undef e_hashval_t
#undef e_int_hash
#undef E_IO
#undef e_merge_sort
#undef e_next_power2_minus1
#undef E_NOMEM
#undef E_NOTCOMPILED
#undef E_OK
#undef E_OPERATOR_NEW_CLEARS_MEMORY
#undef E_OUTOFRANGE
#undef E_PREFER_TDELETE
#undef E_PREFER_TNEW
#undef E_SET_PTR
#undef E_STATE_GET_HASHVAL
#undef E_STATE_INIT_WITH
#undef E_STATE_MIX_ORDERED
#undef E_TFREE1
#undef E_TFREE_ARRAY
#undef E_TFREE_ATOMS
#undef E_THING_DELETE1
#undef E_THING_DELETE_ARRAY
#undef E_THING_DELETE_ATOMS
#undef E_THING_NEW1
#undef E_THING_NEW_ARRAY
#undef E_THING_NEW_ATOMS
#undef E_THING_RENEW_ARRAY
#undef E_THING_RENEW_ATOMS
#undef E_THREAD_SAFE
#undef E_TMALLOC1
#undef E_TMALLOC_ARRAY
#undef E_TMALLOC_ATOMS
#undef E_TO_BOOL
#undef E_TOOLARGE
#undef E_TREALLOC_ARRAY
#undef E_TREALLOC_ATOMS
#undef E_TRUE
#undef E_USE_MUTABLE
#undef E_VERBOSE
#undef OBEING_USED
#undef OCMP
#undef OCONSTRUCTOR
#undef OCOPY
#undef OCOPY_PROVIDED
#undef ODESTRUCTOR
#undef OEQUAL
#undef OFREE
#undef OFREE_PROVIDED
#undef OHASH
#undef OPRIORITY_CMP
#undef OUPDATE_POS2
#undef OUPDATE_POS
#undef OZERO

