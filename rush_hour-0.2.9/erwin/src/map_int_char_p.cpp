/* -*- Mode: C -*- */
/*
 * Author: Henrik Theiling
 *
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifndef MAP_INT_CHAR_P_IMPLEMENTATION
#define MAP_INT_CHAR_P_IMPLEMENTATION
#endif

#include "erwin/defs.h"

#include "erwin/forwards.h"

#include "map_int_char_p_d.h"
#include "map_int_char_p.h"
#include "map_int_char_p_i.h"

#ifdef ERWIN_COMPILING
#  include "erwin/stdinc.h"
#else
#  include <erwin/stdinc.h>
#endif

#ifndef INT_BEING_USED
#define INT_BEING_USED 1
#endif

#ifndef CHAR_P_BEING_USED
#define CHAR_P_BEING_USED 1
#endif

#include "erwin/needed.h"



/*
 * This must be re-done: */

#ifdef MAP_ERR_ASSERTIONFAILED
#define E_ASSERTIONFAILED MAP_ERR_ASSERTIONFAILED
#endif

#ifdef ERWIN_BOOL
#define E_BOOL ERWIN_BOOL
#endif

#ifdef ERWIN_COMPAT_2_0_264
#define E_COMPAT_2_0_264 ERWIN_COMPAT_2_0_264
#endif

#ifdef ERWIN_COMPILING
#define E_COMPILING ERWIN_COMPILING
#endif

#ifdef ERWIN_DEFAULT_NEW_DELETE
#define E_DEFAULT_NEW_DELETE ERWIN_DEFAULT_NEW_DELETE
#endif

#ifdef MAP_WARN_EMPTY
#define E_EMPTY MAP_WARN_EMPTY
#endif

#ifdef erwininternalmaperrno
#define e_erwininternalmaperrno erwininternalmaperrno
#endif

#ifdef MAP_WARN_EXISTINGKEY
#define E_EXISTINGKEY MAP_WARN_EXISTINGKEY
#endif

#ifdef ERWIN_FALSE
#define E_FALSE ERWIN_FALSE
#endif

#ifdef ERWIN_FILE_IDS
#define E_FILE_IDS ERWIN_FILE_IDS
#endif

#ifdef ERWIN_GLOBAL_ERRNO
#define E_GLOBAL_ERRNO ERWIN_GLOBAL_ERRNO
#endif

#ifdef ERWIN_HASH_INIT
#define E_HASH_INIT ERWIN_HASH_INIT
#endif

#define e_hash_into erwin_hash_into

#define e_hash_state_t erwin_hash_state_t

#define e_hashval_t hashval_t

#ifdef erwin_init
#define e_init erwin_init
#endif

#ifdef init
#define e_init init
#endif

#ifdef int_hash
#define e_int_hash int_hash
#endif

#define e_iterator_sorted_t map_iterator_sorted_t

#define e_iterator_t map_iterator_t

#ifdef MAP_WARN_KEYNOTFOUND
#define E_KEYNOTFOUND MAP_WARN_KEYNOTFOUND
#endif

#define e_mapinitialised erwin_mapinitialised

#define e_merge_sort erwin_merge_sort

#ifdef ERWIN_NO_LINKER_TRICKS
#define E_NO_LINKER_TRICKS ERWIN_NO_LINKER_TRICKS
#endif

#ifdef MAP_ERR_NOMEM
#define E_NOMEM MAP_ERR_NOMEM
#endif

#ifdef MAP_WARN_NOMOREELEMS
#define E_NOMOREELEMS MAP_WARN_NOMOREELEMS
#endif

#ifdef MAP_OK
#define E_OK MAP_OK
#endif

#ifdef ERWIN_PREFER_TDELETE
#define E_PREFER_TDELETE ERWIN_PREFER_TDELETE
#endif

#ifdef ERWIN_PREFER_TNEW
#define E_PREFER_TNEW ERWIN_PREFER_TNEW
#endif

#ifdef ERWIN_PROFILE
#define E_PROFILE ERWIN_PROFILE
#endif

#ifdef MAP_REHASH_DUPLICATEKEY
#define E_REHASH_DUPLICATEKEY MAP_REHASH_DUPLICATEKEY
#endif

#ifdef MAP_REHASH_NOMEM
#define E_REHASH_NOMEM MAP_REHASH_NOMEM
#endif

#ifdef MAP_REHASH_RECURSION
#define E_REHASH_RECURSION MAP_REHASH_RECURSION
#endif

#define e_require_determinism erwin_require_determinism

#ifdef ERWIN_REQUIRE_DETERMINISM
#define E_REQUIRE_DETERMINISM ERWIN_REQUIRE_DETERMINISM
#endif

#ifdef ERWIN_SET_PTR
#define E_SET_PTR ERWIN_SET_PTR
#endif

#ifdef ERWIN_STATE_GET_HASHVAL
#define E_STATE_GET_HASHVAL ERWIN_STATE_GET_HASHVAL
#endif

#ifdef ERWIN_STATE_INIT_WITH
#define E_STATE_INIT_WITH ERWIN_STATE_INIT_WITH
#endif

#ifdef ERWIN_STATE_MIX_UNORDERED2
#define E_STATE_MIX_UNORDERED2 ERWIN_STATE_MIX_UNORDERED2
#endif

#ifdef ERWIN_STATE_MIX_UNORDERED
#define E_STATE_MIX_UNORDERED ERWIN_STATE_MIX_UNORDERED
#endif

#ifdef ERWIN_THING_CNEW_ARRAY
#define E_THING_CNEW_ARRAY ERWIN_THING_CNEW_ARRAY
#endif

#ifdef ERWIN_THING_DELETE1
#define E_THING_DELETE1 ERWIN_THING_DELETE1
#endif

#ifdef ERWIN_THING_DELETE_ARRAY
#define E_THING_DELETE_ARRAY ERWIN_THING_DELETE_ARRAY
#endif

#ifdef ERWIN_THING_DELETE_ATOMS
#define E_THING_DELETE_ATOMS ERWIN_THING_DELETE_ATOMS
#endif

#ifdef ERWIN_THING_NEW1
#define E_THING_NEW1 ERWIN_THING_NEW1
#endif

#ifdef ERWIN_THING_NEW_ARRAY
#define E_THING_NEW_ARRAY ERWIN_THING_NEW_ARRAY
#endif

#ifdef ERWIN_THING_NEW_ATOMS
#define E_THING_NEW_ATOMS ERWIN_THING_NEW_ATOMS
#endif

#ifdef ERWIN_THREAD_SAFE
#define E_THREAD_SAFE ERWIN_THREAD_SAFE
#endif

#ifdef ERWIN_TO_BOOL
#define E_TO_BOOL ERWIN_TO_BOOL
#endif

#ifdef ERWIN_TRUE
#define E_TRUE ERWIN_TRUE
#endif

#ifdef ERWIN_USE_MUTABLE
#define E_USE_MUTABLE ERWIN_USE_MUTABLE
#endif

#ifdef ERWIN_WEAK_DETERMINISM
#define E_WEAK_DETERMINISM ERWIN_WEAK_DETERMINISM
#endif

#ifdef ERWIN_WEAK_STORAGE
#define E_WEAK_STORAGE ERWIN_WEAK_STORAGE
#endif

#ifdef INT_BEING_USED
#define IBEING_USED INT_BEING_USED
#endif

#ifdef INT_CMP
#define ICMP INT_CMP
#endif

#ifdef INT_ICOPY
#define ICOPY INT_ICOPY
#endif

#ifdef INT_ICOPY_PROVIDED
#define ICOPY_PROVIDED INT_ICOPY_PROVIDED
#endif

#ifdef INT_DETCMP
#define IDETCMP INT_DETCMP
#endif

#ifdef INT_DETCMP_PROVIDED
#define IDETCMP_PROVIDED INT_DETCMP_PROVIDED
#endif

#ifdef INT_EQUAL
#define IEQUAL INT_EQUAL
#endif

#ifdef INT_EQUAL_PROVIDED
#define IEQUAL_PROVIDED INT_EQUAL_PROVIDED
#endif

#ifdef INT_IFREE
#define IFREE INT_IFREE
#endif

#ifdef INT_IFREE_PROVIDED
#define IFREE_PROVIDED INT_IFREE_PROVIDED
#endif

#ifdef INT_HASH
#define IHASH INT_HASH
#endif

#ifdef INT_PRINT
#define IPRINT INT_PRINT
#endif

#ifdef INT_ZERO
#define IZERO INT_ZERO
#endif

#ifdef CHAR_P_BEING_USED
#define OBEING_USED CHAR_P_BEING_USED
#endif

#ifdef CHAR_P_CMP
#define OCMP CHAR_P_CMP
#endif

#ifdef CHAR_P_OCOPY
#define OCOPY CHAR_P_OCOPY
#endif

#ifdef CHAR_P_OCOPY_PROVIDED
#define OCOPY_PROVIDED CHAR_P_OCOPY_PROVIDED
#endif

#ifdef CHAR_P_DETCMP
#define ODETCMP CHAR_P_DETCMP
#endif

#ifdef CHAR_P_DETCMP_PROVIDED
#define ODETCMP_PROVIDED CHAR_P_DETCMP_PROVIDED
#endif

#ifdef CHAR_P_EQUAL
#define OEQUAL CHAR_P_EQUAL
#endif

#ifdef CHAR_P_OFREE
#define OFREE CHAR_P_OFREE
#endif

#ifdef CHAR_P_OFREE_PROVIDED
#define OFREE_PROVIDED CHAR_P_OFREE_PROVIDED
#endif

#ifdef CHAR_P_HASH
#define OHASH CHAR_P_HASH
#endif

#ifdef CHAR_P_PRINT
#define OPRINT CHAR_P_PRINT
#endif

#ifdef CHAR_P_ZERO
#define OZERO CHAR_P_ZERO
#endif


#ifndef INT_IS_PTR
#define INT_IS_PTR 0
#endif /* !defined INT_IS_PTR */

#ifndef CHAR_P_IS_PTR
#define CHAR_P_IS_PTR 1
#endif /* !defined CHAR_P_IS_PTR */

#if defined(INT_IS_PTR) && INT_IS_PTR
#  define E_SET_KEY(X,Y)  E_SET_PTR(X,Y)
#else
#  define E_SET_KEY(X,Y)  ((X)=(Y))
#endif

#if defined(CHAR_P_IS_PTR) && CHAR_P_IS_PTR
#  define E_SET_VALUE(X,Y)  E_SET_PTR(X,Y)
#else
#  define E_SET_VALUE(X,Y)  ((X)=(Y))
#endif

#if MAP_INT_CHAR_P_INITIAL_SIZE < 0
#  error MAP_INT_CHAR_P_INITIAL_SIZE < 0
#endif

#if MAP_INT_CHAR_P_MINIMAL_SIZE < 0
#  error MAP_INT_CHAR_P_MINIMAL_SIZE < 0
#endif

#if MAP_INT_CHAR_P_MINIMAL_SIZE == 0
#  define MAP_INT_CHAR_P_ZERO_SIZE         1
#  define MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1 1
#elif MAP_INT_CHAR_P_INITIAL_SIZE == 0
#  define MAP_INT_CHAR_P_ZERO_SIZE         1
#  define MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1 MAP_INT_CHAR_P_MINIMAL_SIZE
#else
#  define MAP_INT_CHAR_P_ZERO_SIZE         0
#  define MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1 MAP_INT_CHAR_P_MINIMAL_SIZE
#endif

#if MAP_INT_CHAR_P_ZERO_SIZE

#  define HAS_HEAP_TABLE_AUX(hashsize)    ((hashsize) > 1)

#  define GET_SLOT(table,hashsize,i)      (HAS_HEAP_TABLE_AUX(hashsize) ? \
                                              (table[(i)])                \
                                            : *((map_int_char_p_hashlist_t**)(&(table)))     \
                                          )
#  define return_if_bad_table(self)
#  define return_val_if_bad_table(self,x)
#  define return_if_bad_table_pC(self,x)

#else

#  define HAS_HEAP_TABLE_AUX(hashsize)    ERWIN_TRUE
#  define GET_SLOT(table,hashsize,i)      (table[(i)])

#  define return_if_bad_table(self)       return_if_null_pp     ((self)->m_table, self)
#  define return_val_if_bad_table(self,x) return_val_if_null_pp ((self)->m_table, x, self)
#  define return_if_bad_table_pC(self,x)  return_if_null_ppC    ((self)->m_table, self, x)

#endif

#define HAS_HEAP_TABLE(self)            HAS_HEAP_TABLE_AUX((self)->m_hashsize)
#define SLOT(self,i)                    GET_SLOT((self)->m_table, (self)->m_hashsize, i)


#define FREE_TABLE(self)                do{                                                      \
                                            if (HAS_HEAP_TABLE(self))                            \
                                                ERWIN_THING_DELETE_ARRAY (self->m_table); \
                                        }while(0)

#if defined(CHAR_P_IS_PTR) && !CHAR_P_IS_PTR
#  define VALUE_NEW_ARRAY      ERWIN_THING_NEW_ATOMS
#  define VALUE_DELETE_ARRAY   ERWIN_THING_DELETE_ATOMS
#else
#  define VALUE_NEW_ARRAY      ERWIN_THING_NEW_ARRAY
#  define VALUE_DELETE_ARRAY   ERWIN_THING_DELETE_ARRAY
#endif

#if defined(INT_IS_PTR) && !INT_IS_PTR
#  define KEY_NEW_ARRAY        ERWIN_THING_NEW_ATOMS
#  define KEY_DELETE_ARRAY     ERWIN_THING_DELETE_ATOMS
#else
#  define KEY_NEW_ARRAY        ERWIN_THING_NEW_ARRAY
#  define KEY_DELETE_ARRAY     ERWIN_THING_DELETE_ARRAY
#endif

#if defined(INT_IS_PTR) && defined(CHAR_P_IS_PTR) && !INT_IS_PTR && !CHAR_P_IS_PTR
#  define PAIR_NEW_ARRAY       ERWIN_THING_NEW_ATOMS
#  define PAIR_DELETE_ARRAY    ERWIN_THING_DELETE_ATOMS
#else
#  define PAIR_NEW_ARRAY       ERWIN_THING_NEW_ARRAY
#  define PAIR_DELETE_ARRAY    ERWIN_THING_DELETE_ARRAY
#endif


#if !E_GLOBAL_ERRNO
#  if E_USE_MUTABLE
#      define e_errno (self->m_errno)
#  else
#      define e_errno (ERWIN_CONST_CAST(map_int_char_p_t*,self)->m_errno)
#  endif
#else
#  define e_errno erwininternalmaperrno
#endif

#define SET_ERRNO(X)       do{ e_errno= (X); }while(0)
#define PASS_ERRNO(X)      (e_errno= (X))

#ifndef assert
#define assert(X)         false_if_fail(X)
#endif /* !defined assert */

/* false_if_reached_pt */
/* false_if_reached_pk */

#define ASSERTION_FAILED   PASS_ERRNO(E_ASSERTIONFAILED)

#if MAP_INT_CHAR_P_HAVE_SIG
#  define return_if_bad(self) \
      return_if_fail_ppxxt(self->m_sig == MAP_INT_CHAR_P_SIG, self, self->m_sig, MAP_INT_CHAR_P_SIG, "Structure was probably overwritten");
#  define return_val_if_bad(self, val) \
      return_val_if_fail_ppxxt(self->m_sig == MAP_INT_CHAR_P_SIG, val, self, self->m_sig, MAP_INT_CHAR_P_SIG, "Structure was probably overwritten");
#  define return_if_bad_pC(self, prog) \
      return_if_fail_ppxxtC(self->m_sig == MAP_INT_CHAR_P_SIG, self, self->m_sig, MAP_INT_CHAR_P_SIG, "Structure was probably overwritten", prog);
#else
#  define return_if_bad(self)
#  define return_val_if_bad(self, val)
#  define return_if_bad_pC(self, prog)
#endif

#define return_if_null_or_bad(self) \
    return_if_null(self);           \
    return_if_bad (self);

#define return_val_if_null_or_bad(self, val) \
    return_val_if_null(self, val);           \
    return_val_if_bad (self, val);

#define return_if_null_or_bad_pC(self, prog) \
    return_if_null_pC(self, prog);           \
    return_if_bad_pC (self, prog);

#define return_if_null2i_or_bad(self) \
    return_if_null_or_bad(self);      \
    return_if_bad_table(self);

#define return_val_if_null2i_or_bad(self, val) \
    return_val_if_null_or_bad(self, val);      \
    return_val_if_bad_table(self, val);

#define return_if_null2i_or_bad_pC(self, prog) \
    return_if_null_or_bad_pC(self, prog);      \
    return_if_bad_table_pC(self, prog);

#define return0_if_bad(self)           return_val_if_bad(self, 0);
#define return0_if_bad_table(self)     return_val_if_bad_table(self, 0);
#define return0_if_null_or_bad(self)   return_val_if_null_or_bad(self, 0);
#define return0_if_null2i_or_bad(self) return_val_if_null2i_or_bad(self, 0);

#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A)    \
            ASSERTION_FAILED;                       \
            MAP_INT_CHAR_P_ASSERTION_FAILED_HANDLER(FI,L,FU,A)
#endif

#ifdef E_FILE_IDS
static char const * const map_cvs_id= "$""Id: none$";
#endif

/*
 * This file contains ugly macros.  Their purpose is to debug code, and
 * to be a substitute for assert.h.  This file should compile under any compiler
 * with all (sensible) compiler settings and #defines.  This is meant to be ANSI
 * code with GNUC extensions if we compile under GNUC.  It should under no
 * circumstances produce compiler errors and under GNUC it should not produce
 * any warnings.
 * So if it fails to compile, it is a severe bug.  Please report this to
 * henrik@theiling.de.  To temporarily circumvent the problem, you can comment
 * out the following line. */

/* #define ASSERT_IS_BROKEN */

#ifndef ASSERT_IS_BROKEN

/*
 * Additional user provided assertion failure, warning,
 * and error handlers.
 */
#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_ERROR_HANDLER
#define USER_ERROR_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_WARNING_HANDLER
#define USER_WARNING_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifdef __GNUC__

#define ASSERT_NORETURN  __attribute__((__noreturn__))

#if defined __cplusplus && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95))
#define ASSERT_CAST_VOID static_cast<void>
   /* for compiler warning -Wold-style-cast */
#endif

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   __PRETTY_FUNCTION__
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  (ASSERT_CAST_VOID(0)) /* To get rid of warnings. */
 /* FIXME: CHECK: do we need the different versions of ASSERT_NO_EFFECT? */
#endif

#else

#define ASSERT_NORETURN

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   "-unknown-"
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  0
#endif

#endif

#ifndef ASSERT_CAST_VOID
#define ASSERT_CAST_VOID (void)
#endif

#ifndef NDEBUG
#define ASSERT_DEBUG_CODE(X) X
#else
#define ASSERT_DEBUG_CODE(X)
#endif

#if defined(__KERNEL__)

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#elif defined(HAVE_LIBERROR)

#ifndef IN_LIBERROR_COMPILE
#include <liberror.h>
#endif

#ifndef ASSERT_ABORT
#define ASSERT_ABORT err_crash()
#endif

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (eprintf (C_TAG_ASSERT | 0, 0, ERR_CALLBACKS_ONLY))
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT
#endif

#else /* !defined HAVE_LIBERROR */

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#endif /* !defined HAVE_LIBERROR */

#ifndef ASSERT_ABORT
#define ASSERT_ABORT abort()
#endif

#ifndef ASSERT_NONNEGATIVE
#ifdef erwin_nonnegative
#define ASSERT_NONNEGATIVE(X) erwin_nonnegative(X)
#else
#define ASSERT_NONNEGATIVE(X) ((X) >= 0)
#endif
#endif

#ifndef ASSERT_UNLIKELY
#ifdef ERWIN_UNLIKELY
#define ASSERT_UNLIKELY(X) ERWIN_UNLIKELY(X)
#else
#define ASSERT_UNLIKELY(X) (X)
#endif
#endif


#ifndef NDEBUG
/*
 * The following macros are only available for debugging.  There will not
 * be an error_..._if_crash since a) that is weird, b) the macros
 * do not work on many platforms and should, therefore, not handle normal
 * control flow, c) we have to define helper data and functions. */

/*
 * In order to get the necessary #definitions automatically from a GNU
 * configure script, be sure to have the following lines in configure.in:

--- BEGIN configure.failure ---

AC_CHECK_HEADERS(signal.h)
AC_CHECK_HEADERS(setjmp.h)
AC_CHECK_FUNCS(setjmp)
AC_TYPE_SIGNAL

dnl The following might make the output nicer, but are not required:

AC_CHECK_HEADERS(unistd.h)
AC_DECL_SYS_SIGLIST

--- END configure.failure ---

 * Note that this file does not believe the configure settings if you compile
 * with -ansi (i.e. __STRICT_ANSI__ is defined).  This is a convenience
 * setting for gcc compilation tests when you do not want to call configure
 * again.

 * And either add the following lines to config.h.in:

--- BEGIN config.h.in.failure ---
#undef HAVE_SIGNAL_H
#undef HAVE_SETJMP_H
#undef HAVE_UNISTD_H
#undef RETSIGTYPE
#undef SYS_SIGLIST_DECLARED
--- END config.h.in.failure ---

 * And be sure to include your configuration header file before this file.
 */

#if defined(HAVE_SIGNAL_H) && defined(HAVE_SETJMP_H) && defined(HAVE_SETJMP) && defined(RETSIGTYPE) && !defined(__KERNEL__)

/* We have signals and debugging is enabled here.  And we are not in __KERNEL__ mode.*/

#include <signal.h>
#include <setjmp.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if defined(SYS_SIGLIST_DECLARED) && !defined(__STRICT_ANSI__)
#define ASSERT_STRSIGNAL(X) (sys_siglist[X])
#else
#define ASSERT_STRSIGNAL(X) "unknown"
#endif

static jmp_buf assert_jmp_buf;
static volatile int assert_signal_caught;
static volatile int assert_caught_no;

#if defined(SIGSEGV) || defined(_SIGSEGV)
static RETSIGTYPE (*assert_old_sigsegv)(int);
#endif
#if defined(SIGBUS) || defined(_SIGBUS)
static RETSIGTYPE (*assert_old_sigbus)(int);
#endif
#if defined(SIGABRT) || defined(_SIGABRT)
static RETSIGTYPE (*assert_old_sigabrt)(int);
#endif
#if defined(SIGFPE) || defined(_SIGFPE)
static RETSIGTYPE (*assert_old_sigfpe)(int);
#endif
#if defined(SIGILL) || defined(_SIGILL)
static RETSIGTYPE (*assert_old_sigill)(int);
#endif
#if defined(SIGHUP) || defined(_SIGHUP)
static RETSIGTYPE (*assert_old_sighup)(int);
#endif

static RETSIGTYPE assert_catch_signal (int) ASSERT_NORETURN;
static RETSIGTYPE assert_catch_signal (int which)
{
    assert_signal_caught= 1;
    assert_caught_no= which;
    longjmp (assert_jmp_buf, 1);
}

static void assert_begin_signals (void)
{
    assert_signal_caught= 0;

#if defined(_SIGSEGV)
    assert_old_sigsegv= signal (_SIGSEGV, &assert_catch_signal);
#elif defined(SIGSEGV)
    assert_old_sigsegv= signal (SIGSEGV, &assert_catch_signal);
#endif

#if defined(_SIGBUS)
    assert_old_sigbus= signal (_SIGBUS, &assert_catch_signal);
#elif defined(SIGBUS)
    assert_old_sigbus= signal (SIGBUS, &assert_catch_signal);
#endif

#if defined(_SIGABRT)
    assert_old_sigabrt= signal (_SIGABRT, &assert_catch_signal);
#elif defined(SIGABRT)
    assert_old_sigabrt= signal (SIGABRT, &assert_catch_signal);
#endif

#if defined(_SIGFPE)
    assert_old_sigfpe= signal (_SIGFPE, &assert_catch_signal);
#elif defined(SIGFPE)
    assert_old_sigfpe= signal (SIGFPE, &assert_catch_signal);
#endif

#if defined(_SIGILL)
    assert_old_sigill= signal (_SIGILL, &assert_catch_signal);
#elif defined(SIGILL)
    assert_old_sigill= signal (SIGILL, &assert_catch_signal);
#endif

#if defined(_SIGHUP)
    assert_old_sighup= signal (_SIGHUP, &assert_catch_signal);
#elif defined(SIGHUP)
    assert_old_sighup= signal (SIGHUP, &assert_catch_signal);
#endif
}

static void assert_end_signals (void)
{
#if defined(_SIGSEGV)
    signal (_SIGSEGV, assert_old_sigsegv);
#elif defined(SIGSEGV)
    signal (SIGSEGV, assert_old_sigsegv);
#endif

#if defined(_SIGBUS)
    signal (_SIGBUS, assert_old_sigbus);
#elif defined(SIGBUS)
    signal (SIGBUS, assert_old_sigbus);
#endif

#if defined(_SIGABRT)
    signal (_SIGABRT, assert_old_sigabrt);
#elif defined(SIGABRT)
    signal (SIGABRT, assert_old_sigabrt);
#endif

#if defined(_SIGFPE)
    signal (_SIGFPE, assert_old_sigfpe);
#elif defined(SIGFPE)
    signal (SIGFPE, assert_old_sigfpe);
#endif

#if defined(_SIGILL)
    signal (_SIGILL, assert_old_sigill);
#elif defined(SIGILL)
    signal (SIGILL, assert_old_sigill);
#endif

#if defined(_SIGHUP)
    signal (_SIGHUP, assert_old_sighup);
#elif defined(SIGHUP)
    signal (SIGHUP, assert_old_sighup);
#endif
}

/*
 * This is not nestable. */
#define ASSERT_TRY_COMMAND(X)                 \
        do {                                  \
            assert_begin_signals ();          \
            if (!setjmp (assert_jmp_buf)) {   \
                X;                            \
            }                                 \
            assert_end_signals ();            \
        } while (0)

#define ASSERT_NO_SIGNAL_CAUGHT (assert_signal_caught == 0)

#else

/* No signals, debugging enabled. */
#define ASSERT_TRY_COMMAND(X) do { X; } while (0)
        /* this *is* a crash test, so do it even if catching the error is
         * not possible on this machine... */
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X) "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* defined(HAVE_SIGNAL_H) ... */

#else

/* No signals, debugging disabled. */
#define ASSERT_TRY_COMMAND(X)
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X)  "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* DEBUG */


/*
 * Please note that this does not have any do { ... } while(0) protection.  This is because
 * continue_if_fail and break_if_fail would do wrong things in that case. */
#ifndef raw_do_if_fail
#define raw_do_if_fail(P,A1,A2,A3,W,F1,F2) \
        if (ASSERT_UNLIKELY(!(A1))) { \
            ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                     ""P" function '%s':\n" \
                     ASSERT_INDENT W " failed: '%s'\n" \
                     ASSERT_INDENT "Pre-processed: '%s'\n" \
                             , ASSERT_FUNCTION, \
                             A3 \
                             ,A2 \
                             ); \
            F1; \
            USER_ASSERTION_FAILED_HANDLER(__FILE__,__LINE__,ASSERT_FUNCTION, A); \
            F2; \
        } \
        else { ; }
#endif

/*
 * If you write your USER_ASSERTION_FAILED_HANDLER in such a way that it is an expression,
 * you can use the false_if_fail, null_if_fail, etc. */
#ifndef raw_value_if_fail
#define raw_value_if_fail(P,A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        (ASSERT_UNLIKELY(!(A1)) ? ((\
                     ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                          ""P" function '%s':\n" \
                          ASSERT_INDENT W" failed: '%s'\n" \
                          ASSERT_INDENT "Pre-processed: '%s'\n" \
                          , ASSERT_FUNCTION, \
                          A3 \
                          ,#A2 \
                          )), \
                  (F1), \
                  (USER_ASSERTION_FAILED_HANDLER(__FILE__, __LINE__, ASSERT_FUNCTION, A)), \
                  (FAILVAL)) \
                : (GOODVAL))
#endif

#ifndef NDEBUG

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("In",A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("In",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#else

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) (GOODVAL)
#endif

#endif

#ifndef warn_do_if_fail
#define warn_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Warning in",A1,A2,A3,W,F1,F2)
#endif

#ifndef warn_value_if_fail
#define warn_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Warning in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef error_do_if_fail
#define error_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Error in",A1,A2,A3,W,F1,F2)
#endif

#ifndef error_value_if_fail
#define error_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Error in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3) \
	 { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;break;;); } 
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached() \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached
#define exit1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null
#define exit_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached
#define exit_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef false_if_fail
#define false_if_fail(A1) \
	 ( value_if_fail(A1,A1,""#A1,"Assertion",(ASSERT_NO_EFFECT,ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) \
	 ( value_if_fail(0,0,"""0","Control flow",(ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n"),ASSERT_EPRINTF_MORE_1 ("%s\n", #X1),ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached
#define nothing_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_2 (""#X1"=%d ('%c')\n", (X1), (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2) \
	 do { \
	ASSERT_TRY_COMMAND(A1;);\
	do_if_fail(ASSERT_NO_SIGNAL_CAUGHT,A1;,""#A1,"Execution",ASSERT_EPRINTF_MORE_1 ("Signal number: %d\n", assert_caught_no);ASSERT_EPRINTF_MORE_1 ("Signal name: %s\n", ASSERT_STRSIGNAL(assert_caught_no));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));X3;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null
#define return0_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A4) != NULL,(A4) != NULL,"("#A4") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached
#define return0_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null
#define return1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached
#define return1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return_if_fail
#define return_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));X3;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%lu\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%lu\n", (unsigned long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));X5;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null
#define return_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); \
	do_if_fail((A1->A2) != NULL,(A1->A2) != NULL,"("#A1"->"#A2") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached
#define return_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%ld\n", (long)(X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif


#else /* !defined(ASSERT_IS_BROKEN) */

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1)
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1)
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1)
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1)
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1)
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1)
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1)
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1)
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M)
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached()
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1)
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1)
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2)
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2)
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1)
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1)
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2)
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2)
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1)
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1)
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1)
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1)
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1)
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1)
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1)
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2)
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2)
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1)
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M)
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit1_if_reached
#define exit1_if_reached()
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1)
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1)
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2)
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2)
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1)
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1)
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1)
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1)
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2)
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1)
#endif

#ifndef exit_if_null
#define exit_if_null(A1)
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1)
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1)
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2)
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2)
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1)
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M)
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit_if_reached
#define exit_if_reached()
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1)
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1)
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2)
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2)
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1)
#endif

#ifndef false_if_fail
#define false_if_fail(A1) (!0)
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) (!0)
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1)
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1)
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1)
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2)
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2)
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1)
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1)
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1)
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1)
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2)
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2)
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1)
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M)
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef nothing_if_reached
#define nothing_if_reached()
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1)
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2)
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1)
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2)
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3)
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2)
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1)
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1)
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1)
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1)
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2)
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4)
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1)
#endif

#ifndef return0_if_null
#define return0_if_null(A1)
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2)
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2)
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3)
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3)
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2)
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4)
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1)
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1)
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2)
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2)
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1)
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2)
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2)
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1)
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M)
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return0_if_reached
#define return0_if_reached()
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1)
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1)
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2)
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3)
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2)
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1)
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1)
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1)
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1)
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1)
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1)
#endif

#ifndef return1_if_null
#define return1_if_null(A1)
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1)
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1)
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2)
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2)
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1)
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M)
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return1_if_reached
#define return1_if_reached()
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1)
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1)
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2)
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2)
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1)
#endif

#ifndef return_if_fail
#define return_if_fail(A1)
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1)
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1)
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1)
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2)
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2)
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4)
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5)
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1)
#endif

#ifndef return_if_null
#define return_if_null(A1)
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2)
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2)
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1)
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1)
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2)
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2)
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1)
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2)
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2)
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1)
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M)
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_if_reached
#define return_if_reached()
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1)
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1)
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2)
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2)
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2)
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1)
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1)
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1)
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1)
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1)
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1)
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1)
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1)
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1)
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M)
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached()
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1)
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1)
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2)
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2)
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1)
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O)
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1)
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1)
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1)
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1)
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O)
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O)
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2)
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1)
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1)
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1)
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1)
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O)
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3)
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1)
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O)
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1)
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1)
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2)
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3)
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2)
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1)
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1)
#endif

#endif /* !defined(ASSERT_IS_BROKEN) */


/* ********************************************************************** */

#define TOOSMALL(X,Y) (((X) * MAP_INT_CHAR_P_TRIGGER_DENOMINATOR) > ((Y) * MAP_INT_CHAR_P_TRIGGER_NUMERATOR))

#define TOOLARGE(X,Y) (((Y) >= MAP_INT_CHAR_P_MINIMAL_SIZE) && \
                       (((X) * MAP_INT_CHAR_P_TRIGGER_DENOMINATOR) < (((Y) * MAP_INT_CHAR_P_TRIGGER_NUMERATOR)/4)))


/* Dynamic zero element?
 * Be careful with stupid compilers that choke on casts from A to A in C++.  Only
 * use casts if necessary.
 */
#if MAP_INT_CHAR_P_DYN_ZERO
#    define ZERO(SELF)    ((SELF)->m_zero)
#  define ZEROVAR(SELF) ((SELF)->m_zero)
#else
#    define ZERO(SELF)    OZERO
#    define ZEROVAR(SELF) OZERO
#endif

#define IZEROVAR    ICOPY(IZERO,NULL)

#define SORTITER_VOLATILE  ((e_iterator_sorted_t volatile *)iter)

#define ITER               ((map_int_char_p_internal_Iterator*)iter)
#define SORTITER           ((map_int_char_p_internal_sorted_Iterator*)iter)
#define SORTITERPTR        ((map_int_char_p_internal_sorted_ptr_Iterator*)iter)

#ifdef E_PROFILE
typedef union {
   map_int_char_p_t       *mapt;
   map_int_char_p_t const *mapconstt;
} hack_no_const;
#endif

/* We need all user types that may be a result type as simple type names,
 * because untemplatize cannot parse all C types.
 *
 * Some are now available globally, too:
 *    map_int_char_p_index_t == i_type_t
 *    map_int_char_p_value_t == o_type_t
 */
typedef char *       o_type_t;
typedef char *  o_type_result_t;
typedef char *    o_type_var_t;
typedef int       i_type_t;
typedef int  i_type_result_t;

#define SPLIT_SECTIONS MAP_INT_CHAR_P_SPLIT

#if SPLIT_SECTIONS
#  define CODE_SECTION(X) ATTR_SECTION(X)
#else
#  define CODE_SECTION(X)
#endif

/* Check that MAP_INT_CHAR_P_ALLOW_NULL and ERWIN_THREAD_SAFE are not used at
 * the same time.  It is not possible to do that since the error code is
 * stored in the data structure.  If the pointer to that is NULL, no error
 * codes can be returned. */
#if 0
/* FIXME: NYI */
#if MAP_INT_CHAR_P_ALLOW_NULL && defined(ERWIN_THREAD_SAFE)
#  error "Cannot use MAP_INT_CHAR_P_ALLOW_NULL and ERWIN_THREAD_SAFE at the same time."
#endif
#endif

#if MAP_INT_CHAR_P_NOMEM_IS_FATAL
#define MAP_NOMEM    error_exit_if_reached_pt("Fatal: Memory exhausted.")
#define MAP_NOMEM_R  error_exit_if_reached_pt("Fatal: Memory exhausted.")
#else
#define MAP_NOMEM    SET_ERRNO(E_NOMEM)
#define MAP_NOMEM_R  SET_ERRNO(E_REHASH_NOMEM)
#endif

#if MAP_INT_CHAR_P_DYN_ZERO
#  define map_int_char_p_init_internal_q(SE,Z,SI)  map_int_char_p_init_internal(SE,Z,SI)
#else
#  define map_int_char_p_init_internal_q(SE,Z,SI) map_int_char_p_init_internal(SE,SI)
#endif



#  define feature_q(K,V)                feature(K,V)
#  define map_int_char_p_hashlist_new_q(K,V)               map_int_char_p_hashlist_new(K,V)
#  define map_int_char_p_find_any_pair_q(K,V,SE)   map_int_char_p_find_any_pair(K,V,SE)
#  define map_int_char_p_insert_q(SE,K,V)          map_int_char_p_insert(SE,K,V)

#  define map_int_char_p_insert_no_copy_no_rehash_q(SE,K,V) \
                                        map_int_char_p_insert_no_copy_no_rehash(SE,K,V)

#  define map_int_char_p_poke_internal_q(KO,VO,SE,K,KC,DK,V,VK,DV,I,O) \
                                        map_int_char_p_poke_internal(KO,VO,SE,K,KC,DK,V,VK,DV,I,O)

#  define map_int_char_p_poke_q(KO,VO,SE,K,V,I,O)  map_int_char_p_poke(KO,VO,SE,K,V,I,O)

#  define map_int_char_p_poke_no_icopy_q(KO,VO,SE,K,V,I,O)  \
                                        map_int_char_p_poke_no_icopy(KO,VO,SE,K,V,I,O)

#  define map_int_char_p_remove_internal_no_resize_q(SE,K,R) \
                                        map_int_char_p_remove_internal_no_resize(SE,K,R)

#  define map_int_char_p_remove_internal_q(SE,K,R) map_int_char_p_remove_internal(SE,K,R)



#ifdef TYPE_INFO_T

static
TYPE_STRUCT_T(map_int_char_p_hashlist_t)=
    TYPE_STRUCT_BEGIN(map_int_char_p_hashlist_t)
        TYPE_STRUCT_SLOT(map_int_char_p_hashlist_t, int, key)
        TYPE_STRUCT_SLOT(map_int_char_p_hashlist_t, char_p, value)
        TYPE_STRUCT_SLOT(map_int_char_p_hashlist_t, map_int_char_p_hashlist_t_p,        next)
    TYPE_STRUCT_END
;


TYPE_INFO_T(map_int_char_p_hashlist_t)= TYPE_INFO_STRUCT (map_int_char_p_hashlist_t, map_int_char_p_hashlist_t);


TYPE_INFO_T(map_int_char_p_hashlist_t_p)= TYPE_INFO_POINTER (map_int_char_p_hashlist_t *, map_int_char_p_hashlist_t);


TYPE_INFO_T(map_int_char_p_hashlist_t_const_p)= TYPE_INFO_POINTER (map_int_char_p_hashlist_t const *, map_int_char_p_hashlist_t);


TYPE_INFO_T(map_int_char_p_content)= TYPE_INFO_VECTOR (map_int_char_p_content, map_int_char_p_hashlist_t_p, map_int_char_p_t, m_hashsize);


TYPE_INFO_T(map_int_char_p_content_p)= TYPE_INFO_POINTER (map_int_char_p_content *, map_int_char_p_content);

static
TYPE_STRUCT_T(map_int_char_p_internal_Iterator)=
    TYPE_STRUCT_BEGIN(map_int_char_p_internal_Iterator)
        TYPE_STRUCT_SLOT(map_int_char_p_internal_Iterator, map_int_char_p_hashlist_t_p, cnode)
        TYPE_STRUCT_SLOT(map_int_char_p_internal_Iterator, int,      cslot)
    TYPE_STRUCT_END
;


TYPE_INFO_T(map_int_char_p_internal_Iterator)=
    TYPE_INFO_STRUCT (map_int_char_p_internal_Iterator, map_int_char_p_internal_Iterator);

static
TYPE_STRUCT_T(map_int_char_p_t)=
    TYPE_STRUCT_BEGIN(map_int_char_p_t)
#ifdef  MAP_INT_CHAR_P_SUPER_TYPE
        TYPE_SUPER(map_int_char_p_t, MAP_INT_CHAR_P_SUPER_CLASS),
#endif
        MAP_INT_CHAR_P_TYPE_INFO_STD_MEMBERS
        map_int_char_p_record_sig     (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_sig))
        map_int_char_p_record_table   (TYPE_STRUCT_SLOT(map_int_char_p_t, map_int_char_p_content_p,   m_table))
        map_int_char_p_record_sizes   (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_hashsize))
        map_int_char_p_record_sizes   (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_nentries))
        map_int_char_p_record_errno   (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_errno))
        map_int_char_p_record_zero    (TYPE_STRUCT_SLOT(map_int_char_p_t, char_p, m_zero))
        map_int_char_p_record_compat  (TYPE_STRUCT_SLOT(map_int_char_p_t, map_int_char_p_internal_Iterator, compat1_iter))
        map_int_char_p_record_profile (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_nrehash))
        map_int_char_p_record_profile (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_nrehashops))
        map_int_char_p_record_profile (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_nfind))
        map_int_char_p_record_profile (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_ninsert))
        map_int_char_p_record_profile (TYPE_STRUCT_SLOT(map_int_char_p_t, int,             m_ndelete))
    TYPE_STRUCT_END
;


TYPE_INFO_T(map_int_char_p_t)= TYPE_INFO_STRUCT (map_int_char_p_t, map_int_char_p_t);


TYPE_INFO_T(map_int_char_p_t_p)= TYPE_INFO_POINTER (map_int_char_p_t *, map_int_char_p_t);


TYPE_INFO_T(map_int_char_p_t_const_p)= TYPE_INFO_POINTER (map_int_char_p_t const *, map_int_char_p_t);

#endif /* defined(TYPE_INFO_T) */


ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_new_q")
map_int_char_p_hashlist_t * map_int_char_p_hashlist_new_q
        (int  key, char *  value)
{
    map_int_char_p_hashlist_t *self;
    E_SET_PTR(self, ERWIN_THING_NEW1 (map_int_char_p_hashlist_t));
    if (ERWIN_UNLIKELY(self == NULL))
        return NULL;
    E_SET_KEY   (self->key,   key);
    E_SET_VALUE (self->value, value);
    E_SET_PTR   (self->next,  NULL);
    return self;
}


ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete")
void map_int_char_p_hashlist_delete
        (map_int_char_p_hashlist_t *list)
{
    map_int_char_p_hashlist_t *next;

    while (list) {
        IFREE (list->key);
        OFREE (list->value);
        E_SET_PTR(next, list->next);
        ERWIN_THING_DELETE1 (list, map_int_char_p_hashlist_t);
        E_SET_PTR(list, next);
    }
}


ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete_flags")
void map_int_char_p_hashlist_delete_flags
        (map_int_char_p_hashlist_t *list, ERWIN_BOOL keys, ERWIN_BOOL values)
{
    map_int_char_p_hashlist_t *next;

    while (list) {
        if (keys && IFREE_PROVIDED)   { IFREE (list->key); }
        if (values && OFREE_PROVIDED) { OFREE (list->value); }
        E_SET_PTR(next, list->next);
        ERWIN_THING_DELETE1 (list, map_int_char_p_hashlist_t);
        E_SET_PTR(list, next);
    }
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete_no_child_delete")
void map_int_char_p_hashlist_delete_no_child_delete
        (map_int_char_p_hashlist_t *list)
{
    map_int_char_p_hashlist_t *next;

    while (list) {
        E_SET_PTR(next, list->next);
        ERWIN_THING_DELETE1 (list, map_int_char_p_hashlist_t);
        E_SET_PTR(list, next);
    }
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_delete_cell")
void map_int_char_p_hashlist_delete_cell
        (map_int_char_p_hashlist_t *list)
{
    ERWIN_THING_DELETE1 (list, map_int_char_p_hashlist_t);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.hashlist_length")
int map_int_char_p_hashlist_length
        (map_int_char_p_hashlist_t *list)
{
    int result= 0;
    while (list) {
        result++;
        E_SET_PTR(list, list->next);
    }
    return result;
}
            

#if !E_GLOBAL_ERRNO
CODE_SECTION(".text.errno")
int map_int_char_p_errno
        (map_int_char_p_t const *self)
{
    return_val_if_null_or_bad (self, E_ASSERTIONFAILED);
    return e_errno;
}

CODE_SECTION(".text.clear_errno")
void map_int_char_p_clear_errno
        (map_int_char_p_t const *self)
{
    return_if_null_or_bad (self);
    SET_ERRNO(E_OK);
}
#endif /* !E_GLOBAL_ERRNO */


ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_internal_q")
ERWIN_BOOL map_int_char_p_init_internal_q
        (map_int_char_p_t *self, char *  zero, int nelem)
{
    int size;
#ifndef NDEBUG
    int err= 0;
    static int tested= 0;
            /* See vector.cd for a comment */
#endif

    size= nelem;
    if (nelem >= 0) { /* Compute hash size from expected number of elements: */
        size= ((nelem * MAP_INT_CHAR_P_TRIGGER_DENOMINATOR + MAP_INT_CHAR_P_TRIGGER_NUMERATOR - 1) / /* round up */
                MAP_INT_CHAR_P_TRIGGER_NUMERATOR * 2
              ) + 1;
    }

    if (size < 0)
        size= MAP_INT_CHAR_P_INITIAL_SIZE;

#if  MAP_INT_CHAR_P_HAVE_SIG
    self->m_sig= MAP_INT_CHAR_P_SIG;
#endif

    if (size <= 0)
        size= 1;
#if MAP_INT_CHAR_P_ZERO_SIZE
    if (size == 1)    /* this means that the slot table is missing and we have a single list. */
        E_SET_PTR(self->m_table, NULL); /* empty list! */
    else {
        E_SET_PTR(self->m_table, ERWIN_THING_CNEW_ARRAY (map_int_char_p_content, (unsigned)size));

        if (ERWIN_UNLIKELY(self->m_table == NULL)) {
            MAP_NOMEM;
            return ERWIN_FALSE;
        }
    }
#else
    E_SET_PTR(self->m_table, ERWIN_THING_CNEW_ARRAY (map_int_char_p_content, (unsigned)size));

    if (ERWIN_UNLIKELY(self->m_table == NULL)) {
        MAP_NOMEM;
        return ERWIN_FALSE;
    }
#endif


    self->m_hashsize= size;
    self->m_nentries= 0;

#ifdef E_PROFILE
    self->m_nrehash= 0;
    self->m_nrehashops= 0;
    self->m_nfind= 0;
    self->m_ninsert= 0;
    self->m_ndelete= 0;
#endif

#if MAP_INT_CHAR_P_DYN_ZERO
#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        return0_if_crash_ppt (
            (void)OCOPY (zero, NULL),
            self,
            "OCOPY crashes for zero element when ERR is NULL.");
    }
#endif

    E_SET_VALUE (self->m_zero, OCOPY (zero, NULL));
#endif

#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        /* Check that constraints about the copy functions hold.  These are typical bugs. */
        return0_if_crash_ppt (
            (void)ICOPY (IZERO, &err),
            self,
            "ICOPY crashes for zero element.");

        err= 0;
        (void)ICOPY (IZERO, &err);
        return0_if_fail_ppti (err == 0,
            self,
            "ICOPY seems to set error flag for zero element",
            err);

        err= 17;
        (void)ICOPY (IZERO, &err);
        return0_if_fail_ppti (err == 17,
            self,
            "ICOPY seems to overwrite error flag for zero element (the previous value of 17 was destroyed)",
            err);

        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), &err),
            self,
            "OCOPY crashes for zero element.");

        return0_if_fail_ppt  (
            IEQUAL((ICOPY (IZERO, &err)), IZERO),
            self,
            "ICOPY must not copy zero element.");

#ifdef OEQUAL
        return0_if_fail_ppt  (
            OEQUAL ((OCOPY (ZERO (self), &err)), ZERO (self)),
            self,
            "OCOPY must not copy zero element.");
#endif

        return0_if_crash_ppt (
            (void)ICOPY (IZERO, NULL),
            self,
            "ICOPY crashes when ERR is NULL.");

        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), NULL),
            self,
            "OCOPY crashes when ERR is NULL.");

        err= 0;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 0,
            self,
            "OCOPY seems to set error flag for zero element",
            err);

        err= 17;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 17,
            self,
            "OCOPY seems to overwrite error flag for zero element (the previous value of 17 was destroyed)",
            err);

        /* Check that the deletion function do not crash on zero elements. */
        return0_if_crash_ppt (
            IFREE (ICOPY (IZERO,  &err)),
            self,
            "IFREE crashes for zero element.");

        return0_if_crash_ppt (
            OFREE (ZEROVAR (self)),
            self,
            "OFREE crashes for zero element.");

        tested= 1;
    }
#endif

    return ERWIN_TRUE;
}

CODE_SECTION(".text.init")
int map_int_char_p_init
        (map_int_char_p_t *self)
{
    map_int_char_p_init_internal_q (self, OZERO, MAP_INT_CHAR_P_INITIAL_SIZE);
    return e_errno;
}

CODE_SECTION(".text.init_with_initial_size")
int map_int_char_p_init_with_initial_size
        (map_int_char_p_t *self, int size)
{
    map_int_char_p_init_internal_q (self, OZERO, size);
    return e_errno;
}

#if MAP_INT_CHAR_P_DYN_ZERO

CODE_SECTION(".text.init_with_zero_and_initial_size")
int map_int_char_p_init_with_zero_and_initial_size
        (map_int_char_p_t *self, char *  zero, int size)
{
    map_int_char_p_init_internal_q (self, zero, size);
    return e_errno;
}

/*
 * The general function for creating a new hash table.
 */
CODE_SECTION(".text.new_with_zero_and_initial_size")
map_int_char_p_t * map_int_char_p_new_with_zero_and_initial_size
        (char *  zero, int size)
{
    map_int_char_p_t *self;

    E_SET_PTR(self, ERWIN_THING_NEW1 (map_int_char_p_t));
    SET_ERRNO(E_OK);

    if (ERWIN_UNLIKELY(self == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(map_int_char_p_init_internal_q (self, zero, size)))
       return self;

    ERWIN_THING_DELETE1 (self, map_int_char_p_t);
    return NULL;
}

/*
 * Special frontends for the generic hash creation function
 */
CODE_SECTION(".text.new_with_zero")
map_int_char_p_t * map_int_char_p_new_with_zero
        (char *  zero)
{
    return map_int_char_p_new_with_zero_and_initial_size (zero, MAP_INT_CHAR_P_INITIAL_SIZE);
}

#endif /* MAP_INT_CHAR_P_DYN_ZERO */

#if MAP_INT_CHAR_P_CONSTANT_ZERO
#define map_int_char_p_new_with_zero_and_initial_size(Z,S) map_int_char_p_new_with_initial_size(S)
#define map_int_char_p_new_with_zero(Z)                    map_int_char_p_new()
#endif

/*
 * The general function for creating a new hash table.
 */
CODE_SECTION(".text.new_with_initial_size")
map_int_char_p_t * map_int_char_p_new_with_initial_size
        (int size)
{
    map_int_char_p_t *self;

    E_SET_PTR(self, ERWIN_THING_NEW1 (map_int_char_p_t));

    if (ERWIN_UNLIKELY(self == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(map_int_char_p_init_internal_q (self, OZERO, size)))
       return self;

    ERWIN_THING_DELETE1 (self, map_int_char_p_t);
    return NULL;
}

CODE_SECTION(".text.new")
map_int_char_p_t * map_int_char_p_new
        (void)
{
    return map_int_char_p_new_with_zero_and_initial_size (OZERO, MAP_INT_CHAR_P_INITIAL_SIZE);
}


CODE_SECTION(".text.zero")
o_type_result_t map_int_char_p_zero
        (map_int_char_p_t const *self)
{
    (void)self; /*unused*/

    return ZERO(self);
}

/*
 * For use with copy constructors:
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.struct_copy")
void map_int_char_p_struct_copy
        (map_int_char_p_t *copy, map_int_char_p_t const *self)
{
    int i;

    for (i= 0; i < self->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR(lauf, SLOT(self,i));
       while (lauf) {
           map_int_char_p_insert_q (copy, lauf->key, lauf->value);
           E_SET_PTR(lauf, lauf->next);
       }
    }
}

/*
 * Copy a hash table
 */
CODE_SECTION(".text.copy")
map_int_char_p_t * map_int_char_p_copy
        (map_int_char_p_t const* self)
{
    map_int_char_p_t *copy;
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return NULL;
    }
    return0_if_null2i_or_bad (self);

    E_SET_PTR(copy, map_int_char_p_new_with_zero_and_initial_size (ZERO(self), self->m_nentries));
    map_int_char_p_struct_copy (copy, self);
    return copy;
}

CODE_SECTION(".text.copy_err")
map_int_char_p_t * map_int_char_p_copy_err
        (map_int_char_p_t const* self, int *err)
{
    map_int_char_p_t *result;

    E_SET_PTR(result, map_int_char_p_copy (self));

    if (ERWIN_UNLIKELY(err != NULL && e_errno != E_OK))
        *err= 1;

    return result;
}


/*
 * Get the size of the hash table.  NOT the number of elements
 * in the table, but the size of the internal map.  This is
 * useful for advanced users only.
 */
CODE_SECTION(".text.hash_size")
int map_int_char_p_hash_size
        (map_int_char_p_t const* self)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return0_if_null (self);

    return self->m_hashsize;
}


/*
 * Get the number of entries in the hash table.
 */
CODE_SECTION(".text.nentries")
int map_int_char_p_nentries
        (map_int_char_p_t const* self)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return0_if_null (self);

    return self->m_nentries;
}

CODE_SECTION(".text.empty")
ERWIN_BOOL map_int_char_p_empty
        (map_int_char_p_t const* self)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_TRUE;
#endif
    return0_if_null (self);

    return ERWIN_TO_BOOL (self->m_nentries == 0);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.clear_internal")
void map_int_char_p_clear_internal
        (map_int_char_p_t* self)
{
    int i;
    for (i=0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_delete (SLOT(self,i));
        E_SET_PTR(SLOT(self,i), NULL);
    }
}

CODE_SECTION(".text.clear_no_resize")
void map_int_char_p_clear_no_resize
        (map_int_char_p_t* self)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    return_if_null2i_or_bad (self);

    map_int_char_p_clear_internal (self);

    self->m_nentries= 0;
    SET_ERRNO(E_OK);
}

static
CODE_SECTION(".text.clear_internal_flags")
void map_int_char_p_clear_internal_flags
        (map_int_char_p_t* self, ERWIN_BOOL keys, ERWIN_BOOL values)
{
    int i;
    for (i=0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_delete_flags (SLOT(self,i), keys, values);
        E_SET_PTR (SLOT(self,i), NULL);
    }
}

/*
 * Remove all entries from the hash table but possibly do not delete them.
 */
CODE_SECTION(".text.clear_flags_no_resize")
void map_int_char_p_clear_flags_no_resize
        (map_int_char_p_t* self, ERWIN_BOOL keys, ERWIN_BOOL values)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    return_if_null2i_or_bad (self);

    map_int_char_p_clear_internal_flags (self, keys, values);
    self->m_nentries= 0;
    SET_ERRNO(E_OK);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.destroy_internal")
void map_int_char_p_destroy_internal
        (map_int_char_p_t* self)
{
    return_if_null2i_or_bad (self);

    map_int_char_p_clear_internal (self);
    FREE_TABLE(self);

#if MAP_INT_CHAR_P_HAVE_SIG
    self->m_sig= 0;
#endif
}

CODE_SECTION(".text.xchg")
void map_int_char_p_xchg
        (map_int_char_p_t *self, map_int_char_p_t *other)
{
    map_int_char_p_record_table   (ERWIN_XCHG (map_int_char_p_content_p,   self->m_table,      other->m_table));
    map_int_char_p_record_sizes   (ERWIN_XCHG (int,             self->m_hashsize,   other->m_hashsize));
    map_int_char_p_record_sizes   (ERWIN_XCHG (int,             self->m_nentries,   other->m_nentries));
    map_int_char_p_record_errno   (ERWIN_XCHG (int,             self->m_errno,      other->m_errno));
    map_int_char_p_record_zero    (ERWIN_XCHG (char *,        self->m_zero,       other->m_zero));
    map_int_char_p_record_compat  (ERWIN_XCHG (map_iterator_t,  self->compat1_iter, other->compat1_iter));
    map_int_char_p_record_profile (ERWIN_XCHG (int,             self->m_nrehash,    other->m_nrehash));
    map_int_char_p_record_profile (ERWIN_XCHG (int,             self->m_nrehashops, other->m_nrehashops));
    map_int_char_p_record_profile (ERWIN_XCHG (int,             self->m_nfind,      other->m_nfind));
    map_int_char_p_record_profile (ERWIN_XCHG (int,             self->m_ninsert,    other->m_ninsert));
    map_int_char_p_record_profile (ERWIN_XCHG (int,             self->m_ndelete,    other->m_ndelete));
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.destroy_internal_flags")
void map_int_char_p_destroy_internal_flags
        (
    map_int_char_p_t* self,
    ERWIN_BOOL destroy_keys,
    ERWIN_BOOL destroy_values)
{
    return_if_null2i_or_bad (self);

    map_int_char_p_clear_internal_flags (self, destroy_keys, destroy_values);
    FREE_TABLE(self);

#if MAP_INT_CHAR_P_HAVE_SIG
    self->m_sig= 0;
#endif
}

CODE_SECTION(".text.destroy")
void map_int_char_p_destroy
        (map_int_char_p_t* self)
{
    map_int_char_p_destroy_internal (self);
}

CODE_SECTION(".text.destroy_flags")
void map_int_char_p_destroy_flags
        (map_int_char_p_t* self, ERWIN_BOOL k, ERWIN_BOOL v)
{
    map_int_char_p_destroy_internal_flags (self, k, v);
}

/*
 * Free the whole hash table
 */
CODE_SECTION(".text.delete_flags")
void map_int_char_p_delete_flags
        (
    map_int_char_p_t* self, ERWIN_BOOL destroy_keys, ERWIN_BOOL destroy_values)
{
    if (self != NULL) {
        map_int_char_p_destroy_internal_flags (self, destroy_keys, destroy_values);
        ERWIN_THING_DELETE1 (self, map_int_char_p_t);
    }
}

CODE_SECTION(".text.delete")
void map_int_char_p_delete
        (map_int_char_p_t* self)
{
    if (self != NULL) {
        map_int_char_p_destroy_internal (self);
        ERWIN_THING_DELETE1 (self, map_int_char_p_t);
    }
}


CODE_SECTION(".text.expect_size")
ERWIN_BOOL map_int_char_p_expect_size
        (map_int_char_p_t *self, int newsize)
{
    int new_hash_size;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return ERWIN_FALSE;
    }
#endif
    return0_if_null2i_or_bad (self);

    new_hash_size= self->m_hashsize;
    return0_if_fail (newsize >= 0);

    if (TOOSMALL(newsize, new_hash_size)) {
        /* Slightly more general than grow_perhaps, but
         * we do not replace the code there because of the
         * overhead of checking self */
#if MAP_INT_CHAR_P_ZERO_SIZE
        if (new_hash_size <= 1) {
            /* up to a given size, we keep the single slot, despite TOOSMALL finding
             * this too small. :-) */
            if (newsize <= MAP_INT_CHAR_P_PLAIN_LIST_LENGTH)
                return ERWIN_FALSE;
        }
#endif

        do {
            new_hash_size*= 2;
        } while(TOOSMALL(newsize, new_hash_size));

        map_int_char_p_rehash (self, new_hash_size);

        return ERWIN_TRUE;
    }

    if (TOOLARGE(newsize, new_hash_size)) {
        /* Slightly more general than shrink_perhaps, but
         * we do not replace the code there because of the
         * overhead of checking self */
#if MAP_INT_CHAR_P_ZERO_SIZE
        if (newsize <= MAP_INT_CHAR_P_PLAIN_LIST_LENGTH)
            new_hash_size=1;
        else
#endif
        {
            do {
                new_hash_size/= 2;
            } while (TOOLARGE (newsize, new_hash_size));

            if (new_hash_size < MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1)
                new_hash_size= MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1;
        }

        map_int_char_p_rehash (self, new_hash_size);

        return ERWIN_TRUE;
    }

    return ERWIN_FALSE;
}

/*
 * Internal function: possibly rehashes the table if it is
 * too small
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.grow_perhaps")
ERWIN_BOOL map_int_char_p_grow_perhaps
        (map_int_char_p_t *self)
{
    return0_if_fail (self->m_hashsize > 0); /* must be, even for ZERO_SIZE */
#if MAP_INT_CHAR_P_ZERO_SIZE
    if (ERWIN_UNLIKELY(self->m_hashsize == 1)) {
        if (self->m_nentries+1 <= MAP_INT_CHAR_P_PLAIN_LIST_LENGTH)
            return ERWIN_FALSE;
    }
#endif
    if (ERWIN_UNLIKELY(TOOSMALL ((self->m_nentries+1), self->m_hashsize))) {
        map_int_char_p_rehash (self, self->m_hashsize * 2);
        return ERWIN_TRUE;
    }
    return ERWIN_FALSE;
}

/*
 * Internal function: possibly shrinks the table if it is
 * too large
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.shrink_perhaps")
ERWIN_BOOL map_int_char_p_shrink_perhaps
        (map_int_char_p_t *self)
{
    if (ERWIN_UNLIKELY(TOOLARGE (self->m_nentries, self->m_hashsize))) {
        int newsize= self->m_hashsize;

#if MAP_INT_CHAR_P_ZERO_SIZE
        if (self->m_nentries <= MAP_INT_CHAR_P_PLAIN_LIST_LENGTH)
            newsize= 1;
        else
#endif
        {
            do {
                newsize/= 2;
            } while (TOOLARGE (self->m_nentries, newsize));

            if (newsize < MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1)
                newsize= MAP_INT_CHAR_P_MINIMAL_SIZE_OR_1;
        }

        map_int_char_p_rehash (self, newsize);

        return ERWIN_TRUE;
    }
    return ERWIN_FALSE;
}


/*
 * Remove all entries from the hash table but possibly do not delete them.
 */
CODE_SECTION(".text.clear_flags")
void map_int_char_p_clear_flags
        (map_int_char_p_t* self, ERWIN_BOOL keys, ERWIN_BOOL values)
{
    map_int_char_p_clear_flags_no_resize (self, keys, values);
    map_int_char_p_shrink_perhaps (self);
}

/*
 * Remove all entries from the hash table.  Somewhat equivalent with
 * delete() followed by new().
 */
CODE_SECTION(".text.clear")
void map_int_char_p_clear
        (map_int_char_p_t* self)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    map_int_char_p_clear_no_resize(self);
    map_int_char_p_shrink_perhaps (self);
    SET_ERRNO(E_OK);
}

/*
 * Internal function: get the slot in the hash table an element
 * falls into.
 * NOTE: This profits a lot from -DNDEBUG...
 */
ERWIN_STATIC_INLINE ATTR_ALWAYS_INLINE
CODE_SECTION(".text.slot_no")
unsigned map_int_char_p_slot_no
        (map_int_char_p_t const *self, int  key)
{
    int slot;
    return0_if_null (self);
    return0_if_fail_ppi (self->m_hashsize > 0, self, self->m_hashsize);

#if 0
    /* this breaks the DFS ordering of the modules.  It may not be invoked. */
    return0_if_fail_pptC (e_mapinitialised,
        self,
        "Please invoke erwin_init (&argc, &argv) in main().",
        erwin_init (NULL, NULL));
#else
    /* abort immediately because the library is instable in this state. */
    exit_if_fail_ppt (e_mapinitialised,
        self,
        "Please invoke erwin_init (&argc, &argv) in main().  If this "
        "Erwin library is part of a library, invoke init(&argc, &argv) "
        "instead (or the appropriate initialisation function of the library), "
        "which in turn will invoke erwin_init() probably among other "
        "things.");
#endif

    slot= e_hash_into (IHASH (key), self->m_hashsize);

    return0_if_fail_ppiit (slot >= 0 && slot < self->m_hashsize,
        self,
        slot,
        self->m_hashsize,
        "e_hash_into() does not work correctly.");
    return slot;
}


/*
 * Internal: Find a key in the hash table and return the pointer to the
 * pointer the list entry.  This allows for deletion and insertion.
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.find_internal_ptr")
map_int_char_p_hashlist_t ** map_int_char_p_find_internal_ptr
        (map_int_char_p_t const* self, int  key)
{
    map_int_char_p_hashlist_t **lauf;
#ifdef E_PROFILE
    hack_no_const h;
#endif

#if MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif

    return0_if_null (self);

#ifdef E_PROFILE
    E_SET_PTR(h.mapconstt, self);
    h.mapt->m_nfind++;  /* this is a mutable entry */
#endif

    return0_if_bad_table (self);

    E_SET_PTR(lauf, &SLOT(self, map_int_char_p_slot_no (self, key)));
    while (*lauf) {
        if (IEQUAL (((*lauf)->key), key))
            return lauf;
        E_SET_PTR(lauf, &(*lauf)->next);
    }
    return lauf;
}


/*
 * Internal function: Find a key in the hash table.  Two versions depending
 * on whether optimising for speed or for size. */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.find_internal")
map_int_char_p_hashlist_t * map_int_char_p_find_internal
        (map_int_char_p_t const* self, int  key)
{
    map_int_char_p_hashlist_t **result;

    E_SET_PTR(result, map_int_char_p_find_internal_ptr (self, key));
#if MAP_INT_CHAR_P_ALLOW_NULL
    if (result == NULL)
        return NULL;
#endif
    return0_if_null_pp (result, self);
    return *result;
}



/*
 * This looks disgusting but there are several versions depending on
 * wether char * == char * or not. */
CODE_SECTION(".text.find_ptr")
map_int_char_p_element_ptr_t map_int_char_p_find_ptr
        (map_int_char_p_t const* self, int  key)
{
    map_int_char_p_hashlist_t *lauf;

    E_SET_PTR(lauf, map_int_char_p_find_internal (self, key));
    if (lauf == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return NULL;
    }
    SET_ERRNO(E_OK);
    return &lauf->value;
}



/*
 * This *must* be inlined, otherwise the code is aweful.
 *
 * poke_internal is most general.  It implements all _poke functions.
 * Note that for the following implementation it is (again) essential
 * that the COPY functions do not touch the zero elements.
 * This is written with the hope that the compiler optimises when inlining.
 * There are several issues that may seem to need optimisation, but due
 * to source code optimisation, I leave this to the compiler.
 *
 * FIXME: make this a macro for better optimisation (especially for
 *        map_int_char_p_ensure which currently evaluates ENSURE_VALUE to often).
 *
 * FIXME: change this to return `lauf' instead of errno.  Then find_ptr_ensure
 *        can use this function, too.
 *
 */
ERWIN_STATIC_INLINE_SPEED ATTR_ALWAYS_INLINE
CODE_SECTION(".text.poke_internal_q")
int map_int_char_p_poke_internal_q
        (
        int                *key_out,
        char *             *value_out,
        map_int_char_p_t                *self,
        int           key,
        int          givenkeycopy,
        ERWIN_BOOL     dokeycopy,
        char *           value,
        char *          givenvaluecopy,
        ERWIN_BOOL     dovaluecopy,
        ERWIN_BOOL     introduce,
        ERWIN_BOOL     overwrite)
{
    int copyerror= ERWIN_FALSE;
    map_int_char_p_hashlist_t **lauf;

    /* Try to find the entry */
    E_SET_PTR(lauf, map_int_char_p_find_internal_ptr (self, key));
#if MAP_INT_CHAR_P_ALLOW_NULL
    if (lauf == NULL || *lauf == NULL)
#else
    return_val_if_null_ppC (lauf, ASSERTION_FAILED, self,
        (
            ((value_out == NULL) ? (void)0 : (void)E_SET_VALUE (*value_out, ZEROVAR (self))),
            ((key_out   == NULL) ? (void)0 : (void)E_SET_KEY (*key_out, IZERO))
        )
    );
    if (*lauf == NULL)
#endif
    {

        /* An old value did not exist. */
        if (value_out != NULL) E_SET_VALUE (*value_out, ZEROVAR (self));

        if (introduce) {
            return_val_if_null_pp (self, ASSERTION_FAILED, self);

            /* Possibly rehash.  Do it late so that checking the hash trigger is
             * performed less often.  Searching again hurts less because it's seldom. */
            if (map_int_char_p_grow_perhaps (self)) {
                E_SET_PTR(lauf, map_int_char_p_find_internal_ptr (self, key));
            }
            return_val_if_null_pp (lauf, ASSERTION_FAILED, self);
            return_val_if_fail_pp (*lauf == NULL, ASSERTION_FAILED, self);

            /* ********************************************************************** */
            /* This is long to help optimising compilers.  */
            if (dovaluecopy) {
                char * valuecopy;
                E_SET_VALUE (valuecopy, OCOPY (value, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror))
                    goto nomem;

                if (dokeycopy) {
                    int keycopy;
                    E_SET_KEY (keycopy, ICOPY (key, &copyerror));
                    if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror)) {
                        OFREE (valuecopy);
                        goto nomem;
                    }

                    if (key_out != NULL)
                        E_SET_KEY (*key_out, keycopy);

                    E_SET_PTR(*lauf, map_int_char_p_hashlist_new (keycopy, valuecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL)) {
                        IFREE (keycopy);
                        OFREE (valuecopy);
                        goto nomem;
                    }
                }
                else {
                    if (key_out != NULL)
                        E_SET_KEY (*key_out, givenkeycopy);

                    E_SET_PTR(*lauf, map_int_char_p_hashlist_new (givenkeycopy, valuecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL)) {
                        OFREE (valuecopy);
                        goto nomem;
                    }
                }
            }
            else
            {
                if (dokeycopy) {
                    int keycopy;
                    E_SET_KEY (keycopy, ICOPY (key, &copyerror));
                    if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror))
                        goto nomem;

                    if (key_out != NULL)
                        E_SET_KEY (*key_out, keycopy);

                    E_SET_PTR(*lauf, map_int_char_p_hashlist_new_q (keycopy, givenvaluecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL)) {
                        IFREE (keycopy);
                        goto nomem;
                    }
                }
                else {
                    if (key_out != NULL)
                        E_SET_KEY (*key_out, givenkeycopy);

                    E_SET_PTR(*lauf, map_int_char_p_hashlist_new_q (givenkeycopy, givenvaluecopy));

                    if (ERWIN_UNLIKELY(*lauf == NULL))
                        goto nomem;
                }
            }
            /* ********************************************************************** */

            /* update counter and return happily */
            self->m_nentries++;

            return PASS_ERRNO(E_OK);
        }
        else {
            if (key_out != NULL) E_SET_KEY (*key_out, IZERO);

            /* NOTE: We shall not copy the key (or value) but use the given one.
             *       We don't use either of them, so we have to deallocate them.
             *
             * The bug fix of this memory leak is dedicated to Michael Schmidt who
             * found it using dmalloc. :-) (Yes, someone does use poke_no_icopy...)
             */
            if (!dovaluecopy) {
                OFREE (givenvaluecopy);
            }
            if (!dokeycopy) {
                IFREE (givenkeycopy);
            }

            return PASS_ERRNO(E_KEYNOTFOUND);
        }
    }
    else {
        /* Return found key and value to caller */
        if (key_out != NULL)   E_SET_KEY   (*key_out,   (*lauf)->key);

        if (value_out != NULL) E_SET_VALUE (*value_out, (*lauf)->value);

        /* Same as before: we do not incorporate the given key
         * into the hash table, so we must free it. */
        if (!dokeycopy) {
            IFREE (givenkeycopy);
        }

        if (overwrite) {
#if OFREE_PROVIDED
            /* keep old copy for possibly deletion. */
            char * oldvalue;
            E_SET_VALUE (oldvalue, (*lauf)->value);
#endif


            if (dovaluecopy) {
                char * valuecopy;
                E_SET_VALUE (valuecopy, OCOPY (value, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror))
                    goto nomem;

                E_SET_VALUE ((*lauf)->value, valuecopy);
            }
            else
                E_SET_VALUE ((*lauf)->value, givenvaluecopy);

#if OFREE_PROVIDED
            /* delete old entry if caller does not want it */
            if (value_out == NULL) {
                OFREE (oldvalue);
            }
#endif

            /* return PASS_ERRNO(E_OK); */
            return PASS_ERRNO(E_EXISTINGKEY);
               /* important change!  This means that you get to know when
                * _set overwrites a value. */
        }
        else
        {
            /* We will report that the entry was not overwritten by an appropriate error code. */
            /* If neither overwrite nor introduce is set, return E_OK, since we were only
             * searching and that succeeded. */

            /* Same as before */
            if (!dovaluecopy) {
                OFREE (givenvaluecopy);
            }

            return PASS_ERRNO(introduce ? E_EXISTINGKEY : E_OK);
        }
    }

    return_val_if_reached_pp (ASSERTION_FAILED, self);
    return E_ASSERTIONFAILED;


    /* These are out of the way to improve execution performance in the normal case.
     * Fall through edges rock! */

nomem:
    MAP_NOMEM;
    return e_errno;
}

/*
 * User space poke functions */
CODE_SECTION(".text.poke_q")
int map_int_char_p_poke_q
        (   
    int *ko, char * *vo,
    map_int_char_p_t *self,
    int  k, char *  v,
    ERWIN_BOOL i, ERWIN_BOOL o)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return map_int_char_p_poke_internal_q (ko,vo,self, k,IZEROVAR,ERWIN_TRUE, v,ZEROVAR(self),ERWIN_TRUE, i,o);
}

CODE_SECTION(".text.poke_no_icopy_q")
int map_int_char_p_poke_no_icopy_q
        (
    int *ko, char * *vo, map_int_char_p_t *self, int  k, char *  v, ERWIN_BOOL i, ERWIN_BOOL o)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return map_int_char_p_poke_internal_q (ko,vo,self, k,k,ERWIN_FALSE, v,ZEROVAR(self),ERWIN_TRUE, i,o);
}

CODE_SECTION(".text.poke_no_ocopy")
int map_int_char_p_poke_no_ocopy
        (
    int *ko, char * *vo, map_int_char_p_t *self, int  k, char *  v, ERWIN_BOOL i, ERWIN_BOOL o)
{
    return map_int_char_p_poke_internal (ko,vo,self, k,IZEROVAR,ERWIN_TRUE, v,v,ERWIN_FALSE, i,o);
}

CODE_SECTION(".text.poke_no_icopy_no_ocopy")
int map_int_char_p_poke_no_icopy_no_ocopy
        (
    int *ko, char * *vo, map_int_char_p_t *self, int  k, char *  v, ERWIN_BOOL i, ERWIN_BOOL o)
{
    return map_int_char_p_poke_internal (ko, vo, self, k,k,ERWIN_FALSE, v,v,ERWIN_FALSE, i,o);
}



/*
 * For a given key, find the value in the hash table */
CODE_SECTION(".text.find")
o_type_result_t map_int_char_p_find
        (map_int_char_p_t const* self, int  key)
{
    map_int_char_p_hashlist_t *lauf;

#if defined(MAP_INT_CHAR_P_ALLOW_NULL) && MAP_INT_CHAR_P_CONSTANT_ZERO
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return OZERO;
    }
#endif

    E_SET_PTR(lauf, map_int_char_p_find_internal (self, key));
    if (lauf == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ZERO(self);
    }
    SET_ERRNO(E_OK);

    return lauf->value;

}


CODE_SECTION(".text.find_ensure")
o_type_result_t map_int_char_p_find_ensure
        (map_int_char_p_t * self, int  key)
{
    map_int_char_p_element_ptr_t result;
    E_SET_PTR(result, map_int_char_p_find_ptr_ensure (self, key));
#if !MAP_INT_CHAR_P_NOMEM_IS_FATAL
    if (result == NULL) /* do not trigger segmentation fault */
        return ZERO(self);
#endif
    return *result;
}


/*
 * For a given key, find the key in the hash table */
CODE_SECTION(".text.find_key")
i_type_result_t map_int_char_p_find_key
        (map_int_char_p_t const* self, int  key)
{
    map_int_char_p_hashlist_t *lauf;
#if defined(MAP_INT_CHAR_P_ALLOW_NULL)
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return IZERO;
    }
#endif
    E_SET_PTR(lauf, map_int_char_p_find_internal (self, key));
    if (lauf == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return IZERO;
    }
    SET_ERRNO(E_OK);
    return lauf->key;
}


/*
 * Modify an entry
 */
CODE_SECTION(".text.modify")
o_type_var_t map_int_char_p_modify
        (map_int_char_p_t *self, int  key, char *  value)
{
    /* Does not work without a cast because poke_internal takes int ,
     * not int .
     * Modify is a special case, because it never inserts a new key.
     * Maybe we should generalise the interface of _poke_internal again or
     * maybe make it a huge macro...
     */
    char * result;
    return_val_if_null_or_bad (self, ZEROVAR(self));
    map_int_char_p_poke_internal (
            NULL, &result, self,
            key,
                                IZEROVAR,      ERWIN_TRUE,
            value,              ZEROVAR(self), ERWIN_TRUE,
            ERWIN_FALSE, ERWIN_TRUE);
    if (e_errno == E_EXISTINGKEY)
        SET_ERRNO(E_OK);
    return result;
}


/*
 * Insert or modify an entry
 */
CODE_SECTION(".text.set")
ATTR_FLATTEN
int map_int_char_p_set
        (map_int_char_p_t *self, int  key, char *  value)
{
    return0_if_null (self);
    return map_int_char_p_poke_internal (
            NULL,NULL,self,
            key,   IZEROVAR, ERWIN_TRUE,
            value, ZEROVAR(self), ERWIN_TRUE,
            ERWIN_TRUE, ERWIN_TRUE);
}


CODE_SECTION(".text.find_ptr_ensure")
map_int_char_p_element_ptr_t map_int_char_p_find_ptr_ensure
        (map_int_char_p_t *self, int  key)
/* NOTE: This cannot be implemented with _poke_internal, since it
 *       returns a pointer to an internal structure. */
/* FIXME: extract common parts from map_int_char_p_ensure and map_int_char_p_find_ptr_ensure,
 *        which do essentially the same. */
{
    map_int_char_p_hashlist_t **lauf;
    return0_if_null (self);

    E_SET_PTR(lauf, map_int_char_p_find_internal_ptr (self, key));
    return0_if_null_pp (lauf, self);

    SET_ERRNO(E_OK);
    if (*lauf == NULL) {
        if (ERWIN_UNLIKELY(map_int_char_p_grow_perhaps (self))) {
            E_SET_PTR(lauf, map_int_char_p_find_internal_ptr (self, key));
            return0_if_null_pp (lauf, self);
            return0_if_fail_ppp (*lauf == NULL, self, lauf);
        }

        {
            int copyerror= ERWIN_FALSE;
            int keycopy;
            E_SET_KEY (keycopy, ICOPY (key, &copyerror));
            if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror)) {
                MAP_NOMEM;
                return NULL;
            }

            {
                char * valuecopy;
                E_SET_VALUE (valuecopy, MAP_INT_CHAR_P_ENSURE_VALUE(self, key, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror)) {
                    IFREE (keycopy);
                    MAP_NOMEM;
                    return NULL;
                }

                E_SET_PTR(*lauf, map_int_char_p_hashlist_new (keycopy, valuecopy));
                if (ERWIN_UNLIKELY(*lauf == NULL)) {
                    IFREE (keycopy);
                    OFREE (valuecopy);
                    MAP_NOMEM;
                    return NULL;
                }
            }

            self->m_nentries++;
            SET_ERRNO(E_KEYNOTFOUND);
        }
    }

    return0_if_null_pp  (lauf,  self);
    return0_if_null_ppp (*lauf, self, lauf);

    return &(*lauf)->value;
}


/*
 * Internal function: insert an element into the hash table
 * without copying the key or value, never doing a rehash and not
 * updating the profile insert counter.
 */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.insert_no_copy_no_rehash_q")
int map_int_char_p_insert_no_copy_no_rehash_q
        (
        map_int_char_p_t* self,
        int keycopy,
        char * valuecopy)
/* USE CAREFULLY!! PURELY INTERNAL!! */
/* NOTE: This cannot be implemented with _poke_internal, since it does not
 *       delete keycopy or valuecopy! */
{
    map_int_char_p_hashlist_t **lauf;

    E_SET_PTR(lauf, map_int_char_p_find_internal_ptr (self, keycopy));
    return_val_if_null_pp (lauf, ASSERTION_FAILED, self);

    if (*lauf != NULL)
        return PASS_ERRNO(E_EXISTINGKEY);

    E_SET_PTR(*lauf, map_int_char_p_hashlist_new_q (keycopy, valuecopy));

    if (ERWIN_UNLIKELY(*lauf == NULL)) {
        MAP_NOMEM;
        return e_errno;
    }

    self->m_nentries++;
    return PASS_ERRNO(E_OK);
}


/*
 * User space hash insertion function */
CODE_SECTION(".text.insert_q")
ATTR_FLATTEN
int map_int_char_p_insert_q
        (map_int_char_p_t* self, int  key, char *  value)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return map_int_char_p_poke_internal_q (
                NULL, NULL, self,
                key,   IZEROVAR, ERWIN_TRUE,
                value, ZEROVAR(self), ERWIN_TRUE,
                ERWIN_TRUE, ERWIN_FALSE);
}


CODE_SECTION(".text.insert_map")
int map_int_char_p_insert_map
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int total_errno;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;

       E_SET_PTR(lauf, SLOT(other,i));
       while (lauf) {
           map_int_char_p_insert_q (self, lauf->key, lauf->value);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR(lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}

CODE_SECTION(".text.set_map")
int map_int_char_p_set_map
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int total_errno;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           map_int_char_p_set (self, lauf->key, lauf->value);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}


CODE_SECTION(".text.modify_map")
int map_int_char_p_modify_map
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int total_errno;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           map_int_char_p_modify (self, lauf->key, lauf->value);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}


CODE_SECTION(".text.erase_map")
int map_int_char_p_erase_map
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int total_errno;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
    if (self == NULL && other->m_nentries > 0)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           map_int_char_p_erase (self, lauf->key);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}

CODE_SECTION(".text.erase_map_no_resize")
int map_int_char_p_erase_map_no_resize
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int total_errno;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (other == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
    if (self == NULL && other->m_nentries > 0)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           map_int_char_p_erase_no_resize (self, lauf->key);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}

CODE_SECTION(".text.intersect_no_resize")
int map_int_char_p_intersect_no_resize
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int cnt;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return PASS_ERRNO(E_OK);
    if (other == NULL) {
        cnt= self->m_nentries;
        map_int_char_p_clear (self);
        return cnt;
    }
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    cnt= 0;
    for (i= 0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_t **lauf;
        E_SET_PTR (lauf, &SLOT(self,i));
        while (*lauf) {
            (void)map_int_char_p_find (other, (*lauf)->key);
            if (e_errno != E_OK) {
                 map_int_char_p_hashlist_t *cell;
                 E_SET_PTR (cell,  *lauf);
                 E_SET_PTR (*lauf, (*lauf)->next);

                 IFREE (cell->key);
                 OFREE (cell->value);
                 map_int_char_p_hashlist_delete_cell (cell);
                 self->m_nentries--;
                 cnt++;
            }
            else
                E_SET_PTR (lauf, &(*lauf)->next);
        }
    }

    SET_ERRNO(E_OK);
    return cnt;
}

CODE_SECTION(".text.intersect")
int map_int_char_p_intersect
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int cnt= map_int_char_p_intersect_no_resize (self, other);
    map_int_char_p_shrink_perhaps (self);
    return cnt;
}

/*
 * Ensure that an entry is contained in the table.
 * Do not use the implementation using poke since ENSURE_VALUE would be called
 * too often.  Additionally, the result would be copied too often.  Furthermore,
 * it cannot use insert_no_copy, since it needs the pointer to the list to be
 * able to return a pointer to that it int  has a `const &' appended.
 * Of course we could search again, but that's not fast.
 */
CODE_SECTION(".text.ensure")
i_type_result_t map_int_char_p_ensure
        (map_int_char_p_t *self, int  key)
{
    map_int_char_p_hashlist_t **lauf;

    E_SET_PTR (lauf, map_int_char_p_find_internal_ptr (self, key));
    return_val_if_null_pp (lauf, IZERO, self);

    SET_ERRNO(E_EXISTINGKEY);

    if (*lauf == NULL) {
        int copyerror= ERWIN_FALSE;

        if (ERWIN_UNLIKELY(map_int_char_p_grow_perhaps (self))) {
            E_SET_PTR (lauf, map_int_char_p_find_internal_ptr (self, key));
            return_val_if_null_pp (lauf, IZERO, self);
            return_val_if_fail_pp (*lauf == NULL, IZERO, self);
        }

        {
            int keycopy;
            E_SET_KEY (keycopy, ICOPY (key, &copyerror));
            if (ERWIN_UNLIKELY(ICOPY_PROVIDED && copyerror)) {
                MAP_NOMEM;
                return IZERO;
            }

            {
                char * valuecopy;
                E_SET_VALUE (valuecopy, MAP_INT_CHAR_P_ENSURE_VALUE(self, key, &copyerror));
                if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror)) {
                    IFREE (keycopy);
                    MAP_NOMEM;
                    return IZERO;
                }

                E_SET_PTR (*lauf, map_int_char_p_hashlist_new_q (keycopy, valuecopy));
                if (ERWIN_UNLIKELY(*lauf == NULL)) {
                    IFREE (keycopy);
                    OFREE (valuecopy);
                    MAP_NOMEM;
                    return IZERO;
                }
            }
        }

        self->m_nentries++;
        SET_ERRNO(E_OK);
        /* NOTE: we *must* return the value directly from the map because char * 
         *       might be a reference. */
    }

    return (*lauf)->key;
}


/*
 * Ensure that an entry is contained in the table.
 * Do not use the implementation using poke since ENSURE_VALUE would be called
 * too often.  Additionally, the result would be copied too often.  Furthermore,
 * it cannot use insert_no_copy, since it needs the pointer to the list to be
 * able to return a pointer to that it int  has a `const &' appended.
 * Of course we could search again, but that's not fast.
 */
CODE_SECTION(".text.ensure_no_icopy")
i_type_result_t map_int_char_p_ensure_no_icopy
        (map_int_char_p_t *self, int  key)
{
    map_int_char_p_hashlist_t **lauf;

    E_SET_PTR (lauf, map_int_char_p_find_internal_ptr (self, key));
    return_val_if_null_pp (lauf, IZERO, self);

    SET_ERRNO(E_EXISTINGKEY);

    if (*lauf == NULL) {
        if (ERWIN_UNLIKELY(map_int_char_p_grow_perhaps (self))) {
            E_SET_PTR (lauf, map_int_char_p_find_internal_ptr (self, key));
            return_val_if_null_pp (lauf, IZERO, self);
            return_val_if_fail_pp (*lauf == NULL, IZERO, self);
        }

        {
            int copyerror= ERWIN_FALSE;
            char * valuecopy;
            E_SET_VALUE (valuecopy, MAP_INT_CHAR_P_ENSURE_VALUE(self, key, &copyerror));
            if (ERWIN_UNLIKELY(OCOPY_PROVIDED && copyerror)) {
                MAP_NOMEM;
                return IZERO;
            }

            E_SET_PTR (*lauf, map_int_char_p_hashlist_new_q (key, valuecopy));
            if (ERWIN_UNLIKELY(*lauf == NULL)) {
                OFREE (valuecopy);
                MAP_NOMEM;
                return IZERO;
            }
        }

        self->m_nentries++;
        SET_ERRNO(E_OK);
        /* NOTE: we *must* return the value directly from the map because char * 
         *       might be a reference. */
    }
    else {
        IFREE (key);
    }

    return (*lauf)->key;
}


/*
 * Remove an element and return the old one.  Avoid returning char * (ZERO(self)) to
 * char * here. */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.remove_internal_no_resize_q")
ERWIN_BOOL map_int_char_p_remove_internal_no_resize_q
        (
    map_int_char_p_t *self,
    int  key,
    char * *result)
{
    map_int_char_p_hashlist_t **lauf;
    map_int_char_p_hashlist_t *cell;

#ifdef E_PROFILE
    self->m_ndelete++;
#endif

    return0_if_null (self);
    return0_if_null_pp (result, self);

    /* Now, try to find the entry */
    E_SET_PTR (lauf, map_int_char_p_find_internal_ptr (self, key));
    return0_if_null_pp (lauf, self);

    E_SET_PTR (cell, *lauf);
    if (cell == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ERWIN_FALSE;
    }

    /* Unlink list cell */
    E_SET_PTR (*lauf, (*lauf)->next);

    /* Rrturn value to caller */
    E_SET_VALUE (*result, cell->value);

    /* Delete key and cell */
    IFREE (cell->key);
    map_int_char_p_hashlist_delete_cell (cell);

    /* Decrement number of elements */
    self->m_nentries--;

    /* Return the result */
    SET_ERRNO(E_OK);
    return ERWIN_TRUE;
}

/*
 * Remove an element and return the old one.  Avoid returning char * (ZERO(self)) to
 * char * here. */
ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.remove_internal_q")
ERWIN_BOOL map_int_char_p_remove_internal_q
        (
    map_int_char_p_t *self,
    int  key,
    char * *result)
{
#ifdef E_PROFILE
    self->m_ndelete++;
#endif

    return0_if_null (self);
    /* Possibly shrink.  Do it before we get a pointer to the list entry.  Otherwise,
     * we would have to search again. */
    map_int_char_p_shrink_perhaps (self);

    return map_int_char_p_remove_internal_no_resize_q (self, key, result);
}

CODE_SECTION(".text.remove")
o_type_var_t map_int_char_p_remove
        (map_int_char_p_t *self, int  key)
{
    char * result;
#if defined(MAP_INT_CHAR_P_ALLOW_NULL) && MAP_INT_CHAR_P_CONSTANT_ZERO
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ZEROVAR(self);
    }
#endif
    if (map_int_char_p_remove_internal_q (self, key, &result))
        return result;
    return ZEROVAR(self);
}


CODE_SECTION(".text.remove_no_resize")
o_type_var_t map_int_char_p_remove_no_resize
        (map_int_char_p_t *self, int  key)
{
    char * result;
#if defined(MAP_INT_CHAR_P_ALLOW_NULL) && MAP_INT_CHAR_P_CONSTANT_ZERO
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return ZEROVAR(self);
    }
#endif
    if (map_int_char_p_remove_internal_no_resize_q (self, key, &result))
        return result;
    return ZEROVAR(self);
}


CODE_SECTION(".text.remove_map")
int map_int_char_p_remove_map
        (map_int_char_p_t* self, map_int_char_p_t const *other)
{
    int i;
    int total_errno;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (other == NULL)
        return PASS_ERRNO(E_OK);
    if (self == NULL && other->m_nentries > 0)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif

    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return_val_if_null2i_or_bad (self,  ASSERTION_FAILED);

    total_errno= E_OK;
    for (i= 0; i < other->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(other,i));
       while (lauf) {
           map_int_char_p_remove (self, lauf->key);
           if (e_errno != E_OK)
               total_errno= e_errno; /* this does not break, it tries to do as
                                      * much as possible. */
           E_SET_PTR (lauf, lauf->next);
       }
    }

    return PASS_ERRNO(total_errno);
}


/*
 * Remove some entries according to a given predicate */
CODE_SECTION(".text.remove_if")
int map_int_char_p_remove_if
        (map_int_char_p_t *self, map_int_char_p_feature_t feature, ERWIN_BOOL value)
{
    int slot;
    int cnt= 0;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#else
    return0_if_null (self);
#endif
    return0_if_bad_table (self);
    return0_if_null_pp (feature, self);

    for (slot=0; slot < self->m_hashsize; slot++) {
        map_int_char_p_hashlist_t **lauf;
        E_SET_PTR (lauf, &SLOT(self,slot));
        while (*lauf) {
           if (ERWIN_TO_BOOL (feature ((*lauf)->key, (*lauf)->value) == value)) {
                map_int_char_p_hashlist_t *cell;
                E_SET_PTR (cell,  *lauf);
                E_SET_PTR (*lauf, (*lauf)->next);

                IFREE (cell->key);
                map_int_char_p_hashlist_delete_cell (cell);
                self->m_nentries--;
                cnt++;
            }
            else
                E_SET_PTR (lauf, &(*lauf)->next);
        }
    }

    map_int_char_p_shrink_perhaps (self);
    SET_ERRNO(E_OK);
    return cnt;
}


/*
 * Erase an entry (remove it and free value). */
CODE_SECTION(".text.erase")
int map_int_char_p_erase
        (map_int_char_p_t *self, int  key)
{
    char * result;
#if defined(MAP_INT_CHAR_P_ALLOW_NULL) && MAP_INT_CHAR_P_CONSTANT_ZERO
    if (self == NULL)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif
    if (map_int_char_p_remove_internal_q (self, key, &result)) {
        OFREE (result);
    }
    return e_errno;
}

/*
 * Erase an entry (remove it and free value). */
CODE_SECTION(".text.erase_no_resize")
int map_int_char_p_erase_no_resize
        (map_int_char_p_t *self, int  key)
{
    char * result;
#if defined(MAP_INT_CHAR_P_ALLOW_NULL) && MAP_INT_CHAR_P_CONSTANT_ZERO
    if (self == NULL)
        return PASS_ERRNO(E_KEYNOTFOUND);
#endif
    if (map_int_char_p_remove_internal_no_resize_q (self, key, &result)) {
        OFREE (result);
    }
    return e_errno;
}


/*
 * Erase some entries according to a given predicate */
CODE_SECTION(".text.erase_if")
int map_int_char_p_erase_if
        (map_int_char_p_t *self, map_int_char_p_feature_t feature, ERWIN_BOOL value)
{
    int slot;
    int cnt= 0;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return 0;
    }
#else
    return0_if_null (self);
#endif
    return0_if_bad_table (self);
    return0_if_null_pp (feature, self);

    for (slot=0; slot < self->m_hashsize; slot++) {
        map_int_char_p_hashlist_t **lauf;
        E_SET_PTR (lauf, &SLOT(self,slot));
        while (*lauf) {
           if (ERWIN_TO_BOOL (feature_q ((*lauf)->key, (*lauf)->value) == value)) {
                map_int_char_p_hashlist_t *cell;
                E_SET_PTR (cell,  *lauf);
                E_SET_PTR (*lauf, (*lauf)->next);

                IFREE (cell->key);
                OFREE (cell->value);
                map_int_char_p_hashlist_delete_cell (cell);
                self->m_nentries--;
                cnt++;
            }
            else
                E_SET_PTR (lauf, &(*lauf)->next);
        }
    }

    map_int_char_p_shrink_perhaps (self);
    SET_ERRNO(E_OK);
    return cnt;
}


/*
 * Rehash the hash table to a different size */
CODE_SECTION(".text.rehash")
void map_int_char_p_rehash
        (map_int_char_p_t* self, int newsize)
{
    return_if_null2i_or_bad (self);

#ifdef E_PROFILE
    self->m_nrehash+= self->m_nentries;
    self->m_nrehashops++;
#endif

    if (newsize <= 0)
        newsize= 1;
                                                     
    if (newsize != self->m_hashsize) {
        int i;
        map_int_char_p_content_p newtable;

#if MAP_INT_CHAR_P_ZERO_SIZE
        if (newsize == 1) {
            E_SET_PTR (newtable, NULL);
        }
        else {
            E_SET_PTR (newtable, ERWIN_THING_CNEW_ARRAY (map_int_char_p_content, (unsigned)newsize));
            if (ERWIN_UNLIKELY(newtable == NULL)) {
                MAP_NOMEM_R;
                return;
            }
        }
#else
        E_SET_PTR (newtable, ERWIN_THING_CNEW_ARRAY (map_int_char_p_content, (unsigned)newsize));
        if (ERWIN_UNLIKELY(newtable == NULL)) {
            MAP_NOMEM_R;
            return;
        }
#endif


        /* Copy elements: */
        for (i=0; i < self->m_hashsize; i++) {
            map_int_char_p_hashlist_t *lauf;
            E_SET_PTR (lauf, SLOT(self,i));
            while (lauf != NULL) {
                map_int_char_p_hashlist_t *next;
                map_int_char_p_hashlist_t **newcell= &GET_SLOT(
                                      newtable,
                                      newsize,
                                      e_hash_into (IHASH (lauf->key), newsize));

                E_SET_PTR (next,       lauf->next);
                E_SET_PTR (lauf->next, *newcell);
                E_SET_PTR (*newcell,   lauf);
                E_SET_PTR (lauf,       next);
            }
        }

        /* Free own table: */
        FREE_TABLE(self);

        /* Use new table: */
        E_SET_PTR (self->m_table, newtable);
            /* This is even correct if newtable is not a slot table, but the
             * root of the only list (in case of ZERO_SIZE) */
        self->m_hashsize= newsize;
    }

    SET_ERRNO(E_OK);
}


/*
 * Internal function used for iterating over the hash table.
 */
static
CODE_SECTION(".text.first_internal")
map_int_char_p_hashlist_t * map_int_char_p_first_internal
        (map_int_char_p_t const *self, e_iterator_t *iter)
{
    if (self->m_nentries <= 0) {
        SET_ERRNO(E_EMPTY);
        return NULL;
    }

    ITER->cslot=0;
    while (SLOT(self,ITER->cslot) == NULL) {
        ITER->cslot++;
        return_val_if_fail_ppii (ITER->cslot < self->m_hashsize, NULL,
            self, ITER->cslot, self->m_hashsize);
           /* We MUST find an element here, because there are more than 0 elements. */
    }

    E_SET_PTR (ITER->cnode, SLOT(self,ITER->cslot));
    return ITER->cnode;
}


/*
 * Internal function used for iterating over the hash table.
 */
static
CODE_SECTION(".text.next_internal")
map_int_char_p_hashlist_t * map_int_char_p_next_internal
        (map_int_char_p_t const*self, e_iterator_t *iter)
{
    if (ERWIN_UNLIKELY(ITER->cslot == -1))
        return map_int_char_p_first_internal (self, iter);

    if (ERWIN_UNLIKELY(
           ITER->cslot < 0 || ITER->cslot >= self->m_hashsize || ITER->cnode == NULL))
    {
        SET_ERRNO(E_NOMOREELEMS);
        return NULL;
    }

    /* get next element in hashtable */
    E_SET_PTR (ITER->cnode, ITER->cnode->next);
    if (ITER->cnode != NULL) return ITER->cnode; /*!*/

    do {
        ITER->cslot++;
    } while (ITER->cslot < self->m_hashsize && SLOT(self,ITER->cslot) == NULL);

    /* did we find a next element? */
    if (ERWIN_UNLIKELY(ITER->cslot >= self->m_hashsize)) {
        SET_ERRNO(E_NOMOREELEMS);
        return NULL; /*!*/
    }
    else {
        E_SET_PTR (ITER->cnode, SLOT(self,ITER->cslot));
        return ITER->cnode; /*!*/
    }
}

/*
 * Initialisation of iterating over a hash table
 */
CODE_SECTION(".text.init_iterator")
void map_int_char_p_init_iterator
        (map_int_char_p_t const *self, e_iterator_t *iter)
{
    (void)self; /*unused*/

#ifndef MAP_INT_CHAR_P_ALLOW_NULL
    return_if_null_or_bad (self);
#endif

    return_if_null_pp (iter, self);

    ITER->cslot= -1;
}


/*
 * I am sorry for the next functions. They are ugly. */
static
CODE_SECTION(".text.pair_cmp_keys")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_keys
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef ICMP
#define map_int_char_p_check_cmp_keys
#define map_int_char_p_check0_cmp_keys
    return ICMP ((((map_int_char_p_pair_t*)a)->key),(((map_int_char_p_pair_t*)b)->key));
#else
#define map_int_char_p_check_cmp_keys \
    return_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
#define map_int_char_p_check0_cmp_keys \
    return0_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.wrap_icmp")
ATTR_FUNC_UNUSED
int map_int_char_p_wrap_icmp
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef ICMP
#define map_int_char_p_check_cmp_keys
#define map_int_char_p_check0_cmp_keys
    return ICMP ((*((int *)a)),(*((int *)b)));
#else
#define map_int_char_p_check_cmp_keys \
    return_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
#define map_int_char_p_check0_cmp_keys \
    return0_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_keys_ptr")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_keys_ptr
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef ICMP
#define map_int_char_p_check_cmp_keys_ptr
#define map_int_char_p_check0_cmp_keys_ptr
    return ICMP ((((map_int_char_p_pair_ptr_t*)a)->key),(((map_int_char_p_pair_ptr_t*)b)->key));
#else
#define map_int_char_p_check_cmp_keys_ptr \
    return_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
#define map_int_char_p_check0_cmp_keys_ptr \
    return0_if_reached_pt ("ICMP is not implemented.  Sorting keys is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_values")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_values
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef OCMP
#define map_int_char_p_check_cmp_values
#define map_int_char_p_check0_cmp_values
    return OCMP ((((map_int_char_p_pair_t*)a)->value),(((map_int_char_p_pair_t*)b)->value));
#else
#define map_int_char_p_check_cmp_values \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
#define map_int_char_p_check0_cmp_values \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_values_ptr")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_values_ptr
        (void const *a, void const *b)
{
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    (void)a; /*unused*/
    (void)b; /*unused*/
#ifdef OCMP
#define map_int_char_p_check_cmp_values_ptr
#define map_int_char_p_check0_cmp_values_ptr
    return OCMP ((*(((map_int_char_p_pair_ptr_t*)a)->value)),(*(((map_int_char_p_pair_ptr_t*)b)->value)));
#else
#define map_int_char_p_check_cmp_values_ptr \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
#define map_int_char_p_check0_cmp_values_ptr \
    return_if_reached_pt ("OCMP is not implemented.  Sorting values is not possible.")
    return 0;
#endif
}


static
CODE_SECTION(".text.pair_cmp_values_and_keys")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_values_and_keys
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define map_int_char_p_check_cmp_values_and_keys
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= OCMP ((((map_int_char_p_pair_t*)a)->value),(((map_int_char_p_pair_t*)b)->value));
    if (result == 0)
        result= ICMP ((((map_int_char_p_pair_t*)a)->key),(((map_int_char_p_pair_t*)b)->key));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define map_int_char_p_check_cmp_values_and_keys \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


static
CODE_SECTION(".text.pair_cmp_values_and_keys_ptr")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_values_and_keys_ptr
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define map_int_char_p_check_cmp_values_and_keys_ptr
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= OCMP ((*(((map_int_char_p_pair_ptr_t*)a)->value)),(*(((map_int_char_p_pair_ptr_t*)b)->value)));
    if (result == 0)
        result= ICMP ((((map_int_char_p_pair_ptr_t*)a)->key),(((map_int_char_p_pair_ptr_t*)b)->key));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define map_int_char_p_check_cmp_values_and_keys_ptr \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


static
CODE_SECTION(".text.pair_cmp_keys_and_values")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_keys_and_values
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define map_int_char_p_check_cmp_keys_and_values
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= ICMP ((((map_int_char_p_pair_t*)a)->key),(((map_int_char_p_pair_t*)b)->key));
    if (result == 0)
        result= OCMP ((((map_int_char_p_pair_t*)a)->value),(((map_int_char_p_pair_t*)b)->value));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define map_int_char_p_check_cmp_keys_and_values \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


static
CODE_SECTION(".text.pair_cmp_keys_and_values_ptr")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_cmp_keys_and_values_ptr
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if defined(OCMP) && defined(ICMP)
#define map_int_char_p_check_cmp_keys_and_values_ptr
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= ICMP ((((map_int_char_p_pair_ptr_t*)a)->key),(((map_int_char_p_pair_ptr_t*)b)->key));
    if (result == 0)
        result= OCMP ((*(((map_int_char_p_pair_ptr_t*)a)->value)),(*(((map_int_char_p_pair_ptr_t*)b)->value)));
#else
    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
#define map_int_char_p_check_cmp_keys_and_values_ptr \
    return_if_reached_pt ("OCMP or ICMP is not implemented.  Sorting values is not possible.");
    result= 0;
#endif

    return result;
}


#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)

static
CODE_SECTION(".text.pair_detcmp_keys")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_detcmp_keys
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= IDETCMP ((*((int const*)a)), (*((int const*)b)));
#if defined(ICMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= ICMP ((*((int const*)a)), (*((int const*)b)));
#endif
    return result;
}

#if !IDETCMP_PROVIDED && !IEQUAL_PROVIDED
#  define map_int_char_p_detcmp_pairs     map_int_char_p_pair_cmp_keys
#  define map_int_char_p_detcmp_pairs_ptr map_int_char_p_pair_cmp_keys_ptr
#else
#  define MAP_INT_CHAR_P_DET_SORT_PROVIDED 1
#endif

#ifndef MAP_INT_CHAR_P_DET_SORT_PROVIDED
#  define MAP_INT_CHAR_P_DET_SORT_PROVIDED 0
#endif

#if ODETCMP_PROVIDED || MAP_INT_CHAR_P_DET_SORT_PROVIDED
#  define MAP_INT_CHAR_P_ODET_REQUIRE 1
#endif

#ifndef MAP_INT_CHAR_P_ODET_REQUIRE
#  define MAP_INT_CHAR_P_ODET_REQUIRE 0
#endif


static
CODE_SECTION(".text.pair_detcmp_values")
ATTR_FUNC_UNUSED
int map_int_char_p_pair_detcmp_values
        (void const *a, void const *b)
{
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

#if MAP_INT_CHAR_P_DET_SORT_PROVIDED
    result= ODETCMP (*((char * const*)a), *((char * const*)b));
#if defined(OCMP) && ODETCMP_PROVIDED
    if (result == 0)
        result= OCMP (*((char * const*)a), *((char * const*)b));
#endif
#elif defined(OCMP)
    result= OCMP (*((char * const*)a), *((char * const*)b));
#else
#define map_int_char_p_check_detcmp_values \
    return0_if_reached_pt ("Need CHAR_P_DETCMP or CHAR_P_CMP to enforce determinism on map_int_char_p.  Try to '#define CHAR_P_DETCMP(x,y) false_if_reached_pk(INT_DETCMP)' if you think you never invoke it.");
    result=0;
#endif

#ifndef map_int_char_p_check_detcmp_values
#define map_int_char_p_check_detcmp_values
#endif /* !defined map_int_char_p_check_detcmp_values */

    return result;
}


#if MAP_INT_CHAR_P_DET_SORT_PROVIDED

static
CODE_SECTION(".text.detcmp_pairs")
ATTR_FUNC_UNUSED
int map_int_char_p_detcmp_pairs
        (void const *a, void const *b)
{
    /* This uses paranoid paranoid, perhaps duplicate comparisons.  But the user
     * wants determinism and we try to enforce that in any way.  It may be slower,
     * but that does not hurt here.
     */
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= IDETCMP ((((map_int_char_p_pair_t*)a)->key),(((map_int_char_p_pair_t*)b)->key));

    if (result == 0)
        result= ODETCMP ((((map_int_char_p_pair_t*)a)->value),(((map_int_char_p_pair_t*)b)->value));

#if defined(ICMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= ICMP ((((map_int_char_p_pair_t*)a)->key),(((map_int_char_p_pair_t*)b)->key));
#endif

#if defined(OCMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= OCMP ((((map_int_char_p_pair_t*)a)->value),(((map_int_char_p_pair_t*)b)->value));
#endif

    return result;
}


static
CODE_SECTION(".text.detcmp_pairs_ptr")
ATTR_FUNC_UNUSED
int map_int_char_p_detcmp_pairs_ptr
        (void const *a, void const *b)
{
    /* This uses paranoid paranoid, perhaps duplicate comparisons.  But the user
     * wants determinism and we try to enforce that in any way.  It may be slower,
     * but that does not hurt here.
     */
    int result;
    (void)a; /*unused*/
    (void)b; /*unused*/

    /* return0_if_null2 (a,b);  needs self via ASSERTION_FAILED when THREAD_SAFE */
    result= IDETCMP ((((map_int_char_p_pair_ptr_t*)a)->key),(((map_int_char_p_pair_ptr_t*)b)->key));

    if (result == 0)
        result= ODETCMP ((*(((map_int_char_p_pair_ptr_t*)a)->value)),(*(((map_int_char_p_pair_ptr_t*)b)->value)));

#if defined(ICMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= ICMP ((((map_int_char_p_pair_ptr_t*)a)->key),(((map_int_char_p_pair_ptr_t*)b)->key));
#endif

#if defined(OCMP) && IDETCMP_PROVIDED
    if (result == 0)
        result= OCMP ((*(((map_int_char_p_pair_ptr_t*)a)->value)),(*(((map_int_char_p_pair_ptr_t*)b)->value)));
#endif

    return result;
}

#endif /* MAP_INT_CHAR_P_DET_SORT_PROVIDED */

#endif /* defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM) */


#ifdef __cplusplus
#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)

ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.det_sort")
void map_int_char_p_det_sort
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    qsort ((void*)SORTITER->table,
           self->m_nentries,
           sizeof (map_int_char_p_pair_t),
           map_int_char_p_detcmp_pairs);
}


ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.det_sort_ptr")
void map_int_char_p_det_sort_ptr
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    qsort ((void*)SORTITERPTR->table,
           self->m_nentries,
           sizeof (map_int_char_p_pair_ptr_t),
           map_int_char_p_detcmp_pairs_ptr);
}


#endif /* defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM) */

/* In case REQUIRE_DETERMINISM is not set, we must define defaults. */
#ifndef MAP_INT_CHAR_P_DET_SORT_PROVIDED
#  define MAP_INT_CHAR_P_DET_SORT_PROVIDED 0
#endif

#ifndef MAP_INT_CHAR_P_ODET_REQUIRE
#  define MAP_INT_CHAR_P_ODET_REQUIRE 0
#endif


static
CODE_SECTION(".text.free_sorted_iterator")
void map_int_char_p_free_sorted_iterator
        (void *iter)
{
    map_int_char_p_delete_entries (SORTITER->table);
}


static
CODE_SECTION(".text.free_sorted_iterator_ptr")
void map_int_char_p_free_sorted_iterator_ptr
        (void *iter)
{
    map_int_char_p_delete_entries_ptr (SORTITERPTR->table);
}


CODE_SECTION(".text.init_iterator_sorted_by_key")
void map_int_char_p_init_iterator_sorted_by_key
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
        return;
    }
#else
    return_if_null_or_bad (self);
#endif
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_keys;

    E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
    return_if_null_pp (SORTITER_VOLATILE->p, self);
        /* Need volatile here because of strict aliasing rules.  Change
         * to iter->p would otherwise not necessarily take effect. */
    return_if_fail_pp ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator, self);

#if MAP_INT_CHAR_P_DET_SORT_PROVIDED
    /* If the sort orders _DETCMP and _CMP are the same, and if _CMP and _EQUAL
     * agree about equality, comparison on the keys with _CMP yields deterministic
     * sort orders since keys are unique.  If they are  not the same, _DETCMP might
     * not think that two keys are equal even if they are equal by _CMP.  So then,
     * we still need to pre-sort and use (the stable) merge sort.  */
    if (e_require_determinism ()) {
        map_int_char_p_det_sort (self, iter);
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_keys);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_keys);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_value")
void map_int_char_p_init_iterator_sorted_by_value
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_values;

    E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        map_int_char_p_det_sort (self, iter);
#endif
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_values);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_values);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_value_and_key")
void map_int_char_p_init_iterator_sorted_by_value_and_key
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_values_and_keys;

    E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator,
        SORTITER, self);

#if MAP_INT_CHAR_P_ODET_REQUIRE
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        map_int_char_p_det_sort (self, iter);
#endif
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_values_and_keys);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_values_and_keys);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_key_and_value")
void map_int_char_p_init_iterator_sorted_by_key_and_value
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_keys_and_values;

    E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator,
        SORTITER, self);

#if MAP_INT_CHAR_P_DET_SORT_PROVIDED
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
        map_int_char_p_det_sort (self, iter);
        e_merge_sort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_keys_and_values);
    }
    else
#endif
    {
        qsort ((void*)SORTITER->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               map_int_char_p_pair_cmp_keys_and_values);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_user")
void map_int_char_p_init_iterator_sorted_by_user
        (
    map_int_char_p_t const *self,
    e_iterator_sorted_t *iter,
    map_int_char_p_pair_cmp_t u)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
        SORTITER->count= 0;
        SORTITER->lauf=  0;
        E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);

    E_SET_PTR (SORTITER->table, map_int_char_p_get_entries (self));
    SORTITER->count= self->m_nentries;
    SORTITER->lauf= 0;
    E_SET_PTR (SORTITER->free_cb, map_int_char_p_free_sorted_iterator);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        map_int_char_p_det_sort (self, iter);
#endif
        if (u != NULL)
            e_merge_sort ((void*)SORTITER->table,
                   self->m_nentries,
                   sizeof (map_int_char_p_pair_t),
                   (int(*)(void const*,void const*))u);
    }
    else
#endif
    {
        if (u != NULL)
            qsort ((void*)SORTITER->table,
                   self->m_nentries,
                   sizeof (map_int_char_p_pair_t),
                   (int(*)(void const*,void const*))u);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key")
void map_int_char_p_init_iterator_ptr_sorted_by_key
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_keys_ptr;

    E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator_ptr,
        SORTITER, self);

#if MAP_INT_CHAR_P_DET_SORT_PROVIDED
    /* If the sort orders _DETCMP and _CMP are the same, and if _CMP and _EQUAL
     * agree about equality, comparison on the keys with _CMP yields deterministic
     * sort orders since keys are unique.  If they are  not the same, _DETCMP might
     * not think that two keys are equal even if they are equal by _CMP.  So then,
     * we still need to pre-sort and use (the stable) merge sort.  */
    if (e_require_determinism ()) {
        map_int_char_p_det_sort_ptr (self, iter);
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_keys_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_keys_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value")
void map_int_char_p_init_iterator_ptr_sorted_by_value
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_values_ptr;

    E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator_ptr,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        map_int_char_p_det_sort_ptr (self, iter);
#endif
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_values_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_values_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value_and_key")
void map_int_char_p_init_iterator_ptr_sorted_by_value_and_key
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_values_and_keys_ptr;

    E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator_ptr,
        SORTITER, self);

#if MAP_INT_CHAR_P_ODET_REQUIRE
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        map_int_char_p_det_sort_ptr (self, iter);
#endif
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_values_and_keys_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_values_and_keys_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key_and_value")
void map_int_char_p_init_iterator_ptr_sorted_by_key_and_value
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);
    map_int_char_p_check_cmp_keys_and_values_ptr;

    E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator_ptr,
        SORTITER, self);

#if MAP_INT_CHAR_P_DET_SORT_PROVIDED
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
        map_int_char_p_det_sort_ptr (self, iter);
        e_merge_sort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_keys_and_values_ptr);
    }
    else
#endif
    {
        qsort ((void*)SORTITERPTR->table,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               map_int_char_p_pair_cmp_keys_and_values_ptr);
    }
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_user")
void map_int_char_p_init_iterator_ptr_sorted_by_user
        (
    map_int_char_p_t const *self,
    e_iterator_sorted_t *iter,
    map_int_char_p_pair_ptr_cmp_t u)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
        SORTITERPTR->count= 0;
        SORTITERPTR->lauf=  0;
        E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
        return;
    }
#endif
    return_if_null_or_bad (self);
    return_if_null_pp (iter, self);

    E_SET_PTR (SORTITERPTR->table, map_int_char_p_get_entries_ptr (self));
    SORTITERPTR->count= self->m_nentries;
    SORTITERPTR->lauf= 0;
    E_SET_PTR (SORTITERPTR->free_cb, map_int_char_p_free_sorted_iterator_ptr);
    return_if_null_pp2 (SORTITER_VOLATILE->p,
        SORTITER, self);
    return_if_fail_pp2 ((void*)SORTITER_VOLATILE->free_cb == (void*)map_int_char_p_free_sorted_iterator_ptr,
        SORTITER, self);

#ifdef E_REQUIRE_DETERMINISM
    /* If both value and key comparisons are the same as their _DET equivalents,
     * we can use the simple mechanism.  Otherwise, we have to pre-sort. */
    if (e_require_determinism ()) {
#ifndef E_WEAK_DETERMINISM
        map_int_char_p_det_sort_ptr (self, iter);
#endif
        if (u != NULL)
            e_merge_sort ((void*)SORTITERPTR->table,
                   self->m_nentries,
                   sizeof (map_int_char_p_pair_ptr_t),
                   (int(*)(void const*,void const*))u);
    }
    else
#endif
    {
        if (u != NULL)
            qsort ((void*)SORTITERPTR->table,
                   self->m_nentries,
                   sizeof (map_int_char_p_pair_ptr_t),
                   (int(*)(void const*,void const*))u);
    }
}


CODE_SECTION(".text.init_iterator_sorted_by_key_reverse")
void map_int_char_p_init_iterator_sorted_by_key_reverse
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_sorted_by_key (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_value_reverse")
void map_int_char_p_init_iterator_sorted_by_value_reverse
        (map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_sorted_by_value (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_value_and_key_reverse")
void map_int_char_p_init_iterator_sorted_by_value_and_key_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_sorted_by_value_and_key (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_key_and_value_reverse")
void map_int_char_p_init_iterator_sorted_by_key_and_value_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_sorted_by_key_and_value (self, iter);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_sorted_by_user_reverse")
void map_int_char_p_init_iterator_sorted_by_user_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_pair_cmp_t u)
{
    map_int_char_p_init_iterator_sorted_by_user (self, iter, u);
    SORTITER->lauf= SORTITER->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key_reverse")
void map_int_char_p_init_iterator_ptr_sorted_by_key_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_ptr_sorted_by_key (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value_reverse")
void map_int_char_p_init_iterator_ptr_sorted_by_value_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_ptr_sorted_by_value (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_value_and_key_reverse")
void map_int_char_p_init_iterator_ptr_sorted_by_value_and_key_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_ptr_sorted_by_value_and_key (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_key_and_value_reverse")
void map_int_char_p_init_iterator_ptr_sorted_by_key_and_value_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter)
{
    map_int_char_p_init_iterator_ptr_sorted_by_key_and_value (self, iter);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.init_iterator_ptr_sorted_by_user_reverse")
void map_int_char_p_init_iterator_ptr_sorted_by_user_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_pair_ptr_cmp_t u)
{
    map_int_char_p_init_iterator_ptr_sorted_by_user (self, iter, u);
    SORTITERPTR->lauf= SORTITERPTR->count;
}


CODE_SECTION(".text.next_iteration_sorted")
ERWIN_BOOL map_int_char_p_next_iteration_sorted
        (map_int_char_p_t const *self,
                                e_iterator_sorted_t *iter,
                                int *keyp,
                                char * *valuep)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null2_pp3 (keyp, valuep, self, keyp, valuep);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERWIN_FALSE;

    E_SET_KEY   (*keyp,   SORTITER->table[SORTITER->lauf].key);
    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    SORTITER->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_ptr")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_ptr
        (map_int_char_p_t const *self,
                                e_iterator_sorted_t *iter,
                                int *keyp,
                                map_int_char_p_element_ptr_t *valuepp)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null2_pp3 (keyp, valuepp, self, keyp, valuepp);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf >= SORTITERPTR->count))
        return ERWIN_FALSE;

    E_SET_KEY (*keyp,    SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    SORTITERPTR->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_keys")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_keys
        (map_int_char_p_t const *self,
                                e_iterator_sorted_t *iter,
                                int *keyp)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp2  (keyp, self, keyp);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERWIN_FALSE;

    E_SET_KEY (*keyp, SORTITER->table[SORTITER->lauf].key);
    SORTITER->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_values
        (map_int_char_p_t const *self,
                                e_iterator_sorted_t *iter,
                                char * *valuep)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp2  (valuep, self, valuep);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERWIN_FALSE;

    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    SORTITER->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values_ptr")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_values_ptr
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_element_ptr_t *valuepp)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp2  (valuepp, self, valuepp);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf >= SORTITERPTR->count))
        return ERWIN_FALSE;

    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    SORTITERPTR->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_pairs
        (map_int_char_p_t const *self,
                                e_iterator_sorted_t *iter,
                                map_int_char_p_pair_t *p)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp2  (p, self, p);

    if (ERWIN_UNLIKELY(SORTITER->lauf >= SORTITER->count))
        return ERWIN_FALSE;

    E_SET_KEY (p->key,   SORTITER->table[SORTITER->lauf].key);
    E_SET_KEY (p->value, SORTITER->table[SORTITER->lauf].value);
    SORTITER->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs_ptr")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_pairs_ptr
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_pair_ptr_t *p)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp2  (p, self, p);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf >= SORTITERPTR->count))
        return ERWIN_FALSE;

    E_SET_KEY (p->key,   SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (p->value, SORTITERPTR->table[SORTITERPTR->lauf].value);
    SORTITERPTR->lauf++;
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, int *keyp, char * *valuep)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null2_pp3 (keyp, valuep, self, keyp, valuep);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_KEY   (*keyp,   SORTITER->table[SORTITER->lauf].key);
    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_ptr_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_ptr_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, int *keyp, map_int_char_p_element_ptr_t *valuepp)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null2_pp3 (keyp, valuepp, self, keyp, valuepp);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf <= 0))
        return ERWIN_FALSE;
    SORTITERPTR->lauf--;

    E_SET_KEY (*keyp,    SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_keys_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_keys_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, int *keyp)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp   (keyp, self);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_KEY (*keyp, SORTITER->table[SORTITER->lauf].key);
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_values_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, char * *valuep)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp   (valuep, self);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_VALUE (*valuep, SORTITER->table[SORTITER->lauf].value);
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_values_ptr_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_values_ptr_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_element_ptr_t *valuepp)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp   (valuepp, iter);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf <= 0))
        return ERWIN_FALSE;
    SORTITERPTR->lauf--;

    E_SET_PTR (*valuepp, SORTITERPTR->table[SORTITERPTR->lauf].value);
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_pairs_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_pair_t *p)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITER->table, self, iter);
    return0_if_null_pp   (p, self);

    if (ERWIN_UNLIKELY(SORTITER->lauf <= 0))
        return ERWIN_FALSE;
    SORTITER->lauf--;

    E_SET_KEY   (p->key,   SORTITER->table[SORTITER->lauf].key);
    E_SET_VALUE (p->value, SORTITER->table[SORTITER->lauf].value);
    return ERWIN_TRUE;
}


CODE_SECTION(".text.next_iteration_sorted_pairs_ptr_reverse")
ERWIN_BOOL map_int_char_p_next_iteration_sorted_pairs_ptr_reverse
        (
    map_int_char_p_t const *self, e_iterator_sorted_t *iter, map_int_char_p_pair_ptr_t *p)
{
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_ppp (self, iter, SORTITERPTR->table, self, iter);
    return0_if_null_pp   (p, self);

    if (ERWIN_UNLIKELY(SORTITERPTR->lauf <= 0))
        return ERWIN_FALSE;
    SORTITERPTR->lauf--;

    E_SET_KEY (p->key,   SORTITERPTR->table[SORTITERPTR->lauf].key);
    E_SET_PTR (p->value, SORTITERPTR->table[SORTITERPTR->lauf].value);
    return ERWIN_TRUE;
}

#endif /* defined(__cplusplus) */


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration")
ERWIN_BOOL map_int_char_p_next_iteration
        (
    map_int_char_p_t const*self,
    e_iterator_t *iter,
    int *keyp,
    char * *valuep)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null4_pp4 (self, iter, keyp, valuep, self, iter, keyp, valuep);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_KEY   (*keyp,   it->key);
    E_SET_VALUE (*valuep, it->value);
    return ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_values")
ERWIN_BOOL map_int_char_p_next_iteration_values
        (
    map_int_char_p_t const *self,
    e_iterator_t *iter,
    char * *valuep)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_pp3 (self, iter, valuep, self, iter, valuep);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_VALUE (*valuep, it->value);
    return ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table
 */
CODE_SECTION(".text.next_iteration_keys")
ERWIN_BOOL map_int_char_p_next_iteration_keys
        (map_int_char_p_t const *self, e_iterator_t *iter, int *keyp)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null2_pp2 (self, keyp, self, keyp);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_KEY (*keyp, it->key);
    return ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_pairs")
ERWIN_BOOL map_int_char_p_next_iteration_pairs
        (map_int_char_p_t const *self, e_iterator_t *iter, map_int_char_p_pair_t *pairp)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null3_pp3 (self, iter, pairp, self, iter, pairp);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_KEY   (pairp->key,   it->key);
    E_SET_VALUE (pairp->value, it->value);
    return ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_ptr")
ERWIN_BOOL map_int_char_p_next_iteration_ptr
        (
    map_int_char_p_t const*self,
    e_iterator_t *iter,
    int *keyp,
    map_int_char_p_element_ptr_t *valuepp)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null4_pp4 (self, iter, keyp, valuepp, self, iter, keyp, valuepp);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_KEY (*keyp,    it->key);
    E_SET_PTR (*valuepp, &it->value);
    return ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_values_ptr")
ERWIN_BOOL map_int_char_p_next_iteration_values_ptr
        (
    map_int_char_p_t const *self,
    e_iterator_t *iter,
    map_int_char_p_element_ptr_t *valuepp)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif
    return0_if_null3_pp3 (self, iter, valuepp, self, iter, valuepp);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_PTR (*valuepp, &it->value);
    return ERWIN_TRUE;
}


/*
 * Step function for iterating over a hash table */
CODE_SECTION(".text.next_iteration_pairs_ptr")
ERWIN_BOOL map_int_char_p_next_iteration_pairs_ptr
        (map_int_char_p_t const *self, e_iterator_t *iter, map_int_char_p_pair_ptr_t *pairp)
{
    map_int_char_p_hashlist_t *it;
#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null3_pp3 (self, iter, pairp, self, iter, pairp);

    E_SET_PTR (it, map_int_char_p_next_internal (self, iter));
    if (ERWIN_UNLIKELY(it == NULL))
        return ERWIN_FALSE;

    E_SET_KEY (pairp->key,   it->key);
    E_SET_PTR (pairp->value, &it->value);
    return ERWIN_TRUE;
}


/* Get all pairs of keys and values in the hash table */
CODE_SECTION(".text.get_entries")
map_int_char_p_pair_t * map_int_char_p_get_entries
        (map_int_char_p_t const *self)
{
    struct _map_int_char_p_pair_t *result, *rlauf;
    int    i;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, PAIR_NEW_ARRAY (map_int_char_p_pair_dynarray, 1));
        if (ERWIN_UNLIKELY(result == NULL)) {
            MAP_NOMEM;
            return NULL;
        }

        /* 0-termination */
        E_SET_KEY   (result->key,   IZERO);
        E_SET_VALUE (result->value, ZERO(self));
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, PAIR_NEW_ARRAY (map_int_char_p_pair_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_KEY   (rlauf->key,   lauf->key);
            E_SET_VALUE (rlauf->value, lauf->value);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }

    /* 0-termination */
    E_SET_KEY   (rlauf->key,   IZERO);
    E_SET_VALUE (rlauf->value, ZERO(self));

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ())
        qsort (result,
               self->m_nentries,
               sizeof (map_int_char_p_pair_t),
               (int(*)(void const *, void const *))map_int_char_p_detcmp_pairs);
#endif

    SET_ERRNO(E_OK);
    return result;
}


/*
 * Get all pairs of keys and values in the hash table
 */
CODE_SECTION(".text.get_entries_ptr")
map_int_char_p_pair_ptr_t * map_int_char_p_get_entries_ptr
        (map_int_char_p_t const*self)
{
    struct _map_int_char_p_pair_ptr_t *result, *rlauf;
    int    i;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, ERWIN_THING_NEW_ARRAY (map_int_char_p_pair_ptr_dynarray, 1));
        if (result == NULL) {
            MAP_NOMEM;
            return NULL;
        }
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, ERWIN_THING_NEW_ARRAY (map_int_char_p_pair_ptr_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_KEY (rlauf->key,   lauf->key);
            E_SET_PTR (rlauf->value, &lauf->value);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }
    E_SET_KEY (rlauf->key,   IZERO);
    E_SET_PTR (rlauf->value, NULL);

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ())
        qsort (result,
               self->m_nentries,
               sizeof (map_int_char_p_pair_ptr_t),
               (int(*)(void const *, void const *))map_int_char_p_detcmp_pairs_ptr);
#endif

    SET_ERRNO(E_OK);
    return result;
}


/* Get all values in the hash table */
CODE_SECTION(".text.get_values")
o_type_t * map_int_char_p_get_values
        (map_int_char_p_t const *self)
{
    char * *result;
    char * *rlauf;
    int   i;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, VALUE_NEW_ARRAY (map_int_char_p_value_dynarray, 1));
        if (ERWIN_UNLIKELY(result == NULL)) {
            MAP_NOMEM;
            return NULL;
        }
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, VALUE_NEW_ARRAY (map_int_char_p_value_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_VALUE (*rlauf, lauf->value);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }
    E_SET_VALUE (*rlauf, ZERO(self));

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ()) {
        map_int_char_p_check_detcmp_values;
        qsort (result,
               self->m_nentries,
               sizeof (char *),
               (int(*)(void const *, void const *))map_int_char_p_pair_detcmp_values);
    }
#endif

    SET_ERRNO(E_OK);
    return result;
}


/*
 * Get all keys in the hash table
 */
CODE_SECTION(".text.get_keys")
i_type_t * map_int_char_p_get_keys
        (map_int_char_p_t const *self)
{
    int *result;
    int *rlauf;
    int   i;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        E_SET_PTR (result, KEY_NEW_ARRAY (map_int_char_p_key_dynarray, 1));
        if (ERWIN_UNLIKELY(result == NULL)) {
            MAP_NOMEM;
            return NULL;
        }
        return result;
    }
#endif

    return0_if_null2i_or_bad (self);

    E_SET_PTR (result, KEY_NEW_ARRAY (map_int_char_p_key_dynarray, self->m_nentries+1));
    E_SET_PTR (rlauf,  result);
    if (ERWIN_UNLIKELY(result == NULL)) {
        MAP_NOMEM;
        return NULL;
    }

    for (i=0; i < self->m_hashsize; i++) {
        map_int_char_p_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));
        while (lauf) {
            E_SET_KEY (*rlauf, lauf->key);
            rlauf++;
            E_SET_PTR (lauf, lauf->next);
        }
    }
    E_SET_KEY (*rlauf, IZERO);

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism ())
        qsort (result,
               self->m_nentries,
               sizeof (int),
               (int(*)(void const *, void const *))map_int_char_p_pair_detcmp_keys);
#endif

    SET_ERRNO(E_OK);
    return result;
}

CODE_SECTION(".text.delete_entries")
void map_int_char_p_delete_entries
        (map_int_char_p_pair_t *entries)
{
    PAIR_DELETE_ARRAY (entries);
}

CODE_SECTION(".text.delete_entries_ptr")
void map_int_char_p_delete_entries_ptr
        (map_int_char_p_pair_ptr_t *entries_ptr)
{
    ERWIN_THING_DELETE_ARRAY (entries_ptr);
}


CODE_SECTION(".text.delete_values")
void map_int_char_p_delete_values
        (char * *values)
{
    VALUE_DELETE_ARRAY (values);
}


CODE_SECTION(".text.delete_keys")
void map_int_char_p_delete_keys
        (int *keys)
{
    KEY_DELETE_ARRAY (keys);
}

/*
 * Are two maps equal?  This is a deep comparison */
CODE_SECTION(".text.equal")
ERWIN_BOOL map_int_char_p_equal
        (map_int_char_p_t const *self, map_int_char_p_t const *other)
{
#if defined(OEQUAL) || defined(OCMP)
    e_iterator_t iter;
    int key;
    char * value;
#endif

    if (self == NULL || other == NULL) {
        SET_ERRNO(E_OK);
        return ERWIN_TO_BOOL (self == other);
    }

    return0_if_null2_pp2 (self, other, self, other);

    if (self->m_nentries != other->m_nentries) {
        SET_ERRNO(E_OK);
        return ERWIN_FALSE;
    }

#if defined(OEQUAL) || defined(OCMP)

    map_int_char_p_forall_nondet (self, iter, key, value)
    {
        char * *value_ptr;
        E_SET_PTR (value_ptr, map_int_char_p_find_ptr (other, key));
        if (value_ptr == NULL)
            return ERWIN_FALSE;

#ifdef OEQUAL
        if (!(OEQUAL ((*value_ptr), value)))
            return ERWIN_FALSE;
#else
        if ((OCMP((*value_ptr), value)) != 0)
            return ERWIN_FALSE;
#endif
    }


    /* -> same element count /\ none missing /\ values equal => hash table equal */
    SET_ERRNO(E_OK);
    return ERWIN_TRUE;
#else
    error_return0_if_reached_ppt (
        self,
        "Because neither CHAR_P_EQUAL nor CHAR_P_CMP was #defined, map_int_char_p_equal could not be implemented.");
#endif
}


CODE_SECTION(".text.find_any_pair_q")
int map_int_char_p_find_any_pair_q
        (map_int_char_p_key_result_t *key_p, map_int_char_p_element_ptr_t *value_p, map_int_char_p_t const* self)
{
    int i;

#ifdef MAP_INT_CHAR_P_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_KEYNOTFOUND);
        return 0;
    }
#endif

    return_val_if_null2i_or_bad (self, (ASSERTION_FAILED,0));

    if (self->m_nentries == 0) {
        SET_ERRNO(E_KEYNOTFOUND);
        return 0;
    }

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    { /* Find smallest entry. */
        int first= 1;
        int last; /* Not uninitialised.  Protected by 'first'. */
        for (i= 0; i < self->m_hashsize; i++) {
           map_int_char_p_hashlist_t *lauf;
           E_SET_PTR (lauf, SLOT(self,i));
           while (lauf) {
               if (first || map_int_char_p_pair_detcmp_keys (&lauf->key, &last) < 0) {
                   first= 0;
                   E_SET_KEY (last, lauf->key);
                   if (key_p) E_SET_KEY (*key_p, lauf->key);

                   if (value_p)
                       E_SET_PTR (*value_p, &lauf->value);
               }
               E_SET_PTR (lauf, lauf->next);
           }
        }

        if (!first) {
            SET_ERRNO(E_OK);
            return self->m_nentries;
        }
    }
#else
    for (i= 0; i < self->m_hashsize; i++) {
       map_int_char_p_hashlist_t *lauf;
       E_SET_PTR (lauf, SLOT(self,i));
       if (lauf) {
           if (key_p) E_SET_KEY (*key_p, lauf->key);

           if (value_p) E_SET_PTR (*value_p, &lauf->value);
           SET_ERRNO(E_OK);
           return self->m_nentries;
       }
    }
#endif

    return0_if_reached_pp(self); /* map non-empty, but no entry found!? */
    SET_ERRNO(E_KEYNOTFOUND);
    return 0;
}


CODE_SECTION(".text.find_any_key")
i_type_result_t map_int_char_p_find_any_key
        (map_int_char_p_t const *self)
{
    int result;
    int n= map_int_char_p_find_any_pair_q (&result, NULL, self);
    if (ERWIN_UNLIKELY(n == 0))
        return IZEROVAR;
    return result;
}


CODE_SECTION(".text.find_any_ptr")
map_int_char_p_element_ptr_t map_int_char_p_find_any_ptr
        (map_int_char_p_t const *self)
{
    map_int_char_p_element_ptr_t result;
    int n= map_int_char_p_find_any_pair (NULL, &result, self);
    if (ERWIN_UNLIKELY(n == 0))
        return NULL;
    return result;
}


CODE_SECTION(".text.find_any")
o_type_result_t map_int_char_p_find_any
        (map_int_char_p_t const *self)
{
    map_int_char_p_element_ptr_t result_p;
    int n= map_int_char_p_find_any_pair (NULL, &result_p, self);
    if (ERWIN_UNLIKELY(n == 0))
        return ZERO(self);
    return *result_p;
}


CODE_SECTION(".text.equal_keys")
ERWIN_BOOL map_int_char_p_equal_keys
        (map_int_char_p_t const *self, map_int_char_p_t const *other)
{
    e_iterator_t iter;
    int key;

    if (self == NULL || other == NULL) {
        SET_ERRNO(E_OK);
        return ERWIN_TO_BOOL (self == other);
    }

    return0_if_null2_pp2 (self, other, self, other);

    if (ERWIN_UNLIKELY(self->m_nentries != other->m_nentries)) {
        SET_ERRNO(E_OK);
        return ERWIN_FALSE;
    }

    /* FIXME: can be improved (idea by mschmidt): if the hashsizes are
     *        the same, we can check each slot instead of running a full
     *        search, so we need not hash the individual keys. */
    map_int_char_p_forall_keys_nondet (self, iter, key) {
        (void)map_int_char_p_find_ptr (other, key);
        if (e_errno != E_OK)
            return ERWIN_FALSE;
    }

    SET_ERRNO(E_OK);
    return ERWIN_TRUE;
}


/*
 * Compare two maps.  This is a deep comparison */
CODE_SECTION(".text.cmp")
int map_int_char_p_cmp
        (map_int_char_p_t const *self, map_int_char_p_t const *other)
/* must be NULL safe per definition! */
{
#if defined(ICMP) && defined(OCMP)
    map_int_char_p_pair_t *them1;
    map_int_char_p_pair_t *them2;
    int i;
    int result= 0;
    int cnt;
    map_int_char_p_check0_cmp_keys;
    map_int_char_p_check0_cmp_values;
#endif

    SET_ERRNO(E_OK);

    if (self == NULL)
        return (other == NULL) ? 0 : -1;

    if (other == NULL)
        return 1;

    return0_if_null2_pp2 (self, other, self, other);

    if (self->m_nentries < other->m_nentries)
        return -1;

    if (self->m_nentries > other->m_nentries)
        return +1;

#if defined(ICMP) && defined(OCMP)
    cnt= self->m_nentries; /* == other->m_nentries */

    E_SET_PTR (them1, map_int_char_p_get_entries (self));
    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return 0;

    E_SET_PTR (them2, map_int_char_p_get_entries (other));
    if (ERWIN_UNLIKELY(e_errno != E_OK)) {
        map_int_char_p_delete_entries (them1);
        return 0;
    }

#if defined(E_REQUIRE_DETERMINISM) && !defined(E_WEAK_DETERMINISM)
    if (e_require_determinism()) {
        qsort ((void*)them1, cnt, sizeof (map_int_char_p_pair_t), map_int_char_p_pair_detcmp_keys);
        qsort ((void*)them2, cnt, sizeof (map_int_char_p_pair_t), map_int_char_p_pair_detcmp_keys);

        e_merge_sort ((void*)them1, cnt, sizeof (map_int_char_p_pair_t), map_int_char_p_pair_cmp_keys);
        e_merge_sort ((void*)them2, cnt, sizeof (map_int_char_p_pair_t), map_int_char_p_pair_cmp_keys);
    }
    else
#else
    {
        qsort ((void*)them1, cnt, sizeof (map_int_char_p_pair_t), map_int_char_p_pair_cmp_keys);
        qsort ((void*)them2, cnt, sizeof (map_int_char_p_pair_t), map_int_char_p_pair_cmp_keys);
    }
#endif

    for (i=0; i < cnt; i++) {
        result= map_int_char_p_pair_cmp_keys (them1 + i, them2 + i);
        if (result != 0)
            break;

        result= map_int_char_p_pair_cmp_values (them1 + i, them2 + i);
        if (result != 0)
            break;
    }

    map_int_char_p_delete_entries (them1);
    map_int_char_p_delete_entries (them2);

    SET_ERRNO(E_OK);
    return result;
#else
    error_return0_if_reached_ppt (
        self,
        "Because either INT_CMP or CHAR_P_CMP was not #defined, map_int_char_p_cmp could not be implemented.");
#endif
}


/*
 * Compare set of keys of two maps.  This is a deep comparison */
CODE_SECTION(".text.cmp_keys")
int map_int_char_p_cmp_keys
        (map_int_char_p_t const *self, map_int_char_p_t const *other)
/* must be NULL safe per definition! */
{
#if defined(ICMP) && defined(OCMP)
    int *them1;
    int *them2;
    int i;
    int result= 0;
    int cnt;
    map_int_char_p_check0_cmp_keys;
#endif

    SET_ERRNO(E_OK);

    if (self == NULL)
        return (other == NULL) ? 0 : -1;

    if (other == NULL)
        return 1;

    return0_if_null2_pp2 (self, other, self, other);

    if (self->m_nentries < other->m_nentries)
        return -1;

    if (self->m_nentries > other->m_nentries)
        return +1;

#if defined(ICMP) && defined(OCMP)
    cnt= self->m_nentries; /* == other->m_nentries */

    E_SET_PTR (them1, map_int_char_p_get_keys (self));
    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return 0;

    E_SET_PTR (them2, map_int_char_p_get_keys (other));
    if (ERWIN_UNLIKELY(e_errno != E_OK)) {
        map_int_char_p_delete_keys (them1);
        return 0;
    }

    qsort ((void*)them1, cnt, sizeof (int), map_int_char_p_wrap_icmp);
    qsort ((void*)them2, cnt, sizeof (int), map_int_char_p_wrap_icmp);

    for (i=0; i < cnt; i++) {
        result= ICMP ((them1[i]), (them2[i]));
        if (result != 0)
            break;
    }

    map_int_char_p_delete_keys (them1);
    map_int_char_p_delete_keys (them2);

    SET_ERRNO(E_OK);
    return result;
#else
    error_return0_if_reached_ppt (
        self,
        "Because either INT_CMP was not #defined, map_int_char_p_cmp_keys could not be implemented.");
#endif
}


/* Compute hash value for a map. */
CODE_SECTION(".text.hash_raw")
e_hashval_t map_int_char_p_hash_raw
        (map_int_char_p_t const *self)
/* must be NULL-safe */
{
#ifdef OHASH
    e_iterator_t iter;
    int key;
    char * value;
    e_hash_state_t state;
#endif

    if (self == NULL) {
        SET_ERRNO(E_OK);
        return ERWIN_HASH_INIT;
    }

#ifdef OHASH
    ERWIN_STATE_INIT_WITH (state, int_hash(self->m_nentries));

    map_int_char_p_forall_nondet (self, iter, key, value) {
        ERWIN_STATE_MIX_UNORDERED2 (state, IHASH (key), OHASH (value));
    }

    SET_ERRNO(E_OK);
    return ERWIN_STATE_GET_HASHVAL (state);
#else
    error_return0_if_reached_ppt (
        self,
        "Because CHAR_P_HASH was not #defined, map_int_char_p_hash_raw could not be implemented.");
#endif
}


/*
 * **********************************************************************
 * C++ implementations
 * **********************************************************************
 */

#ifdef __cplusplus
#define self (this->it())

CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (void)
{
    ERWIN_BOOL ok= map_int_char_p_init_internal_q (it(), OZERO, MAP_INT_CHAR_P_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}

CODE_SECTION(".text._constructor")
void map_int_char_p_t::_constructor
        (void)
{
    ERWIN_BOOL ok= map_int_char_p_init_internal_q (it(), OZERO, MAP_INT_CHAR_P_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}

CODE_SECTION(".text.static_zero")
map_int_char_p_t const & map_int_char_p_t::static_zero
        ()
{
    static map_int_char_p_t const *z= NULL;
    if (ERWIN_UNLIKELY(!z))
        E_SET_PTR (z, new map_int_char_p_t);
    return *z;
}

#ifndef NDEBUG

CODE_SECTION(".text.cn")
void map_int_char_p_t::cn
        () const
{
    return_if_null_or_bad (this);
}

CODE_SECTION(".text.cn")
void map_int_char_p_t::cn
        (void const *p) const
{
    (void)p; /*unused*/
    return_if_null_or_bad (this);
    return_if_null_pp (p, this);
}
#endif /* !defined(NDEBUG) */


#if MAP_INT_CHAR_P_HAVE_INT_CONSTRUCTOR
CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (int size)
{
    ERWIN_BOOL ok= map_int_char_p_init_internal_q (it(), OZERO, size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* MAP_INT_CHAR_P_HAVE_INT_CONSTRUCTOR */


#if MAP_INT_CHAR_P_DYN_ZERO
CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (char *  zeroval)
{
    ERWIN_BOOL ok= map_int_char_p_init_internal_q (it(), zeroval, MAP_INT_CHAR_P_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}

CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (char *  zeroval, int size)
{
    ERWIN_BOOL ok= map_int_char_p_init_internal_q (it(), zeroval, size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* MAP_INT_CHAR_P_DYN_ZERO */


CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (map_int_char_p_t const &other)
{
#ifdef ERWIN_DOS
    if (other.it()->m_table == NULL && other.it()->m_nentries == 0) {
        /* See copy constructor for vectors for explanation. */
        map_int_char_p_init_internal_q (it(), OZERO, MAP_INT_CHAR_P_INITIAL_SIZE);
    }
    else
#endif
    {
        map_int_char_p_init_internal_q (it(), ZERO(other.it()), other.it()->m_nentries);
        map_int_char_p_struct_copy (it(), other.it());
    }
}


#ifdef ERWIN_COMPAT_2_0_264
CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (map_int_char_p_t const *other)
{
    map_int_char_p_init_internal_q (it(), ZERO(other), other->m_nentries);
    map_int_char_p_struct_copy (it(), other);
}
#endif /* defined(ERWIN_COMPAT_2_0_264) */


CODE_SECTION(".text.t")
 map_int_char_p_t::map_int_char_p_t
        (map_int_char_p_t const *other)
{
    map_int_char_p_init_internal_q (it(), ZERO(other->it()), other->it()->m_nentries);
    map_int_char_p_struct_copy (it(), other->it());
}


CODE_SECTION(".text.map_int_char_p_t")
 map_int_char_p_t::~map_int_char_p_t
        ()
{
    map_int_char_p_destroy_internal (it());
}


CODE_SECTION(".text._destructor")
void map_int_char_p_t::_destructor
        ()
{
    map_int_char_p_destroy_internal (it());
}

#if !ERWIN_DEFAULT_NEW_DELETE

CODE_SECTION(".text.operatornew")
void * map_int_char_p_t::operator new
        (size_t s)
{
    return ERWIN_PREFER_TNEW (void, s);
}

CODE_SECTION(".text.operatordelete")
void map_int_char_p_t::operator delete
        (void *p, size_t s)
{
    (void)s; /*unused*/
    ERWIN_PREFER_TDELETE (p, void, s);
}

CODE_SECTION(".text.operatornew")
void * map_int_char_p_t::operator new[]
        (size_t s)
{
    return ERWIN_PREFER_TNEW (void, s);
}

CODE_SECTION(".text.operatordelete")
void map_int_char_p_t::operator delete[]
        (void *p, size_t s)
{
    (void)s; /*unused*/
    ERWIN_PREFER_TDELETE (p, void, s);
}

#endif /* !ERWIN_DEFAULT_NEW_DELETE */

CODE_SECTION(".text.operator")
map_int_char_p_t & map_int_char_p_t::operator=
        (map_int_char_p_t const *other)
{
    map_int_char_p_clear_no_resize (it());
    map_int_char_p_expect_size (it(), other->it()->m_nentries); /* realloc to good size */
    map_int_char_p_struct_copy (it(), other->it());
    return *this;
}


CODE_SECTION(".text.operator")
map_int_char_p_t & map_int_char_p_t::operator=
        (map_int_char_p_t const &other)
{
#ifdef ERWIN_DOS
    if (other.it()->m_table == NULL && other.it()->m_nentries == 0) {
        /* See copy constructor for vectors for explanation. */
        map_int_char_p_init_internal_q (it(), OZERO, MAP_INT_CHAR_P_INITIAL_SIZE);
    }
    else
#endif
    {
        map_int_char_p_clear_no_resize (it());
        map_int_char_p_expect_size (it(), other.it()->m_nentries); /* realloc to good size */
        map_int_char_p_struct_copy (it(), other.it());
    }
    return *this;
}

#undef self
#endif /* defined(__cplusplus) */

/*
 * **********************************************************************
 * Section: Statistics and debugging.
 * **********************************************************************
 */

CODE_SECTION(".text.average_line_length")
double map_int_char_p_average_line_length
        (map_int_char_p_t const *self)
{
    double sum = 0.0;
    int i;
    for (i=0; i < self->m_hashsize; i++)
        sum+= map_int_char_p_hashlist_length (SLOT(self,i));
    return sum / (double)(self->m_hashsize);
}

CODE_SECTION(".text.variance_line_length")
double map_int_char_p_variance_line_length
        (map_int_char_p_t const *self)
{
    double average= map_int_char_p_average_line_length (self);
    double sum2= 0.0;
    int i;
    for (i=0; i < self->m_hashsize; i++) {
        double diff= map_int_char_p_hashlist_length (SLOT(self,i)) - average;
        sum2+= diff*diff;
    }
    return sum2 / (double)(self->m_hashsize - 1);
}

CODE_SECTION(".text.max_line_length")
int map_int_char_p_max_line_length
        (map_int_char_p_t const *self)
{
    int i;
    int max = 0;
    for (i=0; i < self->m_hashsize; i++) {
        int len= map_int_char_p_hashlist_length (SLOT(self,i));
        if (len > max) max= len;
    }
    return max;
}

CODE_SECTION(".text.min_line_length")
int map_int_char_p_min_line_length
        (map_int_char_p_t const *self)
{
    int i;
    int min= 0; /* shut up, gcc */
    for (i=0; i < self->m_hashsize; i++) {
        int len= map_int_char_p_hashlist_length (SLOT(self,i));
        if (i==0 || len < min) min= len;
    }
    return min;
}

#ifdef HAVE_SQRT
CODE_SECTION(".text.deviation_line_length")
double map_int_char_p_deviation_line_length
        (map_int_char_p_t const *self)
{
    return sqrt (map_int_char_p_variance_line_length (self));
}
#endif /* defined(HAVE_SQRT) */


CODE_SECTION(".text.dump")
void map_int_char_p_dump
        (FILE *thefile, map_int_char_p_t const *self)
{
    int i;
    fprintf (thefile, "(map_int_char_p_dump):\n");
    fprintf (thefile, "global e_errno=%d\n", e_errno);
    fprintf (thefile, "hashsize=%d\n", self->m_hashsize);
    fprintf (thefile, "nentries=%d\n", self->m_nentries);

#ifdef E_PROFILE
    fprintf (thefile, "nrehash=%d\n", self->m_nrehash);
    fprintf (thefile, "nrehashops=%d\n", self->m_nrehashops);
    fprintf (thefile, "nfind=%d\n", self->m_nfind);
    fprintf (thefile, "ninsert=%d\n", self->m_ninsert);
    fprintf (thefile, "ndelete=%d\n", self->m_ndelete);
#endif /* E_PROFILE */

#ifdef OPRINT
    fprintf (thefile, "zero=");
    {
        char * z;
        E_SET_VALUE (z, ZERO(self)); /* prevent a warning about reading through NULL pointer by
                                      * using this help variable */
        OPRINT (thefile, z);
    }
    fprintf (thefile, "\n");
#endif /* OPRINT */

    for (i= 0; i < self->m_hashsize; i++) {
        int length= 0;
        map_int_char_p_hashlist_t *lauf;
        E_SET_PTR (lauf, SLOT(self,i));

        if (lauf) {
            fprintf (thefile, "table[%d]:\n  ", i);
            while (lauf) {
                fprintf (thefile, "%p: ", lauf);

#ifdef IPRINT
                fprintf (thefile, " ");
                IPRINT (thefile, lauf->key);
#endif /* IPRINT */

#ifdef OPRINT
                fprintf (thefile, "=");
                OPRINT (thefile, lauf->value);
#endif /* OPRINT */

                fprintf (thefile, "\n  ");
                E_SET_PTR (lauf, lauf->next);
                length++;
            }
            fprintf (thefile, "(length %d)\n", length);
        }
    }
    fprintf (thefile, "END\n");
}

#ifdef E_PROFILE


CODE_SECTION(".text.nrehash")
int map_int_char_p_nrehash
        (map_int_char_p_t const *self)
{
    return self->m_nrehash;
}


CODE_SECTION(".text.nrehash_ops")
int map_int_char_p_nrehash_ops
        (map_int_char_p_t const *self)
{
    return self->m_nrehashops;
}


CODE_SECTION(".text.ninsert")
int map_int_char_p_ninsert
        (map_int_char_p_t const *self)
{
    return self->m_ninsert;
}


CODE_SECTION(".text.nfind")
int map_int_char_p_nfind
        (map_int_char_p_t const *self)
{
    return self->m_nfind;
}


CODE_SECTION(".text.nremove")
int map_int_char_p_nremove
        (map_int_char_p_t const *self)
{
    return self->m_ndelete;
}


CODE_SECTION(".text.nops")
int map_int_char_p_nops
        (map_int_char_p_t const *self)
{
    return self->m_ninsert + self->m_ndelete + self->m_nfind;
}


#endif /* defined(E_PROFILE) */


#undef MAP_INT_CHAR_P_IMPLEMENTATION
#undef ASSERTION_FAILED
#undef MAP_NOMEM
#undef MAP_NOMEM_R
#undef ITER
#undef SORTITER
#undef SORTITERPTR

#undef IZEROVAR
#undef errstream
#undef errprint

#undef E_ASSERTIONFAILED
#undef E_BOOL
#undef E_COMPAT_2_0_264
#undef E_COMPILING
#undef E_DEFAULT_NEW_DELETE
#undef E_EMPTY
#undef e_erwininternalmaperrno
#undef E_EXISTINGKEY
#undef E_FALSE
#undef E_FILE_IDS
#undef E_GLOBAL_ERRNO
#undef E_HASH_INIT
#undef e_hash_into
#undef e_hash_state_t
#undef e_hashval_t
#undef e_init
#undef e_init
#undef e_int_hash
#undef e_iterator_sorted_t
#undef e_iterator_t
#undef E_KEYNOTFOUND
#undef e_mapinitialised
#undef e_merge_sort
#undef E_NO_LINKER_TRICKS
#undef E_NOMEM
#undef E_NOMOREELEMS
#undef E_OK
#undef E_PREFER_TDELETE
#undef E_PREFER_TNEW
#undef E_PROFILE
#undef E_REHASH_DUPLICATEKEY
#undef E_REHASH_NOMEM
#undef E_REHASH_RECURSION
#undef e_require_determinism
#undef E_REQUIRE_DETERMINISM
#undef E_SET_PTR
#undef E_STATE_GET_HASHVAL
#undef E_STATE_INIT_WITH
#undef E_STATE_MIX_UNORDERED2
#undef E_STATE_MIX_UNORDERED
#undef E_THING_CNEW_ARRAY
#undef E_THING_DELETE1
#undef E_THING_DELETE_ARRAY
#undef E_THING_DELETE_ATOMS
#undef E_THING_NEW1
#undef E_THING_NEW_ARRAY
#undef E_THING_NEW_ATOMS
#undef E_THREAD_SAFE
#undef E_TO_BOOL
#undef E_TRUE
#undef E_USE_MUTABLE
#undef E_WEAK_DETERMINISM
#undef E_WEAK_STORAGE
#undef IBEING_USED
#undef ICMP
#undef ICOPY
#undef ICOPY_PROVIDED
#undef IDETCMP
#undef IDETCMP_PROVIDED
#undef IEQUAL
#undef IEQUAL_PROVIDED
#undef IFREE
#undef IFREE_PROVIDED
#undef IHASH
#undef IPRINT
#undef IZERO
#undef OBEING_USED
#undef OCMP
#undef OCOPY
#undef OCOPY_PROVIDED
#undef ODETCMP
#undef ODETCMP_PROVIDED
#undef OEQUAL
#undef OFREE
#undef OFREE_PROVIDED
#undef OHASH
#undef OPRINT
#undef OZERO

