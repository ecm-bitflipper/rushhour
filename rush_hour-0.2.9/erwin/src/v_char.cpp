/* -*- Mode: C -*- */

/* Author: Henrik Theiling
 *
 * Description: Implementation of vectors.
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifndef COMPAT_ERROR
#define COMPAT_ERROR 0
#endif

#ifndef V_CHAR_IMPLEMENTATION
#define V_CHAR_IMPLEMENTATION
#endif

#ifndef PASS2

#ifdef HAVE_MATH_H
#  include <math.h>
#endif

#include "erwin/defs.h"

#include "erwin/forwards.h"

#include "v_char_d.h"
#include "v_char.h"
#include "v_char_i.h"

#ifdef ERWIN_COMPILING
#  include "erwin/stdinc.h"
#else
#  include <erwin/stdinc.h>
#endif

#ifndef CHAR_BEING_USED
#define CHAR_BEING_USED 1
#endif

#include "erwin/needed.h"



/* Convenience definitions */
/* FIXME: these should be untemplatize-level defined.  But untemplatize does not
 *        know about whole-word-only replacements. */
#ifdef VECTOR_ERR_ASSERTIONFAILED
#define E_ASSERTIONFAILED VECTOR_ERR_ASSERTIONFAILED
#endif

#ifdef ERWIN_BOOL
#define E_BOOL ERWIN_BOOL
#endif

#define e_char_is_cr0 char_is_cr0

#define e_char_is_digit char_is_digit

#define e_char_is_print char_is_print

#define e_char_is_space0 char_is_space0

#define e_char_is_xdigit char_is_xdigit

#define e_char_to_lower char_to_lower

#define e_char_to_upper char_to_upper

#ifdef ERWIN_COMPAT_2_0_264
#define E_COMPAT_2_0_264 ERWIN_COMPAT_2_0_264
#endif

#ifdef ERWIN_COMPILING
#define E_COMPILING ERWIN_COMPILING
#endif

#ifdef ERWIN_DEFAULT_NEW_DELETE
#define E_DEFAULT_NEW_DELETE ERWIN_DEFAULT_NEW_DELETE
#endif

#ifdef VECTOR_WARN_EMPTY
#define E_EMPTY VECTOR_WARN_EMPTY
#endif

#ifdef ERWIN_ERROR_PRINT
#define E_ERROR_PRINT ERWIN_ERROR_PRINT
#endif

#ifdef ERWIN_ERROR_STREAM
#define E_ERROR_STREAM ERWIN_ERROR_STREAM
#endif

#ifdef erwininternalvectorerrno
#define e_erwininternalvectorerrno erwininternalvectorerrno
#endif

#ifdef ERWIN_FALSE
#define E_FALSE ERWIN_FALSE
#endif

#ifdef ERWIN_FILE_IDS
#define E_FILE_IDS ERWIN_FILE_IDS
#endif

#ifdef FO_CENTER
#define E_FO_CENTER FO_CENTER
#endif

#ifdef FO_CHECK
#define E_FO_CHECK FO_CHECK
#endif

#ifdef FO_DO_USE_SEP
#define E_FO_DO_USE_SEP FO_DO_USE_SEP
#endif

#ifdef FO_GET_RADIX
#define E_FO_GET_RADIX FO_GET_RADIX
#endif

#ifdef FO_GET_SEP_AT
#define E_FO_GET_SEP_AT FO_GET_SEP_AT
#endif

#ifdef FO_GET_USE_SEP
#define E_FO_GET_USE_SEP FO_GET_USE_SEP
#endif

#ifdef FO_QUOTE_MASK
#define E_FO_QUOTE_MASK FO_QUOTE_MASK
#endif

#ifdef FO_QUOTE_USER1
#define E_FO_QUOTE_USER1 FO_QUOTE_USER1
#endif

#ifdef FO_QUOTE_USER2
#define E_FO_QUOTE_USER2 FO_QUOTE_USER2
#endif

#ifdef FO_QUOTE_USER3
#define E_FO_QUOTE_USER3 FO_QUOTE_USER3
#endif

#ifdef FO_QUOTE_USER_MAX
#define E_FO_QUOTE_USER_MAX FO_QUOTE_USER_MAX
#endif

#ifdef FO_QUOTE_USER_MIN
#define E_FO_QUOTE_USER_MIN FO_QUOTE_USER_MIN
#endif

#ifdef FO_SIGNED
#define E_FO_SIGNED FO_SIGNED
#endif

#ifdef FO_SPECIAL
#define E_FO_SPECIAL FO_SPECIAL
#endif

#ifdef FO_S_TYPE_MASK
#define E_FO_S_TYPE_MASK FO_S_TYPE_MASK
#endif

#ifdef FO_UPCASE
#define E_FO_UPCASE FO_UPCASE
#endif

#ifdef FO_VECTOR
#define E_FO_VECTOR FO_VECTOR
#endif

#ifdef FO_VOID_P
#define E_FO_VOID_P FO_VOID_P
#endif

#ifdef ERWIN_GLOBAL_ERRNO
#define E_GLOBAL_ERRNO ERWIN_GLOBAL_ERRNO
#endif

#ifdef ERWIN_HASH_INIT
#define E_HASH_INIT ERWIN_HASH_INIT
#endif

#define e_hash_state_t erwin_hash_state_t

#define e_hashval_t hashval_t

#ifdef int_hash
#define e_int_hash int_hash
#endif

#ifdef VECTOR_ERR_IO
#define E_IO VECTOR_ERR_IO
#endif

#define e_merge_sort erwin_merge_sort

#ifdef erwin_next_power2_minus1
#define e_next_power2_minus1 erwin_next_power2_minus1
#endif

#ifdef VECTOR_ERR_NOMEM
#define E_NOMEM VECTOR_ERR_NOMEM
#endif

#ifdef VECTOR_ERR_NOTCOMPILED
#define E_NOTCOMPILED VECTOR_ERR_NOTCOMPILED
#endif

#ifdef VECTOR_OK
#define E_OK VECTOR_OK
#endif

#ifdef ERWIN_OPERATOR_NEW_CLEARS_MEMORY
#define E_OPERATOR_NEW_CLEARS_MEMORY ERWIN_OPERATOR_NEW_CLEARS_MEMORY
#endif

#ifdef VECTOR_ERR_OUTOFRANGE
#define E_OUTOFRANGE VECTOR_ERR_OUTOFRANGE
#endif

#ifdef ERWIN_PREFER_TDELETE
#define E_PREFER_TDELETE ERWIN_PREFER_TDELETE
#endif

#ifdef ERWIN_PREFER_TNEW
#define E_PREFER_TNEW ERWIN_PREFER_TNEW
#endif

#ifdef ERWIN_SET_PTR
#define E_SET_PTR ERWIN_SET_PTR
#endif

#ifdef ERWIN_STATE_GET_HASHVAL
#define E_STATE_GET_HASHVAL ERWIN_STATE_GET_HASHVAL
#endif

#ifdef ERWIN_STATE_INIT_WITH
#define E_STATE_INIT_WITH ERWIN_STATE_INIT_WITH
#endif

#ifdef ERWIN_STATE_MIX_ORDERED
#define E_STATE_MIX_ORDERED ERWIN_STATE_MIX_ORDERED
#endif

#ifdef ERWIN_TFREE1
#define E_TFREE1 ERWIN_TFREE1
#endif

#ifdef ERWIN_TFREE_ARRAY
#define E_TFREE_ARRAY ERWIN_TFREE_ARRAY
#endif

#ifdef ERWIN_TFREE_ATOMS
#define E_TFREE_ATOMS ERWIN_TFREE_ATOMS
#endif

#ifdef ERWIN_THING_DELETE1
#define E_THING_DELETE1 ERWIN_THING_DELETE1
#endif

#ifdef ERWIN_THING_DELETE_ARRAY
#define E_THING_DELETE_ARRAY ERWIN_THING_DELETE_ARRAY
#endif

#ifdef ERWIN_THING_DELETE_ATOMS
#define E_THING_DELETE_ATOMS ERWIN_THING_DELETE_ATOMS
#endif

#ifdef ERWIN_THING_NEW1
#define E_THING_NEW1 ERWIN_THING_NEW1
#endif

#ifdef ERWIN_THING_NEW_ARRAY
#define E_THING_NEW_ARRAY ERWIN_THING_NEW_ARRAY
#endif

#ifdef ERWIN_THING_NEW_ATOMS
#define E_THING_NEW_ATOMS ERWIN_THING_NEW_ATOMS
#endif

#ifdef ERWIN_THING_RENEW_ARRAY
#define E_THING_RENEW_ARRAY ERWIN_THING_RENEW_ARRAY
#endif

#ifdef ERWIN_THING_RENEW_ATOMS
#define E_THING_RENEW_ATOMS ERWIN_THING_RENEW_ATOMS
#endif

#ifdef ERWIN_THREAD_SAFE
#define E_THREAD_SAFE ERWIN_THREAD_SAFE
#endif

#ifdef ERWIN_TMALLOC1
#define E_TMALLOC1 ERWIN_TMALLOC1
#endif

#ifdef ERWIN_TMALLOC_ARRAY
#define E_TMALLOC_ARRAY ERWIN_TMALLOC_ARRAY
#endif

#ifdef ERWIN_TMALLOC_ATOMS
#define E_TMALLOC_ATOMS ERWIN_TMALLOC_ATOMS
#endif

#ifdef ERWIN_TO_BOOL
#define E_TO_BOOL ERWIN_TO_BOOL
#endif

#ifdef VECTOR_ERR_TOOLARGE
#define E_TOOLARGE VECTOR_ERR_TOOLARGE
#endif

#ifdef ERWIN_TREALLOC_ARRAY
#define E_TREALLOC_ARRAY ERWIN_TREALLOC_ARRAY
#endif

#ifdef ERWIN_TREALLOC_ATOMS
#define E_TREALLOC_ATOMS ERWIN_TREALLOC_ATOMS
#endif

#ifdef ERWIN_TRUE
#define E_TRUE ERWIN_TRUE
#endif

#ifdef ERWIN_USE_MUTABLE
#define E_USE_MUTABLE ERWIN_USE_MUTABLE
#endif

#ifdef ERWIN_VERBOSE
#define E_VERBOSE ERWIN_VERBOSE
#endif

#ifdef CHAR_BEING_USED
#define OBEING_USED CHAR_BEING_USED
#endif

#ifdef CHAR_CMP
#define OCMP CHAR_CMP
#endif

#ifdef CHAR_CONSTRUCTOR
#define OCONSTRUCTOR CHAR_CONSTRUCTOR
#endif

#ifdef CHAR_OCOPY
#define OCOPY CHAR_OCOPY
#endif

#ifdef CHAR_OCOPY_PROVIDED
#define OCOPY_PROVIDED CHAR_OCOPY_PROVIDED
#endif

#ifdef CHAR_DESTRUCTOR
#define ODESTRUCTOR CHAR_DESTRUCTOR
#endif

#ifdef CHAR_EQUAL
#define OEQUAL CHAR_EQUAL
#endif

#ifdef CHAR_OFREE
#define OFREE CHAR_OFREE
#endif

#ifdef CHAR_OFREE_PROVIDED
#define OFREE_PROVIDED CHAR_OFREE_PROVIDED
#endif

#ifdef CHAR_HASH
#define OHASH CHAR_HASH
#endif

#ifdef CHAR_PRIORITY_CMP
#define OPRIORITY_CMP CHAR_PRIORITY_CMP
#endif

#ifdef CHAR_UPDATE_POS2
#define OUPDATE_POS2 CHAR_UPDATE_POS2
#endif

#ifdef CHAR_UPDATE_POS
#define OUPDATE_POS CHAR_UPDATE_POS
#endif

#ifdef CHAR_ZERO
#define OZERO CHAR_ZERO
#endif

/* #undef errno */
/* #define errno   __I_THINK_YOU_MEAN__e_errno__
 *     ERWIN_STRERRNO is used, so this is no good...
 */



#if defined(CHAR_IS_PTR) && CHAR_IS_PTR
#  define E_SET_VALUE(X,Y)     E_SET_PTR(X,Y)
#else
#  define E_SET_VALUE(X,Y)     ((X)=(Y))
#endif

#define QUOTATION_METHOD_CNT 16

#if !E_GLOBAL_ERRNO
#  if E_USE_MUTABLE
#      define e_errno          (self->m_errno)
#  else
#      define e_errno          (ERWIN_CONST_CAST(v_char_t*,self)->m_errno)
#  endif
#else
#  define e_errno              erwininternalvectorerrno
#endif

#define SET_ERRNO(X)           do{ e_errno= (X); }while(0)
#define PASS_ERRNO(X)          (e_errno= (X))


#if V_CHAR_INITIAL_SIZE < 0
#error V_CHAR_INITIAL_SIZE < 0
#endif

#if V_CHAR_MINIMAL_SIZE < 0
#error V_CHAR_MINIMAL_SIZE < 0
#endif


/* Note: Pay attention to INLINE_STORE, too, because if we use an inline
 *       store, we don't need the ZERO_SIZE stuff -- the INLINE_STORE
 *       implementation implements something similar automatically.
 *
 * Note: With INLINE_STORE, we do not know whether INLINE_CNT is > 0 or
 *       not.  So some code that needs special care with ZERO_SIZE also
 *       needs special care with INLINE_STORE.
 */
#if V_CHAR_INLINE_STORE
#  define V_CHAR_ZERO_SIZE 0
#elif V_CHAR_MINIMAL_SIZE == 0 || V_CHAR_INITIAL_SIZE == 0
#  define V_CHAR_ZERO_SIZE 1
#else
#  define V_CHAR_ZERO_SIZE 0
#endif

/* Handling of element array:
 * This is tricky due to INLINE_STORE, LOW_MEM, and ZERO_SIZE stuff */

#define V_CHAR_DUMMY_TABLE ((char*)(void*)&v_char_dummy_table)
   /* This hopefully disables the type-punned pointer warning of gcc,
    * which is otherwise hard to eliminate.  The pointer is never
    * dereferenced, so the warning may be ignored. */

#if V_CHAR_LOW_MEM
#  define v_char_ensure_table_size_force   v_char_ensure_size
#else
#  define v_char_ensure_table_size_force   v_char_ensure_table_size
#endif

#define ADD_MINUS_1(A,B)        ((B) > 0 ? ((A) + (B) - 1) : (A))

#define NEED_GROW(N,T)          ((N) > (T))

#if V_CHAR_INLINE_STORE

#  define V_CHAR_INLINE_CNT     ((v_char_cnt_t)(sizeof(v_char_content_p) / sizeof(v_char_content)))

#  define HAVE_INLINE_STORE     (V_CHAR_INLINE_CNT > 0)

#  if V_CHAR_LOW_MEM
#    define HAS_HEAP_TABLE(X)   ((X) && ((X)->m_nentries > V_CHAR_INLINE_CNT))
#  else
#    define HAS_HEAP_TABLE(X)   ((X) && ((X)->m_tablesize> V_CHAR_INLINE_CNT))
#  endif

#  define INLINE_TABLE(X)       ((v_char_content_p)(&((X)->m_table)))

#  define TABLE(X)              (HAS_HEAP_TABLE(X) ? (X)->m_table : INLINE_TABLE(X))

#  define GET_MINIMAL_SIZE      (HAVE_INLINE_STORE ? V_CHAR_INLINE_CNT : V_CHAR_MINIMAL_SIZE)
#  define GET_INITIAL_SIZE      (HAVE_INLINE_STORE ? V_CHAR_INLINE_CNT : V_CHAR_INITIAL_SIZE)

#  define CLAMP_MINIMAL(N)      ((N) <= V_CHAR_INLINE_CNT ?      \
                                    V_CHAR_INLINE_CNT            \
                                  : (N) <= V_CHAR_MINIMAL_SIZE ? \
                                    V_CHAR_MINIMAL_SIZE          \
                                  : (N)                          \
                                )

#define NEED_SHRINK_MIN(N,T,MIN)  ((N) <= ((T)>>2) && (ADD_MINUS_1(T,MIN) >> 1) >= (MIN))
#define NEED_SHRINK(N,T)          NEED_SHRINK_MIN(N, T, GET_MINIMAL_SIZE)
#define ADJUST_SHRUNK(T)          CLAMP_MINIMAL(T)

#define ADJUST_GROWN(T)           CLAMP_MINIMAL(T)

#else

#  define V_CHAR_INLINE_CNT     0

#  if V_CHAR_ZERO_SIZE
#    define HAS_HEAP_TABLE(X)   ((X) && (X)->m_table != V_CHAR_DUMMY_TABLE)
#  else
#    define HAS_HEAP_TABLE(X)   1
#  endif

#  define TABLE(X)              ((X)->m_table)

#  define GET_MINIMAL_SIZE      V_CHAR_MINIMAL_SIZE
#  define GET_INITIAL_SIZE      V_CHAR_INITIAL_SIZE

#  define CLAMP_MINIMAL(N)      ((N) <= V_CHAR_MINIMAL_SIZE ? \
                                    V_CHAR_MINIMAL_SIZE       \
                                  : (N)                       \
                                )

#define NEED_SHRINK_MIN(N,T,MIN)  ((N) <= ((T)>>2) && ((T) >> 1) >= (MIN))
#define NEED_SHRINK(N,T)          NEED_SHRINK_MIN(N, T, GET_MINIMAL_SIZE)
#define ADJUST_SHRUNK(T)          (T)

#define ADJUST_GROWN(T)           (T)

#endif

/* Regarding NEED_GROW and NEED_SHRINK:
 *
 * Now, shrinking is obviously more elaborated than growing.
 * Why?
 *
 * The problem is the v_char_shrink() function that might resize to a non-power of 2
 * (or better, non-power of two multiple of MINIMAL_SIZE).
 * For growing, this is not considered a problem, but if we reach smaller sizes in
 * the order of MINIMAL_SIZE, we will need to 'realign' the table size to get a good
 * performance, especially if we have an inline store.  E.g. consider:
 *
 *    new element count    current tablesize        inline_cnt
 *    1                    5                        4
 *
 * In this situation, if we only checked whener 5/2 was >= inline_cnt, we'd not
 * resize at all, leaving the array on the heap forever.  But what we want is to
 * resize to 2 and then realign to size 4 to get optimal usage of the inline store.
 *
 * OTOH, in a situation like this:
 *
 *    new element count    current tablesize        inline_cnt
 *    1                    4                        4
 *
 * we do not want to first shrink to 2 and then realign to 4, but we want to
 * know immediately that we're at the limit already.
 *
 * To achieve both, we need to round the current table size up when we divide it
 * by 2, for which ADD_MINUS_1 is used.  Thus with MIN=4, we get:
 *
 *     (5 + 4 - 1)/2 >= 4    => shrink one more (and ofter that, clamp to minimum)
 * but
 *     (4 + 4 - 1)/2 <  4    => no need to shrink
 *
 * growshrink.pl shows what happens when we start with an unalign table size.
 *
 * We might optimise this and switch the resizing depending on whether we have
 * an inline store or not (in the above example, to resize from 5 to 4 on the
 * heap would be slightly silly)
 */

/* We need all user types that may be a result type as simple type names,
 * because untemplatize cannot parse all C types. */
typedef char       o_type_t;
typedef char  o_type_result_t;
typedef char    o_type_var_t;

#define SPLIT_SECTIONS V_CHAR_SPLIT

#if SPLIT_SECTIONS
#  define CODE_SECTION(X) ATTR_SECTION(X)
#else
#  define CODE_SECTION(X)
#endif

#define ASSERTION_FAILED PASS_ERRNO(E_ASSERTIONFAILED)

#define return_if_invalid(self) \
    return_if_fail_ppi (VALID_NENTRIES(self->m_nentries), self, self->m_nentries);
#define return_val_if_invalid(self, val) \
    return_val_if_fail_ppi (VALID_NENTRIES(self->m_nentries), val, self, self->m_nentries);
#define return_if_invalid_pC(self, prog) \
    return_if_fail_ppiC (VALID_NENTRIES(self->m_nentries), self, self->m_nentries, prog);

#if V_CHAR_HAVE_SIG

#  define return_if_bad(self) \
      return_if_fail_ppxxt(self->m_sig == V_CHAR_SIG, self, self->m_sig, V_CHAR_SIG, "Structure was probably overwritten"); \
      return_if_invalid(self);
#  define return_val_if_bad(self, val) \
      return_val_if_fail_ppxxt(self->m_sig == V_CHAR_SIG, val, self, self->m_sig, V_CHAR_SIG, "Structure was probably overwritten"); \
      return_val_if_invalid(self, val);
#  define return_if_bad_pC(self, prog) \
      return_if_fail_ppxxtC(self->m_sig == V_CHAR_SIG, self, self->m_sig, V_CHAR_SIG, "Structure was probably overwritten", prog); \
      return_if_invalid_pC(self, prog);

#else

#  define return_if_bad(self) \
      return_if_invalid(self);
#  define return_val_if_bad(self, val) \
      return_val_if_invalid(self, val);
#  define return_if_bad_pC(self, prog) \
      return_if_invalid_pC(self, prog);

#endif

#define return_if_null_or_bad(self) \
    return_if_null(self); \
    return_if_bad (self);

#define return_val_if_null_or_bad(self, val) \
    return_val_if_null(self, val); \
    return_val_if_bad (self, val);

#define return_if_null_or_bad_pC(self, prog) \
    return_if_null_pC(self, prog); \
    return_if_bad_pC (self, prog); \
    return_if_fail_ppiC (VALID_NENTRIES(self->m_nentries), self, self->m_nentries, prog);

#define return_if_null2i_or_bad(self) \
    return_if_null(self); \
    return_if_bad (self); \
    return_if_fail_pp(!HAS_HEAP_TABLE(self) || (self->m_table != NULL), self);

#define return_val_if_null2i_or_bad(self, val) \
    return_val_if_null(self, val); \
    return_val_if_bad (self, val); \
    return_val_if_fail_pp(!HAS_HEAP_TABLE(self) || (self->m_table != NULL), val, self);

#define return_if_null2i_or_bad_pC(self, prog) \
    return_if_null_pC(self, prog); \
    return_if_bad_pC (self, prog); \
    return_if_fail_ppC(!HAS_HEAP_TABLE(self) || (self->m_table != NULL), self, prog);

#define return0_if_bad(self)           return_val_if_bad(self, 0);
#define return0_if_null_or_bad(self)   return_val_if_null_or_bad(self, 0);
#define return0_if_null2i_or_bad(self) return_val_if_null2i_or_bad(self, 0);

#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A)       \
            ASSERTION_FAILED;                          \
            V_CHAR_ASSERTION_FAILED_HANDLER(FI,L,FU,A)
#endif

#if V_CHAR_SIZE_INDEX_DIFF
#  define VALID_SIZE(A)          (((v_char_cnt_t)(v_char_size_t)(A)) == ((v_char_cnt_t)(A)))
#  define VALID_NENTRIES(A)      1
#else
#  define VALID_SIZE(A)          1
#  define VALID_NENTRIES(A)      (((v_char_cnt_t)(A)) >= 0)
#endif

#if V_CHAR_MAY_BE_INVALID
#  define VALID_SIZE_GT(A,B)     (VALID_SIZE(A) && VALID_SIZE(B) && VALID_NENTRIES(B) && (A) < (B))
#  define VALID_SIZE_PLUS(A,B)   (VALID_SIZE(B) && VALID_SIZE_GT(A, (A)+(B)))
#else
#  define VALID_SIZE_GT(A,B)     VALID_NENTRIES(B)
#  define VALID_SIZE_PLUS(A,B)   VALID_SIZE_GT(A, (A)+(B))
#endif

#ifndef FATAL_ERROR
#define FATAL_ERROR(X,Y,Z,I,N)                                     \
            do {                                                   \
                SET_ERRNO(X);                                      \
                nothing_if_fail_ptii(ERWIN_FALSE, Z, I, N); \
                Y;                                                 \
            } while(0)
#endif

#ifndef FATAL_ERROR_MIN
#define FATAL_ERROR_MIN(X,Y,Z,I)                               \
            do {                                               \
                SET_ERRNO(X);                                  \
                nothing_if_fail_pti(ERWIN_FALSE, Z, I); \
                Y;                                             \
            } while(0)
#endif

#ifdef E_FILE_IDS
static char const * const vector_cvs_id= "$""Id: none$";
#endif

/*
 * This file contains ugly macros.  Their purpose is to debug code, and
 * to be a substitute for assert.h.  This file should compile under any compiler
 * with all (sensible) compiler settings and #defines.  This is meant to be ANSI
 * code with GNUC extensions if we compile under GNUC.  It should under no
 * circumstances produce compiler errors and under GNUC it should not produce
 * any warnings.
 * So if it fails to compile, it is a severe bug.  Please report this to
 * henrik@theiling.de.  To temporarily circumvent the problem, you can comment
 * out the following line. */

/* #define ASSERT_IS_BROKEN */

#ifndef ASSERT_IS_BROKEN

/*
 * Additional user provided assertion failure, warning,
 * and error handlers.
 */
#ifndef USER_ASSERTION_FAILED_HANDLER
#define USER_ASSERTION_FAILED_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_ERROR_HANDLER
#define USER_ERROR_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifndef USER_WARNING_HANDLER
#define USER_WARNING_HANDLER(FI,L,FU,A) ASSERT_NO_EFFECT
#endif

#ifdef __GNUC__

#define ASSERT_NORETURN  __attribute__((__noreturn__))

#if defined __cplusplus && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95))
#define ASSERT_CAST_VOID static_cast<void>
   /* for compiler warning -Wold-style-cast */
#endif

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   __PRETTY_FUNCTION__
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  (ASSERT_CAST_VOID(0)) /* To get rid of warnings. */
 /* FIXME: CHECK: do we need the different versions of ASSERT_NO_EFFECT? */
#endif

#else

#define ASSERT_NORETURN

#ifndef ASSERT_FUNCTION
#define ASSERT_FUNCTION   "-unknown-"
#endif

#ifndef ASSERT_NO_EFFECT
#define ASSERT_NO_EFFECT  0
#endif

#endif

#ifndef ASSERT_CAST_VOID
#define ASSERT_CAST_VOID (void)
#endif

#ifndef NDEBUG
#define ASSERT_DEBUG_CODE(X) X
#else
#define ASSERT_DEBUG_CODE(X)
#endif

#if defined(__KERNEL__)

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (printk (KERN_ERR "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#elif defined(HAVE_LIBERROR)

#ifndef IN_LIBERROR_COMPILE
#include <liberror.h>
#endif

#ifndef ASSERT_ABORT
#define ASSERT_ABORT err_crash()
#endif

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (eprintf (C_TAG_MORE, 0, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (fleprintf (C_TAG_PRE_ASSERT | 0, 0, FILE, LINE, F, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (eprintf (C_TAG_ASSERT | 0, 0, ERR_CALLBACKS_ONLY))
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT
#endif

#else /* !defined HAVE_LIBERROR */

#ifndef ASSERT_EPRINTF_MORE_0
#define ASSERT_EPRINTF_MORE_0(F) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F))
#endif

#ifndef ASSERT_EPRINTF_MORE_1
#define ASSERT_EPRINTF_MORE_1(F,V1) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F, V1))
#endif

#ifndef ASSERT_EPRINTF_MORE_2
#define ASSERT_EPRINTF_MORE_2(F,V1,V2) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "\t"F, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_2
#define ASSERT_FLEPRINTF_ASSERT_2(FILE,LINE,F,V1,V2) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2))
#endif

#ifndef ASSERT_FLEPRINTF_ASSERT_3
#define ASSERT_FLEPRINTF_ASSERT_3(FILE,LINE,F,V1,V2,V3) \
        ASSERT_CAST_VOID (ERWIN_ERROR_PRINT (ERWIN_ERROR_STREAM,  "%s:%d: "F, FILE, LINE, V1, V2, #V3))
#endif

#ifndef ASSERT_END
#define ASSERT_END \
        ASSERT_CAST_VOID (0)
#endif

#ifndef ASSERT_INDENT
#define ASSERT_INDENT "\t"
#endif

#endif /* !defined HAVE_LIBERROR */

#ifndef ASSERT_ABORT
#define ASSERT_ABORT abort()
#endif

#ifndef ASSERT_NONNEGATIVE
#ifdef erwin_nonnegative
#define ASSERT_NONNEGATIVE(X) erwin_nonnegative(X)
#else
#define ASSERT_NONNEGATIVE(X) ((X) >= 0)
#endif
#endif

#ifndef ASSERT_UNLIKELY
#ifdef ERWIN_UNLIKELY
#define ASSERT_UNLIKELY(X) ERWIN_UNLIKELY(X)
#else
#define ASSERT_UNLIKELY(X) (X)
#endif
#endif


#ifndef NDEBUG
/*
 * The following macros are only available for debugging.  There will not
 * be an error_..._if_crash since a) that is weird, b) the macros
 * do not work on many platforms and should, therefore, not handle normal
 * control flow, c) we have to define helper data and functions. */

/*
 * In order to get the necessary #definitions automatically from a GNU
 * configure script, be sure to have the following lines in configure.in:

--- BEGIN configure.failure ---

AC_CHECK_HEADERS(signal.h)
AC_CHECK_HEADERS(setjmp.h)
AC_CHECK_FUNCS(setjmp)
AC_TYPE_SIGNAL

dnl The following might make the output nicer, but are not required:

AC_CHECK_HEADERS(unistd.h)
AC_DECL_SYS_SIGLIST

--- END configure.failure ---

 * Note that this file does not believe the configure settings if you compile
 * with -ansi (i.e. __STRICT_ANSI__ is defined).  This is a convenience
 * setting for gcc compilation tests when you do not want to call configure
 * again.

 * And either add the following lines to config.h.in:

--- BEGIN config.h.in.failure ---
#undef HAVE_SIGNAL_H
#undef HAVE_SETJMP_H
#undef HAVE_UNISTD_H
#undef RETSIGTYPE
#undef SYS_SIGLIST_DECLARED
--- END config.h.in.failure ---

 * And be sure to include your configuration header file before this file.
 */

#if defined(HAVE_SIGNAL_H) && defined(HAVE_SETJMP_H) && defined(HAVE_SETJMP) && defined(RETSIGTYPE) && !defined(__KERNEL__)

/* We have signals and debugging is enabled here.  And we are not in __KERNEL__ mode.*/

#include <signal.h>
#include <setjmp.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#if defined(SYS_SIGLIST_DECLARED) && !defined(__STRICT_ANSI__)
#define ASSERT_STRSIGNAL(X) (sys_siglist[X])
#else
#define ASSERT_STRSIGNAL(X) "unknown"
#endif

static jmp_buf assert_jmp_buf;
static volatile int assert_signal_caught;
static volatile int assert_caught_no;

#if defined(SIGSEGV) || defined(_SIGSEGV)
static RETSIGTYPE (*assert_old_sigsegv)(int);
#endif
#if defined(SIGBUS) || defined(_SIGBUS)
static RETSIGTYPE (*assert_old_sigbus)(int);
#endif
#if defined(SIGABRT) || defined(_SIGABRT)
static RETSIGTYPE (*assert_old_sigabrt)(int);
#endif
#if defined(SIGFPE) || defined(_SIGFPE)
static RETSIGTYPE (*assert_old_sigfpe)(int);
#endif
#if defined(SIGILL) || defined(_SIGILL)
static RETSIGTYPE (*assert_old_sigill)(int);
#endif
#if defined(SIGHUP) || defined(_SIGHUP)
static RETSIGTYPE (*assert_old_sighup)(int);
#endif

static RETSIGTYPE assert_catch_signal (int) ASSERT_NORETURN;
static RETSIGTYPE assert_catch_signal (int which)
{
    assert_signal_caught= 1;
    assert_caught_no= which;
    longjmp (assert_jmp_buf, 1);
}

static void assert_begin_signals (void)
{
    assert_signal_caught= 0;

#if defined(_SIGSEGV)
    assert_old_sigsegv= signal (_SIGSEGV, &assert_catch_signal);
#elif defined(SIGSEGV)
    assert_old_sigsegv= signal (SIGSEGV, &assert_catch_signal);
#endif

#if defined(_SIGBUS)
    assert_old_sigbus= signal (_SIGBUS, &assert_catch_signal);
#elif defined(SIGBUS)
    assert_old_sigbus= signal (SIGBUS, &assert_catch_signal);
#endif

#if defined(_SIGABRT)
    assert_old_sigabrt= signal (_SIGABRT, &assert_catch_signal);
#elif defined(SIGABRT)
    assert_old_sigabrt= signal (SIGABRT, &assert_catch_signal);
#endif

#if defined(_SIGFPE)
    assert_old_sigfpe= signal (_SIGFPE, &assert_catch_signal);
#elif defined(SIGFPE)
    assert_old_sigfpe= signal (SIGFPE, &assert_catch_signal);
#endif

#if defined(_SIGILL)
    assert_old_sigill= signal (_SIGILL, &assert_catch_signal);
#elif defined(SIGILL)
    assert_old_sigill= signal (SIGILL, &assert_catch_signal);
#endif

#if defined(_SIGHUP)
    assert_old_sighup= signal (_SIGHUP, &assert_catch_signal);
#elif defined(SIGHUP)
    assert_old_sighup= signal (SIGHUP, &assert_catch_signal);
#endif
}

static void assert_end_signals (void)
{
#if defined(_SIGSEGV)
    signal (_SIGSEGV, assert_old_sigsegv);
#elif defined(SIGSEGV)
    signal (SIGSEGV, assert_old_sigsegv);
#endif

#if defined(_SIGBUS)
    signal (_SIGBUS, assert_old_sigbus);
#elif defined(SIGBUS)
    signal (SIGBUS, assert_old_sigbus);
#endif

#if defined(_SIGABRT)
    signal (_SIGABRT, assert_old_sigabrt);
#elif defined(SIGABRT)
    signal (SIGABRT, assert_old_sigabrt);
#endif

#if defined(_SIGFPE)
    signal (_SIGFPE, assert_old_sigfpe);
#elif defined(SIGFPE)
    signal (SIGFPE, assert_old_sigfpe);
#endif

#if defined(_SIGILL)
    signal (_SIGILL, assert_old_sigill);
#elif defined(SIGILL)
    signal (SIGILL, assert_old_sigill);
#endif

#if defined(_SIGHUP)
    signal (_SIGHUP, assert_old_sighup);
#elif defined(SIGHUP)
    signal (SIGHUP, assert_old_sighup);
#endif
}

/*
 * This is not nestable. */
#define ASSERT_TRY_COMMAND(X)                 \
        do {                                  \
            assert_begin_signals ();          \
            if (!setjmp (assert_jmp_buf)) {   \
                X;                            \
            }                                 \
            assert_end_signals ();            \
        } while (0)

#define ASSERT_NO_SIGNAL_CAUGHT (assert_signal_caught == 0)

#else

/* No signals, debugging enabled. */
#define ASSERT_TRY_COMMAND(X) do { X; } while (0)
        /* this *is* a crash test, so do it even if catching the error is
         * not possible on this machine... */
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X) "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* defined(HAVE_SIGNAL_H) ... */

#else

/* No signals, debugging disabled. */
#define ASSERT_TRY_COMMAND(X)
#define ASSERT_NO_SIGNAL_CAUGHT 1
#define ASSERT_STRSIGNAL(X)  "unknown"
#define assert_signal_caught 0
#define assert_caught_no     -1

#endif /* DEBUG */


/*
 * Please note that this does not have any do { ... } while(0) protection.  This is because
 * continue_if_fail and break_if_fail would do wrong things in that case. */
#ifndef raw_do_if_fail
#define raw_do_if_fail(P,A1,A2,A3,W,F1,F2) \
        if (ASSERT_UNLIKELY(!(A1))) { \
            ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                     ""P" function '%s':\n" \
                     ASSERT_INDENT W " failed: '%s'\n" \
                     ASSERT_INDENT "Pre-processed: '%s'\n" \
                             , ASSERT_FUNCTION, \
                             A3 \
                             ,A2 \
                             ); \
            F1; \
            USER_ASSERTION_FAILED_HANDLER(__FILE__,__LINE__,ASSERT_FUNCTION, A); \
            F2; \
        } \
        else { ; }
#endif

/*
 * If you write your USER_ASSERTION_FAILED_HANDLER in such a way that it is an expression,
 * you can use the false_if_fail, null_if_fail, etc. */
#ifndef raw_value_if_fail
#define raw_value_if_fail(P,A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        (ASSERT_UNLIKELY(!(A1)) ? ((\
                     ASSERT_FLEPRINTF_ASSERT_3 ( \
                     __FILE__, __LINE__, \
                          ""P" function '%s':\n" \
                          ASSERT_INDENT W" failed: '%s'\n" \
                          ASSERT_INDENT "Pre-processed: '%s'\n" \
                          , ASSERT_FUNCTION, \
                          A3 \
                          ,#A2 \
                          )), \
                  (F1), \
                  (USER_ASSERTION_FAILED_HANDLER(__FILE__, __LINE__, ASSERT_FUNCTION, A)), \
                  (FAILVAL)) \
                : (GOODVAL))
#endif

#ifndef NDEBUG

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("In",A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("In",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#else

#ifndef do_if_fail
#define do_if_fail(A1,A2,A3,W,F1,F2)
#endif

#ifndef value_if_fail
#define value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) (GOODVAL)
#endif

#endif

#ifndef warn_do_if_fail
#define warn_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Warning in",A1,A2,A3,W,F1,F2)
#endif

#ifndef warn_value_if_fail
#define warn_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Warning in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef error_do_if_fail
#define error_do_if_fail(A1,A2,A3,W,F1,F2) \
        raw_do_if_fail("Error in",A1,A2,A3,W,F1,F2)
#endif

#ifndef error_value_if_fail
#define error_value_if_fail(A1,A2,A3,W,F1,FAILVAL,GOODVAL) \
        raw_value_if_fail("Error in",A1,A2,A3,W,F1,FAILVAL,GOODVAL)
#endif

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3) \
	 { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;break;;); } 
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1) \
	 do { error_do_if_fail(A1,A1,""#A1,"Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1) \
	 do { error_do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { error_do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Sanity constraint",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached() \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3) \
	 do { error_do_if_fail(!(A1),!(A1),"!("""#A1")","Sanity constraint",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2) \
	 do { error_do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached
#define exit1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;exit(1);;); } while (0) 
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null
#define exit_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached
#define exit_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;ASSERT_ABORT;;); } while (0) 
#endif

#ifndef false_if_fail
#define false_if_fail(A1) \
	 ( value_if_fail(A1,A1,""#A1,"Assertion",(ASSERT_NO_EFFECT,ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) \
	 ( value_if_fail(0,0,"""0","Control flow",(ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n"),ASSERT_EPRINTF_MORE_1 ("%s\n", #X1),ASSERT_NO_EFFECT),(ASSERT_END,0),(!0)) ) 
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached
#define nothing_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_2 (""#X1"=%d ('%c')\n", (X1), (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;;;); } while (0) 
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2) \
	 do { \
	ASSERT_TRY_COMMAND(A1;);\
	do_if_fail(ASSERT_NO_SIGNAL_CAUGHT,A1;,""#A1,"Execution",ASSERT_EPRINTF_MORE_1 ("Signal number: %d\n", assert_caught_no);ASSERT_EPRINTF_MORE_1 ("Signal name: %s\n", ASSERT_STRSIGNAL(assert_caught_no));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));X3;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null
#define return0_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); \
	do_if_fail((A4) != NULL,(A4) != NULL,"("#A4") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%p\n", (X4));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached
#define return0_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 0;;); } while (0) 
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null
#define return1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached
#define return1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return 1;;); } while (0) 
#endif

#ifndef return_if_fail
#define return_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));X3;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%lu\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%lu\n", (unsigned long)(X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));X5;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null
#define return_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return;;); \
	do_if_fail((A1->A2) != NULL,(A1->A2) != NULL,"("#A1"->"#A2") != NULL","Assertion",;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached
#define return_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return;;); } while (0) 
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached() \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return -1;;); } while (0) 
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%ld\n", (long)(X3));ASSERT_EPRINTF_MORE_1 (""#X4"=%ld\n", (long)(X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=0x%lx\n", (unsigned long)(X2));ASSERT_EPRINTF_MORE_1 (""#X3"=0x%lx\n", (unsigned long)(X3));ASSERT_EPRINTF_MORE_1 ("%s\n", (X4));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1) \
	 do { do_if_fail(A1,A1,""#A1,"Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",;;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A2) != NULL,(A2) != NULL,"("#A2") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); \
	do_if_fail((A3) != NULL,(A3) != NULL,"("#A3") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%p\n", (X2));ASSERT_EPRINTF_MORE_1 (""#X3"=%p\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));X2;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1) \
	 do { do_if_fail((A1) != NULL,(A1) != NULL,"("#A1") != NULL","Assertion",ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1) \
	 do { do_if_fail(ASSERT_NONNEGATIVE((A1)) && (A1) < (M),ASSERT_NONNEGATIVE((A1)) && (A1) < (M),"ASSERT_NONNEGATIVE(("#A1")) && ""("#A1") < ("#M")","Assertion",ASSERT_EPRINTF_MORE_1 (""#A1"=%ld\n", (long)(A1));ASSERT_EPRINTF_MORE_1 (""#M"=%ld\n", (long)(M));ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");X1;;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 (""#X2"=%ld\n", (long)(X2));ASSERT_EPRINTF_MORE_1 ("%s\n", (X3));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%ld\n", (long)(X1));ASSERT_EPRINTF_MORE_1 ("%s\n", (X2));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 (""#X1"=%p\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1) \
	 do { do_if_fail(0,0,"""0","Control flow",ASSERT_EPRINTF_MORE_0 ("This code should never be reached.\n");ASSERT_EPRINTF_MORE_1 ("%s\n", (X1));;,ASSERT_END;return (O);;); } while (0) 
#endif


#else /* !defined(ASSERT_IS_BROKEN) */

#ifndef break_if_out_of_bounds_ppii
#define break_if_out_of_bounds_ppii(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_fail
#define error_exit_if_fail(A1)
#endif

#ifndef error_exit_if_fail_pC
#define error_exit_if_fail_pC(A1,X1)
#endif

#ifndef error_exit_if_fail_pi
#define error_exit_if_fail_pi(A1,X1)
#endif

#ifndef error_exit_if_fail_pii
#define error_exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_piit
#define error_exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_fail_pit
#define error_exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_fail_pt
#define error_exit_if_fail_pt(A1,X1)
#endif

#ifndef error_exit_if_null
#define error_exit_if_null(A1)
#endif

#ifndef error_exit_if_null_pC
#define error_exit_if_null_pC(A1,X1)
#endif

#ifndef error_exit_if_null_pi
#define error_exit_if_null_pi(A1,X1)
#endif

#ifndef error_exit_if_null_pii
#define error_exit_if_null_pii(A1,X1,X2)
#endif

#ifndef error_exit_if_null_piit
#define error_exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef error_exit_if_null_pit
#define error_exit_if_null_pit(A1,X1,X2)
#endif

#ifndef error_exit_if_null_pt
#define error_exit_if_null_pt(A1,X1)
#endif

#ifndef error_exit_if_out_of_bounds
#define error_exit_if_out_of_bounds(A1,M)
#endif

#ifndef error_exit_if_out_of_bounds_pC
#define error_exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pi
#define error_exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef error_exit_if_out_of_bounds_pii
#define error_exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_piit
#define error_exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef error_exit_if_out_of_bounds_pit
#define error_exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef error_exit_if_out_of_bounds_pt
#define error_exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef error_exit_if_reached
#define error_exit_if_reached()
#endif

#ifndef error_exit_if_reached_pC
#define error_exit_if_reached_pC(X1)
#endif

#ifndef error_exit_if_reached_pi
#define error_exit_if_reached_pi(X1)
#endif

#ifndef error_exit_if_reached_pii
#define error_exit_if_reached_pii(X1,X2)
#endif

#ifndef error_exit_if_reached_piit
#define error_exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef error_exit_if_reached_pit
#define error_exit_if_reached_pit(X1,X2)
#endif

#ifndef error_exit_if_reached_pt
#define error_exit_if_reached_pt(X1)
#endif

#ifndef error_exit_unless_fail_pt
#define error_exit_unless_fail_pt(A1,X1)
#endif

#ifndef error_exit_unless_fail_pti
#define error_exit_unless_fail_pti(A1,X1,X2)
#endif

#ifndef error_exit_unless_fail_ptii
#define error_exit_unless_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef error_return0_if_reached_ppt
#define error_return0_if_reached_ppt(X1,X2)
#endif

#ifndef exit1_if_fail
#define exit1_if_fail(A1)
#endif

#ifndef exit1_if_fail_pC
#define exit1_if_fail_pC(A1,X1)
#endif

#ifndef exit1_if_fail_pi
#define exit1_if_fail_pi(A1,X1)
#endif

#ifndef exit1_if_fail_pii
#define exit1_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit1_if_fail_piit
#define exit1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_fail_pit
#define exit1_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit1_if_fail_pt
#define exit1_if_fail_pt(A1,X1)
#endif

#ifndef exit1_if_null
#define exit1_if_null(A1)
#endif

#ifndef exit1_if_null_pC
#define exit1_if_null_pC(A1,X1)
#endif

#ifndef exit1_if_null_pi
#define exit1_if_null_pi(A1,X1)
#endif

#ifndef exit1_if_null_pii
#define exit1_if_null_pii(A1,X1,X2)
#endif

#ifndef exit1_if_null_piit
#define exit1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit1_if_null_pit
#define exit1_if_null_pit(A1,X1,X2)
#endif

#ifndef exit1_if_null_pt
#define exit1_if_null_pt(A1,X1)
#endif

#ifndef exit1_if_out_of_bounds
#define exit1_if_out_of_bounds(A1,M)
#endif

#ifndef exit1_if_out_of_bounds_pC
#define exit1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pi
#define exit1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit1_if_out_of_bounds_pii
#define exit1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_piit
#define exit1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit1_if_out_of_bounds_pit
#define exit1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit1_if_out_of_bounds_pt
#define exit1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit1_if_reached
#define exit1_if_reached()
#endif

#ifndef exit1_if_reached_pC
#define exit1_if_reached_pC(X1)
#endif

#ifndef exit1_if_reached_pi
#define exit1_if_reached_pi(X1)
#endif

#ifndef exit1_if_reached_pii
#define exit1_if_reached_pii(X1,X2)
#endif

#ifndef exit1_if_reached_piit
#define exit1_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit1_if_reached_pit
#define exit1_if_reached_pit(X1,X2)
#endif

#ifndef exit1_if_reached_pt
#define exit1_if_reached_pt(X1)
#endif

#ifndef exit_if_fail
#define exit_if_fail(A1)
#endif

#ifndef exit_if_fail_pC
#define exit_if_fail_pC(A1,X1)
#endif

#ifndef exit_if_fail_pi
#define exit_if_fail_pi(A1,X1)
#endif

#ifndef exit_if_fail_pii
#define exit_if_fail_pii(A1,X1,X2)
#endif

#ifndef exit_if_fail_piit
#define exit_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_fail_pit
#define exit_if_fail_pit(A1,X1,X2)
#endif

#ifndef exit_if_fail_ppt
#define exit_if_fail_ppt(A1,X1,X2)
#endif

#ifndef exit_if_fail_pt
#define exit_if_fail_pt(A1,X1)
#endif

#ifndef exit_if_null
#define exit_if_null(A1)
#endif

#ifndef exit_if_null_pC
#define exit_if_null_pC(A1,X1)
#endif

#ifndef exit_if_null_pi
#define exit_if_null_pi(A1,X1)
#endif

#ifndef exit_if_null_pii
#define exit_if_null_pii(A1,X1,X2)
#endif

#ifndef exit_if_null_piit
#define exit_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef exit_if_null_pit
#define exit_if_null_pit(A1,X1,X2)
#endif

#ifndef exit_if_null_pt
#define exit_if_null_pt(A1,X1)
#endif

#ifndef exit_if_out_of_bounds
#define exit_if_out_of_bounds(A1,M)
#endif

#ifndef exit_if_out_of_bounds_pC
#define exit_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pi
#define exit_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef exit_if_out_of_bounds_pii
#define exit_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_piit
#define exit_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef exit_if_out_of_bounds_pit
#define exit_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef exit_if_out_of_bounds_pt
#define exit_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef exit_if_reached
#define exit_if_reached()
#endif

#ifndef exit_if_reached_pC
#define exit_if_reached_pC(X1)
#endif

#ifndef exit_if_reached_pi
#define exit_if_reached_pi(X1)
#endif

#ifndef exit_if_reached_pii
#define exit_if_reached_pii(X1,X2)
#endif

#ifndef exit_if_reached_piit
#define exit_if_reached_piit(X1,X2,X3)
#endif

#ifndef exit_if_reached_pit
#define exit_if_reached_pit(X1,X2)
#endif

#ifndef exit_if_reached_pt
#define exit_if_reached_pt(X1)
#endif

#ifndef false_if_fail
#define false_if_fail(A1) (!0)
#endif

#ifndef false_if_reached_pk
#define false_if_reached_pk(X1) (!0)
#endif

#ifndef nothing_if_fail
#define nothing_if_fail(A1)
#endif

#ifndef nothing_if_fail_pC
#define nothing_if_fail_pC(A1,X1)
#endif

#ifndef nothing_if_fail_pi
#define nothing_if_fail_pi(A1,X1)
#endif

#ifndef nothing_if_fail_pii
#define nothing_if_fail_pii(A1,X1,X2)
#endif

#ifndef nothing_if_fail_piit
#define nothing_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_fail_pit
#define nothing_if_fail_pit(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ppi
#define nothing_if_fail_ppi(A1,X1,X2)
#endif

#ifndef nothing_if_fail_pt
#define nothing_if_fail_pt(A1,X1)
#endif

#ifndef nothing_if_fail_pti
#define nothing_if_fail_pti(A1,X1,X2)
#endif

#ifndef nothing_if_fail_ptii
#define nothing_if_fail_ptii(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null
#define nothing_if_null(A1)
#endif

#ifndef nothing_if_null_pC
#define nothing_if_null_pC(A1,X1)
#endif

#ifndef nothing_if_null_pi
#define nothing_if_null_pi(A1,X1)
#endif

#ifndef nothing_if_null_pii
#define nothing_if_null_pii(A1,X1,X2)
#endif

#ifndef nothing_if_null_piit
#define nothing_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef nothing_if_null_pit
#define nothing_if_null_pit(A1,X1,X2)
#endif

#ifndef nothing_if_null_pt
#define nothing_if_null_pt(A1,X1)
#endif

#ifndef nothing_if_out_of_bounds
#define nothing_if_out_of_bounds(A1,M)
#endif

#ifndef nothing_if_out_of_bounds_pC
#define nothing_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pi
#define nothing_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef nothing_if_out_of_bounds_pii
#define nothing_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_piit
#define nothing_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef nothing_if_out_of_bounds_pit
#define nothing_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef nothing_if_out_of_bounds_pt
#define nothing_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef nothing_if_reached
#define nothing_if_reached()
#endif

#ifndef nothing_if_reached_pC
#define nothing_if_reached_pC(X1)
#endif

#ifndef nothing_if_reached_pci
#define nothing_if_reached_pci(X1,X2)
#endif

#ifndef nothing_if_reached_pi
#define nothing_if_reached_pi(X1)
#endif

#ifndef nothing_if_reached_pii
#define nothing_if_reached_pii(X1,X2)
#endif

#ifndef nothing_if_reached_piit
#define nothing_if_reached_piit(X1,X2,X3)
#endif

#ifndef nothing_if_reached_pit
#define nothing_if_reached_pit(X1,X2)
#endif

#ifndef nothing_if_reached_pt
#define nothing_if_reached_pt(X1)
#endif

#ifndef return0_if_crash_ppt
#define return0_if_crash_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail
#define return0_if_fail(A1)
#endif

#ifndef return0_if_fail_pC
#define return0_if_fail_pC(A1,X1)
#endif

#ifndef return0_if_fail_pi
#define return0_if_fail_pi(A1,X1)
#endif

#ifndef return0_if_fail_pii
#define return0_if_fail_pii(A1,X1,X2)
#endif

#ifndef return0_if_fail_piit
#define return0_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pit
#define return0_if_fail_pit(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppi
#define return0_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppii
#define return0_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppiit
#define return0_if_fail_ppiit(A1,X1,X2,X3,X4)
#endif

#ifndef return0_if_fail_ppp
#define return0_if_fail_ppp(A1,X1,X2)
#endif

#ifndef return0_if_fail_ppt
#define return0_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return0_if_fail_pptC
#define return0_if_fail_pptC(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_ppti
#define return0_if_fail_ppti(A1,X1,X2,X3)
#endif

#ifndef return0_if_fail_pt
#define return0_if_fail_pt(A1,X1)
#endif

#ifndef return0_if_null
#define return0_if_null(A1)
#endif

#ifndef return0_if_null2
#define return0_if_null2(A1,A2)
#endif

#ifndef return0_if_null2_pp2
#define return0_if_null2_pp2(A1,A2,X1,X2)
#endif

#ifndef return0_if_null2_pp3
#define return0_if_null2_pp3(A1,A2,X1,X2,X3)
#endif

#ifndef return0_if_null3_pp3
#define return0_if_null3_pp3(A1,A2,A3,X1,X2,X3)
#endif

#ifndef return0_if_null3_ppp
#define return0_if_null3_ppp(A1,A2,A3,X1,X2)
#endif

#ifndef return0_if_null4_pp4
#define return0_if_null4_pp4(A1,A2,A3,A4,X1,X2,X3,X4)
#endif

#ifndef return0_if_null_pC
#define return0_if_null_pC(A1,X1)
#endif

#ifndef return0_if_null_pi
#define return0_if_null_pi(A1,X1)
#endif

#ifndef return0_if_null_pii
#define return0_if_null_pii(A1,X1,X2)
#endif

#ifndef return0_if_null_piit
#define return0_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return0_if_null_pit
#define return0_if_null_pit(A1,X1,X2)
#endif

#ifndef return0_if_null_pp
#define return0_if_null_pp(A1,X1)
#endif

#ifndef return0_if_null_pp2
#define return0_if_null_pp2(A1,X1,X2)
#endif

#ifndef return0_if_null_ppp
#define return0_if_null_ppp(A1,X1,X2)
#endif

#ifndef return0_if_null_pt
#define return0_if_null_pt(A1,X1)
#endif

#ifndef return0_if_out_of_bounds
#define return0_if_out_of_bounds(A1,M)
#endif

#ifndef return0_if_out_of_bounds_pC
#define return0_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pi
#define return0_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return0_if_out_of_bounds_pii
#define return0_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_piit
#define return0_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return0_if_out_of_bounds_pit
#define return0_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return0_if_out_of_bounds_pt
#define return0_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return0_if_reached
#define return0_if_reached()
#endif

#ifndef return0_if_reached_pC
#define return0_if_reached_pC(X1)
#endif

#ifndef return0_if_reached_pi
#define return0_if_reached_pi(X1)
#endif

#ifndef return0_if_reached_pii
#define return0_if_reached_pii(X1,X2)
#endif

#ifndef return0_if_reached_piit
#define return0_if_reached_piit(X1,X2,X3)
#endif

#ifndef return0_if_reached_pit
#define return0_if_reached_pit(X1,X2)
#endif

#ifndef return0_if_reached_pp
#define return0_if_reached_pp(X1)
#endif

#ifndef return0_if_reached_pt
#define return0_if_reached_pt(X1)
#endif

#ifndef return1_if_fail
#define return1_if_fail(A1)
#endif

#ifndef return1_if_fail_pC
#define return1_if_fail_pC(A1,X1)
#endif

#ifndef return1_if_fail_pi
#define return1_if_fail_pi(A1,X1)
#endif

#ifndef return1_if_fail_pii
#define return1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return1_if_fail_piit
#define return1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_fail_pit
#define return1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return1_if_fail_pt
#define return1_if_fail_pt(A1,X1)
#endif

#ifndef return1_if_null
#define return1_if_null(A1)
#endif

#ifndef return1_if_null_pC
#define return1_if_null_pC(A1,X1)
#endif

#ifndef return1_if_null_pi
#define return1_if_null_pi(A1,X1)
#endif

#ifndef return1_if_null_pii
#define return1_if_null_pii(A1,X1,X2)
#endif

#ifndef return1_if_null_piit
#define return1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return1_if_null_pit
#define return1_if_null_pit(A1,X1,X2)
#endif

#ifndef return1_if_null_pt
#define return1_if_null_pt(A1,X1)
#endif

#ifndef return1_if_out_of_bounds
#define return1_if_out_of_bounds(A1,M)
#endif

#ifndef return1_if_out_of_bounds_pC
#define return1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pi
#define return1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return1_if_out_of_bounds_pii
#define return1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_piit
#define return1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return1_if_out_of_bounds_pit
#define return1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return1_if_out_of_bounds_pt
#define return1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return1_if_reached
#define return1_if_reached()
#endif

#ifndef return1_if_reached_pC
#define return1_if_reached_pC(X1)
#endif

#ifndef return1_if_reached_pi
#define return1_if_reached_pi(X1)
#endif

#ifndef return1_if_reached_pii
#define return1_if_reached_pii(X1,X2)
#endif

#ifndef return1_if_reached_piit
#define return1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return1_if_reached_pit
#define return1_if_reached_pit(X1,X2)
#endif

#ifndef return1_if_reached_pt
#define return1_if_reached_pt(X1)
#endif

#ifndef return_if_fail
#define return_if_fail(A1)
#endif

#ifndef return_if_fail_pC
#define return_if_fail_pC(A1,X1)
#endif

#ifndef return_if_fail_pi
#define return_if_fail_pi(A1,X1)
#endif

#ifndef return_if_fail_pii
#define return_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_if_fail_piit
#define return_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_pit
#define return_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_if_fail_pp
#define return_if_fail_pp(A1,X1)
#endif

#ifndef return_if_fail_pp2
#define return_if_fail_pp2(A1,X1,X2)
#endif

#ifndef return_if_fail_ppC
#define return_if_fail_ppC(A1,X1,X2)
#endif

#ifndef return_if_fail_ppi
#define return_if_fail_ppi(A1,X1,X2)
#endif

#ifndef return_if_fail_ppiC
#define return_if_fail_ppiC(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppii
#define return_if_fail_ppii(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppt
#define return_if_fail_ppt(A1,X1,X2)
#endif

#ifndef return_if_fail_ppuu
#define return_if_fail_ppuu(A1,X1,X2,X3)
#endif

#ifndef return_if_fail_ppxxt
#define return_if_fail_ppxxt(A1,X1,X2,X3,X4)
#endif

#ifndef return_if_fail_ppxxtC
#define return_if_fail_ppxxtC(A1,X1,X2,X3,X4,X5)
#endif

#ifndef return_if_fail_pt
#define return_if_fail_pt(A1,X1)
#endif

#ifndef return_if_null
#define return_if_null(A1)
#endif

#ifndef return_if_null2_ppp
#define return_if_null2_ppp(A1,A2,X1,X2)
#endif

#ifndef return_if_null2i
#define return_if_null2i(A1,A2)
#endif

#ifndef return_if_null_pC
#define return_if_null_pC(A1,X1)
#endif

#ifndef return_if_null_pi
#define return_if_null_pi(A1,X1)
#endif

#ifndef return_if_null_pii
#define return_if_null_pii(A1,X1,X2)
#endif

#ifndef return_if_null_piit
#define return_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_if_null_pit
#define return_if_null_pit(A1,X1,X2)
#endif

#ifndef return_if_null_pp
#define return_if_null_pp(A1,X1)
#endif

#ifndef return_if_null_pp2
#define return_if_null_pp2(A1,X1,X2)
#endif

#ifndef return_if_null_ppC
#define return_if_null_ppC(A1,X1,X2)
#endif

#ifndef return_if_null_pt
#define return_if_null_pt(A1,X1)
#endif

#ifndef return_if_out_of_bounds
#define return_if_out_of_bounds(A1,M)
#endif

#ifndef return_if_out_of_bounds_pC
#define return_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pi
#define return_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pii
#define return_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_piit
#define return_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_if_out_of_bounds_pit
#define return_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_if_out_of_bounds_pp
#define return_if_out_of_bounds_pp(A1,M,X1)
#endif

#ifndef return_if_out_of_bounds_pt
#define return_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_if_reached
#define return_if_reached()
#endif

#ifndef return_if_reached_pC
#define return_if_reached_pC(X1)
#endif

#ifndef return_if_reached_pi
#define return_if_reached_pi(X1)
#endif

#ifndef return_if_reached_pii
#define return_if_reached_pii(X1,X2)
#endif

#ifndef return_if_reached_piit
#define return_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_if_reached_pit
#define return_if_reached_pit(X1,X2)
#endif

#ifndef return_if_reached_ppt
#define return_if_reached_ppt(X1,X2)
#endif

#ifndef return_if_reached_pt
#define return_if_reached_pt(X1)
#endif

#ifndef return_m1_if_fail
#define return_m1_if_fail(A1)
#endif

#ifndef return_m1_if_fail_pC
#define return_m1_if_fail_pC(A1,X1)
#endif

#ifndef return_m1_if_fail_pi
#define return_m1_if_fail_pi(A1,X1)
#endif

#ifndef return_m1_if_fail_pii
#define return_m1_if_fail_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_piit
#define return_m1_if_fail_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_fail_pit
#define return_m1_if_fail_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_fail_pt
#define return_m1_if_fail_pt(A1,X1)
#endif

#ifndef return_m1_if_null
#define return_m1_if_null(A1)
#endif

#ifndef return_m1_if_null_pC
#define return_m1_if_null_pC(A1,X1)
#endif

#ifndef return_m1_if_null_pi
#define return_m1_if_null_pi(A1,X1)
#endif

#ifndef return_m1_if_null_pii
#define return_m1_if_null_pii(A1,X1,X2)
#endif

#ifndef return_m1_if_null_piit
#define return_m1_if_null_piit(A1,X1,X2,X3)
#endif

#ifndef return_m1_if_null_pit
#define return_m1_if_null_pit(A1,X1,X2)
#endif

#ifndef return_m1_if_null_pt
#define return_m1_if_null_pt(A1,X1)
#endif

#ifndef return_m1_if_out_of_bounds
#define return_m1_if_out_of_bounds(A1,M)
#endif

#ifndef return_m1_if_out_of_bounds_pC
#define return_m1_if_out_of_bounds_pC(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pi
#define return_m1_if_out_of_bounds_pi(A1,M,X1)
#endif

#ifndef return_m1_if_out_of_bounds_pii
#define return_m1_if_out_of_bounds_pii(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_piit
#define return_m1_if_out_of_bounds_piit(A1,M,X1,X2,X3)
#endif

#ifndef return_m1_if_out_of_bounds_pit
#define return_m1_if_out_of_bounds_pit(A1,M,X1,X2)
#endif

#ifndef return_m1_if_out_of_bounds_pt
#define return_m1_if_out_of_bounds_pt(A1,M,X1)
#endif

#ifndef return_m1_if_reached
#define return_m1_if_reached()
#endif

#ifndef return_m1_if_reached_pC
#define return_m1_if_reached_pC(X1)
#endif

#ifndef return_m1_if_reached_pi
#define return_m1_if_reached_pi(X1)
#endif

#ifndef return_m1_if_reached_pii
#define return_m1_if_reached_pii(X1,X2)
#endif

#ifndef return_m1_if_reached_piit
#define return_m1_if_reached_piit(X1,X2,X3)
#endif

#ifndef return_m1_if_reached_pit
#define return_m1_if_reached_pit(X1,X2)
#endif

#ifndef return_m1_if_reached_pt
#define return_m1_if_reached_pt(X1)
#endif

#ifndef return_val_if_fail
#define return_val_if_fail(A1,O)
#endif

#ifndef return_val_if_fail_pC
#define return_val_if_fail_pC(A1,O,X1)
#endif

#ifndef return_val_if_fail_pi
#define return_val_if_fail_pi(A1,O,X1)
#endif

#ifndef return_val_if_fail_pii
#define return_val_if_fail_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_piit
#define return_val_if_fail_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_pit
#define return_val_if_fail_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_pp
#define return_val_if_fail_pp(A1,O,X1)
#endif

#ifndef return_val_if_fail_ppi
#define return_val_if_fail_ppi(A1,O,X1,X2)
#endif

#ifndef return_val_if_fail_ppii
#define return_val_if_fail_ppii(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_fail_ppiii
#define return_val_if_fail_ppiii(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_ppxxt
#define return_val_if_fail_ppxxt(A1,O,X1,X2,X3,X4)
#endif

#ifndef return_val_if_fail_pt
#define return_val_if_fail_pt(A1,O,X1)
#endif

#ifndef return_val_if_null
#define return_val_if_null(A1,O)
#endif

#ifndef return_val_if_null2
#define return_val_if_null2(A1,A2,O)
#endif

#ifndef return_val_if_null2_ppp
#define return_val_if_null2_ppp(A1,A2,O,X1,X2)
#endif

#ifndef return_val_if_null3_pp3
#define return_val_if_null3_pp3(A1,A2,A3,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pC
#define return_val_if_null_pC(A1,O,X1)
#endif

#ifndef return_val_if_null_pi
#define return_val_if_null_pi(A1,O,X1)
#endif

#ifndef return_val_if_null_pii
#define return_val_if_null_pii(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_piit
#define return_val_if_null_piit(A1,O,X1,X2,X3)
#endif

#ifndef return_val_if_null_pit
#define return_val_if_null_pit(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pp
#define return_val_if_null_pp(A1,O,X1)
#endif

#ifndef return_val_if_null_ppC
#define return_val_if_null_ppC(A1,O,X1,X2)
#endif

#ifndef return_val_if_null_pt
#define return_val_if_null_pt(A1,O,X1)
#endif

#ifndef return_val_if_out_of_bounds
#define return_val_if_out_of_bounds(A1,M,O)
#endif

#ifndef return_val_if_out_of_bounds_pC
#define return_val_if_out_of_bounds_pC(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pi
#define return_val_if_out_of_bounds_pi(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pii
#define return_val_if_out_of_bounds_pii(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_piit
#define return_val_if_out_of_bounds_piit(A1,M,O,X1,X2,X3)
#endif

#ifndef return_val_if_out_of_bounds_pit
#define return_val_if_out_of_bounds_pit(A1,M,O,X1,X2)
#endif

#ifndef return_val_if_out_of_bounds_pp
#define return_val_if_out_of_bounds_pp(A1,M,O,X1)
#endif

#ifndef return_val_if_out_of_bounds_pt
#define return_val_if_out_of_bounds_pt(A1,M,O,X1)
#endif

#ifndef return_val_if_reached
#define return_val_if_reached(O)
#endif

#ifndef return_val_if_reached_pC
#define return_val_if_reached_pC(O,X1)
#endif

#ifndef return_val_if_reached_pi
#define return_val_if_reached_pi(O,X1)
#endif

#ifndef return_val_if_reached_pii
#define return_val_if_reached_pii(O,X1,X2)
#endif

#ifndef return_val_if_reached_piit
#define return_val_if_reached_piit(O,X1,X2,X3)
#endif

#ifndef return_val_if_reached_pit
#define return_val_if_reached_pit(O,X1,X2)
#endif

#ifndef return_val_if_reached_pp
#define return_val_if_reached_pp(O,X1)
#endif

#ifndef return_val_if_reached_pt
#define return_val_if_reached_pt(O,X1)
#endif

#endif /* !defined(ASSERT_IS_BROKEN) */


/* Check that V_CHAR_ALLOW_NULL and ERWIN_THREAD_SAFE are not used at
 * the same time.  It is not possible to do that since the error code is
 * stored in the data structure.  If the pointer to that is NULL, no error
 * codes can be returned. */
#if V_CHAR_ALLOW_NULL && defined(ERWIN_THREAD_SAFE)
#error "Cannot use V_CHAR_ALLOW_NULL and ERWIN_THREAD_SAFE at the same time."
#endif

#ifdef ERWIN_VERBOSE
#  define errstream    ERWIN_ERROR_STREAM
#  define errprint(X)  ((void)(ERWIN_ERROR_PRINT X))
#else
#  define errstream
#  define errprint(X)  ((void)0)
#endif

#define E_MAX_REP        16
#define E_HELP_BUFF_SIZE 256

#ifdef __cplusplus
    /* Theoretically, we *must* use operator new/delete in C++, otherwise, key
     * and value members might not be correctly initialised when stored unboxed.
     *
     * Unfortunately, reallocate is not available (for good reasons, btw), so
     * we use a mixed mode C/C++ memory allocation model.  All the structures
     * that do not need resizing use the native model, all others always use
     * the C model.  For this model, we need OCONSTRUCTOR and ODESTRUCTOR to
     * correctly initialise data structures.
     *
     * NOTE: This model assumes that there are no pointers to yourself in your
     *       data structures!  It is quite instable, it works for Erwin data
     *       structures but might not work for others.  Be extremely careful
     *       and try to always use pointers instead, as they are more stable.
     *
     * The only thing that needs reallocation, btw, is TABLE(self).
     */


#endif

/*
 * #define thing_new(t)               (new t)
 * #define thing_free(x)              delete (x)
 *
 * We must not use new and delete even if we compile this in C++ since
 * the functions that invoke new/delete are the C language
 * allocator/deallocator functions v_char_new/v_char_delete.  If
 * we used new/delete there, these would in turn invoke the C++
 * con-/destructors, which is badly wrong: we would e.g. try to
 * allocate and deallocate the table twice!
 *
 * So: in C, we use thing_new/thing_delete and invoke the C con-/destructors
 *     v_char_init/v_char_destroy manually.
 *     in C++, C++ handles allocation and the C++ con-/destructors invoke
 *     the C level functions _init/_delete.
 */

#if V_CHAR_DYN_ZERO
#    define ZERO(SELF)    ((SELF)->m_zero)
#  define ZEROVAR(SELF) ((SELF)->m_zero)
#else
#    define ZERO(SELF)    OZERO
#    define ZEROVAR(SELF) OZERO
#endif

#if V_CHAR_C_MM

#  define V_CHAR_NEW                    ERWIN_TMALLOC1
#  define V_CHAR_DELETE                 ERWIN_TFREE1

#  if defined(CHAR_IS_PTR) && !CHAR_IS_PTR
#    define V_CHAR_NEW_ARRAY            ERWIN_TMALLOC_ATOMS
#    define V_CHAR_DELETE_ARRAY         ERWIN_TFREE_ATOMS
#ifdef ERWIN_TREALLOC_ATOMS
#    define V_CHAR_RENEW_ARRAY          ERWIN_TREALLOC_ATOMS
#endif /* defined ERWIN_TREALLOC_ATOMS */
#  else
#    define V_CHAR_NEW_ARRAY            ERWIN_TMALLOC_ARRAY
#    define V_CHAR_DELETE_ARRAY         ERWIN_TFREE_ARRAY
#ifdef ERWIN_TREALLOC_ARRAY
#    define V_CHAR_RENEW_ARRAY          ERWIN_TREALLOC_ARRAY
#endif /* defined ERWIN_TREALLOC_ARRAY */
#  endif

#else

#  define V_CHAR_NEW                    ERWIN_THING_NEW1
#  define V_CHAR_DELETE                 ERWIN_THING_DELETE1

#  if defined(CHAR_IS_PTR) && !CHAR_IS_PTR
#    define V_CHAR_NEW_ARRAY            ERWIN_THING_NEW_ATOMS
#    define V_CHAR_DELETE_ARRAY         ERWIN_THING_DELETE_ATOMS
#ifdef ERWIN_THING_RENEW_ATOMS
#    define V_CHAR_RENEW_ARRAY          ERWIN_THING_RENEW_ATOMS
#endif /* defined ERWIN_THING_RENEW_ATOMS */
#  else
#    define V_CHAR_NEW_ARRAY            ERWIN_THING_NEW_ARRAY
#    define V_CHAR_DELETE_ARRAY         ERWIN_THING_DELETE_ARRAY
#ifdef ERWIN_THING_RENEW_ARRAY
#    define V_CHAR_RENEW_ARRAY          ERWIN_THING_RENEW_ARRAY
#endif /* defined ERWIN_THING_RENEW_ARRAY */
#  endif

#endif

#if V_CHAR_LOW_MEM

#  define V_CHAR_SOME_BIGGER_NUMBER(X)  erwin_next_power2_minus1(X)

#  define V_CHAR_ALIGN_TABLESIZE(X) \
             do { (X)= V_CHAR_SOME_BIGGER_NUMBER(X); } while(0)

#  define V_CHAR_GET_TABLESIZE(X) \
             ((v_char_cnt_t)V_CHAR_SOME_BIGGER_NUMBER (CLAMP_MINIMAL((X)->m_nentries+1)))
          /* Ensure that one additional element can always be stored in the
           * vector by using nentries+1.  This is needed for nth_char and as_array. */

#  define V_CHAR_SET_TABLESIZE(X,Y) do {} while(0)

#else

#  define V_CHAR_ALIGN_TABLESIZE(X) do {} while(0)
#  define V_CHAR_GET_TABLESIZE(X)   ((X)->m_tablesize)
#  define V_CHAR_SET_TABLESIZE(X,Y) do { (X)->m_tablesize= (Y); } while(0)

#endif

#define IS_ZERO(X,SELF)   (OEQUAL((X),ZERO(SELF)))
#define ISNT_ZERO(X,SELF) (!IS_ZERO(X,SELF))

#define EXTEND_X(out_u,out_s,data,input_size,unsigned_p)                   \
        ((unsigned_p) ?                                                    \
            (out_u)(ERWIN_CONCAT_TOKEN(ERWIN_UB,input_size))(data)         \
        :   (out_u)(out_s)(ERWIN_CONCAT_TOKEN(ERWIN_SB,input_size))(data))

#define EXTEND(data,size,up)   EXTEND_X(unsigned long,            signed long,     data, size, up)
#define EXTEND_L(data,size,up) EXTEND_X(ERWIN_UNSIGNED_LONG_LONG, ERWIN_LONG_LONG, data, size, up)

/* ******************************************************************************** */

#if V_CHAR_NOMEM_IS_FATAL
#define VECTOR_NOMEM        error_exit_if_reached_pt("Fatal: Memory exhausted.")
#else
#define VECTOR_NOMEM        SET_ERRNO(E_NOMEM)
#endif

#if V_CHAR_OUTOFRANGE_IS_FATAL

#  define v_char_if_outofrange(X)                                \
          error_exit_unless_fail_pt (X, "Fatal: Out Of Range."); \
          if (0)

#  define v_char_if_outofrange_minmax(X,I,N)                             \
          error_exit_unless_fail_ptii (X, "Fatal: Out Of Range.", I, N); \
          if (0)

#  define v_char_if_outofrange_min(X,I)                              \
          error_exit_unless_fail_pti (X, "Fatal: Out Of Range.", I); \
          if (0)

#elif V_CHAR_RANGE_CHECK
#  define v_char_if_outofrange(X)             if (ERWIN_UNLIKELY(X))
#  define v_char_if_outofrange_minmax(X,I,N)  if (ERWIN_UNLIKELY(X))
#  define v_char_if_outofrange_min(X,I)       if (ERWIN_UNLIKELY(X))
#else
#  define v_char_if_outofrange(X)             if (0)
#  define v_char_if_outofrange_minmax(X,I,N)  if (0)
#  define v_char_if_outofrange_min(X,I)       if (0)
#endif


/* ********************************************************************** */

#if !defined(CHAR_UPDATE_POS)

#  define V_CHAR_UPDATE_POS_SET(SELF, I)
#  define V_CHAR_UPDATE_POS_SET_MANY(SELF, A, N)

#  define V_CHAR_UPDATE_POS_RESET(SELF, I)
#  define V_CHAR_UPDATE_POS_RESET_MANY(SELF, A, N)

#  define V_CHAR_UPDATE_POS_SET2(SELF, I1, V1, I2, V2)

#else

#  define V_CHAR_UPDATE_POS_SET(SELF, I)                           \
          do {                                                     \
              CHAR_UPDATE_POS(SELF, &(TABLE(SELF)[I]), I); \
          } while(0)

#  define V_CHAR_UPDATE_POS_RESET(SELF, I)                          \
          do {                                                      \
              CHAR_UPDATE_POS(SELF, &(TABLE(SELF)[I]), -1); \
          } while(0)

#  define V_CHAR_UPDATE_POS_SET_MANY(SELF, I0, IN)        \
          do {                                            \
              v_char_index_t i;                           \
              for (i=(I0); i < (v_char_index_t)(IN); i++) \
                  V_CHAR_UPDATE_POS_SET(SELF, i);         \
          } while(0)

#  define V_CHAR_UPDATE_POS_RESET_MANY(SELF, I0, IN)      \
          do {                                            \
              v_char_index_t i;                           \
              for (i=(I0); i < (v_char_index_t)(IN); i++) \
                  V_CHAR_UPDATE_POS_RESET(SELF, i);       \
          } while(0)

#  if !defined(CHAR_UPDATE_POS2)

#    define V_CHAR_UPDATE_POS_SET2(SELF, I1, V1, I2, V2) \
            do {                                         \
                V_CHAR_UPDATE_POS_SET(SELF, I1);         \
                V_CHAR_UPDATE_POS_SET(SELF, I2);         \
            } while(0)

#  else

#    define V_CHAR_UPDATE_POS_SET2(SELF, I1, V1, I2, V2)                   \
            do {                                                           \
                CHAR_UPDATE_POS2(                                  \
                    SELF, &(TABLE(SELF)[I1]), V1, &(TABLE(SELF)[I2]), V2); \
            } while(0)

#  endif

#endif

#if V_CHAR_POSITION_POINTER && !V_CHAR_MANUAL_POSITION
#    define POS(SELF)             ((SELF)->m_pos)
#    define SET_POS(SELF,N)       do{ (SELF)->m_pos= (N); }while(0)
#    define ADD_POS_AT(SELF,A,N)  do{ if ((A)<POS(SELF)) SET_POS(SELF, POS(SELF) + (N)); }while(0)
#    define SUB_POS_AT(SELF,A,N)  do{ if ((A)<POS(SELF)) SET_POS(SELF, POS(SELF) - (N)); }while(0)
#else
#    define POS(SELF)             0
#    define SET_POS(SELF,N)       do{}while(0)
#    define ADD_POS(SELF,N)       do{}while(0)
#    define SUB_POS(SELF,N)       do{}while(0)
#    define ADD_POS_AT(SELF,A,N)  do{}while(0)
#    define SUB_POS_AT(SELF,A,N)  do{}while(0)
#endif


#define V_CHAR_UPDATE_POS_INSERT(SELF, I)   \
        do {                                \
            ADD_POS_AT(SELF, I, 1);         \
            V_CHAR_UPDATE_POS_SET(SELF, I); \
        }while(0)

#define V_CHAR_UPDATE_POS_INSERT_MANY(SELF, I0, IN)   \
        do {                                          \
            ADD_POS_AT(SELF, I0, (IN)-(I0));          \
            V_CHAR_UPDATE_POS_SET_MANY(SELF, I0, IN); \
        }while(0)

#define V_CHAR_UPDATE_POS_ERASE(SELF, I)      \
        do {                                  \
            V_CHAR_UPDATE_POS_RESET(SELF, I); \
            SUB_POS_AT(SELF, I, 1);           \
        }while(0)

#define V_CHAR_UPDATE_POS_ERASE_MANY(SELF, I0, IN)      \
        do {                                            \
            V_CHAR_UPDATE_POS_RESET_MANY(SELF, I0, IN); \
            SUB_POS_AT(SELF, I0, (IN)-(I0));            \
        }while(0)

/* ******************************************************************************** */

#define V_CHAR_EQ_USE_ARG(X) X != ERWIN_FALSE
#define v_char_overwrite_copy_aux_q(A,B,C,D,E)    v_char_overwrite_copy_aux(A,B,C,D,E)
#define v_char_overwrite_no_copy_aux_q(A,B,C,D,E) v_char_overwrite_no_copy_aux(A,B,C,D,E)
#define v_char_erase_aux_q(A,B,C,D,E)             v_char_erase_aux(A,B,C,D,E)
#define v_char_erase_flags_q(A,B,C,D,E)           v_char_erase_flags(A,B,C,D,E)
#define v_char_erase_if_flags_q(A,B,C,D,E)        v_char_erase_if_flags(A,B,C,D,E)
#define v_char_swap_erase_aux_q(A,B,C,D,E)        v_char_swap_erase_aux(A,B,C,D,E)
#define v_char_swap_erase_flags_q(A,B,C,D,E)      v_char_swap_erase_flags(A,B,C,D,E)
#define v_char_swap_erase_if_flags_q(A,B,C,D,E)   v_char_swap_erase_if_flags(A,B,C,D,E)
#define v_char_chop_flags_q(A,B,C,D)              v_char_chop_flags(A,B,C,D)

#if V_CHAR_DYN_ZERO
#  define v_char_init_internal_q(SE,Z,SI)         v_char_init_internal(SE,Z,SI)
#  define v_char_init_from_q(SE,C,S,A,Z)          v_char_init_from_aux(SE,C,S,A,Z)
#else
#  define v_char_init_internal_q(SE,Z,SI)         v_char_init_internal(SE,SI)
#  define v_char_init_from_q(SE,C,S,A,Z)          v_char_init_from_aux(SE,C,S,A)
#endif

#define V_CHAR_DIGIT_SHR_AND(X,N,B) \
          ((char)(unsigned char)v_char_hex_digit[(((unsigned char)(X)) >> ((B)*(N))) & ((1U<<(B))-1)])

#define V_CHAR_HEX_DIGIT(X,N) V_CHAR_DIGIT_SHR_AND(X,N,4)
#define V_CHAR_OCT_DIGIT(X,N) V_CHAR_DIGIT_SHR_AND(X,N,3)
#define V_CHAR_BIN_DIGIT(X,N) V_CHAR_DIGIT_SHR_AND(X,N,1)


/* ******************************************************************************** */
/* ******************************************************************************** */

static
int v_char_dummy_table;
    /* THREAD SAFE: never written, just a dummy */

#ifdef TYPE_INFO_T

static
TYPE_STRUCT_T(v_char_t)=
    TYPE_STRUCT_BEGIN(v_char_t)
#ifdef  V_CHAR_SUPER_TYPE
        TYPE_SUPER(v_char_t, V_CHAR_SUPER_CLASS),
#endif
        V_CHAR_TYPE_INFO_STD_MEMBERS
        v_char_record_sig       (TYPE_STRUCT_SLOT (v_char_t, int,              m_sig))
        v_char_record_table     (TYPE_STRUCT_SLOT (v_char_t, v_char_content_p, m_table))
        v_char_record_tablesize (TYPE_STRUCT_SLOT (v_char_t, v_char_size_t,    m_tablesize))
        v_char_record_nentries  (TYPE_STRUCT_SLOT (v_char_t, v_char_size_t,    m_nentries))
        v_char_record_pos       (TYPE_STRUCT_SLOT (v_char_t, v_char_index_t,   m_pos))
        v_char_record_errno     (TYPE_STRUCT_SLOT (v_char_t, int,              m_errno))
        v_char_record_zero      (TYPE_STRUCT_SLOT (v_char_t, char,  m_zero))
    TYPE_STRUCT_END
;


TYPE_INFO_T(v_char_size_t)= TYPE_INFO_UINT (v_char_size_t);


TYPE_INFO_T(v_char_cnt_t)= TYPE_INFO_SINT (v_char_cnt_t);


TYPE_INFO_T(v_char_index_t)= TYPE_INFO_SINT (v_char_index_t);


TYPE_INFO_T(v_char_t)= TYPE_INFO_STRUCT (v_char_t, v_char_t);


TYPE_INFO_T(v_char_t_p)= TYPE_INFO_POINTER (v_char_t *, v_char_t);


TYPE_INFO_T(v_char_t_const_p)= TYPE_INFO_POINTER (v_char_t const *, v_char_t);


TYPE_INFO_T(v_char_content)=
    TYPE_INFO_VECTOR (v_char_content, char, v_char_t, m_nentries);


TYPE_INFO_T(v_char_content_p)= TYPE_INFO_POINTER (v_char_content *, v_char_content);

#endif /* defined(TYPE_INFO_T) */

#if !E_GLOBAL_ERRNO
CODE_SECTION(".text.errno")
int v_char_errno
        (v_char_t const *self)
{
    return_val_if_null_or_bad (self, VECTOR_ERR_ASSERTIONFAILED);
    return e_errno;
}

CODE_SECTION(".text.clear_errno")
void v_char_clear_errno
        (v_char_t const *self)
{
    return_if_bad (self);
    SET_ERRNO(E_OK);
}
#endif /* !E_GLOBAL_ERRNO */

ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_internal_q")
E_BOOL v_char_init_internal_q
        (v_char_t *self, char  zero, v_char_cnt_t size)
{
#ifndef NDEBUG
    int err;
    static int tested= 0;
        /* This is not threadsafe, but at worst, each thread makes its own
         * checks instead of the program performing one global test.
         * We're not running into inconsistent states, so that's ok.
         * The 'tested=1' code is at the very end to ensure that task
         * switches don't prevent any test to be performed (there are
         * two if-statements that can come to different opinions about
         * the state of 'tested' in one thread). */
#endif

    SET_ERRNO(E_OK);

    if (ERWIN_UNLIKELY(size < 0 || !VALID_SIZE(size)))
        size= CLAMP_MINIMAL(0);

    V_CHAR_ALIGN_TABLESIZE (size);

    v_char_record_sig (self->m_sig= V_CHAR_SIG);

#if V_CHAR_INLINE_STORE

    if (size > V_CHAR_INLINE_CNT) {
        E_SET_PTR(self->m_table, V_CHAR_NEW_ARRAY (v_char_content, size));

        if (ERWIN_UNLIKELY(self->m_table == NULL)) {
            VECTOR_NOMEM;
            return E_FALSE;
        }

        V_CHAR_SET_TABLESIZE (self, size);
    }
    else {
        V_CHAR_SET_TABLESIZE (self, V_CHAR_INLINE_CNT);
            /* Mark table as non-allocated. */
            /* With LOW_MEM, this is a nop (and thus correct). */
    }

#else /* !INLINE_STORE */

#if V_CHAR_ZERO_SIZE
    if (size == 0)
        E_SET_PTR(self->m_table, V_CHAR_DUMMY_TABLE);
    else
        E_SET_PTR(self->m_table, V_CHAR_NEW_ARRAY (v_char_content, size));
#else /* !ZERO_SIZE */
    if (size <= 0)
        size= 1;
    E_SET_PTR(self->m_table, V_CHAR_NEW_ARRAY (v_char_content, size));
#endif

    if (ERWIN_UNLIKELY(TABLE(self) == NULL)) {
        VECTOR_NOMEM;
        return E_FALSE;
    }

    V_CHAR_SET_TABLESIZE (self, size);

#endif /* !INLINE_STORE */


#if defined(OCONSTRUCTOR) && V_CHAR_C_MM
    /* C model for table */
    {
        v_char_cnt_t i;
        for (i=0; i < size; i++)
            OCONSTRUCTOR (TABLE(self)[i]);
    }
#endif


#if V_CHAR_DYN_ZERO
#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        return0_if_crash_ppt (
            (void)OCOPY (zero, NULL),
            self,
            "OCOPY crashes for zero element when ERR is NULL.");
    }
#endif

    E_SET_VALUE (self->m_zero, OCOPY (zero, NULL));
#endif /* DYN_ZERO */

    self->m_nentries= 0;
    SET_POS (self, 0);

#ifndef NDEBUG
    if (ERWIN_UNLIKELY(!tested)) {
        /* Check copying (typical bugs). */
        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), &err),
            self,
            "OCOPY crashes for zero element.");

        return0_if_fail_ppt  (
            OEQUAL (OCOPY (ZERO (self), &err), ZERO (self)),
            self,
            "OCOPY must not copy zero element.");

        return0_if_crash_ppt (
            (void)OCOPY (ZERO (self), NULL),
            self,
            "OCOPY crashes when ERR is NULL.");

        return0_if_crash_ppt (
            OFREE (OCOPY (ZERO (self), &err)),
            self,
            "OFREE crashes for zero element.");

        err= 0;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 0,
            self,
            "OCOPY seems to set error flag for zero element",
            err);

        err= 17;
        (void)OCOPY (ZERO (self), &err);
        return0_if_fail_ppti (err == 17,
            self,
            "OCOPY seems to overwrite error flag for zero element (the previous value of 17 was destroyed)",
            err);

        return0_if_fail_ppii (sizeof(v_char_size_t) <= sizeof(v_char_cnt_t),
           self,
           sizeof(v_char_size_t), sizeof(v_char_cnt_t));

        return0_if_fail_ppii (sizeof(v_char_index_t) == sizeof(v_char_cnt_t),
           self,
           sizeof(v_char_index_t), sizeof(v_char_cnt_t));

        tested= 1;
    }
#endif

    return E_TRUE;
}

CODE_SECTION(".text.init")
int v_char_init
        (v_char_t *self)
{
    v_char_init_internal_q (self, OZERO, GET_INITIAL_SIZE);
    return e_errno;
}

CODE_SECTION(".text.init_with_initial_size")
int v_char_init_with_initial_size
        (v_char_t *self, v_char_cnt_t size)
{
    v_char_init_internal_q (self, OZERO, size);
    return e_errno;
}

#if V_CHAR_DYN_ZERO
CODE_SECTION(".text.init_with_zero_and_initial_size")
int v_char_init_with_zero_and_initial_size
        (v_char_t *self, char  zero, v_char_cnt_t size)
{
    v_char_init_internal_q (self, zero, size);
    return e_errno;
}
#endif /* V_CHAR_DYN_ZERO */

CODE_SECTION(".text.delete_array")
void v_char_delete_array
        (v_char_element_ptr_t array)
{
    /* No special case for V_CHAR_INLINE_STORE, because those arrays
     * allowed to be deleted with this functions will be assured to
     * be allocated on the heap. */

#if V_CHAR_ZERO_SIZE
    if (array == V_CHAR_DUMMY_TABLE)
        return;
#endif

    V_CHAR_DELETE_ARRAY (array);
}

CODE_SECTION(".text.detach")
void v_char_detach
        (v_char_t *self)
{
    return_if_null2i_or_bad (self);

    V_CHAR_UPDATE_POS_ERASE_MANY(self, 0, self->m_nentries);
    SET_POS (self, 0); /* really reset to 0 */

    self->m_nentries= 0;

    /* C model for table */
#if V_CHAR_INLINE_STORE
    E_SET_PTR (self->m_table, NULL); /* just to be sure to overwrite a dangling pointer */
    V_CHAR_SET_TABLESIZE (self, V_CHAR_INLINE_CNT);
#elif V_CHAR_ZERO_SIZE
    E_SET_PTR (self->m_table, V_CHAR_DUMMY_TABLE);
    V_CHAR_SET_TABLESIZE (self, 0);
#else
    E_SET_PTR (self->m_table, V_CHAR_NEW_ARRAY (v_char_content, 1));
    V_CHAR_SET_TABLESIZE (self, 1);

#if defined(OCONSTRUCTOR) && V_CHAR_C_MM
    OCONSTRUCTOR (TABLE(self)[0]);
#endif

#endif
}

CODE_SECTION(".text.detach_as_is")
void v_char_detach_as_is
        (v_char_t *self)
{
    return_if_null2i_or_bad (self);

    self->m_nentries= 0;
    SET_POS (self, 0);

    /* C model for table */
#if V_CHAR_INLINE_STORE
    E_SET_PTR (self->m_table, NULL); /* just to be sure to overwrite a dangling pointer */
    V_CHAR_SET_TABLESIZE (self, V_CHAR_INLINE_CNT);
#elif V_CHAR_ZERO_SIZE
    E_SET_PTR(self->m_table, V_CHAR_DUMMY_TABLE);
    V_CHAR_SET_TABLESIZE (self, 0);
#else
    E_SET_PTR(self->m_table, V_CHAR_NEW_ARRAY (v_char_content, 1));
    V_CHAR_SET_TABLESIZE (self, 1);

#if defined(OCONSTRUCTOR) && V_CHAR_C_MM
    OCONSTRUCTOR (TABLE(self)[0]);
#endif

#endif
}


#if V_CHAR_DYN_ZERO
CODE_SECTION(".text.new_with_zero_and_initial_size")
v_char_t * v_char_new_with_zero_and_initial_size
        (char  zero, v_char_cnt_t size)
{
    v_char_t *self;
    E_SET_PTR(self, V_CHAR_NEW (v_char_t));
    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(v_char_init_internal_q (self, zero, size)))
       return self;

    V_CHAR_DELETE (self, v_char_t);
    return NULL;
}

CODE_SECTION(".text.new_with_zero")
v_char_t * v_char_new_with_zero
        (char  zero)
{
    return v_char_new_with_zero_and_initial_size (zero, GET_INITIAL_SIZE);
}
#endif /* V_CHAR_DYN_ZERO */


#if V_CHAR_CONSTANT_ZERO
#  define v_char_new_with_zero_and_initial_size(Z,S) v_char_new_with_initial_size(S)
#  define v_char_new_with_zero(Z)                    v_char_new()
#endif


CODE_SECTION(".text.new_with_initial_size")
v_char_t * v_char_new_with_initial_size
        (v_char_cnt_t size)
{
    v_char_t *self;
    E_SET_PTR(self, V_CHAR_NEW (v_char_t));

    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(v_char_init_internal_q (self, OZERO, size)))
        return self;

    V_CHAR_DELETE (self, v_char_t);
    return NULL;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_from_q")
E_BOOL v_char_init_from_q
        (
    v_char_t *self, char *contents, v_char_cnt_t nentries, v_char_cnt_t allocsize, char  zero)
{
    if (allocsize < nentries)
        allocsize= nentries;

    /* We don't align the allocsize here since this is done in v_char_init_internal_q,
     * and we do only store it here, which needs no alignment (since when
     * alignment is done, it is not stored). */

    if (contents == NULL || allocsize == 0)
        return v_char_init_internal_q (self, OZERO, allocsize);

    v_char_record_sig (self->m_sig= V_CHAR_SIG);
    SET_POS (self, 0);

    return_val_if_fail_ppi (VALID_SIZE (nentries), E_FALSE, self, nentries);
    self->m_nentries=  nentries;
    V_CHAR_SET_TABLESIZE (self, allocsize);

#if V_CHAR_INLINE_STORE
    if (HAS_HEAP_TABLE(self))
        E_SET_PTR(self->m_table, contents);
    else {
        v_char_cnt_t i;
        for (i=0; i < nentries; i++)
            E_SET_VALUE (TABLE(self)[i], contents[i]);
    }
#else
    E_SET_PTR(TABLE(self), contents);
#endif


#if V_CHAR_DYN_ZERO
    E_SET_VALUE (self->m_zero, OCOPY (zero, NULL));
#endif
    SET_ERRNO(E_OK);

    V_CHAR_UPDATE_POS_INSERT_MANY(self, 0, nentries);

    return E_TRUE;
}

CODE_SECTION(".text.new_from_raw")
v_char_t * v_char_new_from_raw
        (char *contents, v_char_cnt_t nentries, v_char_cnt_t allocsize)
{
    v_char_t *self;
    E_SET_PTR(self, V_CHAR_NEW (v_char_t));
    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

    if (ERWIN_LIKELY(v_char_init_from_q (self, contents, nentries, allocsize, OZERO)))
        return self;

    V_CHAR_DELETE (self, v_char_t);
    return NULL;
}

#if V_CHAR_DYN_ZERO
CODE_SECTION(".text.new_from_raw_with_zero")
v_char_t * v_char_new_from_raw_with_zero
        (char *contents, v_char_cnt_t nentries, v_char_cnt_t allocsize, char  zero)
{
    v_char_t *self;
    E_SET_PTR(self, V_CHAR_NEW (v_char_t));

    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }
    
    if (ERWIN_LIKELY(v_char_init_from_q (self, contents, nentries, allocsize, zero)))
        return self;

    V_CHAR_DELETE(self, v_char_t);
    return NULL;
}
#endif /* V_CHAR_DYN_ZERO */

CODE_SECTION(".text.new_from_vector")
v_char_t * v_char_new_from_vector
        (v_char_t *other)
{
    v_char_t *self;
    v_char_size_t ts;

    if (other == NULL)
        return v_char_new ();

    E_SET_PTR(self, V_CHAR_NEW (v_char_t));
    if (ERWIN_UNLIKELY(self == NULL)) {
        VECTOR_NOMEM;
        return NULL;
    }

#if V_CHAR_LOW_MEM       
    ts= other->m_nentries;   /* will be aligned later */
#else
    ts= other->m_tablesize;
#endif
    if (ERWIN_LIKELY(
            v_char_init_from_q (self,
                TABLE(other),
                other->m_nentries,
                ts,
                other->m_zero)))
    {
        v_char_detach_as_is (other);
            /* The position has not changed: it was exported from vector to vector,
             * so use _as_is version */
        return self;
    }

    V_CHAR_DELETE (self, v_char_t);
    return NULL;
}

CODE_SECTION(".text.new")
v_char_t * v_char_new
        (void)
{
    return v_char_new_with_initial_size (GET_INITIAL_SIZE);
}

CODE_SECTION(".text.zero")
o_type_result_t v_char_zero
        (v_char_t const *self)
{
    (void)self; /*unused*/

    return ZERO(self);
}

/* #define COPY_SIZE(X) (X->m_tablesize) */
        /* This is a bad idea! (E.g. if you have a non-shrinking global variable
         * as a buffer which you copy from time to time, the copies will always
         * allocate as much memory as the longest previous vector.  That's too
         * bad. */

/* #define COPY_SIZE(X) (X->m_nentries) */
        /* According to a good heuristics, as_array() will be called next, so
         * we'll use the following version that adds one: */

#define COPY_SIZE(X) ((X)->m_nentries+1)
        /* I hope this is the best solution */

CODE_SECTION(".text.copy")
v_char_t * v_char_copy
        (v_char_t const* self)
{
    v_char_t *copy;
    if (self == NULL) { /* copy() *must* be NULL safe!  Regardless of V_CHAR_ALLOW_NULL. */
        SET_ERRNO(E_OK);
        return NULL;
    }

    return0_if_null2i_or_bad (self);

    E_SET_PTR(copy, v_char_new_with_zero_and_initial_size (ZERO(self), COPY_SIZE (self)));
    v_char_insert_vector (copy, 0, self);

    return copy;
}

CODE_SECTION(".text.copy_err")
v_char_t * v_char_copy_err
        (v_char_t const* self, int *err)
{
    v_char_t *copy;
    E_SET_PTR(copy, v_char_copy (self));

    if (ERWIN_UNLIKELY(err != NULL && e_errno != E_OK))
        *err= 1;

    return copy;
}

CODE_SECTION(".text.table_size")
v_char_cnt_t v_char_table_size
        (v_char_t const *self)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return V_CHAR_GET_TABLESIZE (self);
}

CODE_SECTION(".text.nentries")
v_char_cnt_t v_char_nentries
        (v_char_t const *self)
{                 
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    return0_if_null (self);
    return self->m_nentries;
}

CODE_SECTION(".text.empty")
E_BOOL v_char_empty
        (v_char_t const *self)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return E_TRUE;
#endif
    return1_if_null (self);
    return ERWIN_TO_BOOL (self->m_nentries == 0);
}

ERWIN_STATIC_INLINE_SPEED
CODE_SECTION(".text.clear_no_resize_aux")
void v_char_clear_no_resize_aux
        (v_char_t *self, v_char_cnt_t new_size)
{
#if OFREE_PROVIDED
    v_char_size_t i;
#endif

    (void)self;     /*unused*/
    (void)new_size; /*unused*/

    V_CHAR_UPDATE_POS_ERASE_MANY (self, new_size, self->m_nentries);

#if OFREE_PROVIDED
    for (i= new_size; i < self->m_nentries; i++) {
        OFREE (TABLE(self)[i]);
    }
#endif
}

CODE_SECTION(".text.xchg")
void v_char_xchg
        (v_char_t *self, v_char_t *other)
{
    v_char_record_table     (ERWIN_XCHG (v_char_content_p, self->m_table,     other->m_table));
    v_char_record_tablesize (ERWIN_XCHG (v_char_size_t,    self->m_tablesize, other->m_tablesize));
    v_char_record_nentries  (ERWIN_XCHG (v_char_size_t,    self->m_nentries,  other->m_nentries));
    v_char_record_pos       (ERWIN_XCHG (v_char_index_t,   self->m_pos,       other->m_pos));
    v_char_record_errno     (ERWIN_XCHG (int,              self->m_errno,     other->m_errno));
    v_char_record_zero      (ERWIN_XCHG (char,         self->m_zero,      other->m_zero));
}

CODE_SECTION(".text.destroy")
void v_char_destroy
        (v_char_t *self)
{
    if (self == NULL ||
        (TABLE(self) == NULL && self->m_nentries == 0))
        return;
        /* This is all a bit obscure.  In a certain test program, gcc seems to `forget'(?)
         * a constructor call so that operator= is invoked with TABLE(self) and
         * self->m_nentries==0, which is not allowed.  Therefore, we make _destroy() robust
         * against this case which is the first function invoked in operator=.
         *
         * Further, self == NULL should be ok anyway. */

    return_if_null_pp (TABLE(self), self);

    v_char_clear_no_resize_aux (self, 0);

    {
        /* C model for table */
#if defined(ODESTRUCTOR) && V_CHAR_C_MM
        v_char_cnt_t i;
        v_char_cnt_t ts= V_CHAR_GET_TABLESIZE (self);
        for (i=0; i < ts; i++) {
            ODESTRUCTOR (TABLE(self)[i]);
        }
#endif

#if V_CHAR_HAVE_SIG
        self->m_sig= 0;
#endif
        if (HAS_HEAP_TABLE(self))
            V_CHAR_DELETE_ARRAY (TABLE(self));
    }
}

CODE_SECTION(".text.delete")
void v_char_delete
        (v_char_t *self)
{
    if (self == NULL) /* It must handle NULL to be nestable! */
        return;
    return_if_null_or_bad (self);
    v_char_destroy (self);
    V_CHAR_DELETE (self, v_char_t);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.reallocate")
E_BOOL v_char_reallocate
        (v_char_t *self, v_char_cnt_t newtablesize)
/* This is very ugly.  I know.
 * NOTE: newtablesize must be aligned (for LOW_MEM)
 */
{
    v_char_cnt_t oldtablesize=      V_CHAR_GET_TABLESIZE (self);
    E_BOOL       old_is_heap_table= HAS_HEAP_TABLE(self);
    char    *oldtable;
    char    *newtable;

    E_SET_PTR(newtable, V_CHAR_DUMMY_TABLE);
    E_SET_PTR(oldtable, TABLE(self));

    (void)oldtablesize; /*unused*/

    if (ERWIN_UNLIKELY(!VALID_SIZE(newtablesize))) {
        SET_ERRNO(E_TOOLARGE);
        return E_FALSE;
    }

    /* C model for table */
#if defined(ODESTRUCTOR) && V_CHAR_C_MM
    {
        v_char_cnt_t i;
        for (i=newtablesize; i < oldtablesize; i++)
            ODESTRUCTOR (oldtable[i]);
    }
#endif

#if V_CHAR_INLINE_STORE
    /* ** INLINE STORE ************************************************** */

    if (newtablesize <= V_CHAR_INLINE_CNT) {
        /* inline,heap > inline */
        newtablesize= V_CHAR_INLINE_CNT; /* this is the minimum */

        V_CHAR_SET_TABLESIZE (self, V_CHAR_INLINE_CNT);
            /* mark missing table: this is no-op for LOW_MEM */

        E_SET_PTR(newtable, INLINE_TABLE(self));

        if (old_is_heap_table) {
            /* heap > inline */
#ifdef V_CHAR_RENEW_ARRAY
            /* If RENEW_ARRAY is not defined, copying is done later anyway. */
            {
                v_char_cnt_t i;
                for (i=0; i < oldtablesize && i < newtablesize; i++)
                    E_SET_VALUE (newtable[i], oldtable[i]);
            }
#endif
            V_CHAR_DELETE_ARRAY (oldtable);
            old_is_heap_table= 0; /* prevent double delete when RENEW_ARRAY exists (see below) */
        }
    }
    else
    if (old_is_heap_table) {
        /* heap > heap: standard operation */
#ifdef V_CHAR_RENEW_ARRAY
        E_SET_PTR(newtable,
            V_CHAR_RENEW_ARRAY (oldtable, v_char_content, newtablesize, oldtablesize));
        old_is_heap_table= 0; /* reallocated => invalidated */
#else
        E_SET_PTR(newtable,
            V_CHAR_NEW_ARRAY (v_char_content, newtablesize));
#endif

        V_CHAR_SET_TABLESIZE (self, newtablesize);
        E_SET_PTR(self->m_table, newtable);
    }
    else {
        /* inline > heap */
        E_SET_PTR(newtable,
            V_CHAR_NEW_ARRAY (v_char_content, newtablesize));

#ifdef V_CHAR_RENEW_ARRAY
        /* Copy manually from old inline store to now heap store. */
        /* If RENEW_ARRAY is not defined, copying is done later anyway. */
        {
            v_char_cnt_t i;
            for (i=0; i < oldtablesize && i < newtablesize; i++)
                E_SET_VALUE (newtable[i], oldtable[i]);
        }
#endif

        V_CHAR_SET_TABLESIZE (self, newtablesize);
        E_SET_PTR(self->m_table, newtable);
    }

#elif V_CHAR_ZERO_SIZE
    /* ** ZERO SIZE ***************************************************** */

    if (newtablesize == 0) {
        if (old_is_heap_table) {
            V_CHAR_DELETE_ARRAY (oldtable);
            old_is_heap_table= 0; /* prevent double delete when RENEW_ARRAY exists (see below) */
        }
        E_SET_PTR(newtable, V_CHAR_DUMMY_TABLE);
    }
    else
    if (old_is_heap_table) {
#ifdef V_CHAR_RENEW_ARRAY
        E_SET_PTR(newtable,
            V_CHAR_RENEW_ARRAY (oldtable, v_char_content, newtablesize, oldtablesize));
        old_is_heap_table= 0;
#else
        E_SET_PTR(newtable, V_CHAR_NEW_ARRAY (v_char_content, newtablesize));
#endif
    }
    else
        E_SET_PTR(newtable, V_CHAR_NEW_ARRAY (v_char_content, newtablesize));

    V_CHAR_SET_TABLESIZE (self, newtablesize);
    E_SET_PTR(self->m_table, newtable);

#else /* !ZERO_SIZE */
    /* ** NORMAL MODE *************************************************** */

    return0_if_fail_ppi (newtablesize > 0, self, newtablesize);

    /* FIXME: If the type cannot be realloced (like almost everything),
     *        then use the real C++ method of reallocation: new array,
     *        copy old into new, throw old one away.
     *
     * NOTE: Erwin structures themselves are NOT capable of being copied
     *       like this!  So this is urgent!
     */
#ifdef V_CHAR_RENEW_ARRAY
    E_SET_PTR(newtable,
        V_CHAR_RENEW_ARRAY (oldtable, v_char_content, newtablesize, oldtablesize));
    old_is_heap_table= 0;
#else
    E_SET_PTR(newtable, V_CHAR_NEW_ARRAY (v_char_content, newtablesize));
#endif

    V_CHAR_SET_TABLESIZE (self, newtablesize);
    E_SET_PTR(self->m_table, newtable);

#endif /* !ZERO_SIZE */

    /* ** COMMON CODE: old and new tables are now allocated *************** */

    if (newtable == NULL) {
#if defined(OCONSTRUCTOR) && V_CHAR_C_MM
        {   /* Re-initialise destroyed elements. Unlikely to be performed, though, as
             * out-of-memory errors are expected when growing only. */
            v_char_cnt_t i;
            for (i=newtablesize; i < oldtablesize; i++)
                OCONSTRUCTOR (oldtable[i]);
        }
#endif
        VECTOR_NOMEM;
        return E_FALSE;
    }

#ifndef V_CHAR_RENEW_ARRAY
    /* If we don't have a reallocation, we have to copy the elements manually
     * into the new vector. */
    {
        v_char_cnt_t i;
        for (i=0; i < oldtablesize && i < newtablesize; i++)
            E_SET_VALUE (newtable[i], oldtable[i]);
    }
#endif

#if defined(OCONSTRUCTOR) && V_CHAR_C_MM
    {
        v_char_cnt_t i;
        for (i=self->oldtablesize; i < newtablesize; i++)
            OCONSTRUCTOR (newtable[i]);
    }
#endif

#ifndef V_CHAR_RENEW_ARRAY
    /* If there is no realloc, throw away old vector now, unless it is already gone. */
    if (old_is_heap_table)
        V_CHAR_DELETE_ARRAY (oldtable);
#endif

    return E_TRUE;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.ensure_size_sub_aux_force")
E_BOOL v_char_ensure_size_sub_aux_force
        (v_char_t *self, v_char_cnt_t newsize)
  /* may leave elements uninitialized! */
  /* ensures that SIZE many elements go into THEM without problem. */
{
    v_char_cnt_t tablesize= V_CHAR_GET_TABLESIZE (self);

#if V_CHAR_LOW_MEM
    v_char_cnt_t newtablesize= V_CHAR_SOME_BIGGER_NUMBER (CLAMP_MINIMAL(newsize));
    if (ERWIN_UNLIKELY(tablesize != newtablesize))
        return v_char_reallocate (self, newtablesize);
#else
    /* Does not shrink below size 2 unless newsize == 0. */
    if (ERWIN_UNLIKELY(NEED_SHRINK(newsize, tablesize))) {
        do {
            tablesize>>=1;
#if V_CHAR_ZERO_SIZE || V_CHAR_INLINE_STORE
            if (tablesize == 0)
                break;
#endif
        } while (ERWIN_UNLIKELY(NEED_SHRINK(newsize, tablesize)));
        return0_if_fail (newsize <= tablesize);
        return v_char_reallocate (self, ADJUST_SHRUNK(tablesize));
    }
#endif
    return E_TRUE;
}

#if V_CHAR_AUTO_SHRINK
#  define v_char_ensure_size_sub_aux(A,B) v_char_ensure_size_sub_aux_force(A,B)
#else
#  define v_char_ensure_size_sub_aux(A,B) E_TRUE
#endif


ERWIN_STATIC_INLINE
CODE_SECTION(".text.ensure_size_add_aux")
E_BOOL v_char_ensure_size_add_aux
        (v_char_t *self, v_char_cnt_t newsize)
  /* May leave elements uninitialized! */
  /* Ensures that SIZE many elements go into THEM without problem. */
  /* The 'newsize' is assumed to be the new number of nentries to be set soon,
   * so for LOW_MEM, this *always* resizes, i.e., also shrinks, if the
   * tablesize would be different (because with LOW_MEM, the tablesize is
   * derived from the size).  So for LOW_MEM, you might have special cases
   * if you only want to resize the table without resetting the number of
   * elements.
   */
{
    v_char_cnt_t  tablesize= V_CHAR_GET_TABLESIZE (self);

#if V_CHAR_LOW_MEM
    v_char_cnt_t  newtablesize= V_CHAR_SOME_BIGGER_NUMBER (CLAMP_MINIMAL(newsize));
    if (ERWIN_UNLIKELY(tablesize != newtablesize))
        return v_char_reallocate (self, newtablesize);

#else /* !V_CHAR_LOW_MEM */
    v_char_size_t tn;
    if (ERWIN_UNLIKELY(NEED_GROW(newsize, tablesize))) {
        if (ERWIN_UNLIKELY(!VALID_SIZE(newsize))) {
            SET_ERRNO(E_TOOLARGE);
            return E_FALSE;
        }

#if V_CHAR_ZERO_SIZE || V_CHAR_INLINE_STORE
        if (tablesize == 0) {
            tablesize= 1;
            goto rein;
        }
#endif
        return0_if_fail_ppi (tablesize > 0, self, tablesize);
        do {
            tn= tablesize << 1;

#if !V_CHAR_LOW_MEM && V_CHAR_SIZE_INDEX_DIFF
            /* cull at MAX(v_char_size_t)-1 */
            if (tn < tablesize && tn != ((v_char_size_t)-1))
                tn= ((v_char_size_t)-1);
#endif

            if (ERWIN_UNLIKELY(!VALID_SIZE_GT(tablesize, (v_char_cnt_t)tn))) {
                SET_ERRNO(E_TOOLARGE);
                return E_FALSE;
            }

            tablesize= tn;
#if V_CHAR_ZERO_SIZE || V_CHAR_INLINE_STORE
        rein:;
#endif
        } while (ERWIN_UNLIKELY(NEED_GROW(newsize, tablesize)));
        /* in LOW_MEM mode, tablesize is aligned since we only mul by 2 and assign 1. */
        return v_char_reallocate(self, ADJUST_GROWN(tablesize));
    }

#endif /* !V_CHAR_LOW_MEM */
    return E_TRUE;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.ensure_size_add_plus")
E_BOOL v_char_ensure_size_add_plus
        (v_char_t *self, v_char_cnt_t newsize, v_char_cnt_t add)
{
   if (ERWIN_UNLIKELY(!VALID_SIZE_PLUS (newsize, add))) {
       SET_ERRNO(E_TOOLARGE);
       return E_FALSE;
   }
   return v_char_ensure_size_add_aux (self, newsize + add);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.init_tail")
void v_char_init_tail
        (v_char_t *self, v_char_cnt_t newsize)
{
    v_char_cnt_t ii;
    for (ii= self->m_nentries; ii < newsize; ii++)
        E_SET_VALUE (TABLE(self)[ii], ZEROVAR(self));
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.grow_plus")
E_BOOL v_char_grow_plus
        (v_char_t *self, v_char_cnt_t oldsize, v_char_cnt_t plus)
{
    v_char_cnt_t newsize= oldsize + plus;
    if (ERWIN_UNLIKELY(newsize > (v_char_cnt_t)self->m_nentries)) {
        if (ERWIN_UNLIKELY(!v_char_ensure_size_add_plus (self, oldsize, plus)))
            return E_FALSE;

        v_char_init_tail (self, newsize);

        return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
        self->m_nentries= newsize;
    }
    return E_TRUE;
}

CODE_SECTION(".text.ensure_size")
int v_char_ensure_size
        (v_char_t *self, v_char_cnt_t newsize)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    v_char_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (ERWIN_UNLIKELY(newsize > (v_char_cnt_t)self->m_nentries)) {
        if (ERWIN_LIKELY(!v_char_ensure_size_add_aux (self, newsize)))
            return e_errno;

        v_char_init_tail (self, newsize);

        return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
        self->m_nentries= newsize;
    }
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.ensure_size_with")
int v_char_ensure_size_with
        (v_char_t *self, v_char_cnt_t newsize, char  elem)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    v_char_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_OUTOFRANGE);

    if (ERWIN_UNLIKELY(newsize > (v_char_cnt_t)self->m_nentries))
        return v_char_make_gap_with (self, self->m_nentries, elem, newsize - self->m_nentries);

    return PASS_ERRNO(E_OK);
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.setsize_noinit_add")
E_BOOL v_char_setsize_noinit_add
        (v_char_t *self, v_char_cnt_t newsize)
{
    if (ERWIN_LIKELY(!v_char_ensure_size_add_aux (self, newsize)))
        return E_FALSE;
    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return E_TRUE;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.setsize_noinit_sub")
E_BOOL v_char_setsize_noinit_sub
        (v_char_t *self, v_char_cnt_t newsize, E_BOOL resize)
{
    if (resize) {
        if (ERWIN_UNLIKELY(!v_char_ensure_size_sub_aux (self, newsize)))
            return E_FALSE;
    }
    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return E_TRUE;
}

CODE_SECTION(".text.clear")
void v_char_clear
        (v_char_t *self)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    v_char_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
    v_char_ensure_size_sub_aux (self, 0);
}

CODE_SECTION(".text.clear_keep")
void v_char_clear_keep
        (v_char_t *self, v_char_cnt_t min)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    v_char_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
    v_char_ensure_size_sub_aux (self, min);
}

CODE_SECTION(".text.clear_flags")
void v_char_clear_flags
        (v_char_t *self, E_BOOL resize, E_BOOL del)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    if (del)
        v_char_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
    if (resize) v_char_ensure_size_sub_aux (self, 0);
}

CODE_SECTION(".text.clear_no_resize")
void v_char_clear_no_resize
        (v_char_t *self)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    v_char_clear_no_resize_aux (self, 0);
    self->m_nentries= 0;
    SET_POS (self, 0);
}

CODE_SECTION(".text.modify")
o_type_var_t v_char_modify
        (v_char_t *self, v_char_index_t key, char  value)
{
    int copyerror= E_FALSE;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#if V_CHAR_ALLOW_OUTOFRANGE

    v_char_if_outofrange_min (key < 0, key) {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return ZEROVAR(self), "index out of range (1)", key);
    }

    if (ERWIN_UNLIKELY(!v_char_grow_plus (self, key, 1)))
        return ZERO(self);

#else
    v_char_if_outofrange_minmax (
        key < 0 || key >= (v_char_cnt_t)self->m_nentries, key, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return ZEROVAR(self), "index out of range (1)",
            key, self->m_nentries);
    }
#endif

    return_val_if_null_pp (TABLE(self), ZEROVAR(self), self);

    {
        char valuecopy;
        E_SET_VALUE(valuecopy, OCOPY (value, &copyerror));

        if (ERWIN_LIKELY(copyerror == E_FALSE)) {
            char result;

            V_CHAR_UPDATE_POS_RESET (self, key);
            E_SET_VALUE (result, TABLE(self)[key]);

            E_SET_VALUE (TABLE(self)[key], valuecopy);
            V_CHAR_UPDATE_POS_SET (self, key);

            SET_ERRNO(E_OK);
            return result;
        }
        else {
            VECTOR_NOMEM;
            return ZEROVAR(self);
        }
    }
}

CODE_SECTION(".text.set")
int v_char_set
        (v_char_t *self, v_char_index_t key, char  value)
/* table==NULL is ok */
{
    int copyerror= E_FALSE;

    return_val_if_null_or_bad (self, ASSERTION_FAILED);

#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (key < 0, key)
    {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return e_errno, "index out of range", key);
    }
    if (ERWIN_UNLIKELY(!v_char_grow_plus (self, key, 1)))
        return e_errno;
#else
    v_char_if_outofrange_minmax (
        key < 0 || key >= (v_char_cnt_t)self->m_nentries, key, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return e_errno, "index out of range",
            key, self->m_nentries);
    }
#endif

    return_val_if_null_pp (TABLE(self), ASSERTION_FAILED, self);

    {
        char valuecopy;
        E_SET_VALUE (valuecopy, OCOPY (value, &copyerror));

        if (ERWIN_LIKELY(copyerror == E_FALSE)) {
            V_CHAR_UPDATE_POS_RESET (self, key);
            OFREE (TABLE(self)[key]);

            E_SET_VALUE (TABLE(self)[key], valuecopy);
            V_CHAR_UPDATE_POS_SET (self, key);

            return PASS_ERRNO(E_OK);
        }
        else {
            VECTOR_NOMEM;
            return e_errno;
        }
   }
}

CODE_SECTION(".text.swap")
void v_char_swap
        (v_char_t *self, v_char_index_t key1, v_char_index_t key2)
/* table==NULL is ok */
{
    char help;

    return_if_null_or_bad (self);

#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (key1 < 0, key1) {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return, "index out of range", key1);
    }
    v_char_if_outofrange_min (key2 < 0, key2) {
        FATAL_ERROR_MIN (E_OUTOFRANGE, return, "index out of range", key2);
    }

    if (ERWIN_UNLIKELY(!v_char_grow_plus (self, key1, 1) || !v_char_grow_plus (self, key2, 1)))
        return;
#else
    v_char_if_outofrange_minmax (
        key1 < 0 || key1 >= (v_char_cnt_t)self->m_nentries, key1, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return, "index out of range",
            key1, self->m_nentries);
    }
    v_char_if_outofrange_minmax (
        key2 < 0 || key2 >= (v_char_cnt_t)self->m_nentries, key2, self->m_nentries)
    {
        FATAL_ERROR (E_OUTOFRANGE, return, "index out of range",
            key2, self->m_nentries);
    }
#endif

    return_if_null_pp (TABLE(self), self);

    E_SET_VALUE (help, TABLE(self)[key1]);
    E_SET_VALUE (TABLE(self)[key1], TABLE(self)[key2]);
    E_SET_VALUE (TABLE(self)[key2], help);
    V_CHAR_UPDATE_POS_SET2 (self, key1, key1, key2, key2);
}

CODE_SECTION(".text.reverse")
void v_char_reverse
        (v_char_t *self)
{
    char help;
    v_char_index_t i;
    v_char_index_t n1;
    v_char_index_t n_2;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    return_if_null_or_bad (self);

    n1=  self->m_nentries - 1;
    n_2= self->m_nentries / 2;
    for (i=0; i < n_2; i++) {
        E_SET_VALUE (help, TABLE(self)[i]);
        E_SET_VALUE (TABLE(self)[i], TABLE(self)[n1-i]);
        E_SET_VALUE (TABLE(self)[n1-i], help);
        V_CHAR_UPDATE_POS_SET2 (self, i, i, n1-i, n1-i);
    }
}

CODE_SECTION(".text.init_iterator")
void v_char_init_iterator
        (v_char_t const *self, v_char_index_t *key)
{
    (void)self; /*unused*/
    return_if_null_pp (key, self);

    *key= -1; /* if you change this, change the C++ forall macros as well! */
}

CODE_SECTION(".text.next_iteration")
E_BOOL v_char_next_iteration
        (v_char_t const *self, v_char_index_t *key, char *valuep)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return0_if_null_or_bad (self);
    return0_if_null3_pp3 (TABLE(self), key, valuep, self, key, valuep);

    (*key)++;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (v_char_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_VALUE (*valuep, TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr")
E_BOOL v_char_next_iteration_ptr
        (v_char_t *self, v_char_index_t *key, char **valuepp)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return0_if_null_or_bad (self);
    return0_if_null3_pp3 (TABLE(self), key, valuepp, self, key, valuepp);

    (*key)++;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (v_char_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_PTR(*valuepp, &TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr_const")
E_BOOL v_char_next_iteration_ptr_const
        (v_char_t const *self, v_char_index_t *key, char const **valuepp)
{
    return v_char_next_iteration_ptr((v_char_t *)self, key, (char **)valuepp);
}

CODE_SECTION(".text.init_iterator_reverse")
void v_char_init_iterator_reverse
        (v_char_t const *self, v_char_index_t *key)
{
    return_if_null_pp (key, self);

    *key= self->m_nentries; /* if you change this, change the C++ forall macros as well! */
}

CODE_SECTION(".text.next_iteration_reverse")
E_BOOL v_char_next_iteration_reverse
        (v_char_t const *self, v_char_index_t *key, char *valuep)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return_val_if_null  (self, E_FALSE);
    return_val_if_null3_pp3 (TABLE(self), key, valuep, E_FALSE, self, key, valuep);

    (*key)--;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (v_char_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_VALUE (*valuep, TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr_reverse")
E_BOOL v_char_next_iteration_ptr_reverse
        (
    v_char_t *self, v_char_index_t *key, char **valuepp)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return E_FALSE;
#endif

    return_val_if_null  (self, E_FALSE);
    return_val_if_null3_pp3 (TABLE(self), key, valuepp, E_FALSE, self, key, valuepp);

    (*key)--;
    if (ERWIN_UNLIKELY(*key < 0 || *key >= (v_char_cnt_t)self->m_nentries))
        return E_FALSE;
    E_SET_PTR(*valuepp, &TABLE(self)[*key]);
    return E_TRUE;
}

CODE_SECTION(".text.next_iteration_ptr_const_reverse")
E_BOOL v_char_next_iteration_ptr_const_reverse
        (v_char_t const *self, v_char_index_t *key, char const **valuepp)
{
    return v_char_next_iteration_ptr_reverse((v_char_t *)self, key, (char **)valuepp);
}


CODE_SECTION(".text.set_size")
int v_char_set_size
        (v_char_t *self, v_char_cnt_t newsize) /* this is user-proof. */
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    v_char_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!v_char_ensure_size_add_aux (self, newsize) ||
        !v_char_ensure_size_sub_aux (self, newsize))
    {
        return e_errno;
    }

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_TOOLARGE);

    v_char_clear_no_resize_aux (self, newsize); /* in case of shrinking */
    v_char_init_tail (self, newsize);           /* in case of growth */

    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.set_size_with")
int v_char_set_size_with
        (v_char_t *self, v_char_cnt_t newsize, char  elem)
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    if (newsize > (v_char_cnt_t)self->m_nentries)
        return v_char_ensure_size_with (self, newsize, elem);
    else
        return v_char_set_size (self, newsize);
}

CODE_SECTION(".text.set_size_no_resize")
int v_char_set_size_no_resize
        (v_char_t *self, v_char_cnt_t newsize) /* this is user-proof. */
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    v_char_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!v_char_ensure_size_add_aux (self, newsize))
        return e_errno;

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_TOOLARGE);

    v_char_clear_no_resize_aux (self, newsize); /* in case of shrinking */
    v_char_init_tail (self, newsize);           /* in case of growth */

    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.set_size_raw")
int v_char_set_size_raw
        (v_char_t *self, v_char_cnt_t newsize) /* this is user-proof. */
{
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    v_char_if_outofrange_min (newsize < 0, newsize)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!v_char_ensure_size_add_aux (self, newsize))
        return e_errno;

    if (ERWIN_UNLIKELY(!VALID_SIZE(newsize)))
        return PASS_ERRNO(E_TOOLARGE);

    v_char_clear_no_resize_aux (self, newsize); /* in case of shrinking */

    return_val_if_fail_ppi (VALID_SIZE (newsize), E_FALSE, self, newsize);
    self->m_nentries= newsize;
    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.shrink")
void v_char_shrink
        (v_char_t *self, E_BOOL tight)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL) {
        SET_ERRNO(E_OK);
        return;
    }
#endif
    return_if_null_or_bad_pC (self, (void)ASSERTION_FAILED);

    (void)self;  /*unused*/
    (void)tight; /*unused*/

#if !V_CHAR_LOW_MEM
    if (tight) {
        v_char_cnt_t ts= V_CHAR_GET_TABLESIZE (self);
        return_if_fail_ppii ((v_char_cnt_t)self->m_nentries <= ts,
            self, self->m_nentries, ts);

        if (ERWIN_LIKELY((v_char_cnt_t)self->m_nentries < ts)) {
            v_char_cnt_t newsize= CLAMP_MINIMAL(self->m_nentries);
            V_CHAR_ALIGN_TABLESIZE (newsize);
            if (!v_char_reallocate (self, newsize))
                return;
        }
    }
    else
    if (!v_char_ensure_size_sub_aux_force (self, self->m_nentries))
        return;
#endif

    SET_ERRNO(E_OK);
}

CODE_SECTION(".text.ensure_table_size")
int v_char_ensure_table_size
        (v_char_t *self, v_char_cnt_t newsize)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    (void)self;    /*unused*/
    (void)newsize; /*unused*/

#if !V_CHAR_LOW_MEM
    if (newsize > 0 && newsize > (v_char_cnt_t)self->m_nentries) {
        if (!v_char_ensure_size_add_aux (self, newsize))
            return e_errno;
    }
#endif

    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.append")
int v_char_append
        (v_char_t *self, char  newvalue)
{
    int copyerror= E_FALSE;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    if (!v_char_ensure_size_add_plus (self, self->m_nentries, 1))
        return e_errno;

    {
        char valuecopy;
        E_SET_VALUE (valuecopy, OCOPY (newvalue, &copyerror));

        if (ERWIN_LIKELY(copyerror == E_FALSE)) {
            self->m_nentries++; /* TABLE(self) uses self->m_nentries in LOW_MEM mode! */
            E_SET_VALUE (TABLE(self)[self->m_nentries-1], valuecopy);
            V_CHAR_UPDATE_POS_INSERT (self, self->m_nentries-1);
            return PASS_ERRNO(E_OK);
        }
        else {
            VECTOR_NOMEM;
            return e_errno;
        }
    }
}

/*
 * Insert empty elements into the vector
 * Already updates POS(SELF).
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.make_gap_aux")
void v_char_make_gap_aux
        (v_char_t *self, v_char_index_t start, v_char_cnt_t count)
{
    v_char_cnt_t i;
    v_char_cnt_t nentries;

    nentries= self->m_nentries;
#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (count < 0, count) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }
    v_char_if_outofrange_min (start < 0, start) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    if (count > 0 && !v_char_grow_plus (self, start, 1))
        return;

#else
    v_char_if_outofrange_min (count < 0, count) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }
    v_char_if_outofrange_minmax (start < 0 || start > nentries, start, nentries) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }
#endif

    if (!v_char_ensure_size_add_plus (self, nentries, count))
        return;

    /* Copy elements up */
    for (i=0; i < nentries - start; i++) {
        E_SET_VALUE (TABLE(self) [nentries + count - 1 - i], TABLE(self) [nentries - 1 - i]);
        V_CHAR_UPDATE_POS_SET (self, nentries - 1 - i);
    }

    /* Set new size */
    self->m_nentries= nentries + count;
    ADD_POS_AT (self, start, count);

    SET_ERRNO(E_OK);
}

/*
 * Insert empty elements into the vector
 */
CODE_SECTION(".text.make_gap_with")
int v_char_make_gap_with
        (v_char_t *self, v_char_index_t start, char  elem, v_char_cnt_t count)
{
    v_char_cnt_t i;
    int    copyerror= E_FALSE;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    v_char_make_gap_aux (self, start, count); /* updates POS */

    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return e_errno;

    /* Fill the gap. */
    for (i=0; i < count; i++) {
        E_SET_VALUE (TABLE(self) [start + i], OCOPY (elem, &copyerror));
        if (ERWIN_UNLIKELY(copyerror != E_FALSE)) {  /* reset to sane state */
            VECTOR_NOMEM;
            return v_char_erase_flags_q (self, start, count, E_FALSE, E_FALSE);
            /* FIXME: memory leak.  The correct behaviour would be to
             *        clear the non-filled positions and then to
             *        deallocate. */
        }
        V_CHAR_UPDATE_POS_SET (self, start + i);
    }

    return e_errno;
}

/*
 * Insert empty elements into the vector
 */
CODE_SECTION(".text.make_gap")
int v_char_make_gap
        (v_char_t *self, v_char_index_t start, v_char_cnt_t count)
{
    v_char_cnt_t i;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    v_char_make_gap_aux (self, start, count);

    if (ERWIN_UNLIKELY(e_errno != E_OK))
        return e_errno;

    /* Blank out duplicates in gap */
    for (i=0; i < count; i++)
        E_SET_VALUE (TABLE(self) [start + i], ZEROVAR(self));

    return e_errno;
}

/*
 *  sub vectors */
CODE_SECTION(".text.insert_subvector")
int v_char_insert_subvector
        (
    v_char_t *self,
    v_char_index_t self_start,
    v_char_t const *other,
    v_char_index_t start,
    v_char_cnt_t count,
    E_BOOL docopy)
{

#if V_CHAR_ALLOW_NULL
    if (other == NULL && count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null_or_bad (other, ASSERTION_FAILED);

    if (count < 0)
        count= other->m_nentries - start;

#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (start < 0, start) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
    v_char_if_outofrange_min (count < 0, count) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }

    if (start >= (v_char_cnt_t)other->m_nentries)
        count= 0;
    else
    if (start + count > (v_char_cnt_t)other->m_nentries)
        count= other->m_nentries - start;

#else
    v_char_if_outofrange_min (start < 0, start) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
    v_char_if_outofrange_min (count < 0, count) {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
    v_char_if_outofrange_minmax (
        (start + count) > (v_char_cnt_t)other->m_nentries, start + count, other->m_nentries)
    {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
#endif

    if (count > 0) {
        return_val_if_null_or_bad (self, ASSERTION_FAILED);
        if (docopy)
            return v_char_insert_raw (self, self_start, TABLE(other) + start, count);
        else
            return v_char_insert_no_copy (self, self_start, TABLE(other) + start, count);
    }

    return PASS_ERRNO(E_OK);
}

CODE_SECTION(".text.subvector")
v_char_t * v_char_subvector
        (v_char_t const *self,
                            v_char_index_t start,
                            v_char_cnt_t count,
                            E_BOOL docopy)
{
    v_char_t *result;
    v_char_cnt_t pre_alloc;

#if V_CHAR_ALLOW_NULL
    if (self == NULL && count <= 0)
        return NULL;
#endif
    return0_if_null_or_bad (self);

    pre_alloc= (v_char_cnt_t)self->m_nentries - start;
    if (pre_alloc < 0)
        pre_alloc= 0;
    if (count > 0 && pre_alloc > count)
        pre_alloc= count;

#if V_CHAR_DYN_ZERO
    E_SET_PTR(result, v_char_new_with_zero_and_initial_size (ZERO(self), pre_alloc));
#else
    E_SET_PTR(result, v_char_new_with_initial_size (pre_alloc));
#endif
    if (ERWIN_UNLIKELY(
           v_char_insert_subvector (result, 0, self, start, count, docopy) != E_OK))
    {
        v_char_delete (result);
        return NULL;
    }

    return result;
}

/*
 * Overwrite entries in the vector
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.overwrite_copy_aux_q")
int v_char_overwrite_copy_aux_q
        (
        v_char_t *self,
        v_char_index_t       start_self,
        char const *other_table,
        v_char_cnt_t       count,
        E_BOOL dealloc)
{
    v_char_cnt_t i;
    int copyerror= E_FALSE;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /*
     * Special case for convenient handling of ill-formed calls like other_table == NULL.
     */
    if (count == 0)
        return PASS_ERRNO(E_OK);

    return_val_if_null_pp (other_table, ASSERTION_FAILED, self);

    /*
     * Out of range errors:
     */
#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (count < 0, count)
        return PASS_ERRNO(E_OUTOFRANGE);
    v_char_if_outofrange_min (start_self < 0, start_self)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!v_char_grow_plus (self, start_self, 1) ||
        !v_char_grow_plus (self, start_self, count))
    {
        return e_errno;
    }

#else
    v_char_if_outofrange_minmax (count < 0 ||
        start_self < 0 ||
        (v_char_cnt_t)self->m_nentries - start_self < (v_char_cnt_t)count ||
        start_self >= (v_char_cnt_t)self->m_nentries, start_self, self->m_nentries)
        return PASS_ERRNO(E_OUTOFRANGE);
#endif

    /*
     * Ok, do it.
     */
    SET_ERRNO(E_OK);
    for (i=0; i < count; i++) {
        char old;
        E_SET_VALUE (old, TABLE(self)[start_self + i]);
        E_SET_VALUE (TABLE(self)[start_self + i], OCOPY (other_table[i], &copyerror));

        if (ERWIN_LIKELY(copyerror != E_FALSE)) {
            E_SET_VALUE (TABLE(self) [start_self + i], old);
            return e_errno;
        }
        V_CHAR_UPDATE_POS_SET (self, start_self + i);

        if (V_CHAR_EQ_USE_ARG(dealloc)) {
            OFREE (old);
        }
    }

    return e_errno;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.overwrite_no_copy_aux_q")
int v_char_overwrite_no_copy_aux_q
        (
    v_char_t       *self,
    v_char_index_t  start_self,
    char const *other_table,
    v_char_cnt_t    count,
    E_BOOL dealloc)
{
    v_char_cnt_t i;

    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /*
     * Special case for convenient handling of ill-formed calls like other_table == NULL.
     */
    if (count == 0)
        return PASS_ERRNO(E_OK);

    return_val_if_null_pp (other_table, ASSERTION_FAILED, self);

    /*
     * Out of range errors:
     */
#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (count < 0, count)
        return PASS_ERRNO(E_OUTOFRANGE);
    v_char_if_outofrange_min (start_self < 0, start_self)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (!v_char_grow_plus (self, start_self, 1) ||
        !v_char_grow_plus (self, start_self, count))
    {
        return e_errno;
    }

#else
    v_char_if_outofrange_minmax (
        count < 0 ||
           start_self < 0 ||
           (v_char_cnt_t)self->m_nentries - start_self < count ||
           start_self >= (v_char_cnt_t)self->m_nentries,
        start_self,
        self->m_nentries)
    {
        return PASS_ERRNO(E_OUTOFRANGE);
    }
#endif

    /*
     * Ok, do it.
     */
    SET_ERRNO(E_OK);
    for (i=0; i < count; i++) {
        char old;
        E_SET_VALUE (old, TABLE(self)[start_self + i]);

        E_SET_VALUE (TABLE(self)[start_self + i], other_table[i]);

        V_CHAR_UPDATE_POS_SET (self, start_self + i);

        if (V_CHAR_EQ_USE_ARG(dealloc)) {
            OFREE (old);
        }
    }

    return e_errno;
}

/*
 * Overwrite entries in the vector
 */
CODE_SECTION(".text.overwrite_raw")
int v_char_overwrite_raw
        (v_char_t *self,
                          v_char_index_t       start_self,
                          char const *other_table,
                          v_char_cnt_t       count)
{
    return v_char_overwrite_copy_aux_q (
            self,
            start_self,
            other_table,
            count,
            E_TRUE);
}

CODE_SECTION(".text.overwrite_string")
int v_char_overwrite_string
        (
    v_char_t *self,
    v_char_index_t       start_self,
    char const *other_table)
{
    /* return_val_if_null (other_table, ASSERTION_FAILED); */
    /* other_table == NULL is explicitly allowed. */

    return v_char_overwrite_copy_aux_q (self,
                                 start_self,
                                 other_table,
                                 v_char_string_length (self, other_table),
                                 E_TRUE);
}

CODE_SECTION(".text.overwrite_vector")
int v_char_overwrite_vector
        (
    v_char_t *self,
    v_char_index_t       start_self,
    v_char_t const *other)
{
    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);

    return v_char_overwrite_copy_aux_q (self,
                                 start_self,
                                 TABLE(other),
                                 other->m_nentries,
                                 E_TRUE);
}

CODE_SECTION(".text.overwrite_flags")
int v_char_overwrite_flags
        (
        v_char_t *self,
        v_char_index_t       start_self,
        char const *other_table,
        v_char_cnt_t       count,
        E_BOOL      copy,
        E_BOOL      del)
{
    return copy ?
         v_char_overwrite_copy_aux_q (self, start_self, other_table, count, del)
       : v_char_overwrite_no_copy_aux_q (
                 self,
                 start_self,
                 ERWIN_SUPERFLUOUS_CAST (char const*, other_table),
                 count,
                 del);
}


/*
 * Overwrite entries in the vector
 */
CODE_SECTION(".text.overwrite")
int v_char_overwrite
        (v_char_t *self,
                      v_char_index_t       start_self,
                      v_char_t const *other,
                      v_char_index_t       start_other,
                      v_char_cnt_t       maxcount)
{
    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);

    /*
     * Copy of both other->m_nentries - start_other and maxcount
     */
    if (maxcount > (v_char_cnt_t)other->m_nentries - start_other)
        maxcount= (v_char_cnt_t)other->m_nentries - start_other;

    /*
     * Errors not handled by v_char_overwrite_raw
     */
#if V_CHAR_ALLOW_OUTOFRANGE
    v_char_if_outofrange_min (start_other < 0, start_other)
        return PASS_ERRNO(E_OUTOFRANGE);

    if (start_other >= (v_char_cnt_t)other->m_nentries)
        return PASS_ERRNO(E_OK);

#else
    /* Range check */
    v_char_if_outofrange_minmax (
        start_other < 0 ||
            start_other >= (v_char_cnt_t)other->m_nentries,
        start_other,
        other->m_nentries)
        return PASS_ERRNO(E_OUTOFRANGE);
#endif

    /*
     * Do it
     */
    return v_char_overwrite_raw (
               self,
               start_self,
               TABLE(other) + start_other,
               maxcount);
}


/*
 * Get the length of a given null-terminated string
 */
ERWIN_STATIC_INLINE
CODE_SECTION(".text.string_length_aux")
v_char_cnt_t v_char_string_length_aux
        (v_char_t const *self, char const *values)
{
    v_char_cnt_t count;

    (void)self; /*unused*/

    if (values == NULL) /* Allow NULL pointer to represent 0 element arrays. */
        return 0;

    return0_if_null_or_bad (self);

    count= 0;
    while (ISNT_ZERO (values[count], self))
        count++;

    return count;
}


/*
 * User side frontend to the string length function
 */
CODE_SECTION(".text.string_length")
v_char_cnt_t v_char_string_length
        (v_char_t const *self, char const *values)
{
    return v_char_string_length_aux (self, values);
}


/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert_raw")
int v_char_insert_raw
        (v_char_t *self, v_char_index_t start, char const *values, v_char_cnt_t count)
{
    /* return_val_if_null2 (self, values); -- already done by callees */

    if (ERWIN_UNLIKELY(v_char_make_gap (self, start, count) != E_OK))
        return e_errno;

    v_char_overwrite_raw (self, start, values, count);

    return e_errno;
}

CODE_SECTION(".text.insert_no_copy")
int v_char_insert_no_copy
        (v_char_t *self, v_char_index_t start, char const *values, v_char_cnt_t count)
{
    /* return_val_if_null2 (self, values); -- already done by callees */

    if (ERWIN_UNLIKELY(v_char_make_gap (self, start, count) != E_OK))
        return e_errno;

    v_char_overwrite_no_copy_aux_q (self, start, values, count, E_FALSE);

    return e_errno;
}


/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert_vector")
int v_char_insert_vector
        (v_char_t *self, v_char_index_t start, v_char_t const *other)
{
    return_val_if_null2i_or_bad (other, ASSERTION_FAILED);
    return v_char_insert_raw (self, start, TABLE(other), (v_char_cnt_t)other->m_nentries);
}

/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert")
int v_char_insert
        (v_char_t *self, v_char_index_t start, char  value)
{
    return v_char_insert_raw (self, start, &value, 1);
}


/*
 * Insert a whole vector into another one
 */
CODE_SECTION(".text.insert_string")
int v_char_insert_string
        (v_char_t *self, v_char_index_t start, char const *values)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

    return v_char_insert_raw (
               self,
               start,
               values,
               v_char_string_length_aux (self, values));
}


/*
 * Append some elements at the end of the vector
 */
CODE_SECTION(".text.append_raw")
int v_char_append_raw
        (v_char_t *self, char const *values, v_char_cnt_t count)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return v_char_insert_raw (self, (v_char_cnt_t)self->m_nentries, values, count);
}

CODE_SECTION(".text.append_no_copy")
int v_char_append_no_copy
        (v_char_t *self, char const *values, v_char_cnt_t count)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return v_char_insert_no_copy (self, (v_char_cnt_t)self->m_nentries, values, count);
}


/*
 * Append a null-terminated string at the end of the vector
 */
CODE_SECTION(".text.append_vector")
int v_char_append_vector
        (v_char_t *self, v_char_t const *other)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return v_char_insert_vector (self, (v_char_cnt_t)self->m_nentries, other);
}


/*
 * Append a null-terminated string at the end of the vector
 */
CODE_SECTION(".text.append_string")
int v_char_append_string
        (v_char_t *self, char const *values)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return v_char_insert_raw (
               self,
               (v_char_cnt_t)self->m_nentries,
               values,
               v_char_string_length_aux (self, values));
}

/* Cut a portion out of the vector. */
static
CODE_SECTION(".text.erase_aux_q")
int v_char_erase_aux_q
        (
        v_char_t *self,
        v_char_index_t start,
        v_char_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    v_char_cnt_t i;

#if V_CHAR_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /* Adjust boundaries */
#if V_CHAR_ALLOW_OUTOFRANGE
    if (start < 0) {
        if (count > 0)
            count+= start; /* e.g. start=-2, count=5 -> start=0, count=3 */
        start= 0;
    }
#endif

    if (count == 0)
        return PASS_ERRNO(E_OK);

    if (count < 0)
        count= (v_char_cnt_t)self->m_nentries - start;

#if V_CHAR_ALLOW_OUTOFRANGE
    if (start >= (v_char_cnt_t)self->m_nentries || count <= 0)
        return PASS_ERRNO(E_OK);
    if ((start + count) > (v_char_cnt_t)self->m_nentries)
        count= self->m_nentries - start;
#endif

    /* Check that both start and end are within bounds: */
    return_val_if_out_of_bounds_pp (start,         (v_char_cnt_t)self->m_nentries, ASSERTION_FAILED, self);
    return_val_if_out_of_bounds_pp (start+count-1, (v_char_cnt_t)self->m_nentries, ASSERTION_FAILED, self);

    V_CHAR_UPDATE_POS_ERASE_MANY (self, start, start + count);

    if (V_CHAR_EQ_USE_ARG(dealloc)) {
        /* Free elements */
        for (i= 0; i < count; i++) {
            OFREE (TABLE(self) [i+start]);
        }
    }

    /* Move elements */
    for (i=0; i < (v_char_cnt_t)self->m_nentries - start - count; i++) {
        E_SET_VALUE (TABLE(self) [i + start], TABLE(self) [i + start + count]);
        V_CHAR_UPDATE_POS_SET (self, i + start);
    }

    /* Resize the table */
    if (ERWIN_UNLIKELY(
            !v_char_setsize_noinit_sub(self, (v_char_cnt_t)self->m_nentries - count, resize)))
        return e_errno;

    return PASS_ERRNO(E_OK);
}

/*
 * Cut a portion out of the vector.
 */
CODE_SECTION(".text.erase_flags_q")
int v_char_erase_flags_q
        (
        v_char_t *self,
        v_char_index_t start,
        v_char_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    return v_char_erase_aux_q (self, start, count, resize, dealloc);
}

CODE_SECTION(".text.erase")
int v_char_erase
        (v_char_t *self, v_char_index_t start, v_char_cnt_t count)
{
    return v_char_erase_aux_q (self, start, count, E_TRUE, E_TRUE);
}

/* Cut a portion out of the vector. */
static
CODE_SECTION(".text.swap_erase_aux_q")
int v_char_swap_erase_aux_q
        (
        v_char_t *self,
        v_char_index_t start,
        v_char_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    v_char_cnt_t i;
    v_char_cnt_t n;
    v_char_cnt_t end;

#if V_CHAR_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    /* Adjust boundaries */
#if V_CHAR_ALLOW_OUTOFRANGE
    if (start < 0) {
        if (count > 0)
            count+= start; /* e.g. start=-2, count=5 -> start=0, count=3 */
        start= 0;
    }
#endif

    if (count == 0)
        return PASS_ERRNO(E_OK);

    n= self->m_nentries;

    if (count < 0)
        count= n - start;

#if V_CHAR_ALLOW_OUTOFRANGE
    if (start >= n || count <= 0)
        return PASS_ERRNO(E_OK);
    if (start + count > n)
        count= n - start;
#endif

    /* Check that both start and end are within bounds: */
    return_val_if_out_of_bounds_pp (start,         (v_char_cnt_t)n, ASSERTION_FAILED, self);
    return_val_if_out_of_bounds_pp (start+count-1, (v_char_cnt_t)n, ASSERTION_FAILED, self);

    V_CHAR_UPDATE_POS_ERASE_MANY (self, start, start + count);

    if (V_CHAR_EQ_USE_ARG(dealloc)) {
        /* Free elements */
        for (i= 0; i < count; i++) {
            OFREE (TABLE(self) [i+start]);
        }
    }

    /* Move elements */
    /*       [0  1  2  3 (4  5  6) 7]
     *   ->  [0  1  2  3  7]
     *                    ^-=start    ^-= n = self->nentries
     *                             ^-=start+count
     *                       ^-=end
     */
    end= self->m_nentries - count;
    for (i=0; i < count; i++) {
        v_char_cnt_t j_from;
        v_char_cnt_t j_to= start + i;
        return_val_if_fail_ppi ((v_char_index_t)j_to >= 0, ASSERTION_FAILED, self, j_to);
        if (ERWIN_UNLIKELY(j_to >= end))
            break;

        j_from= self->m_nentries - 1 - i;
        return_val_if_fail_ppi ((v_char_index_t)j_from >= 0, ASSERTION_FAILED, self, j_from);
        return_val_if_fail_ppiii ((v_char_index_t)j_from >= start + count, ASSERTION_FAILED,
           self, j_from, start, count);

        E_SET_VALUE (TABLE(self) [j_to], TABLE(self)[j_from]);
        V_CHAR_UPDATE_POS_SET (self, j_to);
    }

    /* Resize the table */
    if (ERWIN_UNLIKELY(
            !v_char_setsize_noinit_sub(self, (v_char_cnt_t)self->m_nentries - count, resize)))
        return e_errno;

    return PASS_ERRNO(E_OK);
}

/*
 * Cut a portion out of the vector.
 */
CODE_SECTION(".text.swap_erase_flags_q")
int v_char_swap_erase_flags_q
        (
        v_char_t *self,
        v_char_index_t start,
        v_char_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
    return v_char_swap_erase_aux_q (self, start, count, resize, dealloc);
}

CODE_SECTION(".text.swap_erase")
int v_char_swap_erase
        (v_char_t *self, v_char_index_t start, v_char_cnt_t count)
{
    return v_char_swap_erase_aux_q (self, start, count, E_TRUE, E_TRUE);
}

CODE_SECTION(".text.erase_if_flags_q")
v_char_cnt_t v_char_erase_if_flags_q
        (
        v_char_t *self,
        v_char_feature_t f,
        E_BOOL value,
        E_BOOL resize,
        E_BOOL dealloc)
{
    v_char_index_t rp, wp;
    v_char_cnt_t cnt;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);
    return_val_if_null_pp (f, ASSERTION_FAILED, self);

    value= ERWIN_TO_BOOL (value);

    cnt= self->m_nentries;
    rp= wp= 0;
    while (rp < cnt) {
        if (value == ERWIN_TO_BOOL (f(TABLE(self)[rp]))) {
            V_CHAR_UPDATE_POS_ERASE (self, rp);
            if (V_CHAR_EQ_USE_ARG (dealloc)) {
                OFREE (TABLE(self)[rp]);
            }
        }
        else {
            E_SET_VALUE (TABLE(self)[wp], TABLE(self)[rp]);
            V_CHAR_UPDATE_POS_SET (self, wp);
            wp++;
        }
        rp++;
    }

    v_char_setsize_noinit_sub (self, wp, resize);

    return rp - wp;
}

CODE_SECTION(".text.erase_if")
v_char_cnt_t v_char_erase_if
        (v_char_t *self, v_char_feature_t f, E_BOOL value)
{
    return v_char_erase_if_flags_q (self, f, value, E_TRUE, E_TRUE);
}

CODE_SECTION(".text.erase_zero")
v_char_cnt_t v_char_erase_zero
        (v_char_t *self)
{
    v_char_index_t rp, wp;
    v_char_cnt_t cnt;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    cnt= self->m_nentries;
    rp= wp= 0;
    while (rp < cnt) {
        if (IS_ZERO(TABLE(self)[rp], self)) {
            V_CHAR_UPDATE_POS_ERASE (self, rp);
            OFREE (TABLE(self)[rp]);
        }
        else {
            E_SET_VALUE (TABLE(self)[wp], TABLE(self)[rp]);
            V_CHAR_UPDATE_POS_SET (self, wp);
            wp++;
        }
        rp++;
    }

    v_char_setsize_noinit_sub (self, wp, E_TRUE);

    return rp - wp;
}

/*
 * Chop off end of vector
 */
CODE_SECTION(".text.chop")
int v_char_chop
        (v_char_t *self, v_char_cnt_t count)
{
#if V_CHAR_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif

    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return v_char_erase (self, (v_char_index_t)self->m_nentries - count, count);
}

/*
 * Chop off end of vector
 */
CODE_SECTION(".text.chop_flags_q")
int v_char_chop_flags_q
        (
        v_char_t *self,
        v_char_cnt_t count,
        E_BOOL resize,
        E_BOOL dealloc)
{
#if V_CHAR_ALLOW_NULL
    if (count == 0)
        return PASS_ERRNO(E_OK);
#endif
    return_val_if_null_or_bad (self, ASSERTION_FAILED);
    return v_char_erase_flags_q (
            self,
            (v_char_cnt_t)self->m_nentries - count,
            count,
            resize,
            dealloc);
}

/* Chop off end of vector and return the last element*/
CODE_SECTION(".text.last_chop1")
o_type_var_t v_char_last_chop1
        (v_char_t *self)
{
    char result;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#if V_CHAR_ALLOW_OUTOFRANGE
    if (self->m_nentries == 0)
        return ZEROVAR(self);
#endif

    E_SET_VALUE (result, TABLE(self)[self->m_nentries - 1]);
    v_char_erase_aux_q (self, (v_char_cnt_t)self->m_nentries - 1, 1, E_TRUE, E_FALSE);
       /* resize, but don't delete, since we're going to return the element. */

    return result;
}

/* Chop off end of vector and return the last element*/
CODE_SECTION(".text.first_swap_chop1")
o_type_var_t v_char_first_swap_chop1
        (v_char_t *self)
{
    char result;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#if V_CHAR_ALLOW_OUTOFRANGE
    if (self->m_nentries == 0)
        return ZEROVAR(self);
#endif

    E_SET_VALUE (result, TABLE(self)[0]);
    v_char_swap_erase_aux_q (self, 0, 1, E_TRUE, E_FALSE);
       /* resize, but don't delete, since we're going to return the element. */

    return result;
}

/* Nth element */
CODE_SECTION(".text.nth")
o_type_result_t v_char_nth
        (v_char_t const*self, v_char_index_t idx)
/* table==NULL is ok */
{
    exit_if_null (self);
       /* FATAL: no return value can be generated in case this
        * assertion fails (ZERO(self) would be appropriate,
        * but since self is NULL...) */

#if V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx >= (v_char_cnt_t)self->m_nentries)) {
# if V_CHAR_ALLOW_OUTOFRANGE == 0
        errprint ((errstream, "in v_char_nth: index out of range (0 <= %d < %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return ZERO(self), "index out of range",
            idx, self->m_nentries);
# endif
        return ZERO(self);
    }
#endif

    return_val_if_null_pp (TABLE(self), ZERO(self), self);

    return TABLE(self)[idx];
}


/*
 * Nth element, reference to just after the array is allowed */
CODE_SECTION(".text.nth_char")
o_type_result_t v_char_nth_char
        (v_char_t const*self, v_char_index_t idx)
/* m_table==NULL is ok */
{
    exit_if_null (self);
       /* FATAL: no return value can be generated in case this
        * assertion fails (ZERO(self) would be appropriate,
        * but since self is NULL...) */

    if (ERWIN_UNLIKELY(idx == (v_char_cnt_t)self->m_nentries))
        return ZERO(self);

#if V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx > (v_char_cnt_t)self->m_nentries)) {
# if V_CHAR_ALLOW_OUTOFRANGE == 0
        errprint ((errstream, "in v_char_nth: index out of range (0 <= %d <= %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return ZERO(self), "index out of range",
            idx, self->m_nentries);
# endif
        return ZERO(self);
    }
#endif

    return_val_if_null_pp (TABLE(self), ZERO(self), self);

    return TABLE(self)[idx];
}


/*
 * First element
 */
CODE_SECTION(".text.first")
o_type_result_t v_char_first
        (v_char_t const *self)
/* m_table==NULL is ok */
{
    return v_char_nth (self, 0);
}


/*
 * Last element
 */
CODE_SECTION(".text.last")
o_type_result_t v_char_last
        (v_char_t const *self)
/* m_table==NULL is ok */
{
    exit_if_null (self);
       /* FATAL: no return value can be generated in case this
        * assertion fails (ZERO(self) would be appropriate,
        * since self is NULL...) */

    return v_char_nth (self, (v_char_index_t)(self->m_nentries - 1));
}

/*
 * Pointer to nth element
 */
CODE_SECTION(".text.nth_ptr")
v_char_element_ptr_t v_char_nth_ptr
        (v_char_t *self, v_char_index_t idx)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);

#if V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0))
        return NULL;

    if (ERWIN_UNLIKELY(idx >= (v_char_cnt_t)self->m_nentries)) {
# if V_CHAR_ALLOW_OUTOFRANGE != 0
        if (!v_char_grow_plus (self, idx, 1))
            return NULL;
# else
        return NULL;
# endif
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);

    return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, &TABLE(self)[idx]);
}

/*
 * Pointer to nth element with check.
 */
CODE_SECTION(".text.nth_ptr_check")
v_char_element_ptr_t v_char_nth_ptr_check
        (v_char_t *self, v_char_index_t idx)
/* m_table==NULL is ok */
{
    return_val_if_null (self, NULL);

#if V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx >= (v_char_cnt_t)self->m_nentries)) {
# if V_CHAR_ALLOW_OUTOFRANGE != 0
        if (ERWIN_UNLIKELY(!v_char_grow_plus (self, idx, 1)))
            return NULL;
# else
        errprint ((errstream, "in v_char_nth: index out of range (0 <= %d < %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return NULL, "index out of range",
            idx, self->m_nentries);
# endif
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);

    return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, &TABLE(self)[idx]);
}

/*
 * Pointer to nth element with check, allowing a reference
 * just after the vector's end.
 */
CODE_SECTION(".text.nth_ptr_char")
v_char_element_ptr_t v_char_nth_ptr_char
        (v_char_t *self, v_char_index_t idx)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);

    /* Always terminate it, just like with as_array().  This way,
     * as_array() + 5  === nth_ptr_char (5), which is what
     * people probably expect (apart from the fact that the former
     * performs no checks).
     */

#if !V_CHAR_LOW_MEM
    /* We only want an additional element, which is already allocated for LOW_MEM.
     * And since we do not change nentries, reallocation would leave us with a
     * table that has a non-consistient size. */
    if (ERWIN_UNLIKELY(!v_char_ensure_size_add_plus (self, self->m_nentries, 1)))
        return NULL;
#endif

    E_SET_VALUE (TABLE(self)[self->m_nentries], ZEROVAR(self));
        /* Ensure this always reads back as 0 */

#if V_CHAR_ALLOW_OUTOFRANGE != 0
    if (ERWIN_UNLIKELY(idx < 0 || idx >= (v_char_cnt_t)self->m_nentries)) {
        if (ERWIN_UNLIKELY(!v_char_grow_plus (self, idx, 1)))
            return NULL;
    }
#elif V_CHAR_RANGE_CHECK
    if (ERWIN_UNLIKELY(idx < 0 || idx > (v_char_cnt_t)self->m_nentries)) {
        errprint ((errstream, "in v_char_nth: index out of range (0 <= %d <= %lu failed)\n",
                         idx,
                         (unsigned long)self->m_nentries));
        FATAL_ERROR (E_OUTOFRANGE, return NULL, "index out of range",
            idx, self->m_nentries);
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);

    return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, &TABLE(self)[idx]);
}

/*
 * Pointer to first element
 */
CODE_SECTION(".text.first_ptr")
v_char_element_ptr_t v_char_first_ptr
        (v_char_t *self)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);

#if V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK
    if (ERWIN_UNLIKELY(0 >= (v_char_cnt_t)self->m_nentries)) {
# if V_CHAR_ALLOW_OUTOFRANGE != 0
        if (ERWIN_UNLIKELY(!v_char_grow_plus (self, 0, 1)))
            return NULL;
# else
        return NULL;
# endif
    }
#endif

    return_val_if_null_pp (TABLE(self), NULL, self);
    return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, &TABLE(self)[0]);
}

/*
 * Pointer to nth element
 */
CODE_SECTION(".text.last_ptr")
v_char_element_ptr_t v_char_last_ptr
        (v_char_t *self)
/* m_table==NULL is ok */
{
    return0_if_null_or_bad (self);
    return v_char_nth_ptr (self, self->m_nentries - 1);
}

CODE_SECTION(".text.as_array")
v_char_element_ptr_t v_char_as_array
        (v_char_t const *self_const)
/* self==NULL    is ok: NULL is returned then.
 * m_table==NULL is ok, "" is returned then. */
{
    v_char_t *self;
    E_SET_PTR(self, ERWIN_CONST_CAST(v_char_t*, self_const));
    if (self == NULL)
        return NULL;
    return0_if_null_or_bad (self);

#if !V_CHAR_LOW_MEM
    /* see v_char_nth_ptr_char */
    if (ERWIN_UNLIKELY(!v_char_ensure_size_add_plus (self, self->m_nentries, 1)))
        return NULL;
#endif

    E_SET_VALUE (TABLE(self)[self->m_nentries], ZEROVAR(self));

    return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, TABLE(self));
}

CODE_SECTION(".text.ensure_heap_storage")
void v_char_ensure_heap_storage
        (v_char_t *self)
{
    (void)self; /*unused*/

    return_if_null_or_bad (self);

    /* Ensure that the contents are stored on the heap so that _detach
     * does not destroy the vector. */
#if V_CHAR_INLINE_STORE
    v_char_ensure_table_size_force (self, V_CHAR_INLINE_CNT + 1);
#endif
}

CODE_SECTION(".text.has_heap_storage")
ERWIN_BOOL v_char_has_heap_storage
        (v_char_t const *self)
{
    (void)self; /*unused*/

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return ERWIN_FALSE;
#endif

    return0_if_null_or_bad (self);
    return HAS_HEAP_TABLE(self);
}

CODE_SECTION(".text.inline_store_cnt")
v_char_cnt_t v_char_inline_store_cnt
        (void)
{
    return V_CHAR_INLINE_CNT;
}

CODE_SECTION(".text.as_array_detach")
v_char_element_ptr_t v_char_as_array_detach
        (v_char_t *self)
{
    v_char_element_ptr_t result;

    v_char_ensure_heap_storage (self);
    result= v_char_as_array (self);
    v_char_detach (self);

    return result;
}

CODE_SECTION(".text.as_open_array")
v_char_element_ptr_t v_char_as_open_array
        (v_char_t const *self)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif
    return0_if_null_or_bad (self);
#if V_CHAR_ZERO_SIZE
    if (TABLE(self) == V_CHAR_DUMMY_TABLE)
        return NULL;
#endif
    return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, TABLE(self));
}

CODE_SECTION(".text.as_open_array_detach")
v_char_element_ptr_t v_char_as_open_array_detach
        (v_char_t *self)
{
    v_char_element_ptr_t result;

    v_char_ensure_heap_storage (self);
    result= v_char_as_open_array(self);
    v_char_detach (self);

    return result;
}

#ifdef OCMP
static
CODE_SECTION(".text.element_cmp")
int v_char_element_cmp
        (char const *a, char const *b)
{
    return OCMP ((*a), (*b));
}
#endif /* defined(OCMP) */

#ifdef OPRIORITY_CMP
static
CODE_SECTION(".text.element_priority_cmp")
int v_char_element_priority_cmp
        (char const *a, char const *b)
{
    return OPRIORITY_CMP ((*a), (*b));
}
#endif /* defined(OPRIORITY_CMP) */

CODE_SECTION(".text.heap_left")
v_char_index_t v_char_heap_left
        (v_char_t const *self, v_char_index_t father)
{
    v_char_index_t child;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

    return_val_if_null_or_bad (self, -1);
    return_val_if_out_of_bounds_pp (father, (v_char_cnt_t)self->m_nentries, -1, self);

    child= father * 2 + 1;
    if (child < (v_char_cnt_t)self->m_nentries)
        return child;
    return -1;
}

CODE_SECTION(".text.heap_right")
v_char_index_t v_char_heap_right
        (v_char_t const *self, v_char_index_t father)
{
    v_char_index_t child;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

    return_val_if_null_or_bad (self, -1);
    return_val_if_out_of_bounds_pp (father, (v_char_cnt_t)self->m_nentries, -1, self);

    child= (father + 1) * 2;
    if (child < (v_char_cnt_t)self->m_nentries)
        return child;
    return -1;
}

CODE_SECTION(".text.heap_father")
v_char_index_t v_char_heap_father
        (v_char_t const *self, v_char_index_t child)
{
    (void)self; /*unused*/

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

    return_val_if_null_or_bad (self, -1);
    return_val_if_out_of_bounds_pp (child, (v_char_cnt_t)self->m_nentries, -1, self);

    if (child == 0)
        return -1; /* the root has no father */
    return (child - 1) / 2;
}

#ifndef NDEBUG

static
CODE_SECTION(".text.check_heap_property")
void v_char_check_heap_property
        (v_char_t const *self, v_char_cmp_t cmp)
{
#if 0
    v_char_size_t father;
#endif
    (void)self; /*unused*/
    (void)cmp;  /*unused*/
#if 0
    for (father=0; father < self->m_nentries; father++) {
        v_char_index_t child= v_char_heap_left (self, father);
        if (child >= 0) {
            return_if_fail_ppt (
                cmp (v_char_nth_ptr_const (self, father), v_char_nth_ptr_const (self, child)) >= 0,
                self,
                "The heap property is violated.");
        }
        child= v_char_heap_right (self, father);
        if (child >= 0) {
            return_if_fail_ppt (
                cmp (v_char_nth_ptr_const (self, father), v_char_nth_ptr_const (self, child)) >= 0,
                self,
                "The heap property is violated.");
        }
    }
#endif
}
#endif /* !defined(NDEBUG) */

CODE_SECTION(".text.heap_sink")
void v_char_heap_sink
        (v_char_t *self, v_char_index_t father, v_char_cmp_t cmp)
{
    return_if_null_or_bad (self);
    return_if_out_of_bounds_pp (father, (v_char_cnt_t)self->m_nentries, self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= v_char_element_priority_cmp;
#endif
    return_if_null_pp (cmp, self);

    /* BEGIN MAIN */
    for (;;) {
        v_char_index_t child, largest;

        largest= father;

        child= v_char_heap_left (self, father);
        if (child >= 0) {
            if (cmp (v_char_nth_ptr (self, child), v_char_nth_ptr (self, largest)) > 0)
                largest= child;

            child= v_char_heap_right (self, father);
            if (child >= 0 &&
                cmp (v_char_nth_ptr (self, child), v_char_nth_ptr (self, largest)) > 0)
                largest= child;
        }

        if (ERWIN_UNLIKELY(largest == father))
            break;

        v_char_swap (self, largest, father);
        father= largest;
    }
    /* END MAIN */
}

CODE_SECTION(".text.make_heap")
void v_char_make_heap
        (v_char_t *self, v_char_cmp_t cmp)
{
    v_char_index_t largest_father;
    v_char_index_t i;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null_or_bad (self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= v_char_element_priority_cmp;
#endif
    return_if_null_pp (cmp, self);

    /* BEGIN MAIN */
    largest_father= v_char_heap_father (self, self->m_nentries - 1);
    for (i= largest_father; i >= 0; i--)
        v_char_heap_sink (self, i, cmp);
    /* END MAIN */

#ifndef NDEBUG
    v_char_check_heap_property (self, cmp);
#endif
}

#ifndef NDEBUG

static
CODE_SECTION(".text.check_sort_order")
void v_char_check_sort_order
        (v_char_t const *self, v_char_cmp_t cmp)
{
    v_char_index_t i;
    for (i=0; i < (v_char_index_t)self->m_nentries - 1; i++) {
        return_if_fail_ppt (
            cmp (v_char_nth_ptr_const (self, i), v_char_nth_ptr_const (self, i+1)) <= 0,
            self,
            "The vector is not sorted after a sort function was used.");
    }
}
#endif /* !defined(NDEBUG) */

CODE_SECTION(".text.heap_sort")
void v_char_heap_sort
        (v_char_t *self, v_char_cmp_t cmp)
{
    v_char_index_t i;
    v_char_cnt_t n;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null_or_bad (self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= v_char_element_priority_cmp;
#endif
    return_if_null_pp (cmp, self);

    /* BEGIN MAIN */
    v_char_make_heap (self, cmp);

    n= self->m_nentries;
    for (i=n-1; i >= 1; i--) {
         v_char_swap (self, 0, i);
         self->m_nentries= i;
         v_char_heap_sink (self, 0, cmp);
    }

    self->m_nentries= n;
    /* END MAIN */

#ifndef NDEBUG
    v_char_check_sort_order (self, cmp);
#endif
}

CODE_SECTION(".text.heap_extract")
o_type_var_t v_char_heap_extract
        (v_char_t *self, v_char_cmp_t cmp)
{
    char result;

    return_val_if_null_or_bad (self, ZEROVAR(self));

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= v_char_element_priority_cmp;
#endif
    return_val_if_null_pp (cmp, ZEROVAR(self), self);

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_heap_property (self, cmp);
#endif

#if V_CHAR_ALLOW_OUTOFRANGE
    if (self->m_nentries == 0)
        return ZEROVAR(self);
#endif

    /* BEGIN MAIN */
    result= v_char_first_swap_chop1 (self);
    if (self->m_nentries > 0)
        v_char_heap_sink (self, 0, cmp);
    /* END MAIN */

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_heap_property (self, cmp);
#endif

    return result;
}

CODE_SECTION(".text.heap_raise")
void v_char_heap_raise
        (v_char_t *self, v_char_index_t child, v_char_cmp_t cmp)
{
    return_if_null_or_bad (self);
    return_if_out_of_bounds_pp (child, (v_char_cnt_t)self->m_nentries, self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        cmp= v_char_element_priority_cmp;
#endif
    return_if_null_pp (cmp,self);

    /* BEGIN MAIN */
    for (;;) {
        v_char_index_t father= v_char_heap_father (self, child);
        if (ERWIN_UNLIKELY(father < 0))
            break;

        if (cmp (v_char_nth_ptr (self, father), v_char_nth_ptr (self, child)) >= 0)
            break;

        v_char_swap (self, father, child);
        child= father;
    }
    /* END MAIN */

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_heap_property (self, cmp);
#endif
}

CODE_SECTION(".text.heap_fix")
void v_char_heap_fix
        (v_char_t *self, v_char_index_t father, v_char_cmp_t cmp)
{
    v_char_heap_sink  (self, father, cmp);
    v_char_heap_raise (self, father, cmp);
}

CODE_SECTION(".text.heap_insert")
int v_char_heap_insert
        (v_char_t *self, char  x, v_char_cmp_t cmp)
{
    return_val_if_null_or_bad (self, ASSERTION_FAILED);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_priority_cmp);
#endif
    return_val_if_null_pp (cmp, ASSERTION_FAILED, self);

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_heap_property (self, cmp);
#endif

    /* BEGIN MAIN */
    if (ERWIN_LIKELY(v_char_append (self, x) == E_OK))
        v_char_heap_raise (self, self->m_nentries - 1, cmp);
    /* END MAIN */

    return e_errno;
}

CODE_SECTION(".text.heap_erase")
void v_char_heap_erase
        (v_char_t *self, v_char_index_t i, v_char_cmp_t cmp)
{
    return_if_null_or_bad (self);
    return_if_out_of_bounds_pp (i, (v_char_cnt_t)self->m_nentries,self);

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_priority_cmp);
#endif
    return_if_null_pp (cmp, self);

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_heap_property (self, cmp);
#endif

    /* BEGIN MAIN */
    v_char_swap_erase (self, i, 1);
    if (i < (v_char_cnt_t)self->m_nentries)
        v_char_heap_sink  (self, i, cmp);
    /* END MAIN */

#ifndef NDEBUG
    v_char_check_heap_property (self, cmp);
#endif
}

CODE_SECTION(".text.erase_equals")
v_char_cnt_t v_char_erase_equals
        (v_char_t *self, v_char_cmp_t cmp, v_char_combine_t combine)
{
    v_char_index_t rp, wp;
    v_char_cnt_t cnt;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return 0;
#endif
    if (self->m_nentries <= 1)
        return 0;
#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_cmp);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);

    cnt= self->m_nentries;
    rp= wp= 1; /* start at 1, not at 0, since we address wp-1 */
    while (rp < cnt) {
        if (cmp (&TABLE(self)[wp-1], &TABLE(self)[rp]) == 0) {
            V_CHAR_UPDATE_POS_ERASE (self, rp);
            if (combine != NULL)
                combine (&TABLE(self)[wp-1], &TABLE(self)[rp]);
            OFREE (TABLE(self)[rp]);
        }
        else {
            E_SET_VALUE (TABLE(self)[wp], TABLE(self)[rp]);
            V_CHAR_UPDATE_POS_SET (self, wp);
            wp++;
        }
        rp++;
    }

    v_char_setsize_noinit_sub (self, wp, E_TRUE);

    return rp - wp;
}

CODE_SECTION(".text.qsort")
void v_char_qsort
        (v_char_t *self, v_char_cmp_t cmp)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_cmp);
#endif
    return_if_null2i_or_bad (self);
    return_if_null_pp (cmp, self);

    qsort ((void*)TABLE(self),
           self->m_nentries,
           sizeof (char),
           (int (*)(const void *, const void *))cmp);

    V_CHAR_UPDATE_POS_SET_MANY (self, 0, self->m_nentries);

#ifndef NDEBUG
    v_char_check_sort_order (self, cmp);
#endif
}

CODE_SECTION(".text.sort")
void v_char_sort
        (v_char_t *self, v_char_cmp_t cmp)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_cmp);
#endif
    return_if_null2i_or_bad (self);
    return_if_null_pp (cmp, self);

    e_merge_sort (
           (void*)TABLE(self),
           self->m_nentries,
           sizeof (char),
           (int (*)(const void *, const void *))cmp);

    V_CHAR_UPDATE_POS_SET_MANY (self, 0, self->m_nentries);

#ifndef NDEBUG
    v_char_check_sort_order (self, cmp);
#endif
}

CODE_SECTION(".text.bfind")
v_char_index_t v_char_bfind
        (v_char_t const*self, char  which, v_char_cmp_t cmp)
{
    char *result;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif

#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_cmp);
#endif
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);
    return_val_if_null_pp (cmp, ASSERTION_FAILED, self);

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_sort_order (self, cmp);
#endif

    E_SET_PTR(result,
        (char*)
            bsearch ((void const *)&which,
                     TABLE(self),
                     self->m_nentries,
                     sizeof (char),
                     (int (*)(const void *, const void *))cmp));

    if (result == NULL)
        return -1;

    return result - TABLE(self);
}

CODE_SECTION(".text.find")
v_char_index_t v_char_find
        (v_char_t const *self, v_char_index_t start, char  needle)
{
    v_char_index_t i;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);

    if (start < 0) {
        start= self->m_nentries + start;

        if (ERWIN_UNLIKELY(start < 0))
            return -1;
    }

    for (i=start; i < (v_char_cnt_t)self->m_nentries; i++)
        if (OEQUAL ((TABLE(self)[i]), (needle)))
            return i;
    return -1;
}

CODE_SECTION(".text.find_ptr")
v_char_element_ptr_t v_char_find_ptr
        (v_char_t const *self, v_char_index_t start, char  needle)
{
    v_char_index_t i;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif
    return0_if_null2i_or_bad (self);

    if (start < 0) {
        start= self->m_nentries + start;

        if (ERWIN_UNLIKELY(start < 0))
            return NULL;
    }

    for (i=start; i < (v_char_cnt_t)self->m_nentries; i++)
        if (OEQUAL ((TABLE(self)[i]), (needle)))
            return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, &TABLE(self)[i]);
    return NULL;
}

CODE_SECTION(".text.rfind")
v_char_index_t v_char_rfind
        (v_char_t const *self, v_char_index_t start, char  needle)
{
    v_char_index_t i;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start >= (v_char_cnt_t)self->m_nentries))
        return -1;

    for (i=start; i >= 0; i--)
        if (OEQUAL ((TABLE(self)[i]), needle))
            return i;
    return -1;
}

CODE_SECTION(".text.rfind_ptr")
v_char_element_ptr_t v_char_rfind_ptr
        (v_char_t const *self, v_char_index_t start, char  needle)
{
    v_char_index_t i;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return NULL;
#endif
    return0_if_null2i_or_bad (self);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start >= (v_char_cnt_t)self->m_nentries))
        return NULL;

    for (i=start; i >= 0; i--)
        if (OEQUAL ((TABLE(self)[i]), needle))
            return ERWIN_SUPERFLUOUS_CAST (v_char_element_ptr_t, &TABLE(self)[i]);
    return NULL;
}

CODE_SECTION(".text.find_if")
v_char_index_t v_char_find_if
        (v_char_t const *self, v_char_index_t start, v_char_feature_t feature, E_BOOL value)
{
    v_char_index_t i;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (feature, -1, self);

    value= ERWIN_TO_BOOL (value); /* normalise boolean */

    if (start < 0) {
        start= self->m_nentries + start;

        if (ERWIN_UNLIKELY(start < 0))
            return -1;
    }

    for (i=start; i < (v_char_cnt_t)self->m_nentries; i++)
        if (value == ERWIN_TO_BOOL (feature (TABLE(self)[i])))
            return i;
    return -1;
}

CODE_SECTION(".text.rfind_if")
v_char_index_t v_char_rfind_if
        (v_char_t const *self, v_char_index_t start, v_char_feature_t feature, E_BOOL value)
{
    v_char_index_t i;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (feature, -1, self);

    value= ERWIN_TO_BOOL (value);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start >= (v_char_cnt_t)self->m_nentries))
        return -1;

    for (i=start; i >= 0; i--)
        if (value == ERWIN_TO_BOOL (feature (TABLE(self)[i])))
            return i;
    return -1;
}

CODE_SECTION(".text.is_equal_at")
E_BOOL v_char_is_equal_at
        (v_char_t const *self, v_char_index_t start, char const *needle, v_char_cnt_t len)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL && start == 0 && len == 0)
        return E_TRUE;
#endif
    return0_if_null2i_or_bad (self);
    return0_if_null_pp (needle, self);

    if (start < 0)
        start= self->m_nentries + start;

    if (ERWIN_UNLIKELY(start < 0 || start+len > (v_char_cnt_t)self->m_nentries))
        return E_FALSE;

    while (len > 0) {
        if (!(OEQUAL ((*needle), (TABLE(self)[start]))))
            return E_FALSE;
        needle++;
        start++;
        len--;
    }

    return E_TRUE;
}

CODE_SECTION(".text.find_raw")
v_char_index_t v_char_find_raw
        (v_char_t const *self, v_char_index_t start, char const *needle, v_char_cnt_t len)
{
    v_char_cnt_t noch;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return (start == 0 && len == 0) ? 0 : -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (needle, -1, self);

    if (start < 0)
        start= self->m_nentries + start;

    noch= self->m_nentries - start - len + 1;
    while (noch > 0) {
        v_char_index_t i= v_char_find (self, start, *needle);

        if (i >= 0) {
            if (v_char_is_equal_at (self, i, needle, len))
                return i;
            start= i + 1;
            noch= self->m_nentries - start - len + 1;
        }
        else {
            start++;
            noch--;
        }
    }

    return -1;
}

CODE_SECTION(".text.rfind_raw")
v_char_index_t v_char_rfind_raw
        (v_char_t const *self, v_char_index_t start, char const *needle, v_char_cnt_t len)
{
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return (start == 0 && len == 0) ? 0 : -1;
#endif
    return_val_if_null2i_or_bad (self, -1);
    return_val_if_null_pp (needle, -1, self);

    if (start < 0)
        start= self->m_nentries + start;

    while (start >= 0) {
        v_char_index_t i= v_char_rfind (self, start, *needle);

        if (i >= 0) {
            if (v_char_is_equal_at (self, i, needle, len))
                return i;
            start= i - 1;
        }
        else
            start--;
    }

    return -1;
}

CODE_SECTION(".text.ltrim_if")
void v_char_ltrim_if
        (v_char_t *self, v_char_feature_t feature, E_BOOL value)
{
    v_char_size_t count;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null2i_or_bad (self);

    value= ERWIN_TO_BOOL (value);

    count= 0;
    while (count < self->m_nentries &&
           value == ERWIN_TO_BOOL (feature(TABLE(self)[count])))
        count++;

    if (count != 0)
        v_char_erase (self, 0, count);
}

CODE_SECTION(".text.rtrim_if")
void v_char_rtrim_if
        (v_char_t *self, v_char_feature_t feature, E_BOOL value)
{
    v_char_size_t count;

#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif

    return_if_null2i_or_bad (self);

    value= ERWIN_TO_BOOL (value);

    count= 0;
    while (count < self->m_nentries &&
           value == ERWIN_TO_BOOL (feature (TABLE(self)[self->m_nentries - count - 1])))
        count++;

    if (count != 0)
        v_char_chop (self, count);
}

CODE_SECTION(".text.trim_if")
void v_char_trim_if
        (v_char_t *self, v_char_feature_t feature, E_BOOL value)
{
    v_char_rtrim_if (self, feature, value);
    v_char_ltrim_if (self, feature, value);
}

CODE_SECTION(".text.map")
void v_char_map
        (v_char_t *self, v_char_map_t map)
{
    v_char_size_t count;
#if V_CHAR_ALLOW_NULL
    if (self == NULL)
        return;
#endif
    return_if_null2i_or_bad (self);

    count= 0;
    while (count < self->m_nentries) {
        v_char_set (self, count, (*map) (TABLE(self)[count]));
        count++;
    }      
}

CODE_SECTION(".text.cmp")
int v_char_cmp
        (v_char_t const *a, v_char_t const *b, v_char_cmp_t cmp)
{
    char const *alauf;
    char const *blauf;
    v_char_cnt_t count;

#ifdef OCMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_cmp);
#endif

    if (a == b) return 0;

    if (a == NULL)
        return b == NULL ? 0 : -1;

    if (b == NULL)
        return 1;

#if !V_CHAR_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    E_SET_PTR(alauf, TABLE(a));
    E_SET_PTR(blauf, TABLE(b));
    for (count= (a->m_nentries < b->m_nentries) ? a->m_nentries : b->m_nentries;
         count > 0;
         alauf++, blauf++, count--)
    {
        int result= cmp (alauf, blauf);

        if (result != 0)
            return result;
    }

#if V_CHAR_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    return 0;
}


CODE_SECTION(".text.priority_cmp")
int v_char_priority_cmp
        (v_char_t const *a, v_char_t const *b, v_char_cmp_t cmp)
{
    char const *alauf;
    char const *blauf;
    v_char_cnt_t count;

#ifdef OPRIORITY_CMP
    if (cmp == NULL)
        E_SET_PTR (cmp, v_char_element_priority_cmp);
#endif

    if (a == b) return 0;

    if (a == NULL)
        return b == NULL ? 0 : -1;

    if (b == NULL)
        return 1;

#if !V_CHAR_PRIORITY_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    E_SET_PTR(alauf, TABLE(a));
    E_SET_PTR(blauf, TABLE(b));
    for (count= (a->m_nentries < b->m_nentries) ? a->m_nentries : b->m_nentries;
         count > 0;
         alauf++, blauf++, count--)
    {
        int result= cmp (alauf, blauf);

        if (result != 0)
            return result;
    }

#if V_CHAR_PRIORITY_COMPARE_LEXICOGRAPHICALLY
    if (a->m_nentries > b->m_nentries)
        return 1;

    if (a->m_nentries < b->m_nentries)
        return -1;
#endif

    return 0;
}


CODE_SECTION(".text.hash_raw")
e_hashval_t v_char_hash_raw
        (v_char_t const *self)
{
#ifdef OHASH
    char const *alauf;
    e_hash_state_t state;
    char *end;
#endif

    if (self == NULL || TABLE(self) == NULL)
        return ERWIN_HASH_INIT;

#ifdef OHASH
    ERWIN_STATE_INIT_WITH (state, int_hash (self->m_nentries));

    E_SET_PTR(alauf, TABLE(self));
    for (end= TABLE(self) + self->m_nentries;
                 /* don't use E_SET_PTR: this ptr is out of range (end = one behind last) */
         alauf < end;
         alauf++)
    {
        ERWIN_STATE_MIX_ORDERED(state, OHASH(*alauf));
    }

    return ERWIN_STATE_GET_HASHVAL(state);
#else
    error_return0_if_reached_ppt (
        self,
        "Because CHAR_HASH was not #defined, v_char_hash_raw could not be implemented.");
#endif
}

/*
 * Locate an element's position even if it is not contained in the vector */
CODE_SECTION(".text.locate")
E_BOOL v_char_locate
        (v_char_index_t *idx,
                    v_char_t const *self,
                    char  element,
                    v_char_cmp_t cmp,
                    int how)
/* table==NULL is ok */
{
    v_char_cnt_t a, b;

#if V_CHAR_ALLOW_NULL
    if (self == NULL) {
        *idx= (how > 0) ? -1 : 0;
        return E_FALSE;
    }
#endif

    return0_if_null_or_bad (self);
    nothing_if_fail_ppi (how >= -1 && how <= 1, self, how);

    if (self->m_nentries == 0) {
        *idx= (how > 0) ? -1 : 0;
        return E_FALSE;
    }

    return_val_if_null_pp (TABLE(self), E_FALSE, self);

#ifdef OCMP
    if (cmp == NULL)
        cmp= v_char_element_cmp;
#endif

#if !defined(NDEBUG) && V_CHAR_DEBUG_EXPENSIVE_CHECKS
    v_char_check_sort_order (self, cmp);
#endif

    a= 0;
    b= self->m_nentries;
    if (a < b) {
        v_char_cnt_t a2;
        v_char_cnt_t c;

        do {
            a2= a;
            c= (a + b) / 2;

            if (c >= (v_char_cnt_t)self->m_nentries)
                b= c;  /* last iteration (in some cases), set up b appropriately */
            else {
                v_char_index_t result= cmp (&TABLE(self)[c], &element);

                if (result > 0) b= c;   /* search in left half */
                else
                if (result < 0) a= c+1; /* search in right half */
                else {
                    if (how < 0) { /* return left most equal element */
                        while (c >= 1 &&
                               cmp (&TABLE(self)[c-1], &element) == 0)
                            c--;
                    }
                    else
                    if (how > 0) { /* return right most equal element */
                        while (c < ((v_char_cnt_t)self->m_nentries - 1) &&
                               cmp (&TABLE(self)[c+1], &element) == 0)
                            c++;
                    }

                    *idx= c;
                    return E_TRUE;
                }
            }
        } while (a2 < c);
    }

    *idx= (how > 0) ? b-1 : b;
    return E_FALSE;
}

/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */
/*
 * Char specific routines
 */

CODE_SECTION(".text.fread")
int v_char_fread
        (v_char_t *self, FILE *f, v_char_cnt_t max_count)
{
    v_char_cnt_t anz;
    v_char_cnt_t old_nentries;
    v_char_cnt_t noch;
    v_char_cnt_t chunk_size;

#if V_CHAR_ALLOW_NULL
    if (max_count == 0)
        return 0;
#endif

    return0_if_null_or_bad (self);
    return0_if_null_pp (f, self);
    return0_if_fail_ppi (max_count == 0 || TABLE(self) != NULL, self, max_count);
#if !V_CHAR_LOW_MEM
    /* without an explicit table size, preallocation does not work. */
    if (max_count > 0) { /* pre-alloc to prevent fragmented heap.  This may fail, that's ok. */
        v_char_cnt_t pre_alloc= max_count;
        if (pre_alloc > V_CHAR_PREALLOC_SIZE)
            pre_alloc= V_CHAR_PREALLOC_SIZE;

        v_char_ensure_size_add_plus (self, self->m_nentries, pre_alloc);
    }
#endif

    noch= (max_count >= 0) ? max_count : V_CHAR_CHUNK_SIZE;
    chunk_size= V_CHAR_CHUNK_SIZE;
    old_nentries= self->m_nentries;
    while (noch > 0) {
        if (chunk_size > noch) /* try to not waste memory */
            chunk_size= noch;

        if (ERWIN_UNLIKELY(!v_char_ensure_size_add_plus (self, self->m_nentries, chunk_size)))
            return -1;

        anz= fread ((void*)(TABLE(self) + self->m_nentries), 1, chunk_size, f);
        if (ERWIN_UNLIKELY(anz <= 0)) {
            if (ferror (f) != 0) {
                if (max_count > 0) /* shrink in case we allocated too much */
                    v_char_ensure_size_sub_aux (self, self->m_nentries);
                SET_ERRNO(E_IO);
                return -1;
            }
            break;
        }

        if (max_count > 0)
            noch-= anz;

        self->m_nentries+= anz;

        V_CHAR_UPDATE_POS_INSERT_MANY (self, self->m_nentries - anz, self->m_nentries);
    }

    if (max_count > 0) /* shrink in case we allocated too much */
        v_char_ensure_size_sub_aux (self, self->m_nentries);

    SET_ERRNO(E_OK);
    return self->m_nentries - old_nentries;
}

CODE_SECTION(".text.fgets")
int v_char_fgets
        (v_char_t *self, FILE *f, v_char_cnt_t max_count)
{
    int c;

#if V_CHAR_ALLOW_NULL == 0
    return_val_if_null (self, ASSERTION_FAILED);
#endif
    return_val_if_bad (self, ASSERTION_FAILED);

    return_val_if_null_pp (f, ASSERTION_FAILED, self);

    SET_ERRNO(E_EMPTY);
    if (ERWIN_LIKELY((c = fgetc (f)) != EOF)) {
        SET_ERRNO(E_OK);
        do {
            if (max_count != 0) {
                v_char_append (self, (char )c);
                max_count--;
            }

            if (c == '\n')
                break;
        }
        while ((c = fgetc (f)) != EOF);
    }

    if (ERWIN_UNLIKELY(ferror (f) != 0))
        SET_ERRNO(E_IO);

    return e_errno;
}

/* A wrapper around the general Erwin function that takes 'char' */
static
CODE_SECTION(".text.elem_is_space0")
E_BOOL v_char_elem_is_space0
        (char  x)
{
    return char_is_space0 (x);
}

/* A wrapper around the general Erwin function that takes 'char' */
static
CODE_SECTION(".text.elem_is_cr0")
E_BOOL v_char_elem_is_cr0
        (char  x)
{
    return char_is_cr0 (x);
}

/* A wrapper around the general Erwin function that takes 'char' */
static
CODE_SECTION(".text.elem_to_lower")
o_type_t v_char_elem_to_lower
        (char  x)
{
    return char_to_lower (x);
}

/* A wrapper around the general Erwin function that takes 'char' */
static
CODE_SECTION(".text.elem_to_upper")
o_type_t v_char_elem_to_upper
        (char  x)
{
    return char_to_upper (x);
}

CODE_SECTION(".text.ltrim")
void v_char_ltrim
        (v_char_t *self)
{
    v_char_ltrim_if (self, &v_char_elem_is_space0, E_TRUE);
}

CODE_SECTION(".text.rtrim")
void v_char_rtrim
        (v_char_t *self)
{
    v_char_rtrim_if (self, &v_char_elem_is_space0, E_TRUE);
}

CODE_SECTION(".text.trim")
void v_char_trim
        (v_char_t *self)
{
    v_char_trim_if (self, &v_char_elem_is_space0, E_TRUE);
}

CODE_SECTION(".text.chomp")
void v_char_chomp
        (v_char_t *self)
{
    v_char_rtrim_if (self, &v_char_elem_is_cr0, E_TRUE);
}

CODE_SECTION(".text.to_upper")
void v_char_to_upper
        (v_char_t *self)
{
    v_char_map (self, &v_char_elem_to_upper);
}

CODE_SECTION(".text.to_lower")
void v_char_to_lower
        (v_char_t *self)
{
    v_char_map (self, &v_char_elem_to_lower);
}

CODE_SECTION(".text.basename_range")
void v_char_basename_range
        (v_char_index_t *firstp, v_char_cnt_t *lengthp, v_char_t const *self)
{
    v_char_index_t result= 0;
    v_char_cnt_t length;
#ifdef ERWIN_DOS
    v_char_index_t result2= 0;
#endif
#if V_CHAR_ALLOW_NULL
    if (self == NULL) {
        if (firstp)  *firstp=  0;
        if (lengthp) *lengthp= 0;
        return;
    }
#endif

    return_if_null2i_or_bad (self);

    length= self->m_nentries;

    /* Skip directory separators at the end of the string. */
    while (length > 0 &&
           TABLE(self)[length-1] == ERWIN_PATH_SEP
#ifdef ERWIN_DOS
        || TABLE(self)[length-1] == '/'
#endif
           )
    {
        length--;
    }

    /* Find beginning of basename */
    result= v_char_rfind (self, length - 1, ERWIN_PATH_SEP);
#ifdef ERWIN_DOS
    /* Sometimes, Win also understands the Unix / directory separator, so also
     * handle that here. */
    result2= v_char_rfind (self, length - 1, '/');
    if (result2 > result) /* this handles -1 for both indices, too */
        result= result2;
#endif
    if (result >= 0) {
        if (firstp)  *firstp=  result + 1;
        if (lengthp) *lengthp= length - result - 1;
        return;
    }


#ifdef ERWIN_DOS
    /* also cut of drive letters: */
    result= v_char_find (self, 0, ':'); /* e.g. for C:TEST.BAT */
    if (result >= 0) {
        if (firstp)  *firstp=  result + 1;
        if (lengthp) *lengthp= length - result - 1;
        return;
    }
#endif

    if (firstp)  *firstp=  0;
    if (lengthp) *lengthp= length;
}

CODE_SECTION(".text.basename_index")
v_char_index_t v_char_basename_index
        (v_char_t const *self)
{
    v_char_index_t first;
    v_char_basename_range (&first, NULL, self);
    return first;
}

CODE_SECTION(".text.append_directory")
int v_char_append_directory
        (v_char_t *self, v_char_t const *path)
{
    v_char_index_t pos;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);
    return_val_if_null2_ppp (path, TABLE(path), ASSERTION_FAILED, self, path);
    return_val_if_bad (path, ASSERTION_FAILED);

    pos= v_char_basename_index (path);
    v_char_append_raw (self, TABLE(path), pos);
    return e_errno;
}

CODE_SECTION(".text.append_basename")
int v_char_append_basename
        (v_char_t *self, v_char_t const *path)
{
    v_char_index_t first;
    v_char_cnt_t length;
    return_val_if_null2i_or_bad (self, ASSERTION_FAILED);
    return_val_if_null2_ppp (path, TABLE(path), ASSERTION_FAILED, self, path);
    return_val_if_bad (path, ASSERTION_FAILED);

    v_char_basename_range (&first, &length, path);
    v_char_append_raw (self, TABLE(path) + first, length);
    return e_errno;
}

CODE_SECTION(".text.append_config_file_name")
int v_char_append_config_file_name
        (
    v_char_t *    self,
    char const * programme_name,
    E_BOOL        local)
{
    /* FIXME: not for wchar_t */
    if (local) {
        /* FIXME: Improve this for Win32.  The home dir is not stored in an
         *        environment variable by default. */
        char const *home= (char const *)getenv ("HOME");
        if (home == NULL)
            return PASS_ERRNO(E_OUTOFRANGE);

        v_char_append_string (self, home);
        v_char_append        (self, (char const)ERWIN_PATH_SEP);
        v_char_append_string (self, (char const *)ERWIN_LOCAL_CONF_PREFIX);
        v_char_append_string (self, programme_name);
        v_char_append_string (self, (char const *)ERWIN_LOCAL_CONF_EXT);
    }
    else {
        v_char_append_string (self, (char const *)ERWIN_GLOBAL_CONF_DIR);
        v_char_append        (self, (char const)ERWIN_PATH_SEP);
        v_char_append_string (self, programme_name);
        v_char_append_string (self, (char const *)ERWIN_GLOBAL_CONF_EXT);
    }
    return e_errno;
}

#if V_CHAR_NO_FORMAT == 0


/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */

/* Formatted output */

#define FL_SPECIAL          1
#define FL_LEFT             2
#define FL_CENTER           4
#define FL_LEFT_CENTER  (FL_CENTER | FL_LEFT)
#define FL_UPCASE           8
#define FL_UNSIGNED         0x20
/*#define FL_SIGNED           0x40  Not used: we'd also need FL_SIGN and FL_VARIANT and
                                    then our 32 bits would be full. */
#define FL_HAVE_WIDTH       0x100
#define FL_HAVE_MIN         FL_HAVE_WIDTH
#define FL_HAVE_PREC        0x200
#define FL_HAVE_MAX         FL_HAVE_PREC
#define FL_ZERO             0x800
#define FL_SPACE            0x1000
#define FL_PLUS             0x2000
#define FL_HAVE_LFILLER     0x8000
#define FL_HAVE_SEP         0x10000
#define FL_CHECK            0x20000
#define FL_NULL_PREC        0x40000

typedef enum {
    OW_INT,
    OW_LONG,
    OW_SHORT,
    OW_CHAR,
    OW_LONG_LONG,
    OW_SIZE_T,
    OW_INTMAX_T,
    OW_PTRDIFF_T,
    OW_PTR
} OpWidth;


/*
 * Some Sun libraries seem to crash for isprint('<8-bit-character>')... */
static
CODE_SECTION(".text.elem_is_print")
E_BOOL v_char_elem_is_print
        (char c)
{
   return ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isprint ((unsigned char)c));
}

static
CODE_SECTION(".text.elem_is_digit")
E_BOOL v_char_elem_is_digit
        (char c)
{
   return ERWIN_TO_BOOL (((unsigned char)c) <= 127 && isdigit ((unsigned char)c));
}


static
CODE_SECTION(".text.quoted_length_c")
int v_char_quoted_length_c
        (int previous, char c)
/* Tries to produce short strings. */
{
    /* We quote strings and chars */
    if (ERWIN_UNLIKELY(
           c=='"' || c == '\'' || c == '\\' || c=='\n' ||
           c=='\r' || c=='\t' || c=='\v' || c=='\b'))
        return -2;

    if (ERWIN_UNLIKELY((previous >= 2 && previous <= 4) && v_char_elem_is_digit (c)))
        goto do_quote;
        /* Not necessary for previous == 4, but for previous < 4, it is necessary:
         * For octal encoding, in contrast to hex encoding, the sequence always
         * stops after 3 digits.  However, if the reader is not fully C-conform,
         * it might still get misinterpretations.  So just for the sake of
         * stability, still quote again in this case. */


    if (ERWIN_LIKELY(v_char_elem_is_print (c)))
        return 1;

do_quote:
    /* try octal first: */
    if (((unsigned char)c) < 8U)     return 2;
    if (((unsigned char)c) < 8U*8U)  return 3;

    return 4;
}

static
char const v_char_hex_digit[]= V_CHAR_STRING_LIT ("0123456789ABCDEF");

static
CODE_SECTION(".text.quote_c")
void v_char_quote_c
        (char *dst, char c, int len)
{
    if (ERWIN_LIKELY(len == 1)) {
        dst[0]= c;
        return;
    }

    *dst++= '\\';
    if (len <= 4) {
        switch (len) {
        case -2: /* variant of 2: not octal, but special */
            switch (c) {
                case '\n': *dst++= 'n'; break;
                case '\r': *dst++= 'r'; break;
                case '\t': *dst++= 't'; break;
                case '\v': *dst++= 'v'; break;
                case '\b': *dst++= 'b'; break;
                default:   *dst++= c;   break;
            }
            break;

        case 4: *dst++= V_CHAR_OCT_DIGIT (c, 2);
        case 3: *dst++= V_CHAR_OCT_DIGIT (c, 1);
        case 2: *dst++= V_CHAR_OCT_DIGIT (c, 0);
                break;
        }
    }
    else { /* hexadecimal */
#if E_GLOBAL_ERRNO
        return_if_reached ();
#endif
    }
}

static
CODE_SECTION(".text.quoted_length_lisp")
int v_char_quoted_length_lisp
        (int previous, char c)
{
    (void)previous; /*unused*/

    if (ERWIN_UNLIKELY(c=='"' || c == '\\'))
        return 2;
    /* FIXME:
     * cLisp allows virtually everything in a string.
     * The question is how to deal with WChar here. */
    return 1;
}

static
CODE_SECTION(".text.quoted_length_url")
int v_char_quoted_length_url
        (int previous, char c)
{
    (void)previous; /*unused*/

    if (ERWIN_UNLIKELY(c == ' '))
        return -1; /* do quote, but with length 1 */

    if ((c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= '0' && c <= '9') ||
        c == '_' ||
        c == '.' || c == ',' || c == ';' || c == ':' || c == '-' ||
        c == '/' || c == '\\')
    {
        return 1;
    }

    /* FIXME: URL quotation does not work for WChar. */
    return 3;
}

static
CODE_SECTION(".text.quoted_length_html")
int v_char_quoted_length_html
        (int previous, char c)
{
    (void)previous; /*unused*/

    switch (c) {
    case '<':
    case '>':
    case '"':
    case '\'':
    case '&':
        return 5;
    }

    if (((unsigned char)c) < 128) /* no quotation */
        return 1;

    if (((unsigned char)c) >= 100) return 6;  /* &#...; */

    /* The following condition is always true since we test for >= 128 above,
     * but to be sure nothing bad happens if the above condition is changed,
     * we check this case anyway: */
    if (((unsigned char)c) >= 10) return 5;  /* &#..; */
    return 4; /* &#.; */
}

static
CODE_SECTION(".text.quote_html")
void v_char_quote_html
        (char *dst, char c, int len)
{
    if (ERWIN_LIKELY(len == 1))
        *dst= c;
    else {
        *dst++= '&';
        *dst=   '#';
        dst+=   len-2;
        *dst--= ';';
        switch (len) {
        case  6: *dst--= (char)('0' + ((unsigned char)c) % 10);  c= ((unsigned char)c) / 10;
        case  5: *dst--= (char)('0' + ((unsigned char)c) % 10);  c= ((unsigned char)c) / 10;

        /* final digit: */
        case  4: *dst=   (char)('0' + ((unsigned char)c) % 10);
#if E_GLOBAL_ERRNO
#ifndef NDEBUG
            c= ((unsigned char)c) / 10;
            return_if_fail (c == 0); /* all digits should be eaten now. */
#endif
#endif
            break;

        default: ; /* C needs a command after a label. */
#if E_GLOBAL_ERRNO
            nothing_if_reached_pci (c, len);
#endif
        }
    }
}

static
CODE_SECTION(".text.quoted_length_printf")
int v_char_quoted_length_printf
        (int previous, char c)
{
    (void)previous; /*unused*/

    if (ERWIN_UNLIKELY(c == '%')) return 2;
    return 1;
}

static
CODE_SECTION(".text.quoted_length_unix_shell")
int v_char_quoted_length_unix_shell
        (int previous, char c)
{
    (void)previous; /*unused*/

    if (ERWIN_UNLIKELY(c == '\n'))
        return 3;

    if ( ((unsigned char)c <= 32) ||
         ((unsigned char)c >= 128) ||
         isspace ((unsigned char)c) ||
         (c == '&') || (c == '*') || (c == '[') || (c == ']') ||
         (c == '?') || (c == '^') || (c == '<') || (c == '>') ||
         (c == '|') || (c == ';') || (c == '(') || (c == ')') ||
         (c == '!') || (c == '{') || (c == '}') || (c == '\\') ||
         (c == '=') || (c == ':') || (c == '#') || (c == '\'') ||
         (c == '"')
       )
        return 2;

    return 1;
}

static
CODE_SECTION(".text.quote_unix_shell")
void v_char_quote_unix_shell
        (char *dst, char c, int len)
{
#if E_GLOBAL_ERRNO
    return_if_fail (len == 1 || len == 2 || len == 3);
#endif
    if (len == 3) {
        *dst++= '\'';
        *dst++= c;
        *dst++= '\'';
        return;
    }

    if (len == 2)
        *dst++= '\\';

    *dst= c;
}

static
CODE_SECTION(".text.quoted_length_dos_shell")
int v_char_quoted_length_dos_shell
        (int previous, char c)
{
    (void)previous; /*unused*/

    if (ERWIN_UNLIKELY(c == '"'))
        return 2;

    if ((c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= '0' && c <= '9') ||
        c == '.' || c == '_'   || c == '/' || c == '\\'  ||
        c == '-' || c == '+'   || c == ':' || c == '=')
        return 1;

    return -1; /* this means: needs quotation. */
}

static
CODE_SECTION(".text.quote_dos_shell")
void v_char_quote_dos_shell
        (char *dst, char c, int len)
{
    (void)len; /*unused*/

    if (ERWIN_UNLIKELY(c == '"'))
        *dst++= '\\';
    *dst= c; /* char_to_upper (c); nono!! */
}

static
CODE_SECTION(".text.check_quote_dos_shell")
void v_char_check_quote_dos_shell
        (char *dst, int len)
{
    if (len >= 2 && dst[len-1] == '"' && dst[len-2]=='\\') {
        dst[len-1]= '\\';
        dst[len-2]= '"';
    }
}

static
CODE_SECTION(".text.quote_url")
void v_char_quote_url
        (char *dst, char c, int len)
{
   /* FIXME: not possible for wchar_t. */
    if (len == 3) {
        dst[0]= '%';
        dst[1]= V_CHAR_HEX_DIGIT(c, 1);
        dst[2]= V_CHAR_HEX_DIGIT(c, 0);
    }
    else
    if (c == ' ')
        *dst= '+';
    else
        *dst= c;
}

static
CODE_SECTION(".text.quote_printf")
void v_char_quote_printf
        (char *dst, char c, int len)
{
    (void)c; /*unused*/

#if E_GLOBAL_ERRNO
    return_if_fail (len == 1 || len == 2);
#endif
    if (len == 2)
        *dst++= '%';
    *dst= c;
}

static
CODE_SECTION(".text.always_false")
int v_char_always_false
        (char const *c)
{
    (void)c; /*unused*/

    return 0;
}

static
CODE_SECTION(".text.always_true")
int v_char_always_true
        (char const *c)
{
    (void)c; /*unused*/

    return 1;
}

static
CODE_SECTION(".text.always_check")
int v_char_always_check
        (char const *c)
{
    (void)c; /*unused*/

    return 2;
}


static
CODE_SECTION(".text.always_check_affixes")
int v_char_always_check_affixes
        (char const *c)
{
    (void)c; /*unused*/

    return 4;
}


static
v_char_quotation_method_t v_char_quotation_method[QUOTATION_METHOD_CNT]= {
/* 0: no quotation: */
    { NULL, NULL, V_CHAR_STRING_LIT("(null)"), NULL,
        v_char_always_false,
        NULL,
        NULL,
        NULL,
    },

/* 1: C-quotation: */
    { V_CHAR_STRING_LIT("\""), V_CHAR_STRING_LIT("\""), V_CHAR_STRING_LIT("NULL"), NULL,
        v_char_always_true,
        v_char_quoted_length_c,
        v_char_quote_c,
        NULL,
    },

/* 2: C-quotation without "": */
    { V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), NULL,
        v_char_always_true,
        v_char_quoted_length_c,
        v_char_quote_c,
        NULL,
    },

/* 3: Unix shell quotation (bourne shell): */
    { NULL, NULL, NULL, V_CHAR_STRING_LIT("''"),
        v_char_always_check,
        v_char_quoted_length_unix_shell,
        v_char_quote_unix_shell,
        NULL,
    },

/* 4: printf format quotation: */
    { NULL, NULL, NULL, NULL,
        v_char_always_check,
        v_char_quoted_length_printf,
        v_char_quote_printf,
        NULL,
    },

/* 5: Windows shell quotation. */
    { V_CHAR_STRING_LIT("\""), V_CHAR_STRING_LIT("\""), NULL, NULL,
        v_char_always_check_affixes,
        v_char_quoted_length_dos_shell,
        v_char_quote_dos_shell,
        v_char_check_quote_dos_shell
    },

/* 6: Lisp quotation: */
    { V_CHAR_STRING_LIT("\""), V_CHAR_STRING_LIT("\""), V_CHAR_STRING_LIT("nil"), NULL,
        v_char_always_true,
        v_char_quoted_length_lisp,
        v_char_quote_c, /* same way: \ and " -> \\ and \", no other changes */
        NULL,
    },

/* 7: Lisp quotation without "": */
    {   V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), NULL,
        v_char_always_true,
        v_char_quoted_length_lisp,
        v_char_quote_c, /* same way: \ and " -> \\ and \", no other changes */
        NULL,
    },

/* 8: URL quotation: */
    {   V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), NULL,
        v_char_always_check,
        v_char_quoted_length_url,
        v_char_quote_url,
        NULL
    },

/* 9: HTML quotation: */
    {   V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), V_CHAR_STRING_LIT(""), NULL,
        v_char_always_check,
        v_char_quoted_length_html,
        v_char_quote_html,
        NULL
    },

/* reserved: */
/* 10 */ { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
/* 11 */ { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
/* 12 */ { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },

/* user : */
/* 13 */ { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
/* 14 */ { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
/* 15 */ { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL },
};


CODE_SECTION(".text.get_quotation_method")
v_char_quotation_method_t const * v_char_get_quotation_method
        (
    v_char_t const *self,
    int which)
{
    (void)self; /*unused*/

    if (ERWIN_LIKELY(which >= 0 && which < QUOTATION_METHOD_CNT))
        return &v_char_quotation_method[which];

    SET_ERRNO(E_OUTOFRANGE);
    return NULL;
}

CODE_SECTION(".text.set_quotation_method")
void v_char_set_quotation_method
        (
    v_char_t const *self,
    int which,
    v_char_quotation_method_t const *method)
{
    (void)self; /*unused*/

    if (ERWIN_LIKELY(which >= (int)E_FO_QUOTE_USER_MIN && which <= (int)E_FO_QUOTE_USER_MAX)) {
        v_char_quotation_method[which]= *method;
        return;
    }
    SET_ERRNO(E_OUTOFRANGE);
}

static
CODE_SECTION(".text.get_pre_post")
void v_char_get_pre_post
        (v_char_cnt_t len, v_char_cnt_t width, int flags, v_char_cnt_t *pre, v_char_cnt_t *post)
{
    *pre= *post= 0;
    if ((flags & FL_LEFT_CENTER) == FL_LEFT_CENTER) {
        *pre=  (width-len) / 2;
        *post= (width-len+1) / 2;
    }
    else
    if (flags & FL_CENTER) {
        *pre=  (width-len+1) / 2;
        *post= (width-len) / 2;
    }
    else
    if (flags & FL_LEFT)
        *post= width-len;
    else
        *pre= width-len;
}

#if E_GLOBAL_ERRNO

#ifdef __cplusplus
static
v_char_format_info_t v_char_last_format;
#endif /* defined(__cplusplus) */

#ifndef __cplusplus

static
v_char_format_info_t v_char_last_format= { 0, 0 };
#endif /* !defined(__cplusplus) */


CODE_SECTION(".text.format_pos")
v_char_index_t v_char_format_pos
        (void)
{
    return v_char_last_format.pos;
}


CODE_SECTION(".text.format_quoted")
E_BOOL v_char_format_quoted
        (void)
{
    return v_char_last_format.quoted;
}


#endif /* E_GLOBAL_ERRNO */


ERWIN_STATIC_INLINE
CODE_SECTION(".text.append_formatted_string")
void v_char_append_formatted_string
        (
    v_char_format_info_t *info,
    v_char_t   *self,
    char const *it,
    v_char_cnt_t         len,
    int         flags,
    char       lfiller,
    char       rfiller,
    v_char_cnt_t         min,
    v_char_cnt_t         max)
/*
 * Hopefully this is POSIX behaviour (apart from centring)
 */
{
    char const *c;
    v_char_cnt_t pre, post;

    /* Check for NULL */
    v_char_if_outofrange (it == NULL) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    /*
     * Calc length upto max.  The ,break' is optimisation and prevents over-eager
     * quotation of parts of the string that are not seen.
     * Moreover, it prevents accesses behind the ends of non-\0-terminated strings.
     */
    if (len < 0) {
        len= 0;
        if ((flags & FL_HAVE_MAX) && len >= max) {
            /* ok */
        }
        else
        for (c=it; ISNT_ZERO (*c, self); c++) {
            len++;
            if ((flags & FL_HAVE_MAX) && len == max)
                break;
        }
    }
    else {
        /* Chop if necessary */
        if ((flags & FL_HAVE_MAX) && len >= max)
            len= max;
    }

    /* Append it */
    if (len >= min)
        pre= post= 0;
    else
        v_char_get_pre_post (len, min, flags, &pre, &post);

    if ((flags & FL_CHECK) == 0) {
#if !V_CHAR_LOW_MEM
        /* Pre-allocate vector */
        /* this does not work with LOW_MEM.  Actually, it would reallocate twice,
         * because we don't set nentries here and make_gap_with would also
         * invoke ensure_size_add... */
        v_char_ensure_size_add_plus (self, self->m_nentries, pre + post + len + 1);
#endif

        /* Construct new vector */
        if (pre)
            v_char_make_gap_with (self, self->m_nentries, lfiller, pre);

        return_if_fail_ppuu (sizeof (char) == sizeof (char),
            self, sizeof(char), sizeof(char));
        v_char_append_raw (self, (char const *)it, len);

        if (post)
            v_char_make_gap_with (self, self->m_nentries, rfiller, post);
    }

    /*
     * Store the number of characters read */
    if (info != NULL) info->pos= len;
}

ERWIN_STATIC_INLINE
CODE_SECTION(".text.append_quoted_string")
void v_char_append_quoted_string
        (
    v_char_format_info_t *info,
    v_char_t             *self,
    char const          *it,
    v_char_cnt_t          itlen,
    int                   flags,
    char                 lfiller,
    char                 rfiller,
    v_char_cnt_t          min,
    v_char_cnt_t          max,
    int                   method)
{
    v_char_quotation_method_t const *q;
    v_char_index_t i;
    int pass;
    int what;
    v_char_cnt_t len, counted_len;
    v_char_cnt_t presuflen;
    E_BOOL nlen1;
    char const *c;
    v_char_cnt_t pre, post;
    char *dst;
    v_char_cnt_t qlen, absqlen;
    E_BOOL use_affixes= E_FALSE;
    E_BOOL quoted= E_FALSE;

    return_if_null2i_or_bad (self);

    v_char_if_outofrange_minmax (
        method < 0 || method >= QUOTATION_METHOD_CNT, method, QUOTATION_METHOD_CNT)
    {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    E_SET_PTR(q, &v_char_quotation_method[method]);

    /* String is NULL */
    if (it == NULL) {
        E_SET_PTR(it, q->null_name);
        goto unquoted;
    }            

    /* String is empty?  Is that a special case? */
    if ((*it == '\0') && (q->empty_name != NULL)) {
        E_SET_PTR(it, q->empty_name);
        goto unquoted;
    }

    /* Quotation method is `unquoted'. */
    if (q->needs_quotation == NULL || q->quoted_length == NULL || q->quote == NULL) {
    unquoted:
        quoted= E_FALSE;
        v_char_append_formatted_string (info, self, it, itlen, flags, lfiller, rfiller, min, max);
        return;
    }

    /* Does string not need quotation? */
    what= (*q->needs_quotation) (it);
    if (what == 0)
        goto unquoted;

    /* Yes, we quote! */
    quoted= E_TRUE;
    /* Take pre- and suffix into account */
    presuflen=  v_char_tchar_strlen (q->prefix) /* NULL pointer is allowed */
              + v_char_tchar_strlen (q->suffix);

    /* Init the following loop. */
    nlen1= E_FALSE;
    if (what != 3 && what != 4)
        use_affixes= E_TRUE;

    /*
     * This is a bit hairy.  In pass 1 we decide whether to quote or not, in
     * pass 2 we caluclate the real length.  If we decide not to quote, we
     * only do one pass.  In the second pass, itlen will be used from the
     * pass before.  */
    for (pass= 0; pass < 2; pass++) {
        len= 0;
        if (use_affixes)
            len+= presuflen;

        qlen= -1;
        /* Get string lengths */
        if (itlen == -1) {
            itlen= 0;
            if ((flags & FL_HAVE_MAX) && len >= max) {
                /* no more checks necessary */
            }
            else
            for (c=it; ISNT_ZERO (*c, self); c++) {
                qlen= (*q->quoted_length) (qlen, *c);
                absqlen= abs (qlen);

                if (qlen != 1) nlen1= E_TRUE;
                if ((flags & FL_HAVE_MAX) && (len + absqlen) > max)
                    break;
                len+= absqlen;
                itlen++;
                if ((flags & FL_HAVE_MAX) && len == max) {
                    break;
                }
            }
        }
        else {
            /* Calc quoted length */
            if ((flags & FL_HAVE_MAX) && len >= max) {
                /* no more checks necessary */
                itlen= 0; /* do not print anything */
            }
            else
            for (i=0; i < itlen; i++) {
                qlen= (*q->quoted_length) (qlen, it[i]);
                absqlen= abs (qlen);
                if (qlen != 1) nlen1= E_TRUE;
                if ((flags & FL_HAVE_MAX) && (len + absqlen) > max) {
                    itlen= i; /* This is important! */
                    break;
                }
                len+= absqlen;
                if ((flags & FL_HAVE_MAX) && len == max) { /* ok, no more access to the string! */
                    itlen= i + 1; /* This is important! */
                    break;
                }
            }
        }

        /* Quotation needed? */
        if (what == 2 && nlen1 == E_FALSE)
            goto unquoted;

        /* Possibly add prefix/suffix length */
        if (what == 4 && nlen1 != E_FALSE)
            use_affixes= E_TRUE;
        else
            break;
    }

    /* NOTE:
     *       len MUST be the correct line length now.  Otherwise the insertion of
     *       prepending white space (and possibly other things) does not work.
     */


    /* Decide about chopping and padding */
    E_SET_PTR(c, it);
    if (len >= min)
        pre= post= 0;
    else
        v_char_get_pre_post (len, min, flags, &pre, &post);

#if !V_CHAR_LOW_MEM
    /* Set the size of the new string */
    if ((flags & FL_CHECK) == 0)
        v_char_ensure_size_add_plus (self, self->m_nentries, pre + len + post + 1);
    /* In case someone does write the null character, we allocate one byte more.
     * This isn't too bad because when using format, usage as a string can be
     * expected, thus as_array is likely to be called later.
     */
#endif

    counted_len= 0;
    /* Insert new string */
    if ((flags & FL_CHECK) == 0) {
        if (pre)
            v_char_make_gap_with (self, self->m_nentries, lfiller, pre);

        if (q->prefix && use_affixes) {
            return_if_fail_ppuu (sizeof (char) == sizeof (char),
                self, sizeof(char), sizeof(char));
            v_char_append_string (self, (char const *)q->prefix);
            counted_len+= v_char_tchar_strlen (q->prefix);
        }
    }

    return_if_null2_ppp (q->quote, q->quoted_length, q, self);

#if V_CHAR_LOW_MEM
    /* Do the necessary realloc now (only for the part we're setting directly): */
    if ((flags & FL_CHECK) == 0)
        v_char_ensure_size_add_plus (self, self->m_nentries, itlen);
#endif

    E_SET_PTR(dst, TABLE(self) + self->m_nentries);
    qlen= -1;
    for (i=0; i < itlen; i++) {
        qlen= q->quoted_length (qlen, it[i]);
        absqlen= abs (qlen);

        break_if_out_of_bounds_ppii (absqlen, len - counted_len + 1, self, len, counted_len);

        if ((flags & FL_CHECK) == 0) {
            q->quote (dst, it[i], qlen);
            self->m_nentries+= absqlen; /* FIXME: improve */
            V_CHAR_UPDATE_POS_INSERT_MANY (self, self->m_nentries-absqlen, self->m_nentries);
        }

        dst+= absqlen;
        counted_len+= absqlen;
    }

    if ((flags & FL_CHECK) == 0) {
        if (q->suffix && use_affixes) {
            return_if_fail_ppuu (sizeof (char) == sizeof (char),
                self, sizeof(char), sizeof(char));
            v_char_append_string (self, (char const *)q->suffix);
            counted_len+= v_char_tchar_strlen (q->suffix);
        }

        if (post)
            v_char_make_gap_with (self, self->m_nentries, rfiller, post);

        if (q->check_quote)
            q->check_quote (TABLE(self) + self->m_nentries - counted_len, counted_len);
    }

    if (info != NULL) {
        info->pos= itlen;
        info->quoted= quoted;
    }
}

#define LONG long
#define ULONG unsigned long
ERWIN_STATIC_INLINE
CODE_SECTION(".text.append_long")
void v_char_append_long
        (v_char_t *self,
               ULONG it,
               int   base,
               int   flags,
               char lfiller,
               char rfiller,
               v_char_cnt_t width,
               int   prec,
               int   digwidth,
               char digsep)
/*
 * Unformatunately I did not have the ANSI document on printf format strings.
 * Therefore, I compared the behaviour to that of the Linux glibc2.
 * Well, those parts that can be compared.
 * Thinks I found were wrong in the beginnig are sometimes marked with comments
 * starting with `!'.
 */
{
    /* These are thread safe: they are never written: */
    static char const digitstr_lowcase[]=
            "0123456789abcdefghijklmnopqrstuvwxyz";
    static char const digitstr_upcase[]=
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    static char const digitstr_base64[]=
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    int  digits= 0;
    v_char_cnt_t  len;
    v_char_cnt_t  i, o;
    v_char_cnt_t  pre= 0;
    v_char_cnt_t  post= 0;
    ULONG lauf;
    E_BOOL neg= E_FALSE;
    char const *digitstr;
    char const *p;
    char prefix[5];
    v_char_cnt_t  zeros= 0;
    prefix[0]= 0;

    return_if_null2i_or_bad (self);

    /* Select digits: */
    E_SET_PTR(digitstr, (flags & FL_UPCASE) ? digitstr_upcase : digitstr_lowcase);

    /* Be able to do base 64.  For this to work, use different encoding, independent
     * from upcase flag. */
    if (base > 36)
        E_SET_PTR(digitstr, digitstr_base64);

    /* Reject if base > 64 */
    v_char_if_outofrange_minmax (base < 2 || base > 64, base, 64)
    {
        /* FIXME: add base 1 (unary notation) */
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    /* Get sign */
    if ((flags & FL_UNSIGNED) == 0 && ((LONG)it) < 0) {
        neg= E_TRUE;
        it= -((LONG)it);
    }

    /* Clear meaningless flags for unsigned numbers */
    if (flags & FL_UNSIGNED)
        flags&= ~(FL_PLUS | FL_SPACE);

    /* A precision overrides the zero-pad flag */
    if (flags & FL_HAVE_PREC)
        flags&= ~(FL_ZERO);

    /* Calculate length and width */
    lauf= it;
    while (lauf != 0) {
        lauf /= base;
        digits++;
    }

    len= digits;
    if ((it != 0 || base == 8 || digitstr == digitstr_base64) &&
            /* print 0 as 0, not 0x0 etc, but still print 64rA instead of A
             * For some reason, octal 0 with precision 0 and flag # should be printed "0", not "".
             * But hex 0 with prec 0 and # should be "".  Well...
             */
         base != 10 &&
         (flags & FL_SPECIAL))
    {
        if (base == 2) {
            len+= 2;
            strcpy (prefix, (flags & FL_UPCASE) ? "0B" : "0b");
        }
        else
        if (base == 16) {
            len+= 2;
            strcpy (prefix, (flags & FL_UPCASE) ? "0X" : "0x");
        }
        else
        if (base == 8) {
            digits++;
            len++;
        }
        else {
            sprintf (prefix, "%d%c", base, (flags & FL_UPCASE) ? 'R' : 'r');
            len+= strlen (prefix);
        }
    }

    if (neg || (flags & (FL_SPACE | FL_PLUS)))
        len++;

    /* There are no 0 digit numbers (only if requested) */
    if (digits == 0 && (flags & FL_NULL_PREC) == 0) {
        digits++;
        len++;
    }

    /* Minimal precision (this is different from the previous if(...)): */
    if ((flags & FL_HAVE_PREC) && digits < prec) {
        len+= prec-digits;
        digits= prec;
    }

    /* Digit Separators */
    if (digwidth != 0 && (flags & FL_HAVE_SEP)) {
        int a= (digits - 1) / digwidth;
        digits+= a;
        len+= a;
    }
    else
        digwidth= digits + 2;

    /* Check zero flag and possibly fill with zeros */
    if ((flags & FL_ZERO) &&
        (flags & (FL_CENTER | FL_LEFT)) != FL_LEFT &&
        (flags & FL_HAVE_MIN) && (len < width))
    {
        zeros= width-len;
        if (flags & FL_CENTER) {
           if ((flags & FL_LEFT) == 0)
               zeros++;
            zeros/= 2;
        }
        len+= zeros;
    }

    /* Get amount of fillers */
    if (len < width)
        v_char_get_pre_post (len, width, flags, &pre, &post);

#if !V_CHAR_LOW_MEM
    /* Pre-allocate space */
    /* Not possible and not even allowed for LOW_MEM. */
    v_char_ensure_size_add_plus (self, self->m_nentries, pre + post + len);
#endif

    /* Construct number */
    if (pre)
        v_char_make_gap_with (self, self->m_nentries, lfiller, pre);

    /* Sign */
    if (neg)
       v_char_append (self, (char)'-');
    else
    if ((flags & FL_PLUS) /*! && it > 0 */)
       v_char_append (self, (char)'+');
    else
    if (flags & (FL_SPACE | FL_PLUS))
       v_char_append (self, (char)' ');

    /* Prefix */
    for (p=prefix; *p; p++)
        v_char_append (self, (char)*p);

    /* Fill with zero first */
    v_char_make_gap_with (self, self->m_nentries, digitstr[0], zeros + digits);
    lauf= it;
    o=digwidth;
    for (i=0; i < digits; i++) {
        if (o == 0) {
            v_char_set (self, self->m_nentries - i - 1, digsep);
            o= digwidth;
        }
        else {
            v_char_set (self, self->m_nentries - i - 1, digitstr[lauf % base]);
            lauf/= base;
            o--;
        }
    }

    if (post)
        v_char_make_gap_with (self, self->m_nentries, rfiller, post);
}
#undef ULONG
#undef LONG


#ifdef ERWIN_LONG_LONG
#define LONG ERWIN_LONG_LONG
#define ULONG ERWIN_UNSIGNED_LONG_LONG
ERWIN_STATIC_INLINE
CODE_SECTION(".text.append_longlong")
void v_char_append_longlong
        (v_char_t *self,
               ULONG it,
               int   base,
               int   flags,
               char lfiller,
               char rfiller,
               v_char_cnt_t   width,
               int   prec,
               int   digwidth,
               char digsep)
{
    /* These are thread safe: they are never written: */
    static char const digitstr_lowcase[]=
            "0123456789abcdefghijklmnopqrstuvwxyz";
    static char const digitstr_upcase[]=
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    static char const digitstr_base64[]=
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    int  digits= 0;
    v_char_cnt_t  len;
    v_char_cnt_t  i, o;
    v_char_cnt_t  pre= 0;
    v_char_cnt_t  post= 0;
    ULONG lauf;
    E_BOOL neg= E_FALSE;
    char const *digitstr;
    char const *p;
    char prefix[5];
    v_char_cnt_t  zeros= 0;
    prefix[0]= 0;

    return_if_null2i_or_bad (self);

    /* Select digits: */
    E_SET_PTR(digitstr, (flags & FL_UPCASE) ? digitstr_upcase : digitstr_lowcase);

    /* Be able to do base 64.  For this to work, use different encoding, independent
     * from upcase flag. */
    if (base > 36)
        E_SET_PTR(digitstr, digitstr_base64);

    /* Reject if base > 64 */
    v_char_if_outofrange_minmax (base < 2 || base > 64, base, 64)
    {
        /* FIXME: add base 1 (unary notation) */
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    /* Get sign */
    if ((flags & FL_UNSIGNED) == 0 && ((LONG)it) < 0) {
        neg= E_TRUE;
        it= -((LONG)it);
    }

    /* Clear meaningless flags for unsigned numbers */
    if (flags & FL_UNSIGNED)
        flags&= ~(FL_PLUS | FL_SPACE);

    /* A precision overrides the zero-pad flag */
    if (flags & FL_HAVE_PREC)
        flags&= ~(FL_ZERO);

    /* Calculate length and width */
    lauf= it;
    while (lauf != 0) {
        lauf /= base;
        digits++;
    }

    len= digits;
    if ((it != 0 || base == 8 || digitstr == digitstr_base64) &&
            /* print 0 as 0, not 0x0 etc, but still print 64rA instead of A
             * For some reason, octal 0 with precision 0 and flag # should be printed "0", not "".
             * But hex 0 with prec 0 and # should be "".  Well...
             */
         base != 10 &&
         (flags & FL_SPECIAL))
    {
        if (base == 2) {
            len+= 2;
            strcpy (prefix, (flags & FL_UPCASE) ? "0B" : "0b");
        }
        else
        if (base == 16) {
            len+= 2;
            strcpy (prefix, (flags & FL_UPCASE) ? "0X" : "0x");
        }
        else
        if (base == 8) {
            digits++;
            len++;
        }
        else {
            sprintf (prefix, "%d%c", base, (flags & FL_UPCASE) ? 'R' : 'r');
            len+= strlen (prefix);
        }
    }

    if (neg || (flags & (FL_SPACE | FL_PLUS)))
        len++;

    /* There are no 0 digit numbers (only if requested) */
    if (digits == 0 && (flags & FL_NULL_PREC) == 0) {
        digits++;
        len++;
    }

    /* Minimal precision (this is different from the previous if(...)): */
    if ((flags & FL_HAVE_PREC) && digits < prec) {
        len+= prec-digits;
        digits= prec;
    }

    /* Digit Separators */
    if (digwidth != 0 && (flags & FL_HAVE_SEP)) {
        int a= (digits - 1) / digwidth;
        digits+= a;
        len+= a;
    }
    else
        digwidth= digits + 2;

    /* Check zero flag and possibly fill with zeros */
    if ((flags & FL_ZERO) &&
        (flags & (FL_CENTER | FL_LEFT)) != FL_LEFT &&
        (flags & FL_HAVE_MIN) && (len < width))
    {
        zeros= width-len;
        if (flags & FL_CENTER) {
           if ((flags & FL_LEFT) == 0)
               zeros++;
            zeros/= 2;
        }
        len+= zeros;
    }

    /* Get amount of fillers */
    if (len < width)
        v_char_get_pre_post (len, width, flags, &pre, &post);

#if !V_CHAR_LOW_MEM
    /* Pre-allocate space */
    /* Not possible and not even allowed for LOW_MEM. */
    v_char_ensure_size_add_plus (self, self->m_nentries, pre + post + len);
#endif

    /* Construct number */
    if (pre)
        v_char_make_gap_with (self, self->m_nentries, lfiller, pre);

    /* Sign */
    if (neg)
       v_char_append (self, (char)'-');
    else
    if ((flags & FL_PLUS) /*! && it > 0 */)
       v_char_append (self, (char)'+');
    else
    if (flags & (FL_SPACE | FL_PLUS))
       v_char_append (self, (char)' ');

    /* Prefix */
    for (p=prefix; *p; p++)
        v_char_append (self, (char)*p);

    /* Fill with zero first */
    v_char_make_gap_with (self, self->m_nentries, digitstr[0], zeros + digits);
    lauf= it;
    o=digwidth;
    for (i=0; i < digits; i++) {
        if (o == 0) {
            v_char_set (self, self->m_nentries - i - 1, digsep);
            o= digwidth;
        }
        else {
            v_char_set (self, self->m_nentries - i - 1, digitstr[lauf % base]);
            lauf/= base;
            o--;
        }
    }

    if (post)
        v_char_make_gap_with (self, self->m_nentries, rfiller, post);
}
#undef ULONG
#undef LONG
#endif /* defined(ERWIN_LONG_LONG) */



#define PERHAPS

#define GET_VA_ARG(DEST, VATYPE, PTRTYPE, REALTYPE)    \
            do {                                       \
                DEST= (REALTYPE)(va_arg (va, VATYPE)); \
            }                                          \
            while (0)

#define GET_VA_ARG1(DEST,TYPE) GET_VA_ARG(DEST, TYPE, TYPE, TYPE)


CODE_SECTION(".text.format_info_init")
void v_char_format_info_init
        (v_char_format_info_t *info)
{
#if E_GLOBAL_ERRNO
    return_if_null (info);
#endif
    info->quoted= 0;
    info->pos=    0;
}

CODE_SECTION(".text.format_info_done")
void v_char_format_info_done
        (v_char_format_info_t *info)
{
    (void)info; /*unused*/

#if E_GLOBAL_ERRNO
    return_if_null (info);
#endif
}

CODE_SECTION(".text.rovformat")
void v_char_rovformat
        (
    v_char_format_info_t *info,
    v_char_t *self,
    unsigned long options,
    char const *format,
    va_list va)
    /* FIXME: TODO:
     *     n
     *     I
     *     $
     *     ls
     *     S  == ls
     * Possibly also do floating point (currently passed through to libc)
     *     f, F, g, G, a, A
     */
{
    char       fbuff[E_HELP_BUFF_SIZE];
    char       sbuff[E_HELP_BUFF_SIZE];
    int         rep_flags[E_MAX_REP+1];
#if COMPAT_ERROR
    char const *orig_format;
    E_SET_PTR(orig_format, format);
#endif

    return_if_null2i_or_bad (self);

    if (info != NULL) {
        info->quoted= E_FALSE;
        info->pos= 0;
    }

    v_char_if_outofrange (format == NULL) {
        SET_ERRNO(E_OUTOFRANGE);
        return;
    }

    rep_flags[0]= 0;
    while (*format) {
        if (*format == '%') {
            char const *command_start;
            int   base=  0;
            int   overridden_base=  0;
            int   flags= 0;
            OpWidth ow= OW_INT;
            char lfiller= ' ';
            char rfiller= ' ';
            char digsep= ',';
            int   width=   0;
            int   prec=    0;
            int   variant= 0;
            int   digwidth= 3;
            char *c;
            char const *str_arg;
            v_char_cnt_t str_arglen;
            char char_arg;
            char  format_char;

            E_SET_PTR (command_start, format);

            if (options & E_FO_DO_USE_SEP) {
                digwidth= E_FO_GET_SEP_AT(options);
                if (digwidth == 0)
                    digwidth= 3;

                digsep= (char)E_FO_GET_USE_SEP(options);
                if (digsep == 0)
                    digsep= ',';

                flags|= FL_HAVE_SEP;
            }

            if (options & E_FO_CENTER)  flags|= FL_CENTER;
            if (options & E_FO_CHECK)   flags|= FL_CHECK;
            if (options & E_FO_UPCASE)  flags|= FL_UPCASE;
            if (options & E_FO_SPECIAL) flags|= FL_SPECIAL;
            /* if (options & E_FO_SIGNED) flags|= FL_SIGNED; */

            overridden_base= E_FO_GET_RADIX (options);
            format++;

            /* Read flags */
            for (;;format++) {
                switch (*format) {
                    case '#':  flags|= FL_SPECIAL;   continue;
                    case '0':  flags|= FL_ZERO;      continue;
                    case '-':  flags|= FL_LEFT;      continue;
                    case ' ':  flags|= FL_SPACE;     continue;
                    case '+':  flags|= FL_PLUS;      continue;
                    case 'I':  continue; /* currently ignored: normal decimals are used. */
                    /* SUSv2 (not C99): */
                    case '\'': digwidth= 3;
                               flags|= FL_HAVE_SEP;
                               continue;
                }
                break;
            }

            /* Read width */
            if (*format=='*') {
                GET_VA_ARG1 (width, int);
                format++;
                flags|= FL_HAVE_WIDTH;
                if (width < 0) {
                    flags|= FL_LEFT; /* set the minus flag according to GNU docu */
                    width= -width;
                }
            }
            else
                for (; v_char_elem_is_digit(*format); format++) {
                    width= (width * 10) + *format - '0';
                    flags|= FL_HAVE_WIDTH;
                }

            /* Modifiers with arguments */
            if (*format == '.') {
                /* Read precision */
                format++;
                if (*format=='*') {
                    GET_VA_ARG1 (prec, int);
                    format++;
                    if (prec >= 0)
                        flags|= FL_HAVE_PREC;
                }
                else {
                    flags|= FL_HAVE_PREC;
                    for (; v_char_elem_is_digit(*format); format++)
                        prec= (prec * 10) + *format - '0';
                }
                if (prec == 0 && (flags & FL_HAVE_PREC))
                    flags|= FL_NULL_PREC;
            }

            if ((flags & FL_HAVE_LFILLER) == 0)
                lfiller= rfiller;

            /* Operand width */
            switch (*format) {
            case 'l':
                format++;
                if (*format == 'l') {
                    format++;
                    ow= OW_LONG_LONG;
                }
                else
                    ow= OW_LONG;
                break;

            case 'q':
            case 'L': format++; ow= OW_LONG_LONG; break;

            case 'z':
            case 'Z': format++; ow= OW_SIZE_T;    break;

            case 'j': format++; ow= OW_INTMAX_T;  break;

            case 't': format++; ow= OW_PTRDIFF_T; break;

            case 'h':
                format++;
                if (*format == 'h') {
                    format++;
                    ow= OW_CHAR;
                }
                else
                    ow= OW_SHORT;
                break;
            }

            /* Actual format character */
            if (*format == '\0') /* NOT ZERO(self), this is the format string */
                return;          /* and not the data contained in the vector. */

            format_char= *format;

            /* Handle char-valued base specifications (especially handy for stringify): */
            if (overridden_base) {
                /* Float: */
                switch (format_char) {
                case 'a': case 'A':
                case 'e': case 'E':
                case 'f': case 'F':
                case 'g': case 'G':
                    switch (overridden_base) {
                    case 'a': case 'A':
                    case 'e': case 'E':
                    case 'f': case 'F':
                    case 'g': case 'G':
                        format_char= (char)overridden_base;
                        overridden_base= 0;
                        break;
                    }
                    break;

                /* Int: */
                case 'd': case 'i': case 'u':
                case 'o':
                case 'x': case 'X':
                    switch (overridden_base) {
                    case 'd': case 'i': case 'u':
                        overridden_base= 10;
                        break;

                    case 'o':
                        flags|= FL_SPECIAL;
                        overridden_base= 8;
                        break;

                    case 'X':
                        flags|= FL_UPCASE;
                    case 'x':
                        flags|= FL_SPECIAL;
                        overridden_base= 16;
                        break;

                    case 'B':
                        flags|= FL_UPCASE;
                    case 'b':
                        flags|= FL_SPECIAL;
                        overridden_base= 2;
                        break;
                    }
                    break;
                }
            }
            /* fprintf (stderr, "format_char='%c', overridden_base=%d\n",
             *   format_char, overridden_base); */

            switch (format_char) {
                /* The ugly floating point conversions first */
                case 'a': case 'A':
                case 'e': case 'E':
                case 'f': case 'F':
                case 'g': case 'G':
                    {
                        double f;
#ifdef ERWIN_LONG_DOUBLE
                        ERWIN_LONG_DOUBLE lf;
#endif

                        E_SET_PTR(c, fbuff);
                        *c++= '%';
                        if (flags & FL_SPECIAL) *c++= '#';
                        if (flags & FL_ZERO)    *c++= '0';
                        if (flags & FL_LEFT)    *c++= '-';
                        if (flags & FL_SPACE)   *c++= ' ';
                        if (flags & FL_PLUS)    *c++= '+';
                        *c++= '*';
                        *c++= '.';
                        *c++= '*';

                        if (!(flags & FL_HAVE_PREC)) prec= 6;

                        if (ow == OW_LONG_LONG) {
                            *c++= 'L';
                            *c++= format_char;
                            *c=   '\0';
#ifdef ERWIN_LONG_DOUBLE
                            GET_VA_ARG1 (lf, long double);

                            sprintf (sbuff, fbuff, width, prec, lf);
                            /* FIXME: does not work with WChar */
#else
                            SET_ERRNO(E_OUTOFRANGE);
                            return;
#endif
                        }
                        else {
                            *c++= format_char;
                            *c=   '\0';
                            if (ow == OW_LONG)
                                GET_VA_ARG1 (f, double);
                            else
                                GET_VA_ARG (f, double, float, double); /* FIXME: correct? */

                            sprintf (sbuff, fbuff, width, prec, f);
                        }

                        sbuff [v_char_tchar_strlen(sbuff)]= OZERO;   /* ZERO conversion */

                        /* Append the formatted string */
                        if ((options & E_FO_CHECK) == 0) {
                            return_if_fail_ppuu (sizeof (char) == sizeof(char),
                                self, sizeof(char), sizeof(char));
                            PERHAPS v_char_append_string (self, (char const *)sbuff);
                        }
                    }
                    break;

#if COMPAT_ERROR
                case '[':
                case ']':
                case '<':
                case '>':
                case ':':
                case '=':
                    errprint ((errstream,
                              "COMPATIBILITY ERROR: you used the now illegal character `%c' in your format string `%s'\n",
                              format_char, orig_format));
                    exit (1);
#endif

                /* Dec */
                case 'u':
                    flags|= FL_UNSIGNED;
                case 'd':
                case 'i':
                    base= 10;
                    break;

                /* Hex */
                case 'P':
                    flags|= FL_UPCASE;
                case 'p':
                    flags|= FL_SPECIAL;
                    switch (options & E_FO_S_TYPE_MASK) {
                    default:
                        SET_ERRNO(E_OUTOFRANGE);
                        return;

                    case E_FO_VECTOR:
                        goto case_string;

                    case E_FO_VOID_P:
                        /* fall-through: print as hex */
                        ow= OW_PTR;
                    }

                case 'x':
                    base= 16;
                    flags|= FL_UNSIGNED;
                    break;

                case 'X':
                    flags|= FL_UPCASE;
                    flags|= FL_UNSIGNED;
                    base= 16;
                    break;

                /* Octal */
                case 'o':
                    base= 8;
                    flags|= FL_UNSIGNED;
                    break;

                /*
                 * A character
                 * FIXME: Does not work for isWChar.
                 */
                case 'C':
                    ow= OW_LONG;
                case 'c': {
                        /* This is wrong an only implements the case were char = char.
                         *
                         * FIXME: a conversion from 'char' to 'char' is missing.
                         *
                         * FIXME: 'l' modifier is not implemented fully implemented,
                         *        the trivial case of char=wchar_t is missing.
                         *        (For char=char, the required invocation of
                         *        wcrtomb() already exists.)
                         */
                        if (ow == OW_LONG) {
#if defined(ERWIN_WIDE_CHARACTERS)
                            if (MB_CUR_MAX < E_HELP_BUFF_SIZE) {
                                wchar_t arg;
                                v_char_cnt_t len;
                                mbstate_t ps;

                                GET_VA_ARG (arg, wint_t, wchar_t, wchar_t);

                                memset ((void *)&ps, 0, sizeof (ps));
                                len= wcrtomb (sbuff, arg, &ps);
                                if ((options & E_FO_CHECK) == 0) {
                                    return_if_fail_ppuu (sizeof (char) == sizeof (char),
                                        self, sizeof(char), sizeof(char));
                                    E_SET_PTR(str_arg, (char const *)sbuff);
                                    str_arglen= -1;
                                    goto print_string;
                                    /* PERHAPS
                                     *     v_char_append_raw (self, (char const *)sbuff, len); */
                                }
                            }
                            else {
                                SET_ERRNO(E_OUTOFRANGE);
                                    /* too long (should never happen, since sbuff
                                     * is quite large) */
                                return;
                            }
#else
                            SET_ERRNO(E_OUTOFRANGE);
                            return;
#endif
                        }
                        else {
                            GET_VA_ARG (char_arg, int, char, char);
                            E_SET_PTR (str_arg, &char_arg);
                            str_arglen= 1;
                            goto print_string; /* handled like a string. */
                            /*if ((options & E_FO_CHECK) == 0)
                             *    PERHAPS v_char_append (self, arg); */
                        }
                    }
                    break;

                /* A string */
                case 's': {
                    case_string:
                       /* FIXME: a conversion from 'char const *' to 'char const *'
                        *        is missing, so this does not work for wchar_t vectors.
                        *        Use mbrtowc() for this.
                        *
                        * FIXME: 'l' modifier is not implemented.  (For char=char,
                        *        requires invocation of wcrtomb().)
                        */

                        switch (options & E_FO_S_TYPE_MASK) {
                        default:
                            SET_ERRNO(E_OUTOFRANGE);
                            return;

                        case E_FO_VOID_P: /* misnomer: should be E_FO_DEFAULT */
                            GET_VA_ARG1 (str_arg, char const *);
                            str_arglen= -1;
                            break;

                        case E_FO_VECTOR: {
                                v_char_t *v;
                                GET_VA_ARG1 (v, v_char_t *);
                                return_if_fail_ppuu (sizeof (char) == sizeof (char),
                                    self, sizeof(char), sizeof(char));
                                E_SET_PTR (str_arg, (char const *)v_char_as_open_array(v));
                                str_arglen= v_char_nentries (v);
                            }
                            break;
                        }

                    print_string:
                        if ((flags & FL_LEFT) && !(flags & FL_HAVE_WIDTH))
                            variant= 0; /* %-s: special case: switch off quotation */
                        else
                            variant= (options & E_FO_QUOTE_MASK);

                        PERHAPS v_char_append_quoted_string (
                           info, self, str_arg, str_arglen, flags,
                           lfiller, rfiller, width, prec, variant);
                    }
                    break;

                case 'm': /* libc5: strerror(errno) */
#if defined(ERWIN_STRERRNO)
                    /* If this is available, it is thread-safe.  The invocation
                     * is more efficient that ERWIN_GET_STRERRNO, so we prefer it. */
                    PERHAPS v_char_append_quoted_string (
                        info, self, ERWIN_STRERRNO, -1, flags,
                        lfiller, rfiller, width, prec, 0);
                            /* But no quotation, even for FO_QUOTE. */
#elif defined(ERWIN_GET_STRERRNO)
                    PERHAPS {
                        char msg[200];
                        ERWIN_GET_STRERRNO(msg,199);
                        msg[199]=0;
                        v_char_append_quoted_string (
                            info, self, msg, -1, flags,
                            lfiller, rfiller, width, prec, 0);
                                /* But no quotation, even for FO_QUOTE. */
                    }
#else
                    { int warning__no_strerror_errno; }
                    PERHAPS v_char_append_string (V_CHAR_STRING_LIT("unknown"));
#endif
                    break;

                default:
                    E_SET_PTR(format, command_start);
                case '%':
                    if ((options & E_FO_CHECK) == 0)
                        PERHAPS v_char_append  (self, (char)*format);
            }

            /* Is there an integer argument to print? */
            if (base > 0) {
                unsigned long data= 0;
#ifdef ERWIN_LONG_LONG
                ERWIN_UNSIGNED_LONG_LONG dataL= 0;
#endif /* defined(ERWIN_LONG_LONG) */

                if (overridden_base > 0)
                    base= overridden_base;

                if (width < 0)
                    width= 0;

                /* if (flags & FL_SIGNED) flags&= ~FL_UNSIGNED; */
                switch (ow) {
                    case OW_INT:
                        GET_VA_ARG (data, unsigned int, unsigned int, unsigned long);
                        data= EXTEND (data, SIZEOF_INT, flags & FL_UNSIGNED);
                        break;

                    case OW_SHORT:
                        GET_VA_ARG (data, unsigned int, unsigned short, unsigned long);
                        data= EXTEND (data, SIZEOF_SHORT, flags & FL_UNSIGNED);
                        break;

                    case OW_CHAR:
                        GET_VA_ARG (data, unsigned int, unsigned char, unsigned long);
                        data= EXTEND (data, 1, flags & FL_UNSIGNED);
                        break;

                    case OW_LONG:
                        GET_VA_ARG (data, unsigned long, unsigned long, unsigned long);
                        data= EXTEND (data, SIZEOF_LONG, flags & FL_UNSIGNED);
                        break;

                    /* size_t, intmax_t, ptrdiff_t may all exceed the size of 'long',
                     * so either use 'long' or 'long long': */
                    case OW_SIZE_T:
#if (SIZEOF_SIZE_T > 0) && (SIZEOF_SIZE_T <= SIZEOF_LONG)
                        GET_VA_ARG (data, size_t, size_t, unsigned long);
                        data= EXTEND (data, SIZEOF_SIZE_T, flags & FL_UNSIGNED);
#elif (SIZEOF_SIZE_T > 0) && defined(ERWIN_LONG_LONG)
                        GET_VA_ARG (dataL, size_t, size_t, unsigned long);
                        dataL= EXTEND_L (dataL, SIZEOF_SIZE_T, flags & FL_UNSIGNED);
#else
                        { int warning__no_such_type__size_t; }
                        SET_ERRNO(E_OUTOFRANGE);
                        return;
#endif
                        break;

                    case OW_INTMAX_T:
#if (SIZEOF_INTMAX_T > 0) && (SIZEOF_INTMAX_T <= SIZEOF_LONG)
                        GET_VA_ARG (data, intmax_t, intmax_t, unsigned long);
                        data= EXTEND (data, SIZEOF_INTMAX_T, flags & FL_UNSIGNED);
#elif (SIZEOF_INTMAX_T > 0) && defined(ERWIN_LONG_LONG)
                        GET_VA_ARG (dataL, intmax_t, intmax_t, ERWIN_UNSIGNED_LONG_LONG);
                        dataL= EXTEND_L (dataL, SIZEOF_INTMAX_T, flags & FL_UNSIGNED);
#else
                        { int warning__no_such_type__intmax_t; }
                        SET_ERRNO(E_OUTOFRANGE);
                        return;
#endif
                        break;

                    case OW_PTRDIFF_T:
#if (SIZEOF_PTRDIFF_T > 0) && (SIZEOF_PTRDIFF_T <= SIZEOF_LONG)
                        GET_VA_ARG (data, ptrdiff_t, ptrdiff_t, unsigned long);
                        data= EXTEND (data, SIZEOF_PTRDIFF_T, flags & FL_UNSIGNED);
#elif (SIZEOF_PTRDIFF_T > 0) && defined(ERWIN_LONG_LONG)
                        GET_VA_ARG (dataL, ptrdiff_t, ptrdiff_t, ERWIN_UNSIGNED_LONG_LONG);
                        dataL= EXTEND_L (dataL, SIZEOF_PTRDIFF_T, flags & FL_UNSIGNED);
#else
                        { int warning__no_such_type__ptrdiff_t; }
                        SET_ERRNO(E_OUTOFRANGE);
                        return;
#endif
                        break;

                    case OW_PTR: {
                            void *dataptr;
                            GET_VA_ARG1 (dataptr, void *);
                            if (dataptr != NULL) {
#if SIZEOF_VOIDP <= SIZEOF_LONG
                                data= (unsigned long) dataptr;
                                ow= OW_LONG;
#elif defined(ERWIN_LONG_LONG)
                                dataL= (ERWIN_UNSIGNED_LONG_LONG) dataptr;
                                ow= OW_LONG_LONG;
#else
                                data= (unsigned long) dataptr;
                                ow= OW_LONG;
#endif /* SIZEOF_VOIDP */
                            }
                        }
                        break;

                    case OW_LONG_LONG:
#ifdef ERWIN_LONG_LONG
                        GET_VA_ARG1 (dataL, ERWIN_UNSIGNED_LONG_LONG);
                        break;
#else
                        { int warning__no_such_type__long_long; }
                        SET_ERRNO(E_OUTOFRANGE);
                        return;
#endif /* defined(ERWIN_LONG_LONG) */
                }

                PERHAPS {
                    switch (ow) {
                        case OW_PTR:
                            if ((options & E_FO_CHECK) == 0) {
                                return_if_fail_ppuu (sizeof (char) == sizeof (char),
                                    self, sizeof(char), sizeof(char));
                                v_char_append_string (self,
                                    (char const *)V_CHAR_STRING_LIT ("(nil)"));
                            }
                            break;

#ifdef ERWIN_LONG_LONG
#  if SIZEOF_SIZE_T > SIZEOF_LONG
                        case OW_SIZE_T:
#  endif
#  if SIZEOF_INTMAX_T > SIZEOF_LONG
                        case OW_INTMAX_T:
#  endif
#  if SIZEOF_PTRDIFF_T > SIZEOF_LONG
                        case OW_PTRDIFF_T:
#  endif
                        case OW_LONG_LONG:
                            if ((options & E_FO_CHECK) == 0)
                                v_char_append_longlong (self, dataL, base, flags,
                                                        lfiller, rfiller,
                                                        width, prec,
                                                        digwidth, digsep);
                            break;
#endif /* defined(ERWIN_LONG_LONG) */

                        default:
                            if ((options & E_FO_CHECK) == 0)
                                v_char_append_long (self, data, base, flags,
                                                    lfiller, rfiller,
                                                    width, prec,
                                                    digwidth, digsep);
                            break;
                    }
                }
            }
            format++;
        }
        else {
            if ((options & E_FO_CHECK) == 0)
                PERHAPS v_char_append (self, *format);
            format++;
        }
    }
}

#undef PERHAPS
#undef GET_VA_ARG
#undef GET_VA_ARG1

#if !E_GLOBAL_ERRNO
#  define v_char_global_last_format NULL
#else
#  define v_char_global_last_format (&v_char_last_format)
#endif


CODE_SECTION(".text.format")
void v_char_format
        (v_char_t *it, char const *format, ...)
{
    va_list ap;
    va_start (ap, format);
    v_char_rovformat (v_char_global_last_format, it, 0, format, ap);
    va_end (ap);
}

CODE_SECTION(".text.oformat")
void v_char_oformat
        (v_char_t *it, unsigned long options, char const *format, ...)
{
    va_list ap;
    va_start (ap, format);
    v_char_rovformat (v_char_global_last_format, it, options, format, ap);
    va_end (ap);
}

CODE_SECTION(".text.vformat")
void v_char_vformat
        (v_char_t *it, char const *format, va_list ap)
{
    v_char_rovformat (v_char_global_last_format, it, 0, format, ap);
}

CODE_SECTION(".text.ovformat")
void v_char_ovformat
        (v_char_t *it, unsigned long options, char const *format, va_list ap)
{
    v_char_rovformat (v_char_global_last_format, it, options, format, ap);
}

CODE_SECTION(".text.roformat")
void v_char_roformat
        (
    v_char_format_info_t *info,
    v_char_t *it,
    unsigned long options,
    char const *format, ...)
{
    va_list ap;
    va_start (ap, format);
    v_char_rovformat (info, it, options, format, ap);
    va_end (ap);
}

#endif /* V_CHAR_NO_FORMAT == 0 */

/* ********************************************************************** */
/* ********************************************************************** */
/* ********************************************************************** */



#endif /* !defined(PASS2) */
#ifndef PASS1

#ifdef __cplusplus

#define self (this->it())


CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (void)
{
    E_BOOL ok= v_char_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_ppt (ok, this, "v_char_init_internal_q failed");
}

CODE_SECTION(".text._constructor")
void v_char_t::_constructor
        (void)
{
    E_BOOL ok= v_char_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_ppt (ok, this, "v_char_init_internal_q failed");
}

CODE_SECTION(".text.static_zero")
v_char_t const & v_char_t::static_zero
        ()
{
    static v_char_t const *z= NULL;
    if (ERWIN_UNLIKELY(!z))
        E_SET_PTR(z, new v_char_t);
    return *z;
}

#if V_CHAR_HAVE_INT_CONSTRUCTOR
CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_cnt_t initial_size)
{
    if (initial_size < 0)
        initial_size= GET_INITIAL_SIZE;
                                                        
    E_BOOL ok= v_char_init_internal_q (it(), OZERO, initial_size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* V_CHAR_HAVE_INT_CONSTRUCTOR */

#if V_CHAR_DYN_ZERO
CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (char  z)
{
    E_BOOL ok= v_char_init_internal_q (it(), z, GET_INITIAL_SIZE);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}


CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (char  z, v_char_cnt_t initial_size)
{
    if (initial_size < 0)
        initial_size= GET_INITIAL_SIZE;

    E_BOOL ok= v_char_init_internal_q (it(), z, initial_size);
    (void)ok; /*unused*/
    return_if_fail_pp (ok, this);
}
#endif /* V_CHAR_DYN_ZERO */


CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_t const &other, bool docopy)
{
    return_if_null_pp (&other, this);
#ifdef ERWIN_DOS
    if (TABLE(&other) == NULL && other.m_nentries == 0) {
        /* Because of the braindead Windos linker, object initialisation order
         * might be wrong, we must expect uninitialised m_zero elements here.
         * It does not help to sort the objects manually since the linker
         * reorders them (most notably: possibly in the wrong way) */
        v_char_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    }
    else
#endif
    {
        v_char_init_internal_q (it(), ZERO(other.it()), COPY_SIZE(other.it()));
        if (docopy)
            v_char_insert_vector (it(), 0, other.it());
        else
            v_char_insert_no_copy (it(), 0, TABLE(&other), other.m_nentries);
    }
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_t const *other, bool docopy)
{
    return_if_null_pp (other, this);
    v_char_init_internal_q (it(), ZERO(other->it()), COPY_SIZE(other->it()));
    if (docopy)
        v_char_insert_vector (it(), 0, other->it());
    else
        v_char_insert_no_copy (it(), 0, TABLE(other), other->m_nentries);
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_t const &other, v_char_index_t start, v_char_cnt_t count, bool docopy)
{
    return_if_null_pp (&other, this);
    v_char_init_internal_q (it(), ZERO(other.it()), COPY_SIZE(other.it()));
    v_char_insert_subvector (it(), 0, other.it(), start, count, docopy);
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_t const *other, v_char_index_t start, v_char_cnt_t count, bool docopy)
{
    return_if_null_pp (other, this);
    v_char_init_internal_q (it(), ZERO(other->it()), COPY_SIZE(other->it()));
    v_char_insert_subvector (it(), 0, other->it(), start, count, docopy);
}

#ifdef ERWIN_COMPAT_2_0_264
CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_t const *other, v_char_index_t start, v_char_cnt_t count, bool docopy)
{
    return_if_null_pp (other, this);
    v_char_init_internal_q (it(), ZERO(other), COPY_SIZE(other));
    v_char_insert_subvector (it(), 0, other, start, count, docopy);
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (v_char_t const *other, bool docopy)
{
    return_if_null_pp (other, this);
    v_char_init_internal_q (it(), ZERO(other), COPY_SIZE(other));
    if (docopy)
        v_char_insert_vector (it(), 0, other);
    else
        v_char_insert_no_copy (it(), 0, TABLE(other), other->m_nentries);
}
#endif /* defined(ERWIN_COMPAT_2_0_264) */

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (char const *other, bool docopy)
{
    /* other == NULL is explicitly allowed to represent an empty string. */
    v_char_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    if (docopy)
        v_char_insert_string (it(), 0, other);
    else
        v_char_insert_no_copy (it(), 0, other, v_char_string_length (it(), other));
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (char const *other, v_char_cnt_t n, bool docopy)
{
    /* other == NULL is explicitly allowed if n == 0. */
    v_char_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    if (docopy)
        v_char_insert_raw (it(), 0, other, n);
    else
        v_char_insert_no_copy (it(), 0, other, n);
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (bool must_be_true, char *other, v_char_cnt_t count, v_char_cnt_t alloc)
{
    (void)must_be_true; /*unused*/

    v_char_init_from_q (it(), other, count, alloc, OZERO);
    return_if_fail_pp (must_be_true, this);
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (bool must_be_true, v_char_t *other)
{
    (void)must_be_true; /*unused*/

    v_char_init_from_q (it(),
        TABLE(other),
        other->nentries(),
        other->table_size(),
        other->zero());
    other->detach();
    return_if_fail_pp (must_be_true, this);
}

CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (bool must_be_true, v_char_t &other)
{
    (void)must_be_true; /*unused*/

    v_char_init_from_q (it(),
        TABLE(&other),
        other.nentries(),
        other.table_size(),
        other.zero());
    other.detach();
    return_if_fail_pp (must_be_true, this);
}

#if V_CHAR_DYN_ZERO
CODE_SECTION(".text.t")
 v_char_t::v_char_t
        (bool must_be_true, char *other, v_char_cnt_t count, v_char_cnt_t alloc, char  z)
{
    (void)must_be_true; /*unused*/

    v_char_init_from_q (it(), other, count, alloc, z);
    return_if_fail_pp (must_be_true, this);
}
#endif /* V_CHAR_DYN_ZERO */



CODE_SECTION(".text.v_char_t")
 v_char_t::~v_char_t
        ()
{
    v_char_destroy (it());
}


CODE_SECTION(".text._destructor")
void v_char_t::_destructor
        ()
{
    v_char_destroy (it());
}

#if !ERWIN_DEFAULT_NEW_DELETE

CODE_SECTION(".text.operatornew")
void * v_char_t::operator new
        (size_t s)
{
    return ERWIN_PREFER_TNEW(void, s);
}

CODE_SECTION(".text.operatordelete")
void v_char_t::operator delete
        (void *p, size_t s)
{
    ERWIN_PREFER_TDELETE(p, void, s);
}

CODE_SECTION(".text.operatornew")
void * v_char_t::operator new[]
        (size_t s)
{
    return ERWIN_PREFER_TNEW(void, s);
}

CODE_SECTION(".text.operatordelete")
void v_char_t::operator delete[]
        (void *p, size_t s)
{
    ERWIN_PREFER_TDELETE(p, void, s);
}

#endif /* !ERWIN_DEFAULT_NEW_DELETE */

CODE_SECTION(".text.operator")
v_char_t & v_char_t::operator=
        (v_char_t const &other)
{
    v_char_destroy (it());
#ifdef ERWIN_DOS
    if (TABLE(&other) == NULL && other.m_nentries == 0) {
        /* See copy constructor for explanation */
        v_char_init_internal_q (it(), OZERO, GET_INITIAL_SIZE);
    }
    else
#endif
    {
        v_char_init_internal_q (it(), v_char_zero (other.it()), GET_INITIAL_SIZE);
        v_char_insert_vector (it(), 0, other.it());
    }
    return *this;
}

CODE_SECTION(".text.operator")
v_char_t & v_char_t::operator=
        (v_char_t const *other)
{
    v_char_destroy (it());
    v_char_init_internal_q (it(), v_char_zero (other->it()), GET_INITIAL_SIZE);
    v_char_insert_vector (it(), 0, other->it());
    return *this;
}

#ifdef ERWIN_COMPAT_2_0_264
CODE_SECTION(".text.operator")
v_char_t & v_char_t::operator=
        (v_char_t const *other)
{
    v_char_destroy (it());
    v_char_init_internal_q (it(), v_char_zero (other), GET_INITIAL_SIZE);
    v_char_insert_vector (it(), 0, other);
    return *this;
}
#endif /* defined(ERWIN_COMPAT_2_0_264) */


#if V_CHAR_NO_FORMAT == 0

CODE_SECTION(".text.format")
v_char_t & v_char_t::format
        (char const *formstr, ...)
{
    va_list ap;
    va_start (ap, formstr);
    v_char_rovformat (v_char_global_last_format, it(), 0, formstr, ap);
    va_end (ap);
    return *this;
}

CODE_SECTION(".text.vformat")
v_char_t & v_char_t::vformat
        (char const *formstr, va_list args)
{
    v_char_rovformat (v_char_global_last_format, it(), 0, formstr, args);
    return *this;
}

CODE_SECTION(".text.format")
v_char_t & v_char_t::format
        (unsigned long options, char const *formstr, ...)
{
    va_list ap;
    va_start (ap, formstr);
    v_char_rovformat (v_char_global_last_format, it(), options, formstr, ap);
    va_end (ap);
    return *this;
}

CODE_SECTION(".text.vformat")
v_char_t & v_char_t::vformat
        (unsigned long options, char const *formstr, va_list args)
{
    v_char_rovformat (v_char_global_last_format, it(), options, formstr, args);
    return *this;
}

CODE_SECTION(".text.format")
v_char_t & v_char_t::format
        (
    v_char_format_info_t *info,
    unsigned long options,
    char const *formstr,
    ...)
{
    va_list ap;
    va_start (ap, formstr);
    v_char_rovformat (info, it(), options, formstr, ap);
    va_end (ap);
    return *this;
}

CODE_SECTION(".text.vformat")
v_char_t & v_char_t::vformat
        (
    v_char_format_info_t *info,
    unsigned long options,
    char const *formstr,
    va_list args)
{
    v_char_rovformat (info, it(), options, formstr, args);
    return *this;
}

#if E_GLOBAL_ERRNO


CODE_SECTION(".text.format_pos")
v_char_index_t v_char_t::format_pos
        (void)
{
    return v_char_last_format.pos;
}


CODE_SECTION(".text.format_quoted")
bool v_char_t::format_quoted
        (void)
{
    return ERWIN_TO_BOOL(v_char_last_format.quoted);
}

#endif /* E_GLOBAL_ERRNO */

#endif /* V_CHAR_NO_FORMAT == 0 */


#ifndef NDEBUG

CODE_SECTION(".text.cn")
void v_char_t::cn
        () const
{
    return_if_null_or_bad (this);
}

CODE_SECTION(".text.cn")
void v_char_t::cn
        (void const *p) const
{
    return_if_null_or_bad (this);
    return_if_null_pp (p, this);
}
#endif /* !defined(NDEBUG) */

#undef self

#endif /* defined(__cplusplus) */


#endif /* !defined(PASS1) */

#undef IS_ZERO
#undef ISNT_ZERO
#undef ZERO
#undef ZEROVAR
#undef ASSERTION_FAILED
#undef QUOTATION_METHOD_CNT
#undef VECTOR_NOMEM
#undef errno
#undef FATAL_ERROR
#undef COMPAT_ERROR
#undef v_char_global_last_format
#undef errstream
#undef errprint
#undef PASS1
#undef PASS2

#undef E_ASSERTIONFAILED
#undef E_BOOL
#undef e_char_is_cr0
#undef e_char_is_digit
#undef e_char_is_print
#undef e_char_is_space0
#undef e_char_is_xdigit
#undef e_char_to_lower
#undef e_char_to_upper
#undef E_COMPAT_2_0_264
#undef E_COMPILING
#undef E_DEFAULT_NEW_DELETE
#undef E_EMPTY
#undef E_ERROR_PRINT
#undef E_ERROR_STREAM
#undef e_erwininternalvectorerrno
#undef E_FALSE
#undef E_FILE_IDS
#undef E_FO_CENTER
#undef E_FO_CHECK
#undef E_FO_DO_USE_SEP
#undef E_FO_GET_RADIX
#undef E_FO_GET_SEP_AT
#undef E_FO_GET_USE_SEP
#undef E_FO_QUOTE_MASK
#undef E_FO_QUOTE_USER1
#undef E_FO_QUOTE_USER2
#undef E_FO_QUOTE_USER3
#undef E_FO_QUOTE_USER_MAX
#undef E_FO_QUOTE_USER_MIN
#undef E_FO_SIGNED
#undef E_FO_SPECIAL
#undef E_FO_S_TYPE_MASK
#undef E_FO_UPCASE
#undef E_FO_VECTOR
#undef E_FO_VOID_P
#undef E_GLOBAL_ERRNO
#undef E_HASH_INIT
#undef e_hash_state_t
#undef e_hashval_t
#undef e_int_hash
#undef E_IO
#undef e_merge_sort
#undef e_next_power2_minus1
#undef E_NOMEM
#undef E_NOTCOMPILED
#undef E_OK
#undef E_OPERATOR_NEW_CLEARS_MEMORY
#undef E_OUTOFRANGE
#undef E_PREFER_TDELETE
#undef E_PREFER_TNEW
#undef E_SET_PTR
#undef E_STATE_GET_HASHVAL
#undef E_STATE_INIT_WITH
#undef E_STATE_MIX_ORDERED
#undef E_TFREE1
#undef E_TFREE_ARRAY
#undef E_TFREE_ATOMS
#undef E_THING_DELETE1
#undef E_THING_DELETE_ARRAY
#undef E_THING_DELETE_ATOMS
#undef E_THING_NEW1
#undef E_THING_NEW_ARRAY
#undef E_THING_NEW_ATOMS
#undef E_THING_RENEW_ARRAY
#undef E_THING_RENEW_ATOMS
#undef E_THREAD_SAFE
#undef E_TMALLOC1
#undef E_TMALLOC_ARRAY
#undef E_TMALLOC_ATOMS
#undef E_TO_BOOL
#undef E_TOOLARGE
#undef E_TREALLOC_ARRAY
#undef E_TREALLOC_ATOMS
#undef E_TRUE
#undef E_USE_MUTABLE
#undef E_VERBOSE
#undef OBEING_USED
#undef OCMP
#undef OCONSTRUCTOR
#undef OCOPY
#undef OCOPY_PROVIDED
#undef ODESTRUCTOR
#undef OEQUAL
#undef OFREE
#undef OFREE_PROVIDED
#undef OHASH
#undef OPRIORITY_CMP
#undef OUPDATE_POS2
#undef OUPDATE_POS
#undef OZERO

