dnl -*- Mode: M4 -*-
dnl Include common.m4 first!
dnl
dnl This file defines M4 Makros for writing Makefiles and Makefile.ams.
dnl
divert(-1)dnl

define([_makefile_header_stream],[0])
define([_makefile_user_rule_stream],[1])
define([_makefile_std_rule_stream],[2])
define([_makefile_late_rule_stream],[3])
define([_makefile_trailer_stream],[4])
define([_makefile_am_mode],[])

dnl
dnl check whether a file has changed and possibly rename it.
dnl     $1: new file
dnl     $2: old file to be either overwritten or kept if nothing changed
dnl
define([check_move2], [$(MOVE) [$1] [$2]])


dnl
dnl same as check_move2 assuming the new file is called old_file.new.
dnl     $1: name of the old file
dnl
define([check_move],[check_move2([$1.new], [$1])])

define([try_move],[if test -s [$1].new; then mv [$1].new [$1]; fi
	-rm -f [$1].new])

dnl
dnl generate a file
dnl     $1: generator program
dnl     $2: new file (will be created with .new appended)
dnl     $3: old file
dnl     $4: optional: an option defining the output file
dnl     ... optional: additional dependencies (deprecated, use additional rules)
dnl
define([_generate],
[[$2]: [$2].stamp
[$2].stamp: [$3] _shift3($@)
	ifelse([$4],,[[$1] [$3] > [$2].new],[[$1] [$4] [$2].new [$3]])
	echo timestamp > [$2].stamp])

dnl
dnl generate a file and check whether it has changed.
dnl
define([generate_check],
[_generate($@)
	check_move([$2])])

dnl
dnl How to include the Erwin sub-directory in a distribution file
dnl This is for use with Automake's dist-hook rule.
dnl'
define([dist_include_erwin],
   [mkdir $(distdir)/erwin
	cd $(ERWIN) && $(MAKE) listdirs
	-for i in `cat $(ERWIN)/listdirs` ; do \
		test -d $(distdir)/erwin/$$i || mkdir $(distdir)/erwin/$$i ; \
	done
	-rm -f $(ERWIN)/listdirs
	cd $(ERWIN) && $(MAKE) listdistfiles
	@for i in `cat $(ERWIN)/listdistfiles` ; do \
		cp -p $(srcdir)/erwin/$$i $(distdir)/erwin/$$i ; \
	done
	-rm -f $(ERWIN)/listdistfiles])

dnl
dnl Add standard clean targets.  Most notably, user targets may be added by
dnl defining TARGET-user: rules.
dnl
define([sweep_files],[])
define([mostlyclean_files],[])
define([clean_files],[])
define([distclean_files],[])
define([maintainer_clean_files],[])
define([std_clean],
[
.PHONY: dummy sweep sweep-recursive sweep-am mclean clean-user \
        mostlyclean-user develclean safeclean safeclean-user \
        develclean-user maintainer-clean-user mclean \
        sweep-std mostlyclean-std maintainer-clean-std \
        develclean-std distclean-std distclean-user \
        develclean-recursive develclean-am

sweep-recursive:
        @set fnord $(MAKEFLAGS); amf=$$[]2; \
        dot_seen=no; \
        rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
          rev="$$subdir $$rev"; \
          test "$$subdir" = "." && dot_seen=yes; \
        done; \
        test "$$dot_seen" = "no" && rev=". $$rev"; \
        target=`echo $[]@ | sed s/-recursive//`; \
        for subdir in $$rev; do \
          echo "Making $$target in $$subdir"; \
          if test "$$subdir" = "."; then \
            local_target="$$target-am"; \
          else \
            local_target="$$target"; \
          fi; \
          (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
           || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
        done && test -z "$$fail"

sweep: sweep-recursive
sweep-user:
sweep-am: sweep-user sweep-std
sweep-std:
	-rm -f *~ *.bak \#* .*~ core sweep_files

clean-am: clean-user 
clean-user:

mclean: mostlyclean
	clear || :

mostlyclean-am: mostlyclean-user mostlyclean-std
mostlyclean-std:
## The stamps are typically generated by move_if_changed:
	-rm -f *.stamp mostlyclean_files

mostlyclean-user: safeclean-user

safeclean: mostlyclean
safeclean-user:

distclean-recursive: sweep-recursive
distclean-am: distclean-user distclean-std sweep-am
distclean-user:
distclean-std:
ifelse(distclean_files,,,
[	-rm -f distclean_files])

develclean-recursive: maintainer-clean-recursive
develclean-am: maintainer-clean-am
develclean: maintainer-clean
develclean-user:

maintainer-clean-am: maintainer-clean-user maintainer-clean-std
maintainer-clean-std:
## Obviously, we are using .am4 (otherwise, this macro would not be
## called), so we delete the .am file:
	-rm -f ifelse(_makefile_am_mode,,,Makefile.am) maintainer_clean_files
	-rm -f .desktop.el* configure Makefile.in

maintainer-clean-user: develclean-user

dummy:
])

dnl
dnl Indicate that this is generated output.
dnl
define([m4_input],[Generated automatically by M4])

dnl
dnl Compilation rules for several types of files.  Named after the usual shell
dnl command (starting with an underbar) or the extensions.
dnl

dnl LaTeX
define([_latex_deps],[])
define([_latex],
[define([_latex_deps], _latex_deps[ .deps/[$1].ltP])dnl
[$1].aux:
	$(LATEX) [$1].tex

[$1].dvi: [$1].tex [$1].aux
	$(LATEX) [$1].tex
])

define([_tex_dvi],defn([_latex]))

define([_dvips],
[[$1].ps: [$1].dvi
	$(DVIPS) [$1].dvi -o [$1].ps])

define([_dvi_ps],defn([_dvips]))

define([_tex_ps],
[_tex_dvi($@)
_dvi_ps($@)])

dnl Bison & Flex
dnl FIXME: continue

dnl
dnl Makefile_mode
dnl       - for Makefile.m4
dnl
dnl Makefile_am_mode
dnl       - for Makefile.am4
dnl
dnl       switches on the output (to stream #0) and outputs the line
dnl       # -*- Mode: Fundamental -*-
dnl       to reduce the likelyness of accidentally editing the generated file.
dnl
dnl       Then switches to stream #1 to add several interesting
dnl       things.
dnl
dnl This defines the variable MAKEFILE to be $(top_srcdir)/utils/makemake.
dnl That program is used in maintainer mode to automatically re-generate
dnl the Makefile.am.  If the path is different in your program, either
dnl re-define MAKEMAKE in the Makefile.am4, or to set it globally, re-define
dnl the M4 variable makemake_path in your mmlocal.m4 (or any of the mm*.m4
dnl files).
dnl

define([makemake_path],[./utils/makemake])dnl Read the above comment!
define([_extra_dist_std_files],[])

dnl
dnl For Makefile.am4:
define([Makefile_am_mode],
[define([_makefile_am_mode], 1)dnl
divert(_makefile_header_stream)dnl
# -*- Mode: Fundamental -*-
# Generated automatically by M4
# DO NOT EDIT

MAKEMAKE=makemake_path

EXTRA_DIST_USER=
EXTRA_DIST_STD=
EXTRA_DIST= Makefile.am4 $(EXTRA_DIST_USER) $(EXTRA_DIST_STD)
define([EXTRA_DIST],[EXTRA_DIST_USER])

divert(_makefile_std_rule_stream)

ifelse(_makefile_am_mode,,,
[if MAINTAINER_MODE
Makefile.am: Makefile.am4
	cd $(top_srcdir) && CONFIG_DIRS=$(srcdir)/$(subdir) $(MAKEMAKE)
endif
])

std_clean

m4wrap([[]end_Makefile[]])
divert(_makefile_user_rule_stream)
])

dnl
dnl for Makefile.m4:
define([Makefile_mode],
[define([_makefile_am_mode],[])dnl
divert(_makefile_header_stream)dnl
# -*- Mode: Fundamental -*-
# Generated automatically by M4
# DO NOT EDIT

m4wrap([[]end_Makefile[]])
])


dnl
dnl     end_Makefile      - possibly adds missing things.
dnl                         Currently empty.
dnl
define([end_Makefile],[
ifelse(_makefile_am_mode,,,
[divert(_makefile_header_stream)
EXTRA_DIST_STD=_extra_dist_std_files
divert(_makefile_trailer_stream)
])])


dnl
dnl Files that can be deleted when latex was used.
dnl
define([latex_clean_files],[*.dvi *.ps *.aux *.log *.bbl *.blg *.idx *.toc])

dnl
dnl Autogenerate dependencies of Latex.  Requires AM_CONDITIONs for HAVE_GNUMAKE
dnl and HAVE_PERL
dnl
dnl You can redefine the latex_deps_path to match your own package structure.
dnl
dnl This must be given after all _latex macro commands!
dnl
define([latex_deps_path], [$(top_srcdir)/utils/latex_deps])
define([make_latex_deps],
[
divert(_makefile_header_stream)
if HAVE_GNUMAKE
if HAVE_PERL

LATEX_DEPS= latex_deps_path
LATEX_DEP_FILES= _latex_deps
LATEX_DEPS_MAGIC:= $(shell mkdir .deps > /dev/null 2>&1 || :)

endif
endif

divert(_makefile_std_rule_stream)
if HAVE_GNUMAKE
if HAVE_PERL

-include $(LATEX_DEP_FILES)

%.dvi: .deps/%.ltP

.deps/%.ltP: %.tex
	-$(LATEX_DEPS) $< > $[]@

endif
endif

divert(_makefile_user_rule_stream)
])

dnl
dnl std_latex: generate LaTeX specific rules.
dnl The parameters are the names of the ps files to generate (without extension).
dnl X.ps will be generated from X.tex.  Dependencies will be automatically
dnl generated so the files will automatically re-compile when needed.
dnl
define([std_latex],
[
divert(_makefile_header_stream)
LATEX=@LATEX@
DVIPS=@DVIPS@

psdocdir=$(datadir)/doc/$(PACKAGE)/ps
psdoc_DATA=flatten_spaced(add_suffix([.ps],$@))

dnl Define more distribution files (the .tex files belong to the distribution)
define([_extra_dist_std_files],
    _extra_dist_std_files[ ]flatten_spaced(add_suffix([.tex],$@)))

dnl Generate .ps from .tex for each file.
_flatten(_map([_tex_ps],$@))

divert(_makefile_std_rule_stream)
clean-user: clean-latex
clean-latex:
	-rm -f latex_clean_files

maintainer-clean-user: maintainer-clean-latex
maintainer-clean-latex:
	-rm -rf .deps

# include the LaTeX dependency files in the distribution
dist-hook: dist-hook-latex
dist-hook-latex: $(LATEX_DEP_FILES)
	cat $(LATEX_DEP_FILES) >> $(distdir)/Makefile.in

m4wrap([[]make_latex_deps[]])
divert(_makefile_user_rule_stream)
])


dnl
dnl Add rules for Erwin subdirectory:
dnl     - add it to the distribution
dnl     - clean it up
dnl ERWIN is assumed to be in erwin subdirectory.  This can be changed
dnl by redefining the automake variable ERWIN (or globally by changing
dnl the erwin_subdir variable).
dnl
define([erwin_subdir],[erwin])
define([std_erwin],
[
divert(_makefile_header_stream)
ERWIN=erwin_subdir

divert(_makefile_std_rule_stream)

## Add Erwin to the distribution.
dist-hook: dist-hook-erwin
dist-hook-erwin:
	dist_include_erwin

## Clean-up
mostlyclean-recursive: mostlyclean-erwin
mostlyclean-erwin:
	-cd $(ERWIN) && $(MAKE) safeclean

clean-recursive: clean-erwin
clean-erwin:
	-cd $(ERWIN) && $(MAKE) clean

distclean-recursive: distclean-erwin
distclean-erwin:
	-cd $(ERWIN) && $(MAKE) distclean

maintainer-clean-recursive: maintainer-clean-erwin
maintainer-clean-erwin:
	-rm -rf $(ERWIN)

divert(_makefile_user_rule_stream)
])
