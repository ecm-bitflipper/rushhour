dnl -*- Mode: M4 -*-
divert(-1)dnl
dnl
dnl Common definitions
dnl
dnl  Author: Henrik Theiling
dnl
dnl  Description: General definitions for all output languages.
dnl
dnl Copyright (c) 1999-2000 Henrik Theiling
dnl
dnl The term 'this software' used in the following, additional to its
dnl usual usage, also includes the instantiated source files generated by
dnl tools from this package.
dnl
dnl This software is provided 'as-is', without warranty of any kind,
dnl express or implied.  In no event will the authors or copyright holders
dnl be held liable for any damages arising from the use of this software.
dnl
dnl Permission is granted to anyone to use this software for any purpose,
dnl including commercial applications, and to alter it and redistribute it
dnl freely, subject to the following restrictions:
dnl
dnl 1. The origin of this software must not be misrepresented; you must
dnl not claim that you wrote the original software. If you use this
dnl software in a product, an acknowledgment in the product documentation
dnl would be appreciated but is not required.
dnl
dnl 2. Altered source versions must be plainly marked as such, and must
dnl not be misrepresented as being the original software.
dnl
dnl 3. You must not use any of the names of the authors or copyright
dnl holders of the original software for advertising or publicity
dnl pertaining to distribution without specific, written prior permission.
dnl
dnl 4. This notice may not be removed or altered from any source
dnl distribution.
dnl
dnl This licence is governed by the Laws of Germany.  Disputes shall be
dnl settled by Saarbruecken City Court.
dnl

dnl
dnl
dnl This defines the following macros:
dnl
dnl New macros and some renamed M4 ones always contain at least one underscore.
dnl
dnl     _shift            - renamed internal shift
dnl     _format           - renamed internal format
dnl     _define           - like internal define but with dnl at the end.
dnl
dnl     _deflist          - like _define, but $1 is defined to be the list _shift($@)
dnl
dnl     _shift2           - shift twice
dnl     _shift3           - shift three times
dnl     _shift4           - shift four times
dnl
dnl     make_list($1,$2)  - generate a list with two items, $1 and $2
dnl
dnl     _split($1,...)    - split a list into two lists according to pattern $1.  Returns
dnl                          two values: the first list contains the matching items, the
dnl                          second the others.
dnl
dnl     _append($1,$2)    - append $2 to the list $1 ($1 is a name)
dnl
dnl     _map($1,...)      - apply function $1 to all elements
dnl
dnl     _mapn($1,$2,...)  - apply an n-ary function $1 to all elements.  The first argument
dnl                         is taken from the list, the others are taken from $2.  $2 must
dnl                         therefore be a list.
dnl
dnl     _flatten(...)     - append all items into one string.  Essentially, this deletes
dnl                         commas. :-)
dnl
dnl     flatten_spaced(...)
dnl                       - like _flatten, but inserts white space in between.
dnl
dnl     flatten_nl_tab(...)
dnl                       - like _flatten, but inserts a new line and a tab in between
dnl                         (for commands in Makefile rules)
dnl
dnl     flatten_with($1,...)
dnl                       - like _flatten, but inserts $1 in between.
dnl
dnl     add_prefix($1,...)
dnl                       - prepend the string $1 to all the elements of the list
dnl
dnl     add_suffix($1,...)
dnl                       - append the string $1 to all the elements of the list
dnl
dnl     _atomic(...)      - quote forever.  _atomic(...) always evaluates to itself,
dnl                         so the arguments are never evaluated again.  Unfortunately,
dnl                         it is impossible to remove the _atomic call itself in one
dnl                         pass.  Instead another m4 must be called.  See makedoc.pl
dnl                         to an example.
dnl
dnl NOTE: _atomic can only be used during the documentation generated, not during
dnl       generation of Makefile.in since there is no second pass in makemake.sh.
dnl

dnl Quoting with brackets is nicer.
changequote([, ])

dnl
dnl Undefine things that are too much like text.
define([_shift],defn([shift]))
undefine([shift])

define([_format],defn([format]))
undefine([format])

define([_symbols],defn([symbols]))
undefine([symbols])

define([_define],[ifelse($#,1,[define([$1])],[define([$1],[$2])])dnl[]])

define([_deflist],[_define([$1],[_shift($@)])])

dnl
dnl Make a list of two items.
dnl
define([make_list],[[$1],[$2]])

dnl Split list into two lists according to a pattern.
dnl
dnl E.g.
dnl    split([^a],[a1],[b2],[a3],[b4]) -> [[a1],[a3]],[[b2],[b4]]
dnl
define([_split],[dnl
pushdef([accu1],[])dnl
pushdef([accu2],[])dnl
split_append($@)dnl
make_list(defn([accu1]),defn([accu2]))dnl
popdef([accu1])dnl
popdef([accu2])dnl
])

define([_shift2],[_shift(_shift($@))])
define([_shift3],[_shift(_shift2($@))])
define([_shift4],[_shift(_shift3($@))])

dnl
dnl Append another element to a list.
dnl
define([_append],[ifelse(defn([$1]),,[[$2]],[defn([$1])[,$2]])])

dnl
dnl Depending on a regexp, add an item to list accu1 or accu2.
dnl
define([split_append_one],
[ifelse(regexp([$2],[$1]),-1,
[define([accu2],_append([accu2],[$2]))],
[define([accu1],_append([accu1],[$2]))])])

dnl
dnl Depending on a regexp, split a list into accu1 or accu2
dnl
define([split_append],
[ifelse(
$#,0,,
$#,1,,
$#,2,[split_append_one([$1],[$2])],
[split_append_one([$1],[$2])dnl
split_append([$1],_shift(_shift($@)))])])


dnl
dnl map a unary function on a list
dnl
define([_map],
[ifelse(
$#,0,,
$#,1,,
$#,2,[indir([$1],[$2])],
[indir([$1],[$2]),_map([$1],_shift2($@))])])

dnl
dnl map an n-ary function on a list
dnl    $1:     name of the function
dnl    $2:     the arguments of the function
dnl    $3...:  list to map on
dnl The function is called with its first argument the mapped item, the other arguments
dnl taken from $2.
dnl
define([_mapn],
[ifelse(
$#,0,,
$#,1,,
$#,2,,
$#,3,[indir([$1],[$3],$2)],
[indir([$1],[$3],$2),_mapn([$1],[$2],_shift3($@))])])

dnl
dnl flatten a list to one item
dnl
define([_flatten],
[ifelse(
$#,0,,
$#,1,[$1],
[[$1]_flatten(_shift($@))])])

dnl
dnl flatten to a space separated list
dnl
define([flatten_spaced],
[ifelse(
$#,0,,
$#,1,[$1],
[[$1] flatten_spaced(_shift($@))])])

dnl
dnl flatten with a given infix
dnl    $1: the given infix
dnl   ...: the list
dnl
define([flatten_with],
[ifelse(
$#,0,,
$#,1,,
$#,2,[$2],
[[$2][$1]flatten_with([$1],_shift2($@))])])

dnl
dnl flatten with a newline+tab in between
dnl
define([flatten_nl_tab],[flatten_with([
	],$@)])

dnl
dnl Atomic put around a string will never allow the string to be evaluated.
dnl However, the _atomic itself will never vanish, either, of cause.  You might
dnl want to remove it in a second parse...  Unfortunately, this seems to be the
dnl only way to stop M4 from doing replacements.
dnl
define([_atomic],[[_atomic($@)]])

dnl
dnl Add a prefix to each element of a list
dnl
define([add_prefix_one],[[$2][$1]])
define([add_prefix],[_mapn([add_prefix_one],[[$1]],_shift($@))])

dnl
dnl Add a suffix to each element of a list
dnl
define([add_suffix_one],[[$1][$2]])
define([add_suffix],[_mapn([add_suffix_one],[[$1]],_shift($@))])

