/* -*- Mode: C -*- */
/* Generated Tue Aug 19 15:44:02 GMT 2008
 */
/* Author: Henrik Theiling
 *
 * Implementation specific header file.  Only v_char.c should
 * include this.
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including v_char_i.h"
#endif

#ifndef ERWIN_V_CHAR_I_h
#define ERWIN_V_CHAR_I_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of v_char_i.h"
#endif

/* Note:
 *    Due to complex constraints and a lot of necessary rewriting,
 *    we currently switch off INLINE_STORE when LOW_MEM is requested.
 *    One problem is a common pattern here:
 *
 *       ...ensure_size_add...
 *       CODE: do something to the vector
 *       self->m_nentries= new_size.
 *
 *   The problem is that the CODE in the middle needs self->m_nentries to
 *   decide whether the table is on the heap or inline when INLINE_STORE
 *   and LOW_MEM is activated at the same time.  In the above code, it
 *   cannot rely on self->m_nentries, however, so we'd need to restructure
 *   a lot of code, e.g. by having TABLE2 additional to TABLE, which is
 *   passed the new size (switching the order of assignment isn't always
 *   possible, since, e.g. init_tail requires self->m_nentries to be the
 *   *old* value).
 */
#if V_CHAR_LOW_MEM
#  undef  V_CHAR_INLINE_STORE
#  define V_CHAR_INLINE_STORE 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define v_char_record_table(X) X

#if V_CHAR_LOW_MEM
#  define v_char_record_tablesize(X)
#else
#  define v_char_record_tablesize(X) X
#endif

#define v_char_record_nentries(X) X

#ifdef ERWIN_THREAD_SAFE
#  define v_char_record_errno(X) X
#else
#  define v_char_record_errno(X)
#endif

#if V_CHAR_DYN_ZERO
#  define v_char_record_zero(X) X
#else
#  define v_char_record_zero(X)
#endif

#if V_CHAR_HAVE_SIG
#  define v_char_record_sig(X) X
#else
#  define v_char_record_sig(X)
#endif

#if V_CHAR_POSITION_POINTER
#  define v_char_record_pos(X) X
#else
#  define v_char_record_pos(X)
#endif

typedef char v_char_content;
typedef v_char_content *v_char_content_p;

#define v_char_record                                               \
        v_char_record_sig       (int m_sig;)                        \
        v_char_record_table     (v_char_content_p m_table;)         \
        v_char_record_tablesize (v_char_size_t m_tablesize;)        \
        v_char_record_nentries  (v_char_size_t m_nentries;)         \
        v_char_record_pos       (v_char_index_t m_pos;)             \
        v_char_record_errno     (ERWIN_MUTABLE int m_errno;) \
        v_char_record_zero      (char  m_zero;)

#ifdef ERWIN_COMPAT_2_0_264

#ifdef ERWIN_COMPAT_2_0_248
struct _v_char_t
#else
struct v_char_t
#endif
{
    v_char_record
};

#endif

/* Force linker error when .c and .h are compiled inconsistently */
#if !defined (V_CHAR_IMPLEMENTATION) && defined(ERWIN_WEAK_STORAGE) && !defined(NDEBUG) && !defined(ERWIN_NO_LINKER_TRICKS)
#ifdef __cplusplus
extern "C" {
#endif
#if V_CHAR_DYN_ZERO
ERWIN_WEAK_STORAGE void v_char_variable_zero_element_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void v_char_variable_zero_element_expected(void) {}
#else
ERWIN_WEAK_STORAGE void v_char_constant_zero_element_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void v_char_constant_zero_element_expected(void) {}
#endif
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
}
#endif

#endif
