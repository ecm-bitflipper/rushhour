/* -*- Mode: C -*- */
/* Generated Tue Aug 19 15:44:03 GMT 2008
 */
/*
 * Author: Henrik Theiling
 * Description:
 *     Public header file for vectors with arbitrary value types.
 *
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including vector_char_p.h"
#endif

#ifndef ERWIN_VECTOR_CHAR_P_h
#define ERWIN_VECTOR_CHAR_P_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of vector_char_p.h"
#endif

/* Include basic configuration */
#ifdef ERWIN_COMPILING
#  include "erwin/defs.h"
#else
#  include <erwin/defs.h>
#endif

/* Include definitions */
#include "vector_char_p_d.h"

/* Include basic definitions */
#ifdef ERWIN_COMPILING
#  include "erwin/base.h"
#else
#  include <erwin/base.h>
#endif

#ifdef ERWIN_COMPILING
#  include "erwin/forwards.h"
#else
#  include <erwin/forwards.h>
#endif

#ifdef HAVE_STDIO_H
#  include <stdio.h>
#endif


#undef vector_errno
#if ERWIN_GLOBAL_ERRNO
#  define vector_errno erwininternalvectorerrno
  /* If you compiled Erwin without the ERWIN_THREAD_SAFE flag,
   * this variable holds global status code for vectors.
   */
#endif

#undef  vector_strerror
#define vector_strerror(X) erwininternalvectorstrerror(X)
  /* Returns a textual description of a given error.  This description
   * starts with `Error: ' or `Warning: ' or something the like
   * to indicate the status level.  This is then followed by a
   * short description phrase.
   */

/*! enum: VECTOR_OK, VECTOR_ERR_*, VECTOR_WARN_* */
#undef  VECTOR_OK
#define VECTOR_OK ERWININTERNALVECTOROK
  /* No error occurred. */

#undef  VECTOR_IS_OK
#define VECTOR_IS_OK(X) ERWININTERNALVECTORISOK(X)
  /* Find out whether the status code vector_errno indicates that everything is fine. */

#undef  VECTOR_IS_ERROR
#define VECTOR_IS_ERROR(X) ERWININTERNALVECTORISERROR(X)
  /* Find out whether the status code vector_errno indicates that an error occured. */

#undef  VECTOR_IS_WARNING
#define VECTOR_IS_WARNING(X) ERWININTERNALVECTORISWARNING(X)
  /* Find out whether the status code vector_errno indicates that an error occured. */

#undef  VECTOR_ERR_NOMEM
#define VECTOR_ERR_NOMEM ERWININTERNALVECTORERRNOMEM
  /* Memory exhausted.  If you think this is a fatal error and should be
   * treated like a failed assertion, #define ERWIN_NOMEM_IS_FATAL.
   */

#undef  VECTOR_ERR_OUTOFRANGE
#define VECTOR_ERR_OUTOFRANGE ERWININTERNALVECTORERROUTOFRANGE
  /* Returned whenever an argument has a value that cannot be handled. */

#undef  VECTOR_ERR_TOOLARGE
#define VECTOR_ERR_TOOLARGE ERWININTERNALVECTORERRTOOLARGE
  /* The vector cannot handle the new size due to the limited range of
   * the data type for the index. */

#undef  VECTOR_ERR_IO
#define VECTOR_ERR_IO ERWININTERNALVECTORERRIO
  /* Operations doing I/O return this error when an I/O error occured.  Which
   * error it was can be determined by calling ferror(3) on the FILE * you
   * passed to the vector function.
   *
   * Currently, vector_char_p_fread and vector_char_p_fgets may return this error.
   */

#undef  VECTOR_ERR_ASSERTIONFAILED
#define VECTOR_ERR_ASSERTIONFAILED ERWININTERNALVECTORERRASSERTIONFAILED
  /* Whenever an axiomatic assertion failed, this error is occured.
   *
   * Note: Something really went wrong in this case, so do not expect that
   *       every failed assertion allows normal control flow to continue.
   *       This error means the program is broken and would have crashed
   *       or done something bad if the assertion had not been checked.
   */

#undef  VECTOR_ERR_NOTCOMPILED
#define VECTOR_ERR_NOTCOMPILED ERWININTERNALVECTORERRNOTCOMPILED
  /* If some compile time flags prevented compilation of parts a function needs
   * at run-time, this is returned.  Currently only the `V' argument specifier
   * of the format functions return this if the files where compiled with
   * a C compiler instead of a C++ compiler.
   */

  /*
   * The following are warnings only. */
#undef  VECTOR_WARN_OUTOFRANGE
#define VECTOR_WARN_OUTOFRANGE       ERWININTERNALVECTORWARNOUTOFRANGE
  /* If a value is out of range, this warning is returned. */

#undef  VECTOR_WARN_EMTPY
#define VECTOR_WARN_EMPTY            ERWININTERNALVECTORWARNEMPTY
  /* vector_char_p_fgets returns this if EOF was reached and no character could be
   * read anymore. */

#if VECTOR_CHAR_P_SMALL_SIZE
/* Size: 16 bit, index:32 bits.  if possible. */
   /* We should use 'int' in the API here, but this requires assert()s
    * due to different sizes, which are not yet implemented.
    *
    * Anyway, since there are not enough overflow checks for the other
    * settings either, we allow this to be used...
    */

   /* 16 bit sizes are large enough. */
   /* The index type is always 'int'. */

#  ifndef VECTOR_CHAR_P_PREALLOC_SIZE
#    define VECTOR_CHAR_P_PREALLOC_SIZE  (16*1024)
#  endif
#  ifndef VECTOR_CHAR_P_CHUNK_SIZE
#    define VECTOR_CHAR_P_CHUNK_SIZE      (4*1024)
#  endif
#  if SIZEOF_INT == 2
     /* Prefer 'int' over 'short'. */
     typedef unsigned int vector_char_p_size_t;
     typedef int          vector_char_p_index_t;
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0
#  elif SIZEOF_SHORT == 2
     typedef unsigned short vector_char_p_size_t;
     typedef int            vector_char_p_index_t;  /* 'int' in API, not 'short' */
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_SHORT)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 1
#  else
     /* Hmm?  Strange.  Just use int. */
     typedef unsigned int vector_char_p_size_t;
     typedef int          vector_char_p_index_t;
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0
#  endif

#elif VECTOR_CHAR_P_MEDIUM_SIZE

   /* Try 32 bit sizes, do not use 64 bits if avoidable. */
   /* The index type is always 'int'. */

#  ifndef VECTOR_CHAR_P_PREALLOC_SIZE
#    define VECTOR_CHAR_P_PREALLOC_SIZE   (8*1024)
#  endif
#  ifndef VECTOR_CHAR_P_CHUNK_SIZE
#    define VECTOR_CHAR_P_CHUNK_SIZE      (128*1024)
#  endif

#  if SIZEOF_INT == 4
     /* Prefer 'int' over 'short'. */
     typedef unsigned int vector_char_p_size_t;
     typedef int          vector_char_p_index_t;
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0
#  elif SIZEOF_LONG == 4 && SIZEOF_INT > SIZEOF_LONG
     typedef unsigned long vector_char_p_size_t;
     typedef int           vector_char_p_index_t;
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_LONG)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 1
#  elif SIZEOF_SHORT == 4
     typedef unsigned short vector_char_p_size_t;
     typedef int            vector_char_p_index_t;
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_SHORT)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0
#  else
     /* Hmm? Just use int. */
     typedef unsigned int vector_char_p_size_t;
     typedef int          vector_char_p_index_t;
#    define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0
#  endif

#elif VECTOR_CHAR_P_LARGE_INDEX

   /* Full size_t support (e.g. >= 2G entries on 64 bit). */
   /* The size and index are both '(s)size_t'.
    * This is a different API: we do not have an 'int' index. */
#  ifndef VECTOR_CHAR_P_PREALLOC_SIZE
#    define VECTOR_CHAR_P_PREALLOC_SIZE   (16*1024)
#  endif
#  ifndef VECTOR_CHAR_P_CHUNK_SIZE
#    define VECTOR_CHAR_P_CHUNK_SIZE      (256*1024)
#  endif
   typedef size_t  vector_char_p_size_t;
   typedef ssize_t vector_char_p_index_t;
#  define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_SIZE_T)
#  define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0

#else

   /* By default, vectors work with 'int' as index type. */
#  ifndef VECTOR_CHAR_P_PREALLOC_SIZE
#    define VECTOR_CHAR_P_PREALLOC_SIZE   (8*1024*1024)
#  endif
#  ifndef VECTOR_CHAR_P_CHUNK_SIZE
#    define VECTOR_CHAR_P_CHUNK_SIZE      (128*1024)
#  endif
   typedef unsigned int   vector_char_p_size_t;
   typedef int            vector_char_p_index_t;
#  define VECTOR_CHAR_P_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#  define VECTOR_CHAR_P_SIZE_INDEX_DIFF 0

#endif


typedef vector_char_p_index_t vector_char_p_cnt_t;
   /* index is always the same as cnt, it just marks a different usage */


typedef char * vector_char_p_value_t;


typedef int (*vector_char_p_cmp_t) (char * const *, char * const *);

typedef ERWIN_BOOL (*vector_char_p_feature_t)(char * );

#ifndef VECTOR_CHAR_P_MAP_T_DEFINED
#define VECTOR_CHAR_P_MAP_T_DEFINED
/* In order to have char *  as a result type for vector_char_p_map_t, declare that
 * function yourself and define VECTOR_CHAR_P_MAP_T_DEFINED.
 */
typedef char * (*vector_char_p_map_t)(char * );
#endif
#define VECTOR_CHAR_P_CMP_T_NULL ((vector_char_p_cmp_t)NULL)

#ifdef __cplusplus
typedef bool (*vector_char_p_cpp_feature_t)(char * );
#endif /* defined __cplusplus */

typedef char * *vector_char_p_element_ptr_t;
#ifdef __cplusplus
typedef char * &vector_char_p_element_ref_t;
#endif /* defined __cplusplus */

typedef int  (*vector_char_p_combine_t) (vector_char_p_element_ptr_t, char * const *);
#define VECTOR_CHAR_P_COMBINE_T_NULL ((vector_char_p_combine_t)NULL)


/*
 * ***** handling `vector' objects: ***** */
/*--BEGIN-C--*/

ERWIN_EXPORT
vector_char_p_t *vector_char_p_new (void) ATTR_MALLOC;
   /* Create a new vector with default values.   I.e., with the
   * default zero element VECTOR_CHAR_P_ZERO and the default initial hash table
   * size of VECTOR_CHAR_P_INITIAL_SIZE.
   *
   */


#if VECTOR_CHAR_P_DYN_ZERO
ERWIN_EXPORT
vector_char_p_t *vector_char_p_new_with_zero (char *  /*zero*/) ATTR_MALLOC;
  /* Create a vector specifying the zero element. */


ERWIN_EXPORT
vector_char_p_t *vector_char_p_new_with_zero_and_initial_size (
    char *  /*zero*/, vector_char_p_cnt_t /*initial_size*/) ATTR_MALLOC;
  /* Create a new, empty vector.  The first form uses char_p_zero as the zero element.
   *
   * - If \p initial_size < 0:
   *   the default size VECTOR_CHAR_P_INITIAL_SIZE will be used.
   *
   * - If \p initial_size == 0 but VECTOR_CHAR_P_MINIMAL_SIZE > 0:
   *    a size of 1 will be used.
   *
   * Note: The vector always has size==0 even if \p initial_size > 0.  This
   *       initial size is the size of the data structure used.
   *       The vector does not resize it until the
   *       vector becomes larger than that.
   */
#endif

ERWIN_EXPORT
vector_char_p_t *vector_char_p_new_with_initial_size (vector_char_p_cnt_t /*initial_size*/) ATTR_MALLOC;
  /* Initialise with a given table size.  See vector_char_p_new_with_zero_and_initial_size.
   */

ERWIN_EXPORT
vector_char_p_t *vector_char_p_new_from_raw (
    char * * /*contents*/, vector_char_p_cnt_t /*nentries*/, vector_char_p_cnt_t /*allocsize*/) ATTR_MALLOC;
  /* This makes a vector from contents.   It 'steals' the pointer and makes it its
   * internal vector table.  It is assumed that we can (re/de)allocate the contents
   * using the normal ERWIN_TMALLOC/REALLOC/CMALLOC/FREE mechanism.
   *
   * Initial_size is the amount of memory that is allocated.  You can safely pass less
   * than nentries, meaning we should assume that there are only nentries allocated
   * cells (this is safe behaviour).  If you know the amount that is allocated, you
   * should pass it to this function to improve performance by preventing unnecessary
   * reallocations.
   *
   * If you want to *copy* contents into a vector, use _new_with_initial_size
   * and _append_raw instead.
   *
   * If contents is NULL or allocsize is 0, then we invoke new_with_initial_size
   * instead, so whether you get a vector that has no allocated table
   * at all depends on the setting of VECTOR_CHAR_P_ZERO_SIZE.  By default, table with
   * VECTOR_CHAR_P_INITIAL_SIZE will be allocated.
   *
   * If allocsize is non-zero, VECTOR_CHAR_P_MINIMAL_SIZE is ignored (as with the
   * constructors that contain _with_initial_size), so you may allocate smaller
   * vectors.  (A size of 0, however, is special, see previous paragraph.)
   */

#if VECTOR_CHAR_P_DYN_ZERO

ERWIN_EXPORT
vector_char_p_t *vector_char_p_new_from_raw_with_zero (
    char *   * /*contents*/,
    vector_char_p_cnt_t /*nentries*/,
    vector_char_p_cnt_t /*allocsize*/,
    char *  /*zero*/) ATTR_MALLOC;
  /* Same as before but with a given zero element. */

#endif

ERWIN_EXPORT
vector_char_p_t *vector_char_p_new_from_vector (vector_char_p_t * /*other*/) ATTR_MALLOC;
  /* This might be strange: it makes a new vector from the contents of the other
   * vector and then detaches the data from the other vector.  Its purpose is
   * mainly useful in C++ where you can clone vectors from a static vector
   * by this means.  E.g.:
   *
   *   :  VectorCharP a;
   *   :  ...
   *   :  return vector_char_p_new_from_vector (a);
   *
   * Or with the same effect, but without the need to use a long functions name:
   *     return a.copy_detach();
   *
   * A related thing is vector_char_p_xchg(), because the above is also roughly
   * equivalent to:
   *   : vector_char_p_t a;
   *   : ...
   *   : vector_char_p_t *b= vector_char_p_new();
   *   : vector_char_p_xchg(&a, b);
   *   : return b;
   */

ERWIN_EXPORT
int vector_char_p_init (vector_char_p_t * /*self*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap vector_char_p_t objects that are allocated
   * manually (thus, not via vector_char_p_new).
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

#if VECTOR_CHAR_P_DYN_ZERO
ERWIN_EXPORT
int vector_char_p_init_with_zero_and_initial_size (
    vector_char_p_t * /*self*/,
    char *  /*zero*/,
    vector_char_p_cnt_t /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap vector_char_p_t objects that are allocated
   * manually (thus, not via vector_char_p_new).
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */
#endif

ERWIN_EXPORT
int vector_char_p_init_with_initial_size (
    vector_char_p_t * /*self*/,
    vector_char_p_cnt_t /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap vector_char_p_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
void vector_char_p_destroy (vector_char_p_t * /*self*/);
  /*
   * This is for deleting non-heap vector_char_p_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK)
   */

ERWIN_EXPORT
void vector_char_p_xchg (vector_char_p_t * /*self*/, vector_char_p_t * /*other*/);
  /*
   * Exchanges the two vectors' contents.  No memory allocation is
   * performed; this is a fast O(1) operation for swapping two values.
   */

#if !ERWIN_GLOBAL_ERRNO
ERWIN_EXPORT
int vector_char_p_errno(vector_char_p_t const *) ATTR_PURE ATTR_NONNULL((1));
  /* If you compiled Erwin with ERWIN_THREAD_SAFE, this is the way
   * to get the status code of a given vector.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \noerrno
   */

ERWIN_EXPORT
void vector_char_p_clear_errno(vector_char_p_t const * /*self*/) ATTR_NONNULL((1));
  /* If you compiled Erwin with ERWIN_THREAD_SAFE, this is the way
   * to get the status code of a given vector.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \errno(OK)
   */

#else

#define vector_char_p_errno(X) vector_errno
  /* If you compiled Erwin without ERWIN_THREAD_SAFE, vector_char_p_errno
   * is just a synonym for vector_errno.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \noerrno
   */

#define vector_char_p_clear_errno(X)    ((void)(map_errno= MAP_OK))
  /* If the library was not compiled with ERWIN_THREAD_SAFE, vector_char_p_clear_errno(X)
   * is a small macro that resets the status code to VECTOR_OK.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \errno(OK)
   */
#endif


ERWIN_EXPORT
vector_char_p_t *vector_char_p_copy (vector_char_p_t const* /*self*/);
  /* Copies a vector with all its elements and returns that copy.
   */

ERWIN_EXPORT
vector_char_p_t *vector_char_p_copy_err (vector_char_p_t const* /*self*/, int * /*err*/);
  /* Like vector_char_p_copy but sets *\p err to 1 on failure.
   */

ERWIN_EXPORT
int vector_char_p_insert_subvector (
    vector_char_p_t *        /*self*/,
    vector_char_p_index_t    /*start_index_self*/,
    vector_char_p_t const*   /*other*/,
    vector_char_p_index_t    /*start_index_other*/,
    vector_char_p_cnt_t      /*size*/,
    ERWIN_BOOL /*docopy*/);
  /* Inserts a portion of a vector into another one. If \p size is < 0, it defines
   * the last element to enter. -1 therefore means: the rest of the vector starting
   * at \p start_index
   *
   * Returns its success.
   */

ERWIN_EXPORT
vector_char_p_t *vector_char_p_subvector (
    vector_char_p_t const* /*self*/,
    vector_char_p_index_t /*start_index*/,
    vector_char_p_cnt_t /*size*/,
    ERWIN_BOOL /*docopy*/);
  /* Copies only a portion of the vector. The semantics of the parameters is like in
   * vector_char_p_insert_subvector. */

ERWIN_EXPORT
void vector_char_p_delete (vector_char_p_t* /*self*/);
  /* Deletes everything in the vector and the vector structure itself.
   * vector_char_p_delete is NULL safe (\p self may be NULL without crash or failed
   * assertion).
   */

ERWIN_EXPORT
void vector_char_p_detach (vector_char_p_t* /*self*/);
  /* Clears the vector by initialising a new completely empty
   * table not consuming any memory.  The effect is mainly that
   * you can use the value of vector_char_p_as_array and vector_char_p_as_open_array
   * independently from the vector.  The old function
   * delete_flat is now a sequence of detach() and delete().
   *
   * Note: This function should be used when the vector is not
   *       needed anymore after a cast to a raw array (e.g. by
   *       vector_char_p_as_array).
   *
   * Compare this function with vector_char_p_detach_as_is().  These functions
   * are important to distinguish if you defined CHAR_P_UPDATE_POS.
   *
   * Note: use vector_char_p_delete_array() to deallocate the memory if you retrieve
   *       it with, say, vector_char_p_as_open_array().
   *
   * Note: See the documentation of vector_char_p_delete_array and vector_char_p INLINE_STORE!
   */

ERWIN_EXPORT
void vector_char_p_delete_array (vector_char_p_element_ptr_t /*array*/);
  /* If you extract the vector contents e.g. with vector_char_p_as_array(), then
   * detach a vector to free its contents later, use this function for
   * freeing.  If the memory management is left with its default settings,
   * this is a simple free() (or delete[] if you compiled for C++ only).
   * But to be sure to use the right deallocator in more complex cases,
   * please prefer to use this function.
   *
   * Note: With VECTOR_CHAR_P_INLINE_STORE, you *must only* invoke vector_char_p_delete_array
   *       on arrays obtained with vector_char_p_as_array_detach() or
   *       vector_char_p_as_open_array_detach().  You *must not* invoke it
   *       on arrays obtained with vector_char_p_as_array() or vector_char_p_as_open_array()
   *       because these functions may return a pointer to an inlined array,
   *       causing a SIGSEGV in vector_char_p_delete_array().
   */

ERWIN_EXPORT
void vector_char_p_detach_as_is (vector_char_p_t* /*self*/);
   /* Like vector_char_p_detach_as_is(), but does not invoke CHAR_P_UPDATE_POS
    * for all elements to set them to -1.
    *
    * This function is only different from vector_char_p_detach if you defined
    * CHAR_P_UPDATE_POS.  Otherwise, it is the same.
    */

ERWIN_EXPORT
int vector_char_p_append (vector_char_p_t* /*self*/, char *  /*value*/);
  /* Appends one elements, namely \p value, to the end of the vector.
   *
   * Returns its success.
   */

ERWIN_EXPORT
char *  vector_char_p_zero (vector_char_p_t const * /* self */) ATTR_PURE;
  /* Returns the zero element of this vector.  This need not be the same
   * for all vectors (you can specify it with vector_char_p_new_with_zero) unless
   * you defined VECTOR_CHAR_P_CONSTANT_ZERO.
   */

/*BEGIN:IGNORE*/
#if defined(ERWIN_COMPILING) || VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK || VECTOR_CHAR_P_INLINE_STORE
/*END:IGNORE*/

ERWIN_EXPORT
char *  vector_char_p_nth (vector_char_p_t const* /*self*/, vector_char_p_index_t /*index*/) ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element on failure.
   * If \p index is out of range, a message is also output to
   * stderr if you defined ERWIN_VERBOSE.
   */

/*BEGIN:IGNORE*/
#else
#define VECTOR_CHAR_P_INLINE__NTH
#endif
/*END:IGNORE*/

ERWIN_EXPORT
char *  vector_char_p_nth_char (vector_char_p_t const* /*self*/, vector_char_p_index_t /*index*/) ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element on failure.
   *
   * If you access the element just after the end of the vector, then
   * that is regarded legal in this function and the zero element is
   * returned.
   *
   * If \p index is out of range, a message is also output to
   * stderr if you defined ERWIN_VERBOSE.
   *
   * Dev.Note: this is pure: cmp to vector_char_p_nth_char_ptr and see vector_char_p_as_array().
   */

ERWIN_EXPORT
char *  vector_char_p_first (vector_char_p_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns the first element of the vector.
   * This is the same as
   *   : vector_char_p_nth (self, 0)
   */

ERWIN_EXPORT
char *  vector_char_p_last (vector_char_p_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns the last element of the vector
   *
   * This is the same as
   *   : vector_char_p_nth (self, vector_char_p_nentries (self) - 1)
   */


ERWIN_EXPORT
char * vector_char_p_modify (
    vector_char_p_t* /*self*/, vector_char_p_index_t /*index*/, char *  /*newvalue*/) ATTR_NONNULL((1));
  /* Returns the old value and inserts the new one at \p index.
   *
   * Nothing is freed, \p newvalue is copied if CHAR_P_OCOPY is #defined.
   */


ERWIN_EXPORT
int vector_char_p_set (
    vector_char_p_t* /*self*/, vector_char_p_index_t /*index*/, char *  /*newvalue*/) ATTR_NONNULL((1));
  /* Like vector_char_p_modify, but the old value is freed using CHAR_P_OFREE instead
   * of being returned.
   *
   * Returns its success.
   */

ERWIN_EXPORT
void vector_char_p_swap (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*index1*/, vector_char_p_index_t /*index2*/) ATTR_NONNULL((1));
  /* Because using set or modify to implement swapping of two elements involves
   * freeing and copying elements, this functions provides a way to swap
   * elements without that overhead.
   */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_nth_ptr (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*index*/) ATTR_NONNULL((1));
  /* Returns a pointer to the element at \p index or NULL if \p index is out of
   * range.
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

/* Like vector_char_p_nth_ptr, but constant in input and output type.
 *
 * Does not output anything to stderr even if you define ERWIN_VERBOSE.
 *
 * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
 */
ERWIN_STATIC_INLINE
char * const *vector_char_p_nth_ptr_const (vector_char_p_t const * self, vector_char_p_index_t idx);

ERWIN_STATIC_INLINE
char * const *vector_char_p_nth_ptr_const (vector_char_p_t const * self, vector_char_p_index_t idx)
{
    return vector_char_p_nth_ptr ((vector_char_p_t *)self, idx);
}

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_nth_ptr_check (vector_char_p_t * /*self*/, vector_char_p_index_t /*index*/);
  /* Returns a pointer to the element at \p index or an signals an error if
   * the \p index is out of range.  (This is the same behaviour towards errors
   * as vector_char_p_nth has)
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

/* Like vector_char_p_nth_ptr_check, but constant in input and output type.
 *
 * Does not output anything to stderr even if you define ERWIN_VERBOSE.
 *
 * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
 */
ERWIN_STATIC_INLINE
char * const *vector_char_p_nth_ptr_check_const (vector_char_p_t const * self, vector_char_p_index_t idx);

ERWIN_STATIC_INLINE
char * const *vector_char_p_nth_ptr_check_const (vector_char_p_t const * self, vector_char_p_index_t idx)
{
    return vector_char_p_nth_ptr_check ((vector_char_p_t *)self, idx);
}

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_nth_ptr_char (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*index*/) ATTR_NONNULL((1));
  /* Returns a pointer to the element at \p index if it is in range.
   * If is is one too large, returns a pointer to the element after the end,
   * mimicking string behaviour.  That element is guaranteed to be allocated,
   * of couse.  If you write to that element, it only is guarateed to have
   * any effect up to the next change to the vector size.  Don't change that
   * element, though.
   *
   * Because this function is so similar to adding an integer to a 'char const *',
   * i.e., to get a suffix string, this function always zero-terminates the
   * vector like vector_char_p_as_array() does.  So vector_char_p_nth_ptr_char(self,0) is
   * equivalent to vector_char_p_as_array().
   *
   * NOTE: This behaves a bit strange together with ALLOW_OUTOFRANGE:
   *    Accesses  to any element starting from a[nentries()]  make the vector
   *    larger for the non-const version!  This includes the nentries()th
   *    element, which, even if only read with this function, enlarges the
   *    vector due to the potential threat of the user writing to it.
   *
   * In case ALLOW_OUTOFRANGE is off, this never makes the vector larger,
   * but does allow access to nentries()th element.  That element is always
   * ensured to be ZERO, however, so you cannot write to it.
   *
   * This signals an error if the \p index is out of range.
   * (This is the some behaviour towards errors as vector_char_p_nth_char has.)
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure, see vector_char_p_as_array().
   */

/* Like vector_char_p_nth_ptr_char, but constant in input and output type.
 *
 * Note that despite the 'const', this zero-terminates the vector just like
 * vector_char_p_nth_ptr_char() and vector_char_p_as_array().
 *
 * Does not output anything to stderr even if you define ERWIN_VERBOSE.
 */
ERWIN_STATIC_INLINE
char * const *vector_char_p_nth_ptr_char_const (vector_char_p_t const * self, vector_char_p_index_t idx);

ERWIN_STATIC_INLINE
char * const *vector_char_p_nth_ptr_char_const (vector_char_p_t const * self, vector_char_p_index_t idx)
{
    return vector_char_p_nth_ptr_char ((vector_char_p_t *)self, idx);
}

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_first_ptr (vector_char_p_t * /*self*/) ATTR_NONNULL((1));
  /* Returns a pointer to the element at index 0 or NULL if the vector is empty.
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_last_ptr (vector_char_p_t * /*self*/) ATTR_NONNULL((1));
  /* Returns a pointer to the last element or NULL if the vector is empty.
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

ERWIN_EXPORT
void vector_char_p_reverse (vector_char_p_t * /*self*/);
   /* Reverses the order of all elements in the vector.
    *
    * See vector_char_p_swap, too, which is vaguely related.
    */

ERWIN_EXPORT
int vector_char_p_erase (vector_char_p_t* /*self*/, vector_char_p_index_t /*index*/, vector_char_p_cnt_t /*number_of_elements*/);
  /* The values erased from the the vector are freed.  If \p number_of_elements
   * is negative, the end of the vector is cut off.  If \p index or
   * \p number_of_elements are out of range, they are adjusted appropriately.
   *
   * E.g.:
   *  - if index == -2 and count == 5:
   *       then elements 0,1,2 are erased,
   *
   *  - if index >= nentries:
   *       nothing is erased,
   *
   *  - if index + count >= nentries:
   *      only the tail of the vector is erased.
   *      However, all this is only done if VECTOR_CHAR_P_ALLOW_OUTOFRANGE is true.
   *      Otherwise, you'll get an assertion failure in all these cases,
   *      because index or count are out of range.
   *
   *  - if count < 0:
   *     then count is adjusted to nelements - index, e.g.
   *     index == 2, count = -1 will cut off the last two elements of
   *     the vector.
   *     (The absolute value of count is not considered here, only the fact
   *     that it is < 0).  This adjustment always happens, i.e., even if
   *     VECTOR_CHAR_P_ALLOW_OUTOFRANGE is false.
   *
   * Returns its success.
   *
   * Reference: vector_char_p_erase_flags, vector_char_p_swap_erase
   */

ERWIN_EXPORT
int vector_char_p_erase_flags (
                vector_char_p_t* /* self */,
                vector_char_p_index_t       /* index */,
                vector_char_p_cnt_t       /* number_of_elements_to_delete */,
                ERWIN_BOOL      /* resize */,
                ERWIN_BOOL      /* delete_elems */);
  /* Like vector_char_p_erase but you can specify whether
   *   - the vector should be re-allocated by \p resize
   *   - elements should be freed by \p delete_elems.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_swap_erase (
    vector_char_p_t* /*self*/, vector_char_p_index_t /*index*/, vector_char_p_cnt_t /*number_of_elements*/);
  /* This is similar to vector_char_p_erase, but instead of shifting all elements after
   * the ones erased, this functions copies elements from the end of the vector
   * into the gap.  This is faster if \p number_of_elements is small.
   * The order of the copied elements is reversed.
   *
   * Example:
   *
   * vector_char_p= [0 1 2 3 4 5 6 7 8 9]
   *    : vector_char_p.swap_erase(2,3)  // erases elements 2,3,4 by overwriting with 9,8,7
   * vector_char_p= [0 1 9 8 7 5 6]
   *
   * There are more interesting cases, too:
   *
   * vector_char_p= [0 1 2 3 4 5 6 7 8 9]
   *    : vector_char_p.swap_erase(4,4)  // erases elements 4,5,6,7 by overwriting with 9,8
   * vector_char_p= [0 1 2 3 9 8]
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_swap_erase_flags (
    vector_char_p_t*          /* self */,
    vector_char_p_index_t     /* index */,
    vector_char_p_cnt_t       /* number_of_elements_to_delete */,
    ERWIN_BOOL  /* resize */,
    ERWIN_BOOL  /* delete_elems */);
  /* Like vector_char_p_swap_erase but you can specify whether
   *   a) the vector should be re-allocated by \p resize
   *   b) elements should be freed by \p delete_elems.
   *
   * Returns its success.
   */

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_erase_if (
    vector_char_p_t* /*self*/, vector_char_p_feature_t /* feature */, ERWIN_BOOL /*value*/);
  /* Erases those elements that satisfy \p feature.  You can specify which
   * value \p feature must return for the element in order to trigger that
   * deletion.  So if \p value is ERWIN_FALSE, the feature described
   * by \p feature is negated.
   *
   * The values erased from the vector are freed using CHAR_P_OFREE.
   *
   * Returns the number of elements cut out of the vector.
   *
   * Note: In CommonLisp, this is called |remove-if|.
   */

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_erase_equals (vector_char_p_t* /*self*/, vector_char_p_cmp_t /*cmp*/, vector_char_p_combine_t /*combine*/);
  /* Erases the second of two adjacent elements that is equal (wrt. the
   * given function) to the first.  This is repeated recursively so that
   * groups of adjacent equal elements are reduced to one element.
   *
   * Before erasing, the function calls back combine to let the user
   * adjust things (e.g. copy something from the moribund entry to
   * the surviving one).
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_CMP.
   *
   * In a sorted vector, this procedure erases all equal elements.
   *
   * The values erased from the vector are freed using CHAR_P_OFREE.
   *
   * The number of erased elements is returned.
   */

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_erase_zero (vector_char_p_t* /*self*/);
  /* Specialised version of vector_char_p_erase_if: deletes zero elements. */

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_erase_if_flags (
        vector_char_p_t* /*self*/,
        vector_char_p_feature_t /* feature */,
        ERWIN_BOOL /*value*/,
        ERWIN_BOOL /*resize*/,
        ERWIN_BOOL /*dealloc*/);
  /* Additional to vector_char_p_erase_if, you can specify whether to resize the
   * vector or whether to deallocate the elements that are cut out.
   *
   * Returns the number of elements cut out of the vector.
   */


ERWIN_EXPORT
void vector_char_p_make_heap(vector_char_p_t * /*self*/, vector_char_p_cmp_t /*cmp*/);
  /* This makes a heap.  The first element of the vector will then
   * be the maximum (according to the given compare function).
   * The others will have the Heap Property:
   *
   * : \forall i \in { 0,..,nentries-1 }:
   * :    nth (floor ((i-1) / 2)) >= nth(i)
   *
   * The operation takes O(n log n) time.
   *
   * This is the heap property graphically:
   *   :     0      n[father(i)] >= n[i], whether father(i) = floor ((i-1) / 2)
   *   :   1   2
   *   :  3 4 5 6   // Note that the indeces in our vectors are just the
   *   :            // other way around to
   *
   * As a special case, a vector that is sorted in reverse order is a heap.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * NOTE:
   * The implementation used here has no dedicated heap_size entry.
   * The heap is always as large as the whole vector.
   *
   * This function checks itself when in debug mode, causing assertion failures
   * if the heap property is violated after operation.
   */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_heap_left(vector_char_p_t const * /*self*/, vector_char_p_index_t /*i*/) ATTR_PURE;
   /* Returns the index of the left child of i in a heap structure.
    * The index i must be a valid index of the vector.
    * Returns something < 0 if there is no such child of i.
    * The left index is guaranteed to be < than the right index.
    *
    * The operation takes O(1) time.
    */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_heap_right (vector_char_p_t const * /*self*/, vector_char_p_index_t /*i*/) ATTR_PURE;
   /* Returns the index of the left child of i in a heap structure.
    * The index i must be a valid index of the vector.
    * Returns something < 0 if there is no such child of i.
    * The right index is guaranteed to be > than the left index.
    *
    * The operation takes O(1) time.
    */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_heap_father (vector_char_p_t const * /*self*/, vector_char_p_index_t /*i*/) ATTR_PURE;
   /* Returns the index of the left child of i in a heap structure.
    * The index i must be a valid index of the vector.
    * Returns something < 0 if i does not have a father, i.e., if i == 0.
    *
    * The operation takes O(1) time.
    */

ERWIN_EXPORT
char * vector_char_p_heap_extract (vector_char_p_t * /*self*/, vector_char_p_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* This extracts the maximum from the heap, returns it, shrinks the
   * vector, and re-heapifies it.  See vector_char_p_make_heap()
   * and vector_char_p_heap_sink().  You may only invoke this for vectors that
   * have the heap property and have at least one element.
   *
   * The operation takes O(log n) time, since it reinvokes vector_char_p_heap_sink.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * This function checks the input and itself when in debug mode, causing
   * assertion failures if the heap property is violated.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *   : #define VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors)
   *   : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   *
   * Note: this returns char * instead of char *  (if these are different),
   * because the element is removed, so no reference can be returned.
   */

ERWIN_EXPORT
void vector_char_p_heap_raise (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*i*/, vector_char_p_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* The operation checks for element i whether its priority has increased.
   * it so, the heap property is re-established.
   *
   * The operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * This function checks itself when in debug mode, causing
   * assertion failures if the heap property is violated after operation.
   * Such an assertion failure may also mean that the vector was no
   * heap (apart from the element i) before this operation.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *   : #define VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors)
   *   : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   */

ERWIN_EXPORT
void vector_char_p_heap_sink (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*i*/, vector_char_p_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* The opposite of vector_char_p_heap_raise: it checks whether the value of i
   * has decresed and if so, re-establishes the heap property.
   *
   * This operation is often called 'heapify'.  Because it is related to
   * heap_raise by being its opposite, we'll call it heap_sink here.
   *
   * The operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * See vector_char_p_heap_raise() for more info.
   *
   * Note that this function does not do debug checks of the heap property,
   * because it may be used to construct a heap, so one of its purposes is to
   * be invoked on heaps.  We might add a check for a partial heap property
   * later, though.
   */

ERWIN_EXPORT
void vector_char_p_heap_fix (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*i*/, vector_char_p_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* Fix the position of element at index i according to its new priority.
   *
   * The operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * This is an abbreviation for:
   *    : vector_char_p_heap_raise (self, i, cmp);
   *    : vector_char_p_heap_sink  (self, i, cmp);
   */

ERWIN_EXPORT
int vector_char_p_heap_insert (
    vector_char_p_t * /*self*/, char *  /*elem*/, vector_char_p_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* This function inserts an element into a heap and re-establishes the
   * heap property.
   *
   * This operation is an abbreviation for:
   *    : vector_char_p_append (self, elem);
   *    : vector_char_p_heap_increase (self, vector_char_p_nentries(s) - 1, cmp);
   *
   * Thus the operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * The success is returned.
   *
   * This function checks the input (and itself indirectly via vector_char_p_heap_raise) when
   * in debug mode, causing assertion failures if the heap property is violated.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *    : #define VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors):
   *    : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   */

ERWIN_EXPORT
void vector_char_p_heap_erase (
    vector_char_p_t * /*self*/, vector_char_p_index_t /*i*/, vector_char_p_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* This function deletes an element from the heap and re-establishes the
   * heap property.
   *
   * This operation is an abbreviation for:
   *    : vector_char_p_swap (self, i, vector_char_p_nentries(s) - 1);
   *    : vector_char_p_chop (self, 1);
   *    : vector_char_p_heap_sink (self, i, cmp);
   *
   * Thus the operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
   *
   * The success is returned.
   *
   * This function checks the input (and itself indirectly via vector_char_p_heap_raise) when
   * in debug mode, causing assertion failures if the heap property is violated.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *   : #define VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors)
   *   : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   */

ERWIN_EXPORT
void vector_char_p_heap_sort (vector_char_p_t * /*self*/, vector_char_p_cmp_t /*cmp*/);
   /* Re-builds the heap structure for the given element.
    * This is one of three sort functions available for vectors:
    *
    *   +------------------+------------+------------+------------+---------+-------------+
    *   |! Function        |! Algorithm |! Typical   |! Worst     |! Space  |!  Stability |
    *   | vector_char_p_qsort     | Quicksort  | O(n log n) | O(n)       | O(1)    | not stable  |
    *   | vector_char_p_heap_sort | Heapsort   | O(n log n) | O(n log n) | O(1)    | not stable  |
    *   | vector_char_p_sort      | Mergesort  | O(n log n) | O(n log n) | O(n)    | stable      |
    *   +------------------+------------+------------+------------+---------+-------------+
    *
    * The default cmp function, used if cmp is NULL, is CHAR_P_PRIORITY_CMP.
    *
    * NOTE: This uses a different comparison function by default.  Just in case
    *       you defined it (or differently)...
    *
    * FIXME: We should implement bubblesort as well, since it is very fast if
    *        only few elements have changed.
    *
    * The operation takes O(n log n) time.
    */

ERWIN_EXPORT
int vector_char_p_priority_cmp (vector_char_p_t const *, vector_char_p_t const *, vector_char_p_cmp_t /*cmp*/);
    /* Similar to vector_char_p_cmp, with two differences:
     *    - it uses CHAR_P_PRIORITY_CMP as its default comparison
     *      function
     *    - it uses lexical ordering as its default, unless you define
     *      VECTOR_CHAR_P_PRIORITY_COMPARE_LEXICOGRAPHICALLY to 0.
     *
     * This function is NULL safe.  NULL is smaller than any
     * other vector.
     *
     * If cmp is NULL, CHAR_P_PRIORITY_CMP will be used.  If that is not
     * defined, an error will occur.
     */

ERWIN_EXPORT
int vector_char_p_chop (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*count*/);
  /* Cuts off the last \p count elements of a vector.
   *
   * This is actually nothing more than an abbreviation for:
   *   : (Assert that count is >= 0)
   *   : vector_char_p_erase(self, vector_char_p_nentries(self)-count, count);
   *
   * This functions generates an assertion failure if the number of
   * elements to chop is greater than the number of elements in the
   * vector.  However, if VECTOR_CHAR_P_ALLOW_OUTOFRANGE is true, then
   * this operation simply clears the vector without assertion failure
   * in this case.
   *
   * Due to the fact that the equivalent using vector_char_p_swap_erase is
   * very trivial: vector_char_p_swap_erase (self, 0, 1), there is no
   * vector_char_p_swap_chop() in C (but in C++, we still have it).
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_chop_flags (
        vector_char_p_t * /* self */,
        vector_char_p_cnt_t        /* count */,
        ERWIN_BOOL       /* resize */,
        ERWIN_BOOL       /* delete_elems */);
  /* Like vector_char_p_chop you can specify the deallocation behaviour.
   *
   * Returns its success.
   */

ERWIN_EXPORT
char * vector_char_p_last_chop1 (vector_char_p_t * /*self*/) ATTR_NONNULL((1));
  /* Cuts off the last element of the vector and returns it.
   * Like a pop on a stack.
   */

ERWIN_EXPORT
char * vector_char_p_first_swap_chop1 (vector_char_p_t * /*self*/) ATTR_NONNULL((1));
  /* Cuts off the first element of the vector like vector_char_p_swap_erase()
   * and returns it.  This is like vector_char_p_heap_extract() without
   * heap_sink().
   */

ERWIN_EXPORT
int vector_char_p_append_raw (
        vector_char_p_t *    /*self*/,
        char * const * /*elements*/,
        vector_char_p_cnt_t  /*count*/) ATTR_NONNULL((1));
  /* Append \p count elements to the end of the vector.
   *
   * This is a frontend to vector_char_p_insert_raw which lets you specify an insertion
   * position.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_append_no_copy (
        vector_char_p_t *       /* self */,
        char * const * /* theelements */,
        vector_char_p_cnt_t              /* number_of_elements_to_insert*/) ATTR_NONNULL((1));
  /* Like vector_char_p_append_raw, but the data is not copyied.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_append_vector (
        vector_char_p_t *      /* self */,
        vector_char_p_t const* /* other */) ATTR_NONNULL((1));
  /* Append a whole \p other vector at the end of the vector \p self.
   *
   * This is a frontend to vector_char_p_insert.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_append_string (
        vector_char_p_t*     /*self*/,
        char * const * /*theelements*/) ATTR_NONNULL((1));
  /* Like vector_char_p_append_raw, but with a zero-terminated string instead of a
   * number of elements.   The null-termination will *not* be copied.
   *
   * Returns its success.
   */


ERWIN_EXPORT
int vector_char_p_make_gap (
        vector_char_p_t*      /*self*/,
        vector_char_p_index_t /* start_index*/,
        vector_char_p_cnt_t   /* count */);
  /* Inserts \p count zero elements into the vector at position \p start_index.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_make_gap_with (
        vector_char_p_t*       /*self*/,
        vector_char_p_index_t  /* start_index*/,
        char *     /* elem */,
        vector_char_p_cnt_t    /* count */);
  /* Like vector_char_p_make_gap but with a given value (which is copied for
   * each entry if necessary.
   */


ERWIN_EXPORT
int vector_char_p_overwrite_raw (
    vector_char_p_t*     /* self*/,
    vector_char_p_index_t           /* start_index_in_self */,
    char * const * /* newdata*/,
    vector_char_p_cnt_t           /* count */);
  /* Overwrites portions of the vector from a normal array.
   * The overwritten data is freed using CHAR_P_OFREE in the old vector and
   * the new data copied from the new data array using CHAR_P_OCOPY.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_overwrite_flags (
    vector_char_p_t*           /* self */,
    vector_char_p_index_t      /* start_index */,
    char * const *       /* values */,
    vector_char_p_cnt_t        /* count */,
    ERWIN_BOOL   /* copy_elements */,
    ERWIN_BOOL   /* delete_overwritten_elements */);
  /* Like vector_char_p_overwrite_raw but you can further specify its
   * (de-)allocation behaviour.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int  vector_char_p_overwrite_string (vector_char_p_t*     /* self*/,
                                     vector_char_p_index_t           /* start_index_in_self */,
                                     char * const * /* newdata*/);
  /* Overwrites portions of the vector from a normal array.
   * Like vector_char_p_overwrite_raw but with a zero-terminated string.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_overwrite_vector (
        vector_char_p_t*     /* self*/,
        vector_char_p_index_t           /* start_index_in_self */,
        vector_char_p_t const* /* newdata*/);
  /* Overwrites portions of the vector from a vector.  Like
   * vector_char_p_overwrite_raw but takes its data from another vector.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int  vector_char_p_overwrite (
        vector_char_p_t*         /* self*/,
        vector_char_p_index_t    /* start_index_in_self */,
        vector_char_p_t const*   /* newdata*/,
        vector_char_p_index_t    /* start_index_in_initial */,
        vector_char_p_cnt_t      /* max_count */);
  /* Each element is copied using CHAR_P_OCOPY, the old contents are deleted
   * with CHAR_P_OFREE.  This overwrites maximally max_count elements from
   * initial to self starting at position start_index_in* in the two
   * vectors.
   *
   * This is a frontend to vector_char_p_overwrite_raw.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int  vector_char_p_insert (
    vector_char_p_t*       /* self */,
    vector_char_p_index_t  /* index */,
    char *     /* element */) ATTR_NONNULL((1));
 /* Inserts one \p element at  position \p index.
  *
  * Possible values for \p index are 0...vector_char_p_nentries(self) both
  * inclusive.
  *
  * Returns its success.
  */

ERWIN_EXPORT
int  vector_char_p_insert_raw (
    vector_char_p_t*       /* self */,
    vector_char_p_index_t  /* index */,
    char * const *   /* values */,
    vector_char_p_cnt_t    /* count */);
 /* Inserts elements from an open array whose size is given by \p count.
  * In all other aspects it works just like vector_char_p_insert_vector.
  */

ERWIN_EXPORT
int  vector_char_p_insert_no_copy (
    vector_char_p_t*        /* self */,
    vector_char_p_index_t              /* index */,
    char * const * /* values */,
    vector_char_p_cnt_t              /* count */);
  /* Like vector_char_p_insert_raw but does not copy the given data.
   */

ERWIN_EXPORT
int  vector_char_p_insert_string (
        vector_char_p_t*     /* self */,
        vector_char_p_index_t           /* start_index */,
        char * const * /* values */) ATTR_NONNULL((1));
  /* Inserts a zero-terminated string into the vector.
   *
   * In all other aspects it works just like vector_char_p_insert_vector.
   */

ERWIN_EXPORT
int  vector_char_p_insert_vector (
        vector_char_p_t* /*self*/,
        vector_char_p_index_t       /* start_index */,
        vector_char_p_t const* /*initial*/);
 /*
  * Each element is copied using CHAR_P_OCOPY.
  *
  * This is a simple frontend to vector_char_p_make_gap and vector_char_p_overwrite.
  * To insert only portions of the initial vector, use these functions
  * directly.
  *
  * Possible values for \p index are 0...vector_char_p_nentries(self) both
  * inclusive.
  *
  * Returns its success.
  */


ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_string_length (
    vector_char_p_t const* /* self */, char * const * /* string */) ATTR_PURE;
  /* Find out the string length of the given zero-terminated \p string.
   *
   * The zero element is taken from the vector.  This does not modify
   * the vector at all, nor does it look at the vector's elements.  It
   * only gets the zero element from the vector.
   */


ERWIN_EXPORT
int vector_char_p_ensure_size (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/) ATTR_NONNULL((1));
  /* Possibly enlarges the vector by appending null elements.
   *
   * This is more than vector_char_p_ensure_table_size, since the vector gets the given
   * size with zero-initialised elements at the tail if necessary.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_ensure_size_with (
    vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/, char *  /*elem*/) ATTR_NONNULL((1));
  /* Possibly enlarges the vector by appending the given elements.
   *
   * This is similar to vector_char_p_ensure_size, but you can define with which element
   * the vector will be filled when grown.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_set_size (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/);
  /* Set the vector size (by shrinking or enlarging and filling with
   * null elements).
   *
   * *Note* that the function will never resize the vector smaller
   * than VECTOR_CHAR_P_MINIMAL_SIZE (actually, no function will do that).
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_set_size_with (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/, char *  /*elem*/);
  /* Set the vector size (by shrinking or enlarging and filling with
   * the given elements).
   *
   * This is similar to vector_char_p_set_size, but you can define with which element
   * the vector will be filled when grown.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_set_size_no_resize (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/);
  /* Set the vector size (by shrinking or enlarging and filling with
   * null elements).  When shrinking, no resizing of the table will
   * be done.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int vector_char_p_set_size_raw (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/);
  /* Set the vector size by shrinking or enlarging without, resizing,
   * deallocation and without filling with null elements.
   *
   * This function similar to vector_char_p_set_size_no_resize: when shrinking,
   * no resizing will be done.  Further, this function does not free
   * any elements during shrinking, so that the elements up to the
   * allocation size will remain in memory unmodified.  When enlarging
   * the vector up to the allocation size, this function will
   * not initialise the data.
   *
   * This function is useful if you want to temporarily hide elements
   * at the end of the vector.  E.g. when handling heaps where
   * the vector size is different from the heap size.
   * See vector_char_p_make_heap.
   *
   * BE CAREFUL: if you use this function to shrink the vector, and then
   *             use it to enlarge the vector to a size greater than
   *             the original size, then there will be uninitialised
   *             elements.  Basic initialisation (constructor invocation)
   *             is performed when the vector needs to be reallocated
   *             to enlarged it, however.  But no null element is ever
   *             written by this function.
   *
   * Returns its success.
   */

ERWIN_EXPORT
void vector_char_p_shrink (vector_char_p_t * /*self*/, ERWIN_BOOL /* tight */);
  /* Perform a table shrink operation if necessary.  Mostly useful
   * if VECTOR_CHAR_P_NO_AUTO_SHRINK is set, otherwise, this function is
   * automatically invoked whenever the vector shrinks.
   *
   * If \p tight is not ERWIN_FALSE, the vector is reallocated to the
   * absolute minimum that is necessary to store the data.  Otherwise,
   * the standard algorithm of halving chunks is used.
   *
   * *Note* that the function will never resize the vector smaller
   * than VECTOR_CHAR_P_MINIMAL_SIZE (actually, no function will do that).
   *
   * If VECTOR_CHAR_P_MINIMAL_SIZE == 0, and if you invoke this function
   * on an empty vector, the vector will not use any allocated
   * internal structure anymore until you insert anything.
   *
   * When VECTOR_CHAR_P_LOW_MEM is active, this functions has no operation, since the
   * table size cannot be changed independently from the size.
   *
   * *Note* that calling vector_char_p_as_array() on a shrinked
   * vector is not wise since the vector will have to resize for
   * the padded zero element.
   *
   * Note: This function is always successful.  Even if realloc
   *       failed, the vector is still consistent.  Therefore, no
   *       error code is returned.  However, the error code is
   *       set up correctly.
   *
   * Further Note: If you defined memory overflow errors to be
   *       fatal (by #define ERWIN_NOMEM_IS_FATAL), they are also
   *       fatal in this function.
   */

ERWIN_EXPORT
int vector_char_p_ensure_table_size (vector_char_p_t * /*self*/, vector_char_p_cnt_t /*size*/) ATTR_NONNULL((1));
  /* Pre-allocates vector elements.  To be used when you know some good
   * upper approximation to the expected number of elements which will be
   * inserted in the future.  Does not change the contents of the vector.
   *
   * To set a minimal size for the vector by appending zero elements,
   * use vector_char_p_ensure_size.
   *
   * When VECTOR_CHAR_P_LOW_MEM is active, this functions has no operation, since the
   * table size cannot be changed independently from the size.
   *
   * Returns its success.
   */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_as_array (vector_char_p_t const *);
  /* returns a pointer to the string the vector is stored in.  The string
   * is terminated with a zero element (usually CHAR_P_ZERO, but this
   * can be changed by using vector_char_p_new_with_zero).
   *
   * Note: For convenience, this takes a const pointer although the
   * representation (but not the contained data) might be changed.  It only
   * changes things outside the user view (behind the end of the vector).
   *
   * Further note that NULL is ok, NULL is returned, regardless of VECTOR_CHAR_P_ALLOW_NULL.
   *
   * When VECTOR_CHAR_P_INLINE_STORE is active, the returned pointer may become
   * invalid when you invoke vector_char_p_detach or vector_char_p_detach_as_is.  Use
   * vector_char_p_as_array_detach() in that case (you cannot split that operation
   * in this case).
   *
   * Developer's Note: this functions is not __pure__: it may change the
   * internal structure, and thus the result of table_size() and
   * has_heap_storage() etc.
   */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_as_open_array (vector_char_p_t const *) ATTR_ERRNO_PURE;
  /* Same as vector_char_p_as_array, but without the guaranteed zero element.
   * This is sometimes faster and /never/ resizes the vector.
   *
   * Note: If VECTOR_CHAR_P_MINIMAL_SIZE is 0 and the vector has size 0, this
   *       function might return NULL instead of an allocated array!
   *       This is because the function will never try to reallocate.
   *
   * When VECTOR_CHAR_P_INLINE_STORE is active, the returned pointer may become
   * invalid when you invoke vector_char_p_detach or vector_char_p_detach_as_is.  Use
   * vector_char_p_as_array_detach() in that case (you cannot split that operation
   * in this case).
   */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_as_array_detach (vector_char_p_t *);
  /* Like vector_char_p_as_array() followed by vector_char_p_detach() with the difference
   * that this also works when VECTOR_CHAR_P_INLINE_STORE is active.
   */

ERWIN_EXPORT
void vector_char_p_ensure_heap_storage (vector_char_p_t *) ATTR_NONNULL((1));
  /* Ensure that the contents are stored on the heap so that _detach
   * does not destroy the vector.  Used by vector_char_p_as_array_detach(), but
   * may also be used manually before as_array() or vector_char_p_nth_ptr() to
   * ensure that the pointer is on the heap.
   *
   * This function actually does something only when VECTOR_CHAR_P_INLINE_STORE
   * is used or VECTOR_CHAR_P_MINIMAL_SIZE is 0.  Otherwise, this function does
   * nothing.  This includes not doing any harm.
   *
   * Note: With both LOW_MEM and INLINE_STORE active, this functions may
   *       append ZERO elements to the vector, because resizing the table
   *       may mean to resize the vector.
   *
   * Note: With VECTOR_CHAR_P_MINIMAL_SIZE == 0, vectors of size 0 are still *not*
   *       resized to size 1.
   *       Functions returning pointers to the table (e.g. vector_char_p_as_open_array)
   *       will return NULL in this special case, which is ususally no problem
   *       in handling.
   *       This function is for handling the more complex cases that occur with
   *       the VECTOR_CHAR_P_INLINE_STORE option.
   */

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_has_heap_storage (vector_char_p_t const *) ATTR_PURE;
  /* Returns whether the storage on the heap is allocated or not.
   * This is interesting only when VECTOR_CHAR_P_MINIMIAL_SIZE == 0 or
   * VECTOR_CHAR_P_INLINE_STORE is activated.
   */

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_inline_store_cnt (void) ATTR_PURE;
  /* Returns the number of elements the inline store has.
   * This is 0 unless VECTOR_CHAR_P_INLINE_STORE is activated, in which case other
   * values are possible.  The result is a constant, therefore there is no
   * argument to this function.
   */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_as_open_array_detach (vector_char_p_t *);
  /* Like vector_char_p_as_open_array() followed by vector_char_p_detach() with the difference
   * that this also works when VECTOR_CHAR_P_INLINE_STORE is active.
   */

ERWIN_EXPORT
void vector_char_p_qsort (vector_char_p_t *, vector_char_p_cmp_t /*order*/);
  /* Uses the \p order function to sort the vector.  The compare function may be NULL
   * if CHAR_P_CMP is defined.  In this case that default compare function
   * is used.  See vector_char_p_u.h for definition.
   *
   * For a stable sort function, see vector_char_p_sort.
   *
   * For a guaranteed O(n log n) runtime and O(1) space, see vector_char_p_heap_sort.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_CMP.
   *
   * This function the CLib function qsort(3).   Note that qsort(3) need not
   * use Quicksort internally, e.g. if the glibc under Linux finds that there
   * is enough memory, it uses merge sort instead.  So you have good chances
   * that this function is stable *in many cases under Linux*.  However, if you
   * need stability, this function does not guarantee that.  Especially, when
   * running your programm under Windows, its qsort(3) implementation is *not*
   * stable.  That's perfectly ok.  For stability, simply always use
   * vector_char_p_sort().
   *
   * In sorted vectors, you can find entries in O(log n) vector using
   * vector_char_p_bfind or vector_char_p_locate.
   */

ERWIN_EXPORT
void vector_char_p_sort (vector_char_p_t *, vector_char_p_cmp_t /*order*/);
  /* Uses erwin_merge_sort, which implements a stable sorting algorithm.
   * Uses the \p order function. \p order may be NULL (see vector_char_p_qsort and
   * vector_char_p_heap_sort) if CHAR_P_CMP is defined, which will then be used.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_CMP.
   *
   * Uses Erwin's erwin_merge_sort function which is stable but needs O(n) space.
   *
   * You can find entries in a sorted vector using vector_char_p_bfind or vector_char_p_locate.
   */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_bfind (vector_char_p_t const *, char * , vector_char_p_cmp_t);
  /* Needs a sorted vector.  Then searches with binary search.  Uses the cmp function.
   * cmp may be NULL (see above)
   * -1 means: not found.
   *
   * Uses the system function bsearch().
   *
   * This operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_CMP.
   *
   * This function checks the input when in debug mode, causing assertion
   * failures if input is not sorted.the heap property is violated after operation.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *    #define VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS        0
   * or #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0   (for all vectors)
   *
   * References
   * ~~~~~~~~~~
   * vector_char_p_qsort, vector_char_p_sort, vector_char_p_locate, vector_char_p_find.
   */

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_locate (
    vector_char_p_index_t * /*index*/,
    vector_char_p_t const * /*self*/,
    char *  /*needle*/,
    vector_char_p_cmp_t /*order*/,
    int /* how */);
  /* Needs a sorted vector.   Then searches with binary search.  Uses the cmp function.
   * cmp may be NULL (see above)
   *
   * In contrast to vector_char_p_bfind you are provided with a possible
   * insertion position that will keep the vector's order.
   *
   * The function returns ERWIN_TRUE if the element was found and ERWIN_FALSE if not.
   *
   * This operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_P_CMP.
   *
   * This function checks the input when in debug mode, causing assertion
   * failures if input is not sorted.the heap property is violated after operation.
   * Chis check takes O(n) time, so the function is significantly slower
   * during debugging.  If you don't want this, you may
   *
   *    #define VECTOR_CHAR_P_DEBUG_EXPENSIVE_CHECKS        0
   * or #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0   (for all vectors)
   *
   * The \p how argument defines what value to return for the *\p index.  The following table
   * give an explanation of the value written into *\p index:
   *
   *   +---------+------------------------+------------------------+-----------------------+
   *   |! \p how |! if found (result ==   |! if not found (result  |! usage                |
   *   |         |  ERWIN_TRUE)    |  == ERWIN_FALSE |                       |
   *   +---------+------------------------+------------------------+-----------------------+
   *   | -1      | the smallest index     | insertion position     | to find an element or |
   *   |         | of equal elements      |                        | to insert an element  |
   *   |         |                        |                        | at the smallest       |
   *   |         |                        |                        | possible position     |
   *   +---------+------------------------+------------------------+-----------------------+
   *   | 0       | some index of an equal | insertion position     | to find and insert    |
   *   |         | element                |                        | without caring about  |
   *   |         |                        |                        | order of equal        |
   *   |         |                        |                        | elements              |
   *   +---------+------------------------+------------------------+-----------------------+
   *   | 1       | the largest index of   | insertion position - 1 | to find an element or |
   *   |         | equal elements         |                        | to insert an element  |
   *   |         |                        |                        | at the largest        |
   *   |         |                        |                        | possible position.    |
   *   +---------+------------------------+------------------------+-----------------------+
   *
   * At first sight, for \p how==1 the value of \p index seems strange.  But from the point of
   * view of inserting even in case of equality, you can simply insert at (*\p index+1) to
   * insert at the right most possible position keeping the vector's order without looking at
   * the function's return value.  However, in case of finding the element, *\p index always
   * points to an equal element.  Note that because of this, \p index may be -1 (for \p how=1
   * if you want to insert at the beginning).
   *
   * Note: for \p how==0 and \p how==-1, the functions will set *\p index to
   * vector_char_p_nentries(self) if the searched element is larger than any in the vector,
   * because that is the correct value for vector_char_p_insert.
   *
   * Summarized constraints that always hold:
   *
   *    +-------------------------------------+------------------------------------------+
   *    | for \p how==0 and \p how==-1        | *\p index always is the correct          |
   *    |                                     | insertion position.                      |
   *    +-------------------------------------+------------------------------------------+
   *    | for \p how==1                       | (*\p index + 1) always is the correct    |
   *    |                                     | insert position.                         |
   *    +-------------------------------------+------------------------------------------+
   *    | if the return value is              | *\p index points to an equal element.    |
   *    | ERWIN_TRUE                   |                                          |
   *    +-------------------------------------+------------------------------------------+
   *
   * References
   * ~~~~~~~~~~
   * vector_char_p_qsort, vector_char_p_sort, vector_char_p_bfind.
   */

/* ***** iteration: ***** */
/* New approach: */
#define vector_char_p_forall(v,i,h) \
        for(vector_char_p_init_iterator((v),&(i)); \
            vector_char_p_next_iteration((v),&(i),&(h)); /*nix*/)
/* Iteration operator for vectors.  Iterates over all indices and values starting at index 0
 * and incrementing \p i by 1 in each iteration. In constrast to maps, you do not need an
 * iterator (the index is used as an iterator).
 *
 * In C++, use vector_forall.
 *
 * Iterators are nestable without restriction (even on the same vector).
 * During iteration, the vector may not be changed.
 * If you use C++, the *_copy and *_sorted iterators allow changing during iteration.
 *
 * You may freely use break and continue in the loop.
 *
 * : int i;
 * : char *s;
 * : vector_char_p_forall (v, i, s) {
 * :     printf ("v[%d]=%s\n", i, s);
 * : }
 */

#define vector_char_p_forall_ptr(v,i,h) for(vector_char_p_init_iterator(v,&(i)); vector_char_p_next_iteration_ptr(v,&(i),&(h)); /*nix*/)
/* Iteration operator for vectors.  Iterates over all indices and pointers to values starting at
 * index 0.  In contrast to vector_char_p_forall this macro can be used to change the values due to
 * the pointer iteration. */

#define vector_char_p_forall_ptr_const(v,i,h) for(vector_char_p_init_iterator(v,&(i)); vector_char_p_next_iteration_ptr_const(v,&(i),&(h)); /*nix*/)

#define vector_char_p_forall_reverse(v,i,h) for(vector_char_p_init_iterator_reverse(v,&(i)); vector_char_p_next_iteration_reverse(v,&(i),&(h)); /*nix*/)
/* Iterator operator for reversed order, i.e., starting at index vector_char_p_nentries()-1 and
 * decrementing \p i downto 0.  See vector_char_p_forall for details.
 */

#define vector_char_p_forall_ptr_reverse(v,i,h) for(vector_char_p_init_iterator_reverse(v,&(i)); vector_char_p_next_iteration_ptr_reverse(v,&(i),&(h)); /*nix*/)
/* Iterator operator for reversed order, i.e., starting at index vector_char_p_nentries()-1 and
 * decrementing \p i downto 0.  See vector_char_p_forall, vector_char_p_forall_reverse and
 * vector_char_p_forall_ptr for details.
 */

#define vector_char_p_forall_ptr_const_reverse(v,i,h) for(vector_char_p_init_iterator_reverse(v,&(i)); vector_char_p_next_iteration_ptr_const_reverse(v,&(i),&(h)); /*nix*/)

ERWIN_EXPORT
void vector_char_p_init_iterator (vector_char_p_t const *, vector_char_p_index_t * /*keyptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_next_iteration  (vector_char_p_t const *, vector_char_p_index_t * /*keyptr*/, char * * /*valueptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_next_iteration_ptr  (vector_char_p_t *, vector_char_p_index_t * /*keyptr*/, char * ** /*valuepp*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_next_iteration_ptr_const  (vector_char_p_t const *, vector_char_p_index_t * /*keyptr*/, char * const ** /*valuepp*/);
/*private*/

ERWIN_EXPORT
void vector_char_p_init_iterator_reverse (vector_char_p_t const *, vector_char_p_index_t * /*keyptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_next_iteration_reverse  (vector_char_p_t const *, vector_char_p_index_t * /*keyptr*/, char * * /*valueptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_next_iteration_ptr_reverse  (vector_char_p_t *, vector_char_p_index_t * /*keyptr*/, char * ** /*valueptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_next_iteration_ptr_const_reverse  (vector_char_p_t const *, vector_char_p_index_t * /*keyptr*/, char * const ** /*valueptr*/);
/*private*/

/* ***** access to all entries: ***** */
ERWIN_EXPORT
void vector_char_p_clear (vector_char_p_t* /*self*/);
   /* Like vector_char_p_erase for all elements. */

ERWIN_EXPORT
void vector_char_p_clear_keep (vector_char_p_t* /*self*/, vector_char_p_cnt_t /*table_min_size*/);
   /* Like vector_char_p_clear(), but the internal table is not shrunk below
    * the given minimal size (instead of the predefined minimal table size)
    */

ERWIN_EXPORT
void vector_char_p_clear_flags (vector_char_p_t* /*self*/, ERWIN_BOOL /* resize */, ERWIN_BOOL /* delete_elems */);
   /* Like vector_char_p_clear you can specify whether a realloc will be performed and
    * whether the elements will be freed.
    * The former is useful if you  want to clear the vector but expect new data of
    * around the same length to be inserted afterwards.
    *
    * This function is only available of char * == char *.
    */

ERWIN_EXPORT
void vector_char_p_clear_no_resize (vector_char_p_t* /*self*/);
   /* Compatibility & convenience:
    * Like vector_char_p_clear(\p self) without resizing the table.
    */

/*BEGIN:IGNORE*/
#if defined(ERWIN_COMPILING) || !defined(NDEBUG)
/*END:IGNORE*/

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_nentries (vector_char_p_t const * /*self*/) ATTR_PURE;
   /* Returns the number of entries in the vector.
    *
    * Note: This is not called `vector_char_p_size' in order to prevent confusion
    * about the unit of the result.  `size' might refer to bytes.  `nentries', however,
    * is clearer.
    */

ERWIN_EXPORT
ERWIN_BOOL vector_char_p_empty (vector_char_p_t const * /*self*/) ATTR_PURE;
   /* Returns whether the vector contains no elements. */

/*BEGIN:IGNORE*/
/* #if defined(ERWIN_COMPILING) || VECTOR_CHAR_P_ALLOW_OUTOFRANGE || VECTOR_CHAR_P_RANGE_CHECK */
#else
#define VECTOR_CHAR_P_INLINE__NENTRIES
#endif
/*END:IGNORE*/

ERWIN_EXPORT
vector_char_p_cnt_t vector_char_p_table_size (vector_char_p_t const* /*self*/) ATTR_PURE;
  /* For debugging and optimisation purposes (use rarely): the current
   * size of of the internal pre-allocated array of elements.
   */


ERWIN_EXPORT
vector_char_p_index_t vector_char_p_find  (
    vector_char_p_t const * /*self*/, vector_char_p_index_t /*start*/, char *  /*needle*/) ATTR_ERRNO_PURE;
   /* Tries to finds an entry equal to needle.  Returns the index of the first element >= start
    * or -1 of nothing was found.  The search is performed from the beginning to the end.
    *
    * If start is negativ, search is started at the last but start-th position.  So to search
    * the whole vector, start should be 0.
    *
    * Note: This function is not called `vector_char_p_search', because it does not only
    * perform the search, but also returns the result of that search.
    *
    * References
    * ~~~~~~~~~~
    * vector_char_p_rfind, vector_char_p_bfind.
    */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_find_ptr (
   vector_char_p_t const * /*self*/, vector_char_p_index_t /*start*/, char *  /*needle*/) ATTR_ERRNO_PURE;
   /* Like vector_char_p_find but returns a pointer to the found item or NULL on failure. */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_rfind (
    vector_char_p_t const * /*self*/, vector_char_p_index_t /*start*/, char *  /*needle*/) ATTR_ERRNO_PURE;
   /* Tries to finds an entry equal to needle.  Returns the index of the first element <= start
    * or -1 of nothing was found.  The search is performed from the end to the beginning.
    *
    * If start is negativ, search is started at the last but start-th position.  So to search
    * the whole vector, start should be -1.
    *
    * References
    * ~~~~~~~~~~
    * vector_char_p_find
    */

ERWIN_EXPORT
vector_char_p_element_ptr_t vector_char_p_rfind_ptr (
    vector_char_p_t const * /*self*/, vector_char_p_index_t /*start*/, char *  /*needle*/) ATTR_ERRNO_PURE;
   /* Like vector_char_p_rfind but returns a pointer to the found item or NULL on failure. */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_find_raw (
        vector_char_p_t const * /*self*/,
        vector_char_p_index_t /*start*/,
        char * const * /*needle*/,
        vector_char_p_cnt_t /*len*/) ATTR_ERRNO_PURE;
   /* Like vector_char_p_find but tries to find equal parts.  See vector_char_p_rfind_raw. */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_rfind_raw (vector_char_p_t const * /*self*/, vector_char_p_index_t /*start*/,
                            char * const * /*needle*/, vector_char_p_cnt_t /*len*/) ATTR_ERRNO_PURE;
   /* Like vector_char_p_rfind but tries to find equal parts.
    *
    * Return the position of `needle' or -1 if it is not found.
    * Note that it is no problem to search for the zero element CHAR_P_ZERO.
    * These all use the VECTOR_CHAR_P_EQUAL macro.
    *
    * Negative values for start will count from the end of the vector.
    */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_find_if (
        vector_char_p_t const * /*self*/,
        vector_char_p_index_t /* start*/,
        vector_char_p_feature_t /*feature*/,
        ERWIN_BOOL /* value */);
   /* find_if behaves like position-if in CommonLisp.
    *
    * Tries to find an entry with a certain feature.  Returns the index of the first element >= start
    * or -1 of nothing was found.  The search is performed from the beginning to the end.
    *
    * If start is negativ, search is started at the last but start-th position.  So to search
    * the whole vector, start should be 0.
    */

ERWIN_EXPORT
vector_char_p_index_t vector_char_p_rfind_if (
        vector_char_p_t const * /*self*/,
        vector_char_p_index_t /* start */,
        vector_char_p_feature_t /*feature*/,
        ERWIN_BOOL /* value */);
   /* Tries to find an entry with a certain feature.  Returns the index of the first element <= start
    * or -1 of nothing was found.  The search is performed from the end to the beginning.
    *
    * If start is negativ, search is started at the last but start-th position. So to search
    * the whole vector, start should be -1.
    */


ERWIN_EXPORT
ERWIN_BOOL vector_char_p_is_equal_at (vector_char_p_t const * /*self*/,  vector_char_p_index_t /*pos*/,
                                char * const * /*other*/, vector_char_p_cnt_t /*len*/) ATTR_ERRNO_PURE;
   /* Checks whether the given string is found at the given position.
    * Negative values for pos will count from the end of the vector.
    */

ERWIN_EXPORT
void vector_char_p_ltrim_if (vector_char_p_t * /*self*/, vector_char_p_feature_t /*feature*/, ERWIN_BOOL /*value*/);
   /* Cuts off all elements that have the `feature' from the left of the vector
    *
    * References: vector_char_p_rtrim_if, vector_char_p_trim_if
    */

ERWIN_EXPORT
void vector_char_p_rtrim_if (vector_char_p_t * /*self*/, vector_char_p_feature_t /*feature*/, ERWIN_BOOL /*value*/);
   /* Cuts off all elements that have the `feature' from the right of the vector
    *
    * References: vector_char_p_ltrim_if, vector_char_p_trim_if
    */

ERWIN_EXPORT
void vector_char_p_trim_if  (vector_char_p_t * /*self*/, vector_char_p_feature_t /*feature*/, ERWIN_BOOL /*value*/);
   /* Cuts off all elements that have the `feature' from the left and right of the vector
    *
    * References: vector_char_p_ltrim_if, vector_char_p_rtrim_if
    */

ERWIN_EXPORT
void vector_char_p_map (vector_char_p_t * /*self*/, vector_char_p_map_t /*map*/);
   /* Applies a given function to all elements of the vector. */

ERWIN_EXPORT
int vector_char_p_cmp (vector_char_p_t const *, vector_char_p_t const *, vector_char_p_cmp_t /*cmp*/);
    /* Returns a comparison value for lexical sort order, or by length order,
     * depending on VECTOR_CHAR_P_COMPARE_LEXICOGRAPHICALLY, which defaults to 1 for
     * non-character types, and to 0 for all others.  The difference is that
     * the length order checks the length of the vector first, which is expected
     * to yield a quicker distinction for most vectors.
     *
     * This function is NULL safe.  NULL is smaller than any
     * other vector.  By this you can easily sort a vector in reverse order and then
     * rtrim_if(is_NULL) to get rid of NULL elements.
     *
     * If cmp is NULL, CHAR_P_CMP will be used.  If that is not defined, an error
     * will occur.
     */

ERWIN_EXPORT
hashval_t vector_char_p_hash_raw (vector_char_p_t const *) ATTR_ERRNO_PURE;
    /* Returns a hash value, which is derived from hash values for char *.
     *
     * This is traditionally called hash_raw although the hash value is
     * good enough for a normal HASH nowadays.
     *
     * Note: Usually you want hash values if you work with maps.  So you
     *       should define the hash value in such a way that both the map
     *       header as well as the vector header find them.
     *
     * Further Note: This will only be implemented if CHAR_P_HASH_RAW
     * is defined.
     *
     */

ERWIN_WRAPPER
hashval_t vector_char_p_hash (vector_char_p_t const *) ATTR_ERRNO_PURE;
    /* Same as vector_char_p_hash_raw() now that hash_raw() is good enough. */

ERWIN_WRAPPER
hashval_t vector_char_p_hash (vector_char_p_t const *x)
{
    return vector_char_p_hash_raw(x);
}


/*--END-C--*/

#include "vector_char_p_i.h"
/* Same problem as for arrays.  For efficient implementation, the compiler
 * needs to know the size of a vector structure.
 */


/*
 * If initial_size < 0 for any of the following functions, the default
 * size will be used.
 */

struct vector_char_p_t
#ifdef VECTOR_CHAR_P_SUPER_CLASS
   : VECTOR_CHAR_P_SUPER_CLASS_ACCESS VECTOR_CHAR_P_SUPER_CLASS
#endif
{
    /*
     * The vector_char_p Class
     * ================
     * This class implements dynamically resizable arrays.
     *
     * Throughout the documentation, the following prefixes will be used:
     *   - :
     *       The library prefix: for applications, this is typically
     *       empty, for an xyz-Library, this is either \tt(XYZ_), \tt(xyz_) or
     *       \tt(Xyz), depending on the identifier in occurs in.
     *       +---------------------+-----------------+
     *       |! Template           |! Instantiation  |
     *       | VECTOR_OK    | XYZ_VECTOR_OK   |
     *       | vector_new   | xyz_vector_new  |
     *       +---------------------+-----------------+
     *
     *   - vector_char_p_:
     *       This is equivalent to vector_char_p, or the name
     *       that was set with \tt(-name=...) for this data structure.
     *       The case and underbar convention is adjusted, too.
     *
     *       Assuming a library prefix \tt(xyz) and char * == char, you get:
     *       +-------------------+----------------------------+
     *       |! Template         |! Instantiation             |
     *       | vector_char_p_t          | xyz_vector_char_t          |
     *       | VECTOR_CHAR_P_ALLOW_NULL | XYZ_VECTOR_CHAR_ALLOW_NULL |
     *       +-------------------+----------------------------+
     *   - VectorCharP:
     *       This is the name of the data structure type in C++: capitalised
     *       and with underbars removed:
     *       +-------------------+-----------------+
     *       |! vector_char_p_t         |! VectorCharP   |
     *       | vector_char_t     | VectorChar      |
     *       +-------------------+-----------------+
     *
     * Conventions
     * -----------
     *
     * It was tried to keep the argument order consistent, with some rules:
     *
     *    - for functions returning multiple values into pointer arguments, these
     *      are always /before/ input arguments. (e.g. vector_char_p_locate (output, self, ...)).
     *      (Mnemonic: like memcpy, strcpy, assignment statement etc.)
     *       : ERWIN_BOOL vector_char_p_locate (int *i, vector_char_p_t const *, ...)
     *       : ^output                          ^output ^input            ^input
     *       :                                          ^first input = self
     *    - the self argument is always the first input argument.
     *    - index before element   (e.g.,
     *       : vector_char_p_insert (self, position, element)
     *    - count after element(s). E.g.:
     *       : vector_char_p_insert_raw (self, position, elemnt_ptr, count)
     *    - flags last. E.g.:
     *       : vector_char_p_overwrite_flags (self, start, value, count,
     *       :                         copy_elems, delete_overwritten)
     *
     * Results
     * ~~~~~~~
     *   - if there is no natural result value, C functions return their success,
     *     i.e., the value of vector_errno:
     *       : int vector_char_p_erase (vector_char_p_t *self, int pos, int count)
     *     In these circumstances, C++ functions return the vector itself as
     *     a reference:
     *       : vector_char_p_t &vector_char_p_t::erase (int pos, int count = 1)
     *   - if vector_char_p_errno is not interesting, either because it is not
     *     set or because only memory overflow or assertion failures may be
     *     a possible sources of an error, the C functions return void:
     *       : void vector_char_p_delete (vector_char_p_t *self)
     *     The C++ functions still return the object reference.
     *
     * Status Codes
     * ------------
     *
     * These are undef'ed first because there is only one error code for all
     * the arrays in your program.
     * All the functions returing error codes will both return this error
     * and write it into vector_errno.
     *
     *    +-----------------------+---------------------------+-----------------------------+
     *    |! Condition            |! Description              |! Macro to use               |
     *    +-----------------------+---------------------------+-----------------------------+
     *    | == VECTOR_OK   | Ok.                       | VECTOR_IS_OK(X)      |
     *    +-----------------------+---------------------------+-----------------------------+
     *    | <  VECTOR_OK   | *Error*: operation did    | VECTOR_IS_ERROR(X)   |
     *    |                       | not succeed.              |                             |
     *    +-----------------------+---------------------------+-----------------------------+
     *    | >  VECTOR_OK   | *Warning*: operation      | VECTOR_IS_WARNING(X) |
     *    |                       | succeeded but not         |                             |
     *    |                       | perfectly. (e.g. rehash   |                             |
     *    |                       | failed)                   |                             |
     *    +-----------------------+---------------------------+-----------------------------+
     *
     *
     *  In all cases, the consistency of the data structure is guaranteed.
     *
     *  Warnings are only visible in vector_errno; the functions still return
     *  VECTOR_OK.
     */

    VECTOR_CHAR_P_STD_MEMBERS(vector_char_p_t)

#ifdef __cplusplus
public: /* The implementation is in C, so these need access. */
#endif /* defined __cplusplus */

    vector_char_p_record

#ifdef __cplusplus

    /*! doc-ignore */
    vector_char_p_t *it()             { return this; }

    /*! doc-ignore */
    vector_char_p_t const *it() const { return this; }

/*--BEGIN-CLASS--*/
public:
#ifdef __cplusplus
#if !ERWIN_DEFAULT_NEW_DELETE
    static void *operator new(size_t);
    static void operator delete(void *, size_t);
    static void *operator new[](size_t);
    static void operator delete[](void *, size_t);
#endif
#endif

    /* Creation */

    vector_char_p_t (void);

    static vector_char_p_t const &static_zero();

#if VECTOR_CHAR_P_HAVE_INT_CONSTRUCTOR
    ERWIN_EXPLICIT vector_char_p_t (vector_char_p_cnt_t initial_size);
#endif
#if VECTOR_CHAR_P_DYN_ZERO
    ERWIN_EXPLICIT vector_char_p_t (char * );
    vector_char_p_t (char * , vector_char_p_cnt_t);
#endif

    /*
     * Enforced vector copying.  All of the following functions create a new vector
     * and leave the old one (if any) intact.  It can be defined whether the elements
     * are to be copied. */

    vector_char_p_t (vector_char_p_t const *, bool do_copy VECTOR_CHAR_P_DEFAULT_ARG(true));

    vector_char_p_t (vector_char_p_t const *, vector_char_p_index_t, vector_char_p_cnt_t, bool do_copy VECTOR_CHAR_P_DEFAULT_ARG(true));

    vector_char_p_t (char * const *, bool do_copy VECTOR_CHAR_P_DEFAULT_ARG(true));
    vector_char_p_t (char * const *, vector_char_p_cnt_t, bool do_copy VECTOR_CHAR_P_DEFAULT_ARG(true));

    /* The following is thought to be for coercing arrays to vectors.  The vector
     * then operates directly on the given array.  See vector_char_p_new_from_raw for
     * details. */

    vector_char_p_t (bool       /* must_be_true */,
              char * * /* other */,
              vector_char_p_cnt_t        /* count */,
              vector_char_p_cnt_t        /* alloc */);
       /* alloc may be -1: see vector_char_p_new_from_raw */

#if VECTOR_CHAR_P_DYN_ZERO
    vector_char_p_t (bool         /* must_be_true */,
              char * *   /* other */,
              vector_char_p_cnt_t          /* count */,
              vector_char_p_cnt_t          /* alloc */,
              char *  /* zero_element */);
       /* alloc may be -1: see vector_char_p_new_from_raw */
#endif

    vector_char_p_t (bool       /* must_be_true */,
              vector_char_p_t * /* other */);

    vector_char_p_t (bool       /* must_be_true */,
              vector_char_p_t & /* other */);

    void _constructor (void);
    void _destructor  (void);

    /* Check for NULL pointers */
protected:
#ifndef NDEBUG
    void cn() const;
    void cn(void const *) const;
#else
    /* Hopefully optimised away: */
    static void cn() {}
    static void cn(void const *) {}
#endif

public:
    /* Status code */

#if !ERWIN_GLOBAL_ERRNO
    int get_errno(void) const
    { return it()->m_errno; }

    void clear_errno(void) const
    { vector_char_p_clear_errno (it()); }
#else
    static int get_errno(void)
    { return vector_errno; }

    static void clear_errno(void)
    { vector_errno= VECTOR_OK; }
#endif

    /* Copying */

    vector_char_p_t (vector_char_p_t const &, bool docopy VECTOR_CHAR_P_DEFAULT_ARG(true));
    vector_char_p_t (vector_char_p_t const &, vector_char_p_index_t, vector_char_p_cnt_t, bool do_copy VECTOR_CHAR_P_DEFAULT_ARG(true));

    vector_char_p_t *copy (void) const
    {
        if (this == NULL)
            return NULL;
        return new vector_char_p_t (it(), true);
    }

    vector_char_p_t *copy_err (int *err) const
    {
        if (this == NULL) /* special case for copy function */
            return NULL;
        vector_char_p_t *result= new vector_char_p_t (it(), true);
        if (err != NULL && VECTOR_IS_ERROR (get_errno()))
            *err= 1;
        return result;
    }

    /* The following functions assume that vector_char_p_t and vector_char_p_t are the
     * same type making things more easy.  Since they did not exist in pre 2.0.265,
     * we can simply not declare them when the compat is define. */

    vector_char_p_t *copy_detach()
    {
        return vector_char_p_new_from_vector (it());
    }

    vector_char_p_t &xchg(vector_char_p_t *other)
    {
        vector_char_p_xchg (it(), other);
        return *this;
    }

    vector_char_p_t &xchg(vector_char_p_t &other)
    {
        vector_char_p_xchg (this, &other);
        return *this;
    }

    /* Normal members */

    vector_char_p_t *subvector (vector_char_p_index_t b, vector_char_p_cnt_t c) const
    {
        return new vector_char_p_t (this, b, c, true);
    }

    vector_char_p_t *subvector (vector_char_p_index_t b, vector_char_p_cnt_t c, bool d) const
    {
        return new vector_char_p_t (this, b, c, d);
    }


    /* Assignment */

    vector_char_p_t &operator=(vector_char_p_t const &);
    vector_char_p_t &operator=(vector_char_p_t const *);

    /* Destruction */

    ~vector_char_p_t ();

    /* Re-init by dropping responsibility for the table: */

    vector_char_p_t &detach (void)
    { vector_char_p_detach (it()); return *this; }

    vector_char_p_t &detach_as_is (void)
    { vector_char_p_detach_as_is (it()); return *this; }

    /* Conversion to C type <= 2.0.264 / conversion to pointer > 2.0.264 */

    operator vector_char_p_t const *() const
    { return it(); }

    operator vector_char_p_t *()
    { return it(); }

    /* operator int () const { cn(); return get_errno(); }
     * FIXME: maybe add this one day.  It produces invisible semantics changes with
     * old versions when 'explicit' is used as well. */

#if VECTOR_CHAR_P_MANY_CASTS != 0
    operator vector_char_p_element_ptr_t () const
    { return as_array(); }

    operator bool () const
    { return !empty(); }
#endif

#if VECTOR_CHAR_P_POSITION_POINTER
    vector_char_p_index_t *pos_ptr ()                 { return &m_pos; }
    vector_char_p_index_t &pos_ref ()                 { return m_pos;  }
    vector_char_p_index_t  pos     ()                 { return m_pos;  }
    void            set_pos (vector_char_p_index_t y) { m_pos= y;      }
#endif

    char *  nth (vector_char_p_index_t i) const
    {
#ifdef VECTOR_CHAR_P_INLINE__NTH
        cn();
        return m_table[i];
#else
        return vector_char_p_nth (it(), i);
#endif
    }

    char *  nth_char (vector_char_p_index_t i) const
    { return vector_char_p_nth_char (it(), i); }

    vector_char_p_element_ptr_t nth_ptr_check (vector_char_p_index_t i)
    {
        return vector_char_p_nth_ptr_check (it(), i);
    }

    char * const *nth_ptr_check (vector_char_p_index_t i) const
    {
        return vector_char_p_nth_ptr_check_const (it(), i);
    }

    vector_char_p_element_ptr_t nth_ptr_char (vector_char_p_index_t i)
    {
        return vector_char_p_nth_ptr_char (it(), i);
    }

    char * const *nth_ptr_char (vector_char_p_index_t i) const
    {
        return vector_char_p_nth_ptr_char_const (it(), i);
    }

    vector_char_p_element_ptr_t nth_ptr (vector_char_p_index_t i)
    {
        return vector_char_p_nth_ptr (it(), i);
    }

    char * const *nth_ptr (vector_char_p_index_t i) const
    {
        return vector_char_p_nth_ptr_const (it(), i);
    }

    vector_char_p_element_ref_t nth_ref (vector_char_p_index_t i)
    {
        return *(vector_char_p_nth_ptr (it(), i));
    }

    char * const &nth_ref (vector_char_p_index_t i) const
    {
        return *(vector_char_p_nth_ptr_const (it(), i));
    }

    vector_char_p_element_ref_t nth_ref_check (vector_char_p_index_t i)
    {
        return *(vector_char_p_nth_ptr_check (it(), i));
    }

    char * const &nth_ref_check (vector_char_p_index_t i) const
    {
        return *(vector_char_p_nth_ptr_check_const (it(), i));
    }

    vector_char_p_element_ref_t nth_ref_char (vector_char_p_index_t i)
    {
        return *(vector_char_p_nth_ptr_char (it(), i));
    }

    char * const &nth_ref_char (vector_char_p_index_t i) const
    {
        return *(vector_char_p_nth_ptr_char_const (it(), i));
    }



    vector_char_p_element_ref_t operator[] (vector_char_p_index_t i)
    { return *nth_ptr_check (i); }

    char *  operator[] (vector_char_p_index_t i) const
    { return nth (i); }


    char *  first (void) const
    {
        return nth (0);
    }

    vector_char_p_element_ptr_t first_ptr ()
    {
        return vector_char_p_first_ptr (it());
    }

    vector_char_p_element_ref_t first_ref ()
    {
        return *(vector_char_p_first_ptr (it()));
    }

    char *  last (void) const
    {
        return nth (nentries()-1);
    }

    vector_char_p_element_ptr_t last_ptr ()
    {
        return vector_char_p_last_ptr (it());
    }

    vector_char_p_element_ref_t last_ref ()
    {
        return *(vector_char_p_last_ptr (it()));
    }

    char * modify (vector_char_p_index_t i, char *  v)
    { return vector_char_p_modify (it(), i, v); }

    vector_char_p_t &reverse (void)
    {
        vector_char_p_reverse (it());
        return *this;
    }

    char * last_chop1 (void)
    {
        return vector_char_p_last_chop1 (it());
    }

    char * first_swap_chop1 (void)
    {
        return vector_char_p_first_swap_chop1 (it());
    }

    /* Set */

    vector_char_p_t &set (vector_char_p_index_t i, char *  v)
    { vector_char_p_set (it(), i, v); return *this; }

    /* Erase family */

    vector_char_p_t &swap_erase (vector_char_p_index_t i, vector_char_p_cnt_t n = -1)
    { vector_char_p_swap_erase (it(), i, n); return *this; }


    vector_char_p_t &swap_erase (vector_char_p_index_t i, vector_char_p_cnt_t n, bool a, bool b=true)
    {
        vector_char_p_swap_erase_flags (it(), i, n, a, b);
        return *this;
    }

    vector_char_p_t &erase (vector_char_p_index_t i, vector_char_p_cnt_t n = -1)
    { vector_char_p_erase (it(), i, n); return *this; }


    vector_char_p_cnt_t erase_zero ()
    {
        return vector_char_p_erase_zero (it());
    }

    vector_char_p_t &erase (vector_char_p_index_t i, vector_char_p_cnt_t n, bool a, bool b=true)
    {
        vector_char_p_erase_flags (it(), i, n, a, b);
        return *this;
    }

    vector_char_p_cnt_t erase_if (vector_char_p_feature_t f,
                  bool inv VECTOR_CHAR_P_DEFAULT_ARG(true),
                  bool a   VECTOR_CHAR_P_DEFAULT_ARG(true),
                  bool b   VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_erase_if_flags (it(), f, inv,a,b);
    }

    vector_char_p_cnt_t erase_if_not (
                  vector_char_p_feature_t f,
                  bool inv VECTOR_CHAR_P_DEFAULT_ARG(true),
                  bool a   VECTOR_CHAR_P_DEFAULT_ARG(true),
                  bool b   VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_erase_if_flags (it(), f, !inv, a, b);
    }

    vector_char_p_cnt_t erase_equals (vector_char_p_cmp_t fcmp VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL),
                      vector_char_p_combine_t combine VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_COMBINE_T_NULL))
    {
        return vector_char_p_erase_equals (it(), fcmp, combine);
    }


    vector_char_p_t &swap_chop (vector_char_p_cnt_t n VECTOR_CHAR_P_DEFAULT_ARG(1))
    {
        vector_char_p_swap_erase (it(), 0, n);
        return *this;
    }

    vector_char_p_t &swap_chop (bool a, bool b VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        vector_char_p_swap_erase_flags (it(), 0, 1, a, b);
        return *this;
    }
    vector_char_p_t &swap_chop (vector_char_p_cnt_t n, bool a, bool b VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        vector_char_p_swap_erase_flags (it(), 0, n, a, b);
        return *this;
    }

    vector_char_p_t &chop (vector_char_p_cnt_t n VECTOR_CHAR_P_DEFAULT_ARG(1))
    {
        vector_char_p_chop (it(), n);
        return *this;
    }

    vector_char_p_t &chop (bool a, bool b VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        vector_char_p_chop_flags (it(), 1, a, b);
        return *this;
    }
    vector_char_p_t &chop (vector_char_p_cnt_t n, bool a, bool b VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        vector_char_p_chop_flags (it(), n, a, b);
        return *this;
    }

    vector_char_p_t &prepend (char *  a)
    { vector_char_p_insert (it(), 0, a); return *this; }

    vector_char_p_t &prepend_raw     (char * const *a, vector_char_p_cnt_t n)
    { vector_char_p_insert_raw (it(), 0, a, n); return *this; }

    vector_char_p_t &prepend_no_copy (char * const *a, vector_char_p_cnt_t n)
    { vector_char_p_insert_no_copy (it(), 0, a, n); return *this; }

    vector_char_p_t &prepend_vector  (vector_char_p_t const *a)
    { vector_char_p_insert_vector (it(), 0, a->it()); return *this; }

    vector_char_p_t &prepend_vector  (vector_char_p_t const &a)
    { vector_char_p_insert_vector (it(), 0, a.it()); return *this; }

    vector_char_p_t &prepend_string  (char * const *a)
    { vector_char_p_insert_string (it(), 0, a); return *this; }


    vector_char_p_t &append (char *  a)
    { vector_char_p_append (it(), a); return *this; }

    vector_char_p_t &append_raw     (char * const *a, vector_char_p_cnt_t n)
    { vector_char_p_append_raw (it(), a, n); return *this; }

    vector_char_p_t &append_no_copy (char * const *a, vector_char_p_cnt_t n)
    { vector_char_p_append_no_copy (it(), a, n); return *this; }

    vector_char_p_t &append_vector  (vector_char_p_t const *a)
    { vector_char_p_append_vector (it(), a->it()); return *this; }

    vector_char_p_t &append_vector  (vector_char_p_t const &a)
    { vector_char_p_append_vector (it(), a.it()); return *this; }

    vector_char_p_t &append_string  (char * const *a)
    { vector_char_p_append_string (it(), a); return *this; }

    vector_char_p_t &append_subvector (
        vector_char_p_t const &a,
        vector_char_p_index_t b,
        vector_char_p_cnt_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (0, a, b, c, d);
    }

    vector_char_p_t &append_subvector (
        vector_char_p_t const *a,
        vector_char_p_index_t b,
        vector_char_p_cnt_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (0, a, b, c, d);
    }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    /* The following function is really bad when format() is defined and you mix up
       append and format.

       Compare:
            : v->append ("There are many pieces");
            : v->format ("There are many pieces");

       These are equivalent.  I would choose to use append here.  But look at this:
            : v->append ("There are %d pieces", i);
            : v->format ("There are %d pieces", i);

       Of course, the second one was meant here.  This is an easy typo the compiler
       cannot warn about.

       Therefore, Erwin does not implement the following function.  It is still
       available via append_raw.
    */

    /*
    int append (char * const *a, int n)
    { return vector_char_p_append_raw (it(), a, n); }
    */

    vector_char_p_t &prepend (vector_char_p_t const *a)
    { vector_char_p_insert_vector (it(), 0, a->it()); return *this; }

    vector_char_p_t &prepend (vector_char_p_t const &a)
    { vector_char_p_insert_vector (it(), 0, a.it()); return *this; }

    vector_char_p_t &prepend (char * const *a)
    { vector_char_p_insert_string (it(), 0, a); return *this; }

    vector_char_p_t &append (vector_char_p_t const *a)
    { vector_char_p_append_vector (it(), a->it()); return *this; }

    vector_char_p_t &append (vector_char_p_t const &a)
    { vector_char_p_append_vector (it(), a.it()); return *this; }

    vector_char_p_t &append (char * const *a)
    { vector_char_p_append_string (it(), a); return *this; }

    vector_char_p_t &operator<< (char * const *a)
    { vector_char_p_append_string (it(), a); return *this; }

   /* For the same reason as the one above, we will not implement the following functions, since
    * the second one may be invoked for append ("Test", 4) with an autocast.  You will then
    * effectively append "", which is probably not what you want.  The first one is
    * not implemented for symmetry reasons.

    vector_char_p_t &append (
        vector_char_p_t const *a,
        vector_char_p_index_t b,
        vector_char_p_index_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        return append_subvector (a, b, c, d);
    }

    vector_char_p_t &append (
        vector_char_p_t const &a,
        vector_char_p_index_t b,
        vector_char_p_index_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        return append_subvector (a, b, c, d);
    }
    */

#endif /* VECTOR_CHAR_P_DIRECT_RECURSION == 0*/

    vector_char_p_t &operator<< (char *  a)
    { vector_char_p_append (it(), a); return *this; }

    vector_char_p_t &operator<< (vector_char_p_t const*a)
    { vector_char_p_append_vector (it(), a->it()); return *this; }

    vector_char_p_t &operator<< (vector_char_p_t const&a)
    { vector_char_p_append_vector (it(), a.it()); return *this; }

    /* Find family */

    vector_char_p_index_t find (char *  needle) const
    { return vector_char_p_find (it(), 0, needle); }

    vector_char_p_index_t find_raw (char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_find_raw (it(), 0, needle, n); }

    vector_char_p_index_t find_string (char * const *needle) const
    { return vector_char_p_find_raw (it(), 0, needle, string_length (needle)); }

    vector_char_p_index_t find_vector (vector_char_p_t const &needle) const
    { return vector_char_p_find_raw (it(), 0, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t find_vector (vector_char_p_t const *needle) const
    { return vector_char_p_find_raw (it(), 0, needle->it()->m_table, needle->it()->m_nentries); }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    vector_char_p_index_t find (char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_find_raw (it(), 0, needle, n); }

    vector_char_p_index_t find (char * const *needle) const
    { return vector_char_p_find_raw (it(), 0, needle, string_length (needle)); }

    vector_char_p_index_t find (vector_char_p_t const &needle) const
    { return vector_char_p_find_raw (it(), 0, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t find (vector_char_p_t const *needle) const
    { return vector_char_p_find_raw (it(), 0, needle->it()->m_table, needle->it()->m_nentries); }
#endif

    vector_char_p_index_t find (vector_char_p_index_t a, char *  needle) const
    { return vector_char_p_find (it(), a, needle); }

    vector_char_p_index_t find_raw (vector_char_p_index_t a, char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_find_raw (it(), a, needle, n); }

    vector_char_p_index_t find_string (vector_char_p_index_t a, char * const *needle) const
    { return vector_char_p_find_raw (it(), a, needle, string_length (needle)); }

    vector_char_p_index_t find_vector (vector_char_p_index_t a, vector_char_p_t const &needle) const
    { return vector_char_p_find_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t find_vector (vector_char_p_index_t a, vector_char_p_t const *needle) const
    { return vector_char_p_find_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    vector_char_p_index_t find (vector_char_p_index_t a, char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_find_raw (it(), a, needle, n); }

    vector_char_p_index_t find (vector_char_p_index_t a, char * const *needle) const
    { return vector_char_p_find_raw (it(), a, needle, string_length (needle)); }

    vector_char_p_index_t find (vector_char_p_index_t a, vector_char_p_t const &needle) const
    { return vector_char_p_find_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t find (vector_char_p_index_t a, vector_char_p_t const *needle) const
    { return vector_char_p_find_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }
#endif

    /* rFind family */

    vector_char_p_index_t rfind  (char *  needle) const
    { return vector_char_p_rfind (it(), -1, needle); }

    vector_char_p_index_t rfind_raw  (char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_rfind_raw (it(), -1, needle, n); }

    vector_char_p_index_t rfind_string (char * const *needle) const
    { return vector_char_p_rfind_raw (it(), -1, needle, string_length (needle)); }

    vector_char_p_index_t rfind_vector (vector_char_p_t const &needle) const
    { return vector_char_p_rfind_raw (it(), -1, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t rfind_vector (vector_char_p_t const *needle) const
    { return vector_char_p_rfind_raw (it(), -1, needle->it()->m_table, needle->it()->m_nentries); }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    vector_char_p_index_t rfind (char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_rfind_raw (it(), -1, needle, n); }

    vector_char_p_index_t rfind (char * const *needle) const
    { return vector_char_p_rfind_raw (it(), -1, needle, string_length (needle)); }

    vector_char_p_index_t rfind (vector_char_p_t const &needle) const
    { return vector_char_p_rfind_raw (it(), -1, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t rfind (vector_char_p_t const *needle) const
    { return vector_char_p_rfind_raw (it(), -1, needle->it()->m_table, needle->it()->m_nentries); }
#endif

    vector_char_p_index_t rfind  (vector_char_p_index_t a, char *  needle) const
    { return vector_char_p_rfind (it(), a, needle); }

    vector_char_p_index_t rfind_raw  (vector_char_p_index_t a, char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_rfind_raw (it(), a, needle, n); }

    vector_char_p_index_t rfind_string  (vector_char_p_index_t a, char * const *needle) const
    { return vector_char_p_rfind_raw (it(), a, needle, string_length (needle)); }

    vector_char_p_index_t rfind_vector (vector_char_p_index_t a, vector_char_p_t const &needle) const
    { return vector_char_p_rfind_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t rfind_vector (vector_char_p_index_t a, vector_char_p_t const *needle) const
    { return vector_char_p_rfind_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    vector_char_p_index_t rfind (vector_char_p_index_t a, char * const *needle, vector_char_p_cnt_t n) const
    { return vector_char_p_rfind_raw (it(), a, needle, n); }

    vector_char_p_index_t rfind (vector_char_p_index_t a, char * const *needle) const
    { return vector_char_p_rfind_raw (it(), a, needle, string_length (needle)); }

    vector_char_p_index_t rfind (vector_char_p_index_t a, vector_char_p_t const &needle) const
    { return vector_char_p_rfind_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    vector_char_p_index_t rfind (vector_char_p_index_t a, vector_char_p_t const *needle) const
    { return vector_char_p_rfind_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }
#endif


    /* is_equal_at family
     * FIXME: Some functions are missing.  Compare to overwrite.  This is because
     *        the C function has a bad calling convention.  This must be fixed in
     *        the next major release of Erwin. */

    bool is_equal_at_raw (vector_char_p_index_t a, char * const *b, vector_char_p_cnt_t n) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b, n)); }

    bool is_equal_at_string (vector_char_p_index_t a, char * const *b) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b, string_length (b))); }

    bool is_equal_at_vector (vector_char_p_index_t a, vector_char_p_t const &b) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b.it()->m_table, b.it()->m_nentries)); }

    bool is_equal_at_vector (vector_char_p_index_t a, vector_char_p_t const *b) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b->it()->m_table, b->it()->m_nentries)); }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    bool is_equal_at (vector_char_p_index_t a, char * const *b, vector_char_p_cnt_t n) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b, n)); }

    bool is_equal_at (vector_char_p_index_t a, char * const *b) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b, string_length (b))); }

    bool is_equal_at (vector_char_p_index_t a, vector_char_p_t const &b) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b.it()->m_table, b.it()->m_nentries)); }

    bool is_equal_at (vector_char_p_index_t a, vector_char_p_t const *b) const
    { return ERWIN_TO_BOOL(vector_char_p_is_equal_at (it(), a, b->it()->m_table, b->it()->m_nentries)); }
#endif

    vector_char_p_index_t find_if (vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_find_if (it(), 0, feature, inverted);
    }

    vector_char_p_index_t find_if (vector_char_p_index_t start, vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_find_if (it(), start, feature, inverted);
    }

    vector_char_p_index_t rfind_if (vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_rfind_if (it(), -1, feature, inverted);
    }

    vector_char_p_index_t rfind_if (vector_char_p_index_t start, vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_rfind_if (it(), start, feature, inverted);
    }

    /* Convenience functions */

    vector_char_p_index_t find_if_not (vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_find_if (it(), 0, feature, !inverted);
    }

    vector_char_p_index_t find_if_not (vector_char_p_index_t start, vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_find_if (it(), start, feature, !inverted);
    }

    vector_char_p_index_t rfind_if_not (vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_rfind_if (it(), -1, feature, !inverted);
    }

    vector_char_p_index_t rfind_if_not (vector_char_p_index_t start, vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        return vector_char_p_rfind_if (it(), start, feature, !inverted);
    }

    /*  Trimming */

    vector_char_p_t &ltrim_if (vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        vector_char_p_ltrim_if (it(), feature, inverted);
        return *this;
    }

    vector_char_p_t &ltrim_if_not (vector_char_p_feature_t feature, bool inverted VECTOR_CHAR_P_DEFAULT_ARG(true))
    {
        vector_char_p_ltrim_if (it(), feature, !inverted);
        return *this;
    }

    vector_char_p_t &rtrim_if (vector_char_p_feature_t feature, bool inv VECTOR_CHAR_P_DEFAULT_ARG (true))
    {
        vector_char_p_rtrim_if (it(), feature, inv);
        return *this;
    }

    vector_char_p_t &rtrim_if_not (vector_char_p_feature_t feature, bool inv VECTOR_CHAR_P_DEFAULT_ARG (true))
    {
        vector_char_p_rtrim_if (it(), feature, !inv);
        return *this;
    }

    vector_char_p_t &trim_if (vector_char_p_feature_t feature, bool inv VECTOR_CHAR_P_DEFAULT_ARG (true))
    {
        vector_char_p_trim_if (it(), feature, inv);
        return *this;
    }

    vector_char_p_t &trim_if_not (vector_char_p_feature_t feature, bool inv VECTOR_CHAR_P_DEFAULT_ARG (true))
    {
        vector_char_p_trim_if (it(), feature, !inv);
        return *this;
    }

    /* Mapping */

    vector_char_p_t &map (vector_char_p_map_t fmap)
    {
        vector_char_p_map (it(), fmap);
        return *this;
    }



    vector_char_p_t &make_gap (vector_char_p_index_t a, vector_char_p_cnt_t b)
    {
        vector_char_p_make_gap (it(), a, b);
        return *this;
    }

    vector_char_p_t &make_gap (vector_char_p_index_t a, char *  x, vector_char_p_cnt_t b)
    {
        vector_char_p_make_gap_with (it(), a, x, b);
        return *this;
    }

    /* compatibility function */
    vector_char_p_t &make_gap_with (vector_char_p_index_t a, char *  x, vector_char_p_cnt_t b)
    {
        return make_gap (a, x, b);
    }

    char *  zero (void) const
    { return vector_char_p_zero (it()); }

    /* Overwrite family */

    vector_char_p_t &overwrite (
        vector_char_p_index_t i,
        vector_char_p_t const *a,
        vector_char_p_index_t ia,
        vector_char_p_cnt_t n)
    {
        vector_char_p_overwrite (it(), i, a->it(), ia, n);
        return *this;
    }

    vector_char_p_t &overwrite (
        vector_char_p_index_t i,
        vector_char_p_t const &a,
        vector_char_p_index_t ia,
        vector_char_p_cnt_t n)
    {
        vector_char_p_overwrite (it(), i, a.it(), ia, n);
        return *this;
    }

    vector_char_p_t &overwrite_raw (vector_char_p_index_t i, char * const *a, vector_char_p_cnt_t n)
    {
        vector_char_p_overwrite_raw (it(), i, a, n);
        return *this;
    }

    vector_char_p_t &overwrite_string (vector_char_p_index_t i, char * const *a)
    {
        vector_char_p_overwrite_string (it(), i, a);
        return *this;
    }

    vector_char_p_t &overwrite_vector (vector_char_p_index_t i, vector_char_p_t const *a)
    {
        vector_char_p_overwrite_vector (it(), i, a->it());
        return *this;
    }

    vector_char_p_t &overwrite_vector (vector_char_p_index_t i, vector_char_p_t const &a)
    {
        vector_char_p_overwrite_vector (it(), i, a.it());
        return *this;
    }

    vector_char_p_t &overwrite_flags (vector_char_p_index_t i, char * const *a, vector_char_p_cnt_t n, bool dealloc, bool docopy)
    {
        vector_char_p_overwrite_flags (it(), i, a, n, dealloc, docopy);
        return *this;
    }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    vector_char_p_t &overwrite (vector_char_p_index_t i, char * const *a, vector_char_p_cnt_t n)
    {
        vector_char_p_overwrite_raw (it(), i, a, n);
        return *this;
    }

    vector_char_p_t &overwrite (vector_char_p_index_t i, char * const *a)
    {
        vector_char_p_overwrite_string (it(), i, a);
        return *this;
    }

    vector_char_p_t &overwrite (vector_char_p_index_t i, vector_char_p_t const *a)
    {
        vector_char_p_overwrite_vector (it(), i, a->it());
        return *this;
    }

    vector_char_p_t &overwrite (vector_char_p_index_t i, vector_char_p_t const &a)
    {
        vector_char_p_overwrite_vector (it(), i, a.it());
        return *this;
    }
#endif

    /* Insert family */

    vector_char_p_t &insert (vector_char_p_index_t i, char *  a)
    {
        vector_char_p_insert (it(), i, a);
        return *this;
    }

    vector_char_p_t &insert_raw (vector_char_p_index_t i, char * const *a, vector_char_p_cnt_t n)
    {
        vector_char_p_insert_raw (it(), i, a, n);
        return *this;
    }

    vector_char_p_t &insert_no_copy (vector_char_p_index_t i, char * const *a, vector_char_p_cnt_t n)
    {
        vector_char_p_insert_no_copy (it(), i, a, n);
        return *this;
    }

    vector_char_p_t &insert_string (vector_char_p_index_t i, char * const *a)
    {
        vector_char_p_insert_string (it(), i, a);
        return *this;
    }

    vector_char_p_t &insert_vector (vector_char_p_index_t i, vector_char_p_t const *a)
    {
        vector_char_p_insert_vector (it(), i, a->it());
        return *this;
    }

    vector_char_p_t &insert_vector (vector_char_p_index_t i, vector_char_p_t const &a)
    {
        vector_char_p_insert_vector (it(), i, a.it());
        return *this;
    }

    vector_char_p_t &insert_subvector (
        vector_char_p_index_t i,
        vector_char_p_t const *a,
        vector_char_p_index_t b VECTOR_CHAR_P_DEFAULT_ARG (0),
        vector_char_p_cnt_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        vector_char_p_insert_subvector (it(), i, a->it(), b, c, d ? ERWIN_TRUE : ERWIN_FALSE);
        return *this;
    }

    vector_char_p_t &insert_subvector (
        vector_char_p_index_t i,
        vector_char_p_t const &a,
        vector_char_p_index_t b VECTOR_CHAR_P_DEFAULT_ARG (0),
        vector_char_p_cnt_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        vector_char_p_insert_subvector (it(), i, a.it(), b, c, d ? ERWIN_TRUE : ERWIN_FALSE);
        return *this;
    }

#if VECTOR_CHAR_P_DIRECT_RECURSION == 0
    vector_char_p_t &insert (
        vector_char_p_index_t i,
        vector_char_p_t const &a,
        vector_char_p_index_t b,
        vector_char_p_cnt_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (i, a, b, c, d);
    }

    vector_char_p_t &insert (
        vector_char_p_index_t i,
        vector_char_p_t const *a,
        vector_char_p_index_t b,
        vector_char_p_cnt_t c VECTOR_CHAR_P_DEFAULT_ARG (-1),
        ERWIN_BOOL d VECTOR_CHAR_P_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (i, a, b, c, d);
    }

    vector_char_p_t &insert (vector_char_p_index_t i, char * const *a, vector_char_p_cnt_t n)
    {
        vector_char_p_insert_raw (it(), i, a, n);
        return *this;
    }

    vector_char_p_t &insert (vector_char_p_index_t i, char * const *a)
    {
        vector_char_p_insert_string (it(), i, a);
        return *this;
    }

    vector_char_p_t &insert (vector_char_p_index_t i, vector_char_p_t const *a)
    {
        vector_char_p_insert_vector (it(), i, a->it());
        return *this;
    }
                                       
    vector_char_p_t &insert (vector_char_p_index_t i, vector_char_p_t const &a)
    {
        vector_char_p_insert_vector (it(), i, a.it());
        return *this;
    }

#endif

    vector_char_p_cnt_t string_length (char * const *a) const
    {
        return vector_char_p_string_length (it(), a);
    }

    vector_char_p_t &ensure_size (vector_char_p_cnt_t a)
    { vector_char_p_ensure_size (it(), a); return *this; }

    vector_char_p_t &ensure_size (vector_char_p_cnt_t a, char *  b)
    { vector_char_p_ensure_size_with (it(), a, b); return *this; }

    vector_char_p_t &set_size (vector_char_p_cnt_t a)
    { vector_char_p_set_size (it(), a); return *this; }

    vector_char_p_t &set_size (vector_char_p_cnt_t a, char *  b)
    { vector_char_p_set_size_with (it(), a, b); return *this; }

    int ensure_table_size (vector_char_p_cnt_t a)
    { return vector_char_p_ensure_table_size (it(), a); }

    vector_char_p_element_ptr_t as_array (void) const
    { return vector_char_p_as_array (it()); }

    vector_char_p_element_ptr_t as_open_array (void) const
    { return vector_char_p_as_open_array (it()); }

    vector_char_p_element_ptr_t as_array_detach (void)
    { return vector_char_p_as_array_detach (it()); }

    vector_char_p_t &ensure_heap_storage(void)
    {
        vector_char_p_ensure_heap_storage (it());
        return *this;
    }

    bool has_heap_storage() const
    {
        return vector_char_p_has_heap_storage (it());
    }

    static vector_char_p_cnt_t inline_store_cnt()
    {
        return  vector_char_p_inline_store_cnt();
    }

    vector_char_p_element_ptr_t as_open_array_detach (void)
    { return vector_char_p_as_open_array_detach (it()); }


    vector_char_p_element_ptr_t operator+(vector_char_p_index_t i)
    { return  nth_ptr_check (i); }

#if ERWIN_IGNORE_BROKEN_MS_COMPILER
    char * const *operator+(vector_char_p_index_t i) const
    { return  nth_ptr_check (i); }
#endif

    vector_char_p_element_ref_t operator*()
    { return *nth_ptr_check (0); }

#if ERWIN_IGNORE_BROKEN_MS_COMPILER
    char *  operator*() const
    { return nth (0); }
#endif

    vector_char_p_element_ptr_t operator+() const
    { return as_open_array(); }
        /* No 0-termination with non-charactor types.  That's consistent with using
         * nth_ptr_check here instead of nth_ptr_char for the isChar case. */


    vector_char_p_t &make_heap(vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_make_heap(it(), f);
        return *this;
    }

    vector_char_p_index_t heap_left (vector_char_p_index_t i) const
    {
        return vector_char_p_heap_left(it(), i);
    }

    vector_char_p_index_t heap_right (vector_char_p_index_t i) const
    {
        return vector_char_p_heap_right (it(), i);
    }

    vector_char_p_index_t heap_father (vector_char_p_index_t i) const
    {
        return vector_char_p_heap_father (it(), i);
    }

    char * heap_extract (vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        return vector_char_p_heap_extract (it(), f);
    }

    vector_char_p_t &heap_raise (vector_char_p_index_t i, vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_heap_raise (it(), i, f);
        return *this;
    }

    vector_char_p_t &heap_sink (vector_char_p_index_t i, vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_heap_sink (it(), i, f);
        return *this;
    }

    vector_char_p_t &heap_fix (vector_char_p_index_t i, vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_heap_fix (it(), i, f);
        return *this;
    }

    vector_char_p_t &heap_insert (
        char *  elem, vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_heap_insert (it(), elem, f);
        return *this;
    }

    vector_char_p_t &heap_erase (
        vector_char_p_index_t i, vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_heap_erase (it(), i, f);
        return *this;
    }

    vector_char_p_t &heap_sort (vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_heap_sort (it(), f);
        return *this;
    }


    vector_char_p_t &qsort (vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_qsort (it(), f);
        return *this;
    }

    vector_char_p_t &sort  (vector_char_p_cmp_t f VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL))
    {
        vector_char_p_sort (it(), f);
        return *this;
    }


    vector_char_p_index_t  bfind (char *  a, vector_char_p_cmp_t f = NULL) const
    {
        return vector_char_p_bfind (it(), a, f);
    }

    hashval_t hash_raw (void) const
    {
        return vector_char_p_hash_raw (it());
    }

    hashval_t hash (void) const
    {
        return vector_char_p_hash (it());
    }

    void init_iterator (vector_char_p_index_t *a) const
    {
        vector_char_p_init_iterator (it(), a);
    }

    bool next_iteration (vector_char_p_index_t *a, char * *b) const
    {
        return ERWIN_TO_BOOL(vector_char_p_next_iteration  (it(), a, b));
    }

    bool next_iteration_ptr (vector_char_p_index_t *a, char * **b)
    {
        return ERWIN_TO_BOOL(vector_char_p_next_iteration_ptr  (it(), a, b));
    }

    bool next_iteration_ptr (vector_char_p_index_t *a, char * const **b) const
    {
        return ERWIN_TO_BOOL(vector_char_p_next_iteration_ptr_const  (it(), a, b));
    }

    void init_iterator_reverse (vector_char_p_index_t *a) const
    {
        vector_char_p_init_iterator_reverse (it(), a);
    }

    bool next_iteration_reverse (vector_char_p_index_t *a, char * *b) const
    {
        return ERWIN_TO_BOOL(vector_char_p_next_iteration_reverse  (it(), a, b));
    }

    bool next_iteration_ptr_reverse (vector_char_p_index_t *a, char * **b)
    {
        return ERWIN_TO_BOOL(vector_char_p_next_iteration_ptr_reverse  (it(), a, b));
    }

    bool next_iteration_ptr_reverse (vector_char_p_index_t *a, char * const **b) const
    {
        return ERWIN_TO_BOOL(vector_char_p_next_iteration_ptr_const_reverse  (it(), a, b));
    }

    vector_char_p_t &shrink(bool tight = true)
    {
        vector_char_p_shrink(it(), tight ? ERWIN_TRUE : ERWIN_FALSE);
        return *this;
    }
    vector_char_p_t &clear ()
    { vector_char_p_clear (it()); return *this; }

    vector_char_p_t &clear_keep (vector_char_p_cnt_t n)
    { vector_char_p_clear_keep (it(),n); return *this; }

    vector_char_p_t &clear_no_resize ()
    { vector_char_p_clear_no_resize (it()); return *this; }

    static void delete_array(vector_char_p_element_ptr_t array)
    {
        vector_char_p_delete_array(array);
    }

    vector_char_p_t &clear (bool a, bool b=true)
    { vector_char_p_clear_flags (it(), a, b); return *this; }

#ifdef VECTOR_CHAR_P_INLINE__NENTRIES
    vector_char_p_cnt_t  nentries () const
    {
#ifdef VECTOR_CHAR_P_ALLOW_NULL
        if (this == NULL) return 0;
#endif
        return m_nentries;
    }
#else
    vector_char_p_cnt_t nentries () const
    { return vector_char_p_nentries (it()); }
#endif

    bool empty () const
    { return nentries() == 0; }

    bool non_empty () const
    { return !empty(); }

    vector_char_p_cnt_t table_size () const
    { return vector_char_p_table_size (it()); }

    int cmp (vector_char_p_t const *other,           
             vector_char_p_cmp_t fcmp VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL)) const
    {
        if (this == NULL)
            return other == NULL ? 0 : -1;
        if (other == NULL)
            return +1;
        return vector_char_p_cmp(it(), other->it(), fcmp);
    }

    int cmp (vector_char_p_t const &other,
             vector_char_p_cmp_t cmp_func VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL)) const
    {
        return cmp (&other, cmp_func);
    }

    int priority_cmp (vector_char_p_t const *other,
             vector_char_p_cmp_t fcmp VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL)) const
    {
        if (this == NULL)
            return other == NULL ? 0 : -1;
        if (other == NULL)
            return +1;
        return vector_char_p_priority_cmp(it(), other->it(), fcmp);
    }

    int priority_cmp (vector_char_p_t const &other,
             vector_char_p_cmp_t fcmp VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL)) const
    {
        return priority_cmp (&other, fcmp);
    }

    bool operator== (vector_char_p_t const &b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) == 0; } /* see cmp() */

    bool operator== (vector_char_p_t const *b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) == 0; } /* see cmp() */

    bool operator!= (vector_char_p_t const &b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) != 0; } /* see cmp() */

    bool operator!= (vector_char_p_t const *b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) != 0; } /* see cmp() */

    bool operator<= (vector_char_p_t const &b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) <= 0; } /* see cmp() */

    bool operator<= (vector_char_p_t const *b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) <= 0; } /* see cmp() */

    bool operator>= (vector_char_p_t const &b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) >= 0; } /* see cmp() */

    bool operator>= (vector_char_p_t const *b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) >= 0; } /* see cmp() */

    bool operator<  (vector_char_p_t const &b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) < 0; }  /* see cmp() */

    bool operator<  (vector_char_p_t const *b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) < 0; }  /* see cmp() */

    bool operator>  (vector_char_p_t const &b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) > 0; }  /* see cmp() */

    bool operator>  (vector_char_p_t const *b)
    { return cmp(b,VECTOR_CHAR_P_CMP_T_NULL) > 0; }  /* see cmp() */

    vector_char_p_t &swap (vector_char_p_index_t a, vector_char_p_index_t b)
    {
        vector_char_p_swap (it(), a, b);
        return *this;
    }

    bool locate (vector_char_p_index_t &index, char *  element, int how) const
    {
        return ERWIN_TO_BOOL(vector_char_p_locate (&index, it(), element, VECTOR_CHAR_P_CMP_T_NULL, how));
    }

    bool locate (vector_char_p_index_t &index,
                 char *  element,
                 vector_char_p_cmp_t fcmp VECTOR_CHAR_P_DEFAULT_ARG(VECTOR_CHAR_P_CMP_T_NULL),
                 int how VECTOR_CHAR_P_DEFAULT_ARG(0)) const
    {
        return ERWIN_TO_BOOL(vector_char_p_locate (&index, it(), element, fcmp, how));
    }

/*--END-CLASS--*/

#endif /* defined __cplusplus */
};

#undef VECTOR_CHAR_P_LOCAL_WRAPPER

#ifdef __cplusplus


/* For nasty code like:
 *
 *    extern "C" {
 *    #include <erwin/erwin.h>
 *    ...
 *    }
 *
 * Yes, some people do such things.
 */
extern "C++" {
/* some nasty global functions that are useful e.g. for forall.  Note that these
 * are not local to one vector but will be overloaded by all different vector
 * instantiations. */

ERWIN_WRAPPER
vector_char_p_t *erwin_ptr_of(vector_char_p_t *x) { return x;  }

ERWIN_WRAPPER
vector_char_p_t *erwin_ptr_of(vector_char_p_t &x) { return &x; }

ERWIN_WRAPPER
vector_char_p_t const *erwin_ptr_const_of (vector_char_p_t const *x) { return x;  }

ERWIN_WRAPPER
vector_char_p_t const *erwin_ptr_const_of (vector_char_p_t const &x) { return &x; }
}


/* Forall macros for C++ */
#ifndef vector_forall
#define vector_forall(v,i,h)                                      \
            for(erwin_ptr_const_of(v)->init_iterator(&(i));       \
                erwin_ptr_const_of(v)->next_iteration(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr
#define vector_forall_ptr(v,i,h)                                \
            for(erwin_ptr_of(v)->init_iterator(&(i));           \
                erwin_ptr_of(v)->next_iteration_ptr(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr_const
#define vector_forall_ptr_const(v,i,h)                                \
            for(erwin_ptr_const_of(v)->init_iterator(&(i));           \
                erwin_ptr_const_of(v)->next_iteration_ptr(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_keys
#define vector_forall_keys(v,i) \
            for((i)=0; ((vector_char_p_index_t)(i)) < erwin_ptr_const_of(v)->nentries(); (i)++)
#endif


#ifndef vector_forall_values
#define vector_forall_values(v,h)                                                         \
            for(vector_char_p_index_t ERWIN_GENSYM(erwin_local_j)=-1;                                   \
                erwin_ptr_const_of(v)->next_iteration(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_values_ptr
#define vector_forall_values_ptr(v,h)                                                   \
            for(vector_char_p_index_t ERWIN_GENSYM(erwin_local_j)=-1;                                            \
                erwin_ptr_of(v)->next_iteration_ptr(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_values_ptr_const
#define vector_forall_values_ptr_const(v,h)                                                   \
            for(vector_char_p_index_t ERWIN_GENSYM(erwin_local_j)=-1;                                       \
                erwin_ptr_const_of(v)->next_iteration_ptr(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_reverse
#define vector_forall_reverse(v,i,h)                                      \
            for(erwin_ptr_const_of(v)->init_iterator_reverse(&(i));       \
                erwin_ptr_const_of(v)->next_iteration_reverse(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr_reverse
#define vector_forall_ptr_reverse(v,i,h)                                \
            for(erwin_ptr_of(v)->init_iterator_reverse(&(i));           \
                erwin_ptr_of(v)->next_iteration_ptr_reverse(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr_const_reverse
#define vector_forall_ptr_const_reverse(v,i,h)                                \
            for(erwin_ptr_const_of(v)->init_iterator_reverse(&(i));           \
                erwin_ptr_const_of(v)->next_iteration_ptr_reverse(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_keys_reverse
#define vector_forall_keys_reverse(v,i) \
            for((i)=erwin_ptr_const_of(v)->nentries()-1; ((vector_char_p_index_t)(i)) >= 0; (i)--)
#endif


#ifndef vector_forall_values_reverse
#define vector_forall_values_reverse(v,h)                                          \
            for(vector_char_p_index_t ERWIN_GENSYM(erwin_local_j)=erwin_ptr_const_of(v)->nentries(); \
                erwin_ptr_const_of(v)                                              \
                     ->next_iteration_reverse(&ERWIN_GENSYM(erwin_local_j),&(h));         \
                /* no stepper */)
#endif

#ifndef vector_forall_values_ptr_reverse
#define vector_forall_values_ptr_reverse(v,h)                                 \
            for(vector_char_p_index_t ERWIN_GENSYM(erwin_local_j)=                          \
                    erwin_ptr_const_of(v)->nentries();                        \
                erwin_ptr_of(v)                                               \
                    ->next_iteration_ptr_reverse(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif

#ifndef vector_forall_values_ptr_const_reverse
#define vector_forall_values_ptr_const_reverse(v,h)                           \
            for(vector_char_p_index_t ERWIN_GENSYM(erwin_local_j)=                          \
                    erwin_ptr_const_of(v)->nentries();                        \
                erwin_ptr_const_of(v)                                         \
                    ->next_iteration_ptr_reverse(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif

#endif /* defined __cplusplus */

/* ********************************************************************** */
/* Inline implementations: */

#if VECTOR_CHAR_P_POSITION_POINTER

ERWIN_WRAPPER vector_char_p_index_t *vector_char_p_pos_ptr (vector_char_p_t *);
ERWIN_WRAPPER vector_char_p_index_t *vector_char_p_pos_ptr (vector_char_p_t *x)                   { return &x->m_pos; }

ERWIN_WRAPPER vector_char_p_index_t  vector_char_p_pos     (vector_char_p_t *);
ERWIN_WRAPPER vector_char_p_index_t  vector_char_p_pos     (vector_char_p_t *x)                   { return x->m_pos;  }

ERWIN_WRAPPER void            vector_char_p_set_pos (vector_char_p_t *,  vector_char_p_index_t);
ERWIN_WRAPPER void            vector_char_p_set_pos (vector_char_p_t *x, vector_char_p_index_t y) { x->m_pos= y;      }

#endif

#ifdef VECTOR_CHAR_P_INLINE__NTH

ERWIN_STATIC_INLINE
char *  vector_char_p_nth (vector_char_p_t const* self, vector_char_p_index_t idx)
{
    return self->m_table[idx];
}

#endif

#ifdef VECTOR_CHAR_P_INLINE__NENTRIES

ERWIN_STATIC_INLINE
vector_char_p_cnt_t vector_char_p_nentries (vector_char_p_t const *self)
{
    return self->m_nentries;
}

ERWIN_STATIC_INLINE
ERWIN_BOOL vector_char_p_empty (vector_char_p_t const *self)
{
    return self->m_nentries == 0;
}

#endif

#endif /* ERWINMM_VECTOR_CHAR_P_h */
