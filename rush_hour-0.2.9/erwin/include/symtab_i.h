/* -*- Mode: C -*- */
/* Generated Tue Aug 19 15:44:00 GMT 2008
 */
/* Author: Henrik Theiling
 *
 * Implementation specific header file.  Only symtab.c should
 * include this.  (For technical reasons, symtab.h also includes
 * it).
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including symtab_i.h"
#endif

#ifndef ERWIN_SYMTAB_I_h
#define ERWIN_SYMTAB_I_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of symtab_i.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

ERWIN_KIND_TYPEDEFS(struct, symtab_hashlist_t)

/* For the following ones, type info isn't easy.  We need a new
 * type, a dynamic array, because we do not store the size of
 * the these arrays.  They are no vectors, which must be embedded
 * in structs. */

typedef char const * symtab_key_dynarray;

typedef int symtab_value_dynarray;

typedef symtab_hashlist_t_p symtab_content;
typedef symtab_content *symtab_content_p;

struct _symtab_hashlist_t {
    char * key;

    int value;

    symtab_hashlist_t_p next;
#ifdef __cplusplus
    _symtab_hashlist_t ():
        next(NULL)
        {}

    _symtab_hashlist_t (char *  k, int  v):
        key (k),
        value (v),
        next (NULL)
        {}

#endif
};

typedef struct _symtab_internal_Iterator {
    symtab_hashlist_t *cnode;
    int    cslot;
} symtab_internal_Iterator;

typedef struct _symtab_internal_sorted_Iterator {
    symtab_pair_t *table;
    int         lauf;
    int         count;
    void        (*free_cb)(void *);
} symtab_internal_sorted_Iterator;

typedef struct _symtab_internal_sorted_ptr_Iterator {
    symtab_pair_ptr_t *table;
    int             lauf;
    int             count;
    void            (*free_cb)(void *);
} symtab_internal_sorted_ptr_Iterator;

#define symtab_record_table(X) X

#define symtab_record_sizes(X) X

#ifdef ERWIN_THREAD_SAFE
#  define symtab_record_errno(X) X
#else
#  define symtab_record_errno(X)
#endif

#if SYMTAB_DYN_ZERO
#  define symtab_record_zero(X) X
#else
#  define symtab_record_zero(X)
#endif

#ifdef ERWINMM_COMPAT1
#define symtab_record_compat(X) X
#else
#define symtab_record_compat(X)
#endif

#ifdef ERWIN_PROFILE
#define symtab_record_profile(X) X
#else
#define symtab_record_profile(X)
#endif

#if SYMTAB_HAVE_SIG
#  define symtab_record_sig(X) X
#else
#  define symtab_record_sig(X)
#endif

/* If m_hashsize becomes 64 bit, we need to adjust the 64-bit hashinto
 * functions (hashval_t is already 64 bit), but maps with more than
 * 2G entries currently still seem too large no matter what.  This view
 * will change soon, of course...
 *
 * Note than vectors have been switched to 64 bit values (on demand with
 * Vector_LARGE_INDEX).
 */
#define symtab_record                                             \
        symtab_record_sig     (int m_sig;)                        \
        symtab_record_table   (symtab_content_p m_table;)            \
        symtab_record_sizes   (int    m_hashsize;)                \
        symtab_record_sizes   (int    m_nentries;)                \
        symtab_record_errno   (ERWIN_MUTABLE int m_errno;) \
        symtab_record_zero    (int  m_zero;)                 \
        symtab_record_compat  (map_iterator_t compat1_iter;)      \
        symtab_record_profile (int m_nrehash;)                    \
        symtab_record_profile (int m_nrehashops;)                 \
        symtab_record_profile (int m_nfind;)                      \
        symtab_record_profile (int m_ninsert;)                    \
        symtab_record_profile (int m_ndelete;)


#ifdef ERWIN_COMPAT_2_0_264

#ifdef ERWIN_COMPAT_2_0_248
struct _symtab_t
#else
struct symtab_t
#endif
{
    symtab_record
};

#endif

/*
 * Force linker error when .c and .h are compiled inconsistently */
#if !defined (SYMTAB_IMPLEMENTATION) && defined(ERWIN_WEAK_STORAGE) && !defined(NDEBUG) && !defined(ERWIN_NO_LINKER_TRICKS)

#if SYMTAB_DYN_ZERO
ERWIN_WEAK_STORAGE void symtab_variable_zero_element_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void symtab_variable_zero_element_expected(void) {}
#else
ERWIN_WEAK_STORAGE void symtab_constant_zero_element_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void symtab_constant_zero_element_expected(void) {}
#endif

#ifdef ERWIN_PROFILE
ERWIN_WEAK_STORAGE void symtab_profile_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void symtab_profile_expected(void) {}
#else
ERWIN_WEAK_STORAGE void symtab_no_profile_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void symtab_no_profile_expected(void) {}
#endif

#ifdef ERWINMM_COMPAT1
ERWIN_WEAK_STORAGE void symtab_erwinmm_compat1_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void symtab_erwinmm_compat1_expected(void) {}
#else
ERWIN_WEAK_STORAGE void symtab_no_erwinmm_compat1_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void symtab_no_erwinmm_compat1_expected(void) {}
#endif

#endif /* defined(INTERNAL... *) */

#ifdef __cplusplus
}
#endif

#endif /* !defined(ERWIN_SYMTAB_I_h) */
