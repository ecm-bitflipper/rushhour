/* -*- Mode: C -*- */
/* Generated Tue Aug 19 15:44:00 GMT 2008
 */
/*
 * Author: Henrik Theiling
 * Description:
 *     Public header file for maps with arbitrary key and value types.
 *     The implementation uses dynamic hashing with lists as conflict
 *     resolving mechanism.
 *
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including symtab.h"
#endif

#ifndef ERWIN_SYMTAB_h
#define ERWIN_SYMTAB_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of symtab.h"
#endif

/* Include basic configuration */
#ifdef ERWIN_COMPILING
#  include "erwin/defs.h"
#else
#  include <erwin/defs.h>
#endif

/* Include the definitions: */
#include "symtab_d.h"

/* Include basic definitions */
#ifdef ERWIN_COMPILING
#  include "erwin/base.h"
#else
#  include <erwin/base.h>
#endif

/* Include forward declarations */
#ifdef ERWIN_COMPILING
#  include "erwin/forwards.h"
#else
#  include <erwin/forwards.h>
#endif

#ifdef HAVE_STDIO_H
#include <stdio.h>
#endif


#if defined(ERWIN_REQUIRE_DETERMINISM) && !defined(ERWIN_WEAK_DETERMINISM)
#  ifndef __cplusplus
/* #    error "Determinism for maps is currently only available for C++." */
/*     Too many problems with mixed C/C++ projects. */
/*     Actually, C projects will still be 'weakly' deterministic, in the sence
 *     that they are determinstic on the EQUAL and HASH_RAW level.  Only the
 *     special DETCMP are ignored.  This is because iteration in C still
 *     iterates over the internal structure deterministically, which is
 *     sorted by HASH_RAW mainly and the insertion order and EQUAL secondly.
 *     And since with enabled determinism, the internal hash table for
 *     distributing HASH_RAW to HASH is not randomised when using determinism,
 *     hash tables are still, well, weakly determistic.
 *     The non-determinsm usually occurs when symbols are hash, since the
 *     system simply produces different pointer values during different
 *     runs, leading to different structures inside the hash table.  This
 *     is then overcome in C++ by sorting the table before iteration. */
#  endif
#endif

/* These are undef'ed first because there is only one error code for all
 * the maps in your program.
 * All the functions returing error codes will both return this error
 * and write it into map_errno.
 *    == MAP_OK: Ok.
 *               Macro: MAP_IS_OK(X)
 *
 *    <  MAP_OK: Error: operation did not succeed.
 *               Macro: MAP_IS_ERROR(X)
 *
 *    >  MAP_OK: Warning: operation did succeed but not perfectly. (e.g.
 *                        rehash failed)
 *               Macro: MAP_IS_WARNING(X)
 *
 *  In all cases, success, errors, warnings, rehash failures, failed assertions, etc, the
 *  consistency of the data structure is guaranteed.
 */

#undef  map_errno

#if ERWIN_GLOBAL_ERRNO
#  define map_errno erwininternalmaperrno
  /* The global map status code. */
#endif

#undef  map_strerror
#define map_strerror erwininternalmapstrerror
  /* Returns a textual description of a given error.  This description
   * starts with `Error: ' or `Warning: ' or something the like
   * to indicate the status level.  This is then followed by a
   * short description phrase.
   */

/*! enum: MAP_OK, MAP_ERR_*, MAP_WARN_*, MAP_REHASH_* */
#undef  MAP_OK
#define MAP_OK                     ERWININTERNALMAPOK
    /* No error occurred */

#undef  MAP_IS_OK
#define MAP_IS_OK(X)               ERWININTERNALMAPISOK(X)
  /* Find out whether the status code map_errno indicates that everything is fine. */

#undef  MAP_IS_ERROR
#define MAP_IS_ERROR(X)            ERWININTERNALMAPISERROR(X)
  /* Find out whether the status code map_errno indicates that an error occured. */

#undef  MAP_IS_WARNING
#define MAP_IS_WARNING(X)          ERWININTERNALMAPISWARNING(X)
  /* Find out whether the status code map_errno indicates that an error occured. */

#undef  MAP_ERR_NOMEM
#define MAP_ERR_NOMEM              ERWININTERNALMAPERRNOMEM
  /* Memory exhausted.  If you think this is a fatal error and should be
   * treated like a failed assertion, #define ERWIN_NOMEM_IS_FATAL.
   */

#undef  MAP_ERR_ASSERTIONFAILED
#define MAP_ERR_ASSERTIONFAILED    ERWININTERNALMAPERRASSERTIONFAILED
  /* Whenever an axiomatic assertion failed, this error is occured.
   *
   * Note: Something really went wrong in this case, so do not expect that
   *       every failed assertion allows normal control flow to continue.
   *       This error means the program is broken and would have crashed
   *       or done something bad if the assertion had not been checked.
   */

  /* The following are warnings only.  They are created by the iterator functions: */

#undef  MAP_WARN_EXISTINGKEY
#define MAP_WARN_EXISTINGKEY       ERWININTERNALMAPWARNEXISTINGKEY
  /* A key could not be inserted into a map, because it already exists. */

#undef  MAP_ERR_EXISTINGKEY
#define MAP_ERR_EXISTINGKEY please_use_MAP_WARN_EXISTINGKEY_instead

#undef  MAP_WARN_KEYNOTFOUND
#define MAP_WARN_KEYNOTFOUND       ERWININTERNALMAPWARNKEYNOTFOUND
  /* A key was not found in the map. */

#undef  MAP_ERR_KEYNOTFOUND
#define MAP_ERR_KEYNOTFOUND please_use_MAP_WARN_KEYNOTFOUND_instead

#undef  MAP_WARN_EMTPY
#define MAP_WARN_EMPTY             ERWININTERNALMAPWARNEMPTY

#undef  MAP_WARN_NOMOREELEMS
#define MAP_WARN_NOMOREELEMS       ERWININTERNALMAPWARNNOMOREELEMS

#undef  MAP_REHASH_NOMEM
#define MAP_REHASH_NOMEM           ERWININTERNALMAPREHASHNOMEM
  /* This is returned if the element could be inserted but the rehash then failed. */

#undef  MAP_REHASH_DUPLICATEKEY
#define MAP_REHASH_DUPLICATEKEY    ERWININTERNALMAPREHASHDUPLICATEKEY
  /* This is returned if a consistency error is detected during a rehash operation.
   * In this case there where two duplicate keys.
   *   This can happen if the copy function for the
   *   keys is missing or if the comparison and hash functions do not
   *   work properly. */

#undef  MAP_REHASH_RECURSION
#define MAP_REHASH_RECURSION       ERWININTERNALMAPREHASHRECURSION
  /* This is returned if a rehash operation behaved totally unexpectedly
   * and triggered its own recursive call. */


typedef char const * symtab_index_t;
typedef int symtab_value_t;

typedef struct _symtab_pair_t {
    char const * key;
    int value;
} symtab_pair_t;

typedef symtab_pair_t symtab_pair_dynarray;


typedef struct _symtab_pair_ptr_t {
    char const * key;
    int *value;
} symtab_pair_ptr_t;


typedef symtab_pair_ptr_t symtab_pair_ptr_dynarray;

typedef int (*symtab_pair_cmp_t)(symtab_pair_t const *, symtab_pair_t const *);

typedef int (*symtab_pair_ptr_cmp_t)(symtab_pair_ptr_t const *, symtab_pair_ptr_t const *);

typedef int (*symtab_void_pair_cmp_t)(void const *, void const *);



typedef ERWIN_BOOL (*symtab_feature_t)(char const * , int );


typedef int *symtab_element_ptr_t;



typedef char const * symtab_key_result_t;


#ifndef MAP_ITERATOR

#define MAP_ITERATOR
struct _map_iterator_t;

typedef void (*_map_iterator_callback_t) (void const *, struct _map_iterator_t *);

typedef struct _map_iterator_t {
    /* This is an iterator for maps.  You need to know about this struct
     * when programming in C, since you have to declare such an iterator
     * manually.  symtab iteration looks like this:
     *     : map_iterator_t iter;
     *     : ...
     *     : symtab_forall (map, iter, key, value) {
     *     :     ...
     *     : }
     *
     * The internal structure of this class is not important to the user,
     * however -- you should never try to look inside an iterator structure.
     */

    /*! class-ignore */
    void *p;
    int i;
#ifdef __cplusplus
    _map_iterator_t ()
    {}

   /* This is a hack, but I did not find a good way of programming the C++ iterator. */
    _map_iterator_t (
        _map_iterator_callback_t callback,
        void const *map)
    {
         callback (map, this);
    }
#endif /* defined(__cplusplus) */
} map_iterator_t;


#ifdef __cplusplus
/*
 * Only available in C++ since otherwise some easy to produce memory leaks would be
 * really hard to find for the user.  In C, the user must sort the array themself.
 */
struct _map_iterator_sorted_t;

typedef void (*_map_iterator_sorted_callback_t)
                 (void const *, struct _map_iterator_sorted_t *);

typedef int  (*_map_iterator_cmp_callback_t)(void const *, void const *);

typedef void (*_map_iterator_sorted_init_callback_t)(
            void const *,
            struct _map_iterator_sorted_t *,
            _map_iterator_cmp_callback_t);

typedef struct _map_iterator_sorted_t {
    /* You do not need any knowledge about this class, since
     * the C++ interface introduces iterators on the fly and
     * the C interface currently has no support for sorted
     * iteration, since allocation/deallocation of the needed
     * help structures is a serious problem in C.
     */

    /*! class-ignore */
    void *p;
    int l;
    int c;
    void (*free_cb)(void *);

    _map_iterator_sorted_t ():
         free_cb(0)
    {}

    _map_iterator_sorted_t (
        _map_iterator_sorted_callback_t callback,
        void const *map)
    {
        callback (map, this);
    }

    _map_iterator_sorted_t (
        _map_iterator_sorted_init_callback_t callback,
        void const *map,
        _map_iterator_cmp_callback_t u)
    {
         callback (map, this, u);
    }

    ~_map_iterator_sorted_t ()
    {
         if (free_cb) free_cb ((void*)this);
            /* (a kind of virtual destructor)
             * Callback, since the operator does not know how to do it.
             */
    }
} map_iterator_sorted_t;
#endif

#endif /* defined(MAP_ITERATOR) */


/* ***** handling `hash' objects: ***** */


/*--BEGIN-C--*/
ERWIN_EXPORT
symtab_t *symtab_new (void) ATTR_MALLOC;
  /* Return a new map with default settings.  I.e., with the
   * default zero element SYMTAB_ZERO and the default initial hash table
   * size of SYMTAB_INITIAL_SIZE.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
symtab_t *symtab_new_with_initial_size (int /*initial_size*/) ATTR_MALLOC;
  /* Create a new map with a given initial hash table.  This is
   * useful whenever you know how many entries you will have.
   *
   * The number you pass is interpreted as the number of elements.
   * The real hash size that will be used will be computed in such
   * a way that no rehash will occur when inserting the number of
   * elements given.  Note that a single deletion of an element may
   * still trigger a rehash, only when only inserting the elements,
   * no rehash is guaranteed.
   *
   * If initial_size < 0 the default size SYMTAB_INITIAL_SIZE will be used.
   * If initial_size == 0 but SYMTAB_MINIMAL_SIZE > 0, a size of 1 will be
   * used.
   *
   * With the default value of the re-hash parameters, a re-hash
   * will be done when the map has more than 80% entries compared
   * to the hash table size.  So if you intend to insert 80 entries,
   * you must specify more than 100 for the initial size.  To be
   * precise, you must specify more than
   * SYMTAB_TRIGGER_NUMERATOR * 80 / SYMTAB_TRIGGER_DENOMINATOR.
   *
   * \errno(OK, ERR_NOMEM)
   */

#if SYMTAB_DYN_ZERO
ERWIN_EXPORT
symtab_t *symtab_new_with_zero (int  /*zero*/) ATTR_MALLOC;
  /* zero will eventually be tried to be copied!  So if you provide
   * INT_OCOPY, make sure it handles the zero element appropriately.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
symtab_t *symtab_new_with_zero_and_initial_size (int  /*zero*/, int /*initial_size*/) ATTR_MALLOC;
  /* Create a new, empty map.  The first form uses
   * int_zero as the zero element.
   *
   * If initial_size < 0 the default size SYMTAB_INITIAL_SIZE will be used.
   * If initial_size == 0 but SYMTAB_MINIMAL_SIZE > 0, a size of 1 will be
   * used.
   *
   * \errno(OK, ERR_NOMEM)
   */
#endif

ERWIN_EXPORT
int symtab_init (
    symtab_t * /*self*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap symtab_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

#if SYMTAB_DYN_ZERO
ERWIN_EXPORT
int symtab_init_with_zero_and_initial_size (
    symtab_t *      /*self*/,
    int  /*zero*/,
    int          /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap symtab_t objects that are allocated
   * manually (thus, not via symtab_new).
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */
#endif

ERWIN_EXPORT
int symtab_init_with_initial_size (
    symtab_t * /*self*/,
    int     /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap symtab_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
void symtab_destroy (symtab_t * /*self*/);
  /*
   * This is for deleting non-heap symtab_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK)
   */

ERWIN_EXPORT
void symtab_xchg (symtab_t * /*self*/, symtab_t * /*other*/);
  /*
   * Exchanges the two maps' contents.  No memory allocation is
   * performed; this is a fast O(1) operation for swapping two values.
   */

ERWIN_EXPORT
void symtab_destroy_flags (
  symtab_t * /*self*/, ERWIN_BOOL /* destroy_keys */, ERWIN_BOOL /* destroy_values */);
  /*
   * Same as symtab_destroy with the possiblity to determine what to destroy.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK)
   */


#if !ERWIN_GLOBAL_ERRNO
ERWIN_EXPORT
int symtab_errno(symtab_t const *) ATTR_PURE ATTR_NONNULL((1));
  /* If the library was compiled with ERWIN_THREAD_SAFE, this is the
   * way to retrieve the status code of a map.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \noerrno
   */

ERWIN_EXPORT
void symtab_clear_errno(symtab_t const *) ATTR_NONNULL((1));
  /* Resets the status code to MAP_OK.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \errno(OK)
   */

#else

#define symtab_errno(X)          map_errno
  /* If the library was not compiled with ERWIN_THREAD_SAFE, symtab_errno(X)
   * is just a synonym for the global variable map_errno.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \noerrno
   */

#define symtab_clear_errno(X)    ((void)(map_errno= MAP_OK))
  /* If the library was not compiled with ERWIN_THREAD_SAFE, symtab_clear_errno(X)
   * is a small macro that resets the status code to MAP_OK.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \errno(OK)
   */

#endif

ERWIN_EXPORT
symtab_t *symtab_copy (symtab_t const* /*self*/);
  /* Copies the map with all its keys and elements
   *
   * NULL is allowed and passed through.
   *
   * Don't use as a copy function for other Erwin structures.  Use _copy_err instead.
   *
   * \errno(OK,REHASH_*,ERR_NOMEM)
   */

ERWIN_EXPORT
symtab_t *symtab_copy_err (symtab_t const* /*self*/, int *err);
  /* Copies the map with all its keys and elements.  *err will be set
   * to 1 if an error occurs.
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */


ERWIN_EXPORT
void symtab_delete (symtab_t* /*self*/);
  /* Deletes everything in the map and the map structure itself
   *
   * \errno(OK)
   */

ERWIN_EXPORT
void   symtab_delete_flags (symtab_t* /* self*/, ERWIN_BOOL /* destroy_keys */, ERWIN_BOOL /* destroy_values */);
  /* Deletes only the map structure, not the entries.  This is
   * useful if you got the entries via symtab_get_{values|keys}.
   * symtab_delete_flat (a, true, true) is the same as
   * symtab_delete (a);
   *
   * \errno(OK)
   */


/* *****  normal operations: ***** */


/* The `char const *' is used to force the caller to provide copy functions
 * when pointers are used for char const *.  Otherwise, duplicate keys are
 * easily possible. */
ERWIN_EXPORT
int symtab_insert (symtab_t* /*self*/, char const *  /*key*/, int  /*value*/) ATTR_NONNULL((1));
  /* Introduces a value for a given key into the map.  If the key did not
   * exist, errno will be OK.  If the key existed, the map will not be changed,
   * and errno will be WARN_EXISTINGKEY.
   *
   * Key and value are copied (if copy functions are available, as usual).
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int symtab_insert_map (symtab_t* /*self*/, symtab_t const * /* other */);
  /* Inserts all keys from other into self.  If any key is not inserted,
   * returns WARN_EXISTINGKEY.
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
char const *  symtab_ensure (symtab_t* /*self*/, char const *  /*key*/) ATTR_NONNULL((1));
  /* This ensures that key is inserted in the table, i.e., it allocates a cell
   * for it.  The inserted value will be INT_ZERO.  If you
   * want to change this, re-define SYMTAB_ENSURE_VALUE.
   * The result is the key as inserted in the hash table, so if you defined
   * CHAR_CONST_P_ICOPY, you will get a copy of your key.
   *
   * Note: This function implements symbol tables.
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
char const *  symtab_ensure_no_icopy (symtab_t * /*self*/, char *  /*key*/) ATTR_NONNULL((1));
  /* This is like symtab_ensure(), but the input key will be stolen or freed, i.e.,
   * it will be used as a copy inside the hash table, instead of being copied
   * as in symtab_ensure.  If the key already exists, the key passed will be freed.
   *
   * Note: This function implements symbol tables.
   *
   * This could be called symtab_ensure_steal(), but we already have poke_no_icopy().
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int  symtab_find_any (symtab_t const* /*self*/)
  ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element if not found.
   *
   * For maps with 0 or 1 elements and in the non-deterministic
   * case, this is very fast.  In the deterministic mode, this
   * is O(n).  In weak determinism, it is typically O(1) as in
   * the non-deterministic mode.  (The very unlikely worst case
   * is always O(n)).
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */


ERWIN_EXPORT
int symtab_find_any_pair (symtab_key_result_t *, symtab_element_ptr_t *, symtab_t const* /*self*/)
  ATTR_ERRNO_PURE;
  /* Returns the number of elements in the map.  If that is > 0, the
   * first argument is set to any key, and the second to the pointer to
   * the corresponding value.
   *
   * You may pass NULL for any of the first two parameters if you do not want
   * the return value.
   *
   * See symtab_find_any() for more documentation.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */


ERWIN_EXPORT
int   symtab_find (symtab_t const* /*self*/, char const *  /*index*/)
  ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element if not found.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
int  symtab_find_ensure (symtab_t * /*self*/, char const *  /*index*/);
  /* Returns the found element or introduces an empty element into the
   * map and returns that (use SYMTAB_ENSURE_VALUE to determine the value
   * that is introduced).
   *
   * Also consider find_ptr_ensure if you want to modify the (newly
   * introduced) value.  Also see symtab_ensure if you need the key, not
   * the value after the operation.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
char const *   symtab_find_key (symtab_t const* /*self*/, char const *  /*index*/) ATTR_ERRNO_PURE;
  /* Returns the key as stored in the table.  For copied pointer types, this
   * might be different from index.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
char const *   symtab_find_any_key (symtab_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns some key that is stored in the table.
   *
   * See symtab_find_any() for docu.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */


ERWIN_EXPORT
symtab_element_ptr_t symtab_find_ptr (symtab_t const* /*self*/, char const *  /*index*/) ATTR_ERRNO_PURE;
  /* Returns a pointer to the found element or NULL on failure.
   *
   * Note: If int == int, you may not use the pointer to directly
   * write into the hash table because this circumvents copying and that
   * is prohibited.  Use poke_no_ocopy for things like that to make it
   * explicit.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
symtab_element_ptr_t symtab_find_any_ptr (symtab_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns a pointer to some element or NULL on failure.
   *
   * Note: If int == int, you may not use the pointer to directly
   * write into the hash table because this circumvents copying and that
   * is prohibited.  Use poke_no_ocopy for things like that to make it
   * explicit.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
symtab_element_ptr_t symtab_find_ptr_ensure (symtab_t * /*self*/, char const *  /*index*/);
  /* Returns a pointer to the found element or one to a newly allocated one.
   * In the case when it was not possible to allocate space for a new element,
   * the result NULL.  Otherwise, it is not NULL.
   *
   * If a new element was introduced, errno will be set to MAP_WARN_KEYNOTFOUND,
   * otherwise to MAP_OK.  Note again that in both cases, the result is non-NULL!
   *
   * Note: If int == int, you may not use the pointer to directly
   * write into the hash table because this circumvents copying and that
   * is prohibited.  Use poke_no_ocopy for things like that to make it
   * explicit.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
int symtab_modify (
    symtab_t* /*self*/, char const *  /*index*/, int  /*value*/) ATTR_NONNULL((1));
  /* Change an existing value for the given index (errno=OK).  If the index does
   * not exist, do not modify the map nothing (errno=WARN_KETNOTFOUND).
   *
   * Returns the old value or INT_ZERO if it is new in which case the map is
   * not changed.  Nothing is freed, value is copied.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int symtab_modify_map (symtab_t* /*self*/, symtab_t const * /* other */);
  /* like symtab_modify on all entries in other.  If any key was not found,
   * WARN_KEYNOTFOUND is returned.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int symtab_set (symtab_t* /*self*/, char const *  /*index*/, int  /*value*/) ATTR_NONNULL((1));
  /* Insert or modify a value: introduce value for given index if it does not
   * exist (errno=OK) or change value if index does exist (errno=WARN_EXISTINGKEY).
   *
   * Similar to symtab_modify, but value is freed and the status instead of the value
   * is returned.   Furthermore, of course, it is different in that if the value
   * does not exist, it will be inserted.
   *
   * Note: If you don't care whether to use symtab_set or symtab_insert, use symtab_insert.
   *       symtab_insert might be a little faster.
   *
   * Result:
   *    The error code, same as map_errno.
   *
   * \errno(OK, WARN_EXISTINGKEY, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int symtab_set_map (symtab_t* /*self*/, symtab_t const * /* other */);
  /* like symtab_set on all entries in other
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */


ERWIN_EXPORT
int symtab_intersect (symtab_t* /*self*/, symtab_t const * /* other */);
  /* Implements set intersection: this invokes symtab_erase on all entries
   * in self that are not in other.
   * Returns the number of erased elements (quite like symtab_erase_if).
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int symtab_intersect_no_resize (symtab_t* /*self*/, symtab_t const * /* other */);
  /* Like symtab_intersect, but does not shrink the internal hash table.
   *
   * \errno(OK, REHASH_*, ERR_NOMEM)
   */

ERWIN_EXPORT
int symtab_remove (symtab_t* /*self*/, char const *  /*index*/) ATTR_NONNULL((1));
  /* Returns the old value or INT_ZERO. Does *not* free the value (which is
   * returned), but only the key.   A more appropriate name for this function
   * might be `steal', because the value is kept.
   *
   * In error-free operation, returns errno=OK if the index was found and erased,
   * and WARN_KEYNOTFOUND if the index was not found.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERWIN_EXPORT
int symtab_remove_no_resize (symtab_t* /*self*/, char const *  /*index*/) ATTR_NONNULL((1));
  /* Like symtab_remove, but does not shrink the internal hash table.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
int symtab_remove_map (symtab_t* /*self*/, symtab_t const * /* other */);
  /* like symtab_remove on all entries in other.  If any key was not found,
   * WARN_KEYNOTFOUND is returned.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERWIN_EXPORT
int symtab_remove_if (symtab_t * /*self */, symtab_feature_t /* feature */, ERWIN_BOOL /* value */);
  /* Remove some entries from the map according to a given feature.  This
   * is much faster than repeated deletions and maximally requires one
   * rehash operation only.
   *
   * NOTE: Even if the library is compiled with determinism, the order of the
   *       invocations of the feature callback is non-deterministic!
   *
   * \errno (OK, REHASH_*)
   */


ERWIN_EXPORT
int symtab_erase (symtab_t* /*self*/, char const *  /*index*/) ATTR_NONNULL((1));
  /* Same as symtab_remove, but value is freed.  In error-free operation, returns
   * errno=OK if the index was found and erased, and WARN_KEYNOTFOUND if the
   * index was not found.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERWIN_EXPORT
int symtab_erase_no_resize (symtab_t* /*self*/, char const *  /*index*/) ATTR_NONNULL((1));
  /* Same as symtab_erase, but does not shrink the internal hash table.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
int symtab_erase_map (symtab_t* /*self*/, symtab_t const * /* other */);
  /* like symtab_erase on all entries in other.  If any key was not found,
   * WARN_KEYNOTFOUND is returned.
   *
   * \errno(OK, WARN_KEYNOTFOUND, REHASH_*)
   */

ERWIN_EXPORT
int symtab_erase_map_no_resize (symtab_t* /*self*/, symtab_t const * /* other */);
  /* Like symtab_erase_map, but does not shrink the internal hash table.
   *
   * \errno(OK, WARN_KEYNOTFOUND)
   */

ERWIN_EXPORT
int symtab_erase_if (symtab_t * /*self */, symtab_feature_t /* feature */, ERWIN_BOOL /* value */);
  /* Erase some entries from the map according to a given feature.  This
   * is much faster than repeated deletions and maximally requires one
   * rehash operation only.
   *
   * NOTE: Even if the library is compiled with determinism, the order of the
   *       invocations of the feature callback is non-deterministic!
   *
   * \errno (OK, REHASH_*)
   */


ERWIN_EXPORT
int symtab_poke (
        char const * *      /* key_out */,
        int *   /* value_out */,
        symtab_t *      /* self */,
        char const *  /* key */,
        int  /* value */,
        ERWIN_BOOL       /* introduce */,
        ERWIN_BOOL       /* overwrite */) ATTR_NONNULL((3));
  /* This is the generalised interface to symtab_insert, symtab_modify, symtab_set, symtab_ensure, symtab_find
   * and symtab_find_key.  This function cannot erase, however (see symtab_erase).
   *
   * Input parameters:
   *   +--------------+----------------------------------------------------------------------+
   *   | \p self      | is the map as usual                                                  |
   *   | \p key       | defines the entry which is to be inserted or changed                 |
   *   | \p value     | is the value that is inserted or with which the entry is overwritten |
   *   | \p introduce | insert a new value if nothing exists for the key                     |
   *   | \p overwrite | defines whether a value will be overwritten if it already exists     |
   *   +--------------+----------------------------------------------------------------------+
   *
   * Output parameters:
   *   +--------------+----------------------------------------------------------------------+
   *   | return value | the error code (map_errno)                                    |
   *   +--------------+----------------------------------------------------------------------+
   *   | \p key_out   | *key_out will be the key as inserted in the map.  This can be        |
   *   |              | different from key when the keys are copied.                         |
   *   |              | key_out may be NULL                                                  |
   *   +--------------+----------------------------------------------------------------------+
   *   | \p value_out | If non-NULL, the entry found in the map will be stored here. It      |
   *   |              | will not be freed if it is overwritten of value_out != NULL.         |
   *   |              | If value_out==NULL, overwritten values are freed as usual.           |
   *   +--------------+----------------------------------------------------------------------+
   *
   * Note: The is an important difference between key_out and value_out.  Via
   *       key_out, the *current* key in the map is returned, but via value_out, the
   *       *old* value is returned.
   *
   * The following shows the (idealised) bodies of some functions.
   *
   * symtab_insert:
   *       : return symtab_poke (NULL, NULL, self, key, value,
   *       :                  ERWIN_TRUE, ERWIN_FALSE);
   *
   * symtab_set:
   *       : return symtab_poke (NULL, NULL, self, key, value,
   *       :                 ERWIN_TRUE, ERWIN_TRUE);
   *
   * symtab_modify:
   *       : int *result;
   *       : symtab_poke (NULL, &result, self, key, value,
   *       :           ERWIN_FALSE, ERWIN_TRUE);
   *       : return result;
   *
   * symtab_find:
   *       : int *result;
   *       : symtab_poke (NULL, &result, self, key, ZERO (int),
   *       :           ERWIN_FALSE, ERWIN_FALSE);
   *       : return (int*)result;
   *
   * symtab_find_key:
   *       : char * *result;
   *       : symtab_poke (&result, NULL, self, key, ZERO (int),
   *       :           ERWIN_FALSE, ERWIN_FALSE);
   *       : return (char const **)result;
   *
   * Almost:
   * symtab_ensure:
   *       : char * *result;
   *       : symtab_poke (&result, NULL, self, key, ZERO (int),
   *       :           ERWIN_TRUE, ERWIN_FALSE);
   *       : result;
   * (Only symtab_ensure uses SYMTAB_ENSURE_VALUE to introduce a new element, not
   * ZERO and without copying)
   *
   * Note that symtab_find_ptr, symtab_remove and symtab_erase cannot be implemented with
   * this function.
   *
   * Return Values:
   *    - MAP_OK:
   *         If an entry was not found, but could be successfully inserted
   *         or if an entry was found and could be successfully overwritten
   *         or if an entry was found and neither insertion nor overwriting was
   *         allowed (introduce == overwrite == ERWIN_FALSE).
   *
   *     - MAP_WARN_KEYNOTFOUND:
   *         If a key was not found, but not inserted (due to introduce ==
   *         ERWIN_FALSE).
   *
   *     - MAP_WARN_EXISTINGKEY:
   *         If a key was found, but not overwritten (due to overwrite == ERWIN_FALSE).
   *
   *     - MAP_ERR_NOMEM:
   *         If a structure could not be allocated, or a key or a value could not
   *         be copied. In this case, the map is returned unmodified.
   *
   *     - MAP_ERR_ASSERTIONFAILED:
   *         If an assertion failed.
   */

ERWIN_EXPORT
int symtab_poke_no_icopy (
   char const * * /*key_out*/,
   int * /*value_out*/,
   symtab_t * /*self*/,
   char *  /*key*/,
   int  /*value*/,
   ERWIN_BOOL /*introduce*/,
   ERWIN_BOOL /*overwrite*/) ATTR_NONNULL((3));
  /* Like symtab_poke, but the key is not copied.  However, \p key will be freed if it is not
   * used for the map.  This means that you pass the responsibility for memory management
   * of the key to the map.  In particular, if you use this function for searching
   * only (i.e., \p introduce == ERWIN_FALSE, \p overwrite == ERWIN_FALSE), the key will
   * always be deallocated.
   */

ERWIN_EXPORT
int symtab_poke_no_ocopy (
  char const * * /*key_out*/,
  int * /*value_out*/,
  symtab_t * /*self*/,
  char const *  /*key*/,
  int  /*value*/,
  ERWIN_BOOL /*introduce*/,
  ERWIN_BOOL /*overwrite*/) ATTR_NONNULL((3));
  /* Like symtab_poke, but the value is not copied.  However, value may be freed if
   * value_out is NULL.  The rules for copying and freeing values are the same as
   * for key with symtab_poke_no_icopy.
   */

ERWIN_EXPORT
int symtab_poke_no_icopy_no_ocopy (
  char const * * /*key_out*/,
  int * /*value_out*/,
  symtab_t * /*self*/,
  char *  /*key*/,
  int  /*value*/,
  ERWIN_BOOL /*introduce*/,
  ERWIN_BOOL /*overwrite*/) ATTR_NONNULL((3));
  /* Like symtab_poke, but neither the key nor the value are copied.  Both, key and value
   * may be freed.  The rules for copying and freeing keys and values are the same
   * as for symtab_poke_no_icopy and symtab_poke_no_ocopy.
   */

ERWIN_EXPORT
int  symtab_zero (symtab_t const* /*self*/) ATTR_PURE ATTR_NONNULL((1));
  /* Returns the zero element of int
   *
   * \noerrno
   */

ERWIN_EXPORT
int symtab_cmp (symtab_t const* /*self*/, symtab_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns a comparison value for the two maps.  The keys must be sortable for this to
   * work.  Maps are invariant in the actual storage order in the hash table.
   *
   * Note: This operation is expensive and needs additional space for copying the
   *       keys of self for sorting!
   *
   * For equality tests, use symtab_equal instead, which is faster.
   *
   * The comparison value is as follows:
   *    a) the map that contains most elements is assumed largest.
   *    b) for equally sized maps, a lexical order is used by sorting the keys and
   *       comparing the values of the two maps.  'Not contained' is assumed
   *       smallest.
   *
   * Further Note: Calling this results in a runtime error if either
   *    CHAR_CONST_P_CMP or INT_CMP is not defined.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
ERWIN_BOOL symtab_equal (symtab_t const* /*self*/, symtab_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns whether two maps are equal.  (Of course, maps are invariant in the
   * actual storage order in the hash table.)
   *
   * Note: This operation is quite expensive but *much* *less* *expensive*
   *       than symtab_cmp!
   *
   * Further Note: Calling this results in a runtime error if
   * INT_EQUAL is not defined.
   *
   * \errno(OK)
   */

ERWIN_EXPORT
int symtab_cmp_keys (symtab_t const* /*self*/, symtab_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns whether the set of keys in the map is equal.
   *
   * Note: This operation is quite expensive.  Use keys_equal
   *                if that is sufficient.
   *
   * Further Note: Calling this results in a runtime error if either
   *    CHAR_CONST_P_CMP is not defined.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
ERWIN_BOOL symtab_equal_keys (symtab_t const* /*self*/, symtab_t const * /*other */) ATTR_ERRNO_PURE;
  /* Returns whether the set of keys in the map is equal.
   *
   * Note: This operation is quite expensive but less expensive than
   *                symtab_keys_cmp
   *
   * \errno(OK)
   */

ERWIN_EXPORT
hashval_t symtab_hash_raw (symtab_t const * /*self*/) ATTR_ERRNO_PURE;
  /* Calculates a hash value for this hash table.  In earlier versions of Erwin,
   * the result was inferior to that of symtab_hash, but they are now the same
   * and no additional hashing of the result needs to be done.
   *
   * Note: Calling this results in a runtime error if INT_HASH is not defined.
   *
   * \errno(OK)
   */

ERWIN_WRAPPER hashval_t symtab_hash (symtab_t const *) ATTR_ERRNO_PURE;
    /* Same as symtab_hash_raw() now that hash_raw() is good enough. */

ERWIN_WRAPPER hashval_t symtab_hash (symtab_t const *x)
{
    return symtab_hash_raw(x);
}


/* ***** access to all entries: ***** */
ERWIN_EXPORT
void symtab_clear (symtab_t* /*self*/);
   /* Like symtab_erase for all elements
    *
    * \errno(OK)
    */

ERWIN_EXPORT
void symtab_clear_no_resize (symtab_t* /*self*/);
   /* Like symtab_erase for all elements, but does not shrink the internal hash table.
    *
    * \errno(OK)
    */

ERWIN_EXPORT
void symtab_clear_flags (
    symtab_t* /*self*/,
    ERWIN_BOOL     /*destroy_keys*/,
    ERWIN_BOOL     /*destroy_values*/);
   /* Clear and selectively free the map
    *
    * \errno(OK)
    */

ERWIN_EXPORT
void symtab_clear_flags_no_resize (
    symtab_t* /*self*/,
    ERWIN_BOOL     /*destroy_keys*/,
    ERWIN_BOOL     /*destroy_values*/);
   /* Like symtab_clear_flags, but does not shrink the internal hash table.
    *
    * \errno(OK)
    */

ERWIN_EXPORT
int symtab_nentries (symtab_t const* /*self*/) ATTR_PURE;
   /* Returns the number of entries (pairs of keys and values)
    *
    * \noerrno
    */

ERWIN_EXPORT
ERWIN_BOOL symtab_empty (symtab_t const* /*self*/) ATTR_PURE;
   /* Returns whether map has 0 entries
    *
    * \noerrno
    */

ERWIN_EXPORT
symtab_pair_t *symtab_get_entries (symtab_t const* /*self*/) ATTR_MALLOC;
   /* Use symtab_delete_entries to deallocate the returned array.
    *
    * \errno(OK, ERR_NOMEM)
    */

ERWIN_EXPORT
void symtab_delete_entries (symtab_pair_t * /*entries*/);
   /* Deallocate keys obtained by symtab_get_entries(). */


ERWIN_EXPORT
symtab_pair_ptr_t *symtab_get_entries_ptr (symtab_t const* /*self*/) ATTR_MALLOC;
   /* Usp symtab_delete_entries_ptr to deallocate the returned array.
    *
    * \errno(OK, ERR_NOMEM) */

ERWIN_EXPORT
void symtab_delete_entries_ptr (symtab_pair_ptr_t * /*entries_ptr*/);
   /* Deallocate keys obtained by symtab_get_entries_ptr(). */

ERWIN_EXPORT
int *symtab_get_values (symtab_t const* /*self*/) ATTR_MALLOC;
   /* \errno(OK, ERR_NOMEM) */

ERWIN_EXPORT
void symtab_delete_values (int * /*values*/);
   /* Deallocate keys obtained by symtab_get_values(). */

ERWIN_EXPORT
char const * *symtab_get_keys   (symtab_t const* /*self*/) ATTR_MALLOC;
   /* Get all keys, values, or key/value pairs as a normal standard C array.
    * The elements and keys are *not* copied.   The array will be terminated
    * with the zero value.
    *
    * Note: The returned maps are newly allocated and must eventually be
    *       freed by the user using symtab_delete_keys().  In earlier versions
    *       of Erwin, free() was recommended for freeing, but due to more
    *       sophisticated memory management, symtab_delete_keys() is the
    *       primary choice now.  It old code, no adjustment should be
    *       necessary, since this is only different if you
    *       customise ERWIN_TMALLOC etc.
    *
    * \errno(OK, ERR_NOMEM)
    */

ERWIN_EXPORT
void symtab_delete_keys (char const * * /*keys*/);
   /* Deallocate keys obtained by symtab_get_keys(). */


/* ***** debugging and special purposes (use rarely!): ***** */
ERWIN_EXPORT
int symtab_hash_size (symtab_t const* /*self*/) ATTR_PURE;
   /* Returns the size of the internal array of list pointers used to implement
    * the hash table.
    *
    * \noerrno
    */

ERWIN_EXPORT
void symtab_rehash (symtab_t* /*self*/, int /*newsize*/);
   /* Do a manual rehash.   If map_errno holds anything other than MAP_OK,
    * the map operation did not succeed.  However, the map is guaranteed to be
    * usable after the function call; either rehashed or original.
    * The return type is set to void because the function should not be
    * considered failed if anything bad has happened.
    *
    * \errno(OK, REHASH_*)
    */

ERWIN_EXPORT
ERWIN_BOOL symtab_expect_size (symtab_t* /*self*/, int /*newsize*/);
   /* Declare that the immediately following action will
    * insert or delete elements so that the new number of
    * elements will be newsize.  This will possibly rehash
    * to a hash size that requires no rehashes during the
    * following operation.  Note: this only works if you
    * consistently insert or consistently delete elements.
    * If you mix the operations, further rehashes might
    * occur.
    *
    * Returns whether a rehash was performed.
    *
    * \errno(OK, REHASH_*)
    */

ERWIN_EXPORT
double symtab_average_line_length (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
double symtab_variance_line_length (symtab_t const* /*self*/) ATTR_PURE;

#ifdef HAVE_SQRT
ERWIN_EXPORT
double symtab_deviation_line_length (symtab_t const* /*self*/) ATTR_PURE;
#endif

ERWIN_EXPORT
int symtab_max_line_length (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
int symtab_min_line_length (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
void symtab_dump (FILE *, symtab_t const * /*self*/);
  /* Dumps the internal structure of the map to the given file. */

/* ***** iteration: ***** */
/* New approach: */
#define symtab_forall_nondet(h,i,k,v) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration ((h),&i,&k,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over keys and values.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#define symtab_forall_ptr_nondet(h,i,k,v) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration_ptr ((h),&i,&k,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over keys and pointers to values.  You need a map_iterator_t as a
 * temporary for using this.  See symtab_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#define symtab_forall_values_nondet(h,i,v) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration_values ((h),&i,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#define symtab_forall_values_ptr_nondet(h,i,v) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration_values_ptr ((h),&i,&v);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#define symtab_forall_keys_nondet(h,i,k) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration_keys ((h),&i,&k);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over keys only.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#define symtab_forall_pairs_nondet(h,i,p) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration_pairs ((h),&i,&p);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#define symtab_forall_pairs_ptr_nondet(h,i,p) \
        for(symtab_init_iterator ((h),&i); \
            symtab_next_iteration_pairs_ptr ((h),&i,&p);)
/* Operator for non-deterministic hash iteration.  This is non-deterministic even if
 * ERWIN_REQUIRE_DETERMINISM is #defined.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#if !defined (ERWIN_REQUIRE_DETERMINISM) || defined (ERWIN_WEAK_DETERMINISM)
   /* Only have these implementations if the user does not require
    * non-determinism. */

#  define symtab_forall(h,i,k,v) symtab_forall_nondet(h,i,k,v)
/* Operator for hash iteration.  This iterates over keys and values.  To use it,
 * declare an additional map_iterator_t.  Example:
 *    : map_int_char_p_t *m= map_int_char_p_new ();
 *    : ...
 *    : int i;
 *    : char *s;
 *    : map_iterator_t iter;
 *    : map_int_char_p_forall (m, iter, i, s) {
 *    :     printf ("key=%d, value=%s\n", i, s);
 *    : }
 */

#  define symtab_forall_ptr(h,i,k,v) symtab_forall_ptr_nondet(h,i,k,v)
/* Works similar to map_forall.
 *
 * This iterates over keys and pointers to values.  You need a map_iterator_t as a
 * temporary for using this.  See symtab_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#  define symtab_forall_values(h,i,v) symtab_forall_values_nondet(h,i,v)
/* Works similar to map_forall.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#  define symtab_forall_values_ptr(h,i,v) symtab_forall_values_ptr_nondet(h,i,v)
/* Works similar to map_forall.
 *
 * This iterates over values only.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#  define symtab_forall_keys(h,i,k)   symtab_forall_keys_nondet(h,i,k)
/* Works similar to map_forall.
 *
 * This iterates over keys only.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#  define symtab_forall_pairs(h,i,p)  symtab_forall_pairs_nondet(h,i,p)
/* Works similar to map_forall.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.
 */

#  define symtab_forall_pairs_ptr(h,i,p)  symtab_forall_pairs_ptr_nondet(h,i,p)
/* Works similar to map_forall.
 *
 * This iterates over key/value pairs.  You need a map_iterator_t as a temporary for
 * using this.  See symtab_forall for details.  Iterating over pointers
 * allows you to change entries in the table on the fly.
 */

#endif

/* The following function should not be invoked by the user! */
/* BEGIN: Generated automatically by makeforall.pl (part of Erwin2) */

ERWIN_EXPORT
void symtab_init_iterator (symtab_t const *, map_iterator_t *);
/*private*/

#ifdef __cplusplus
ERWIN_EXPORT
void symtab_init_iterator_sorted_by_key (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_value (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_key_and_value (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_value_and_key (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_user (symtab_t const *, map_iterator_sorted_t *,
    symtab_pair_cmp_t);
/*private*/

ERWIN_EXPORT                       
void symtab_init_iterator_ptr_sorted_by_key (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_value (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_key_and_value (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_value_and_key (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_user (symtab_t const *, map_iterator_sorted_t *,
    symtab_pair_ptr_cmp_t);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_key_reverse (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_value_reverse (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_key_and_value_reverse (
    symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_value_and_key_reverse (
   symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_sorted_by_user_reverse (
    symtab_t const *, map_iterator_sorted_t *, symtab_pair_cmp_t);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_key_reverse (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_value_reverse (symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_key_and_value_reverse (
    symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_value_and_key_reverse (
    symtab_t const *, map_iterator_sorted_t *);
/*private*/

ERWIN_EXPORT
void symtab_init_iterator_ptr_sorted_by_user_reverse (
    symtab_t const *, map_iterator_sorted_t *, symtab_pair_ptr_cmp_t);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted (symtab_t const *, map_iterator_sorted_t *,
    char const * *, int *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_ptr (symtab_t const *, map_iterator_sorted_t *,
    char const * *, symtab_element_ptr_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_keys (symtab_t const *,
    map_iterator_sorted_t *, char const * *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_values (symtab_t const *,
    map_iterator_sorted_t *, int *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_values_ptr (symtab_t const *,
    map_iterator_sorted_t *, symtab_element_ptr_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_pairs (symtab_t const *,
    map_iterator_sorted_t *, symtab_pair_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_pairs_ptr (symtab_t const *,
    map_iterator_sorted_t *, symtab_pair_ptr_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_reverse (
    symtab_t const *, map_iterator_sorted_t *, char const * *, int *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_ptr_reverse (
    symtab_t const *, map_iterator_sorted_t *, char const * *, symtab_element_ptr_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_keys_reverse (symtab_t const *,
    map_iterator_sorted_t *, char const * *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_values_reverse (symtab_t const *,
    map_iterator_sorted_t *, int *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_values_ptr_reverse (symtab_t const *,
    map_iterator_sorted_t *, symtab_element_ptr_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_pairs_reverse (symtab_t const *,
    map_iterator_sorted_t *, symtab_pair_t *);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_sorted_pairs_ptr_reverse (symtab_t const *,
    map_iterator_sorted_t *, symtab_pair_ptr_t *);
/*private*/

#endif /* defined(__cplusplus) */

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration  (symtab_t const* /*self*/,
    map_iterator_t *, char const * * /*key*/, int * /*value*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_ptr  (symtab_t const* /*self*/,
    map_iterator_t *, char const * * /*key*/, symtab_element_ptr_t * /*value_ptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_values  (symtab_t const * /*self*/,
    map_iterator_t *, int * /* value */);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_values_ptr  (symtab_t const * /*self*/,
    map_iterator_t *, symtab_element_ptr_t * /* value_ptr */);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_keys  (symtab_t const* /*self*/,
    map_iterator_t *, char const * * /* key */);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_pairs (symtab_t const* /*self*/,
    map_iterator_t *, symtab_pair_t * /*pair*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL symtab_next_iteration_pairs_ptr (symtab_t const* /*self*/,
    map_iterator_t *, symtab_pair_ptr_t * /*pair*/);
/*private*/

#ifdef ERWIN_PROFILE

ERWIN_EXPORT
int symtab_nrehash_ops (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
int symtab_nrehash (symtab_t const* /*self*/) ATTR_PURE;
  /* rehash_ops is the number of pure rehash operations and rehash
   * is the number of elements moved around during rehashes */

ERWIN_EXPORT
int symtab_ninsert (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
int symtab_nremove (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
int symtab_nfind (symtab_t const* /*self*/) ATTR_PURE;

ERWIN_EXPORT
int symtab_nops (symtab_t const* /*self*/) ATTR_PURE;
  /* Sum of inserts, deletions, and searches */

  /* Most interesting are symtab_nops / symtab_nrehash. */
#endif

/*--END-C--*/

/*
 * Unfortunately, for a good implementation of the C++ class, we need to
 * include the file showing the internal structure of an map.  This
 * is only to give the compiler information about the size of the
 * structure.  I don't like an #ifdef'd include, so always include this:
 */
#include "symtab_i.h"


struct symtab_t
#ifdef SYMTAB_SUPER_CLASS
   : SYMTAB_SUPER_CLASS_ACCESS SYMTAB_SUPER_CLASS
#endif
{
    /* The symtab Class
     * =============
     * This class implements hash tables.
     *
     * Throughout the documentation, the following prefixes will be used:
     *   - :
     *       The library prefix: for applications, this is typically
     *       empty, for an xyz-Library, this is either \tt(XYZ_), \tt(xyz_) or
     *       \tt(Xyz), depending on the identifier in occurs in.
     *       +------------------+-----------------+
     *       |! Template        |! Instantiation  |
     *       | MAP_OK    | XYZ_MAP_OK      |
     *       | map_new   | xyz_map_new     |
     *       +------------------+-----------------+
     *
     *   - symtab_:
     *       This is equivalent to symtab, or the name
     *       that was set with \tt(-name=...) for this data structure.
     *       The case and underbar convention is adjusted, too.
     *
     *       Assuming a library prefix \tt(xyz) and char const *=int *,
     *       int == int, you get:
     *       +-------------------+------------------------------+
     *       |! Template         |! Instantiation               |
     *       | symtab_t             | xyz_map_int_p_int_t          |
     *       | SYMTAB_ALLOW_NULL    | XYZ_MAP_INT_P_INT_ALLOW_NULL |
     *       +-------------------+------------------------------+
     *   - Symtab:
     *       This is the name of the data structure type in C++: capitalised
     *       and with underbars removed:
     *       +-------------------+-----------------+
     *       |! symtab_t            |! Symtab      |
     *       | map_int_p_int_t   | MapIntPInt      |
     *       +-------------------+-----------------+
     *
     * In the following, for many functions, the error code values are given.  There are
     * two kinds, those for success and those for failure.  The error codes (if set at all)
     * are  always stored in the global variable map_errno, no mattern whether the function
     * returns its success or not.  Note that the error value MAP_ERR_ASSERTIONFAILED
     * is never explicitly given, because it
     *
     *   - can happen virtually always
     *
     *   - is considered a fatal error and should therefore lead to program
     *     abortion immediately.
     *
     * Successful operation is indicated by MAP_OK, MAP_WARN_*, and
     * MAP_REHASH*.
     *
     * Failure is indicated by MAP_ERR_*.  If a functions does not return the error code,
     * its result value in case of an error is _always_ the zero element of the result type.
     * I.e. NULL for pointers, 0 for integers, the user specified zero element for char const * or int,
     * ERWIN_FALSE for ERWIN_BOOL, etc.
     *
     * Functions that only set map_errno to MAP_REHASH_* or MAP_OK will return
     * void if they do not have a natural result.
     *
     * Note: The term `success' means that the function could perform its operation
     *       according to the specification.  E.g. if you call _insert and the
     *       key exists, the functions does not insert it.  However, this is no
     *       error.  It is defined that it should not be inserted in this case.
     *       Accordingly, you get a warning, not an error.
     */

    SYMTAB_STD_MEMBERS(symtab_t)

#ifdef __cplusplus
public:
#endif

    symtab_record

#ifdef __cplusplus

    /*! doc-ignore */
    symtab_t *it()             { return this; }

    /*! doc-ignore */
    symtab_t const *it() const { return this; }

protected:
#ifndef NDEBUG
    void cn() const;
    void cn(void const *) const;
#else
    /* Hopefully optimised away: */
    static void cn() {}
    static void cn(void const *) {}
#endif
    static void nocn() {}             /* makes explicit that functions might handle NULL well. */
    static void nocn(void const *) {} /* makes explicit that functions might handle NULL well. */

/*--BEGIN-CLASS--*/
public:
#ifdef __cplusplus
#if !ERWIN_DEFAULT_NEW_DELETE
    static void *operator new(size_t);
    static void operator delete(void *, size_t);
    static void *operator new[](size_t);
    static void operator delete[](void *, size_t);
#endif
#endif

    /* Creation */

    symtab_t (void);

    static symtab_t const &static_zero();

#if SYMTAB_HAVE_INT_CONSTRUCTOR
    ERWIN_EXPLICIT symtab_t (int initial_size);
#endif
#if SYMTAB_DYN_ZERO
    ERWIN_EXPLICIT symtab_t (int  zero_element);
    symtab_t (int  zero_element, int initial_size);
#endif

    /* status code */
#if !ERWIN_GLOBAL_ERRNO
    int get_errno(void) const        { cn(); return it()->m_errno; }
    void clear_errno(void) const     { cn(); symtab_clear_errno (it()); }
#else
    static int get_errno(void)       { return map_errno; }
    static void clear_errno(void)    { map_errno= MAP_OK; }
#endif

    /* Copying */

    ERWIN_EXPLICIT symtab_t (symtab_t const *a);

    symtab_t (symtab_t const &a);

    symtab_t *copy (void) const
    {
        cn();
        return new symtab_t (it());
    }

    symtab_t *copy_err (int *err) const
    {
        cn();
        symtab_t *result= new symtab_t (it());
        if (err != NULL && MAP_IS_ERROR (get_errno ()))
            *err= 1;
        return result;
    }

    symtab_t &xchg(symtab_t *other)
    {
        symtab_xchg (it(), other);
        return *this;
    }

    symtab_t &xchg(symtab_t &other)
    {
        symtab_xchg (this, &other);
        return *this;
    }

    /* Assignment */

    symtab_t &operator= (symtab_t const &);

    symtab_t &operator= (symtab_t const *);
        /* without this, it would be copied twice */

    void _constructor (void);
        /* Quite private: do not use unless you know what you're doing:
         *
         * This constructs the map for a given preallocated memory location.
         *
         * FIXME: There should be an operator new() for this. */

    void _destructor  (void);
        /* Quite private: do not use unless you know what you're doing:
         *
         * Needed if you want to use maps without a pointer in vectors.  vectors use
         * C-style memory allocation because they need realloc.  The constructor/destructors
         * are invoked via these two functions.
         */

    /* Destruction */

    ~symtab_t ();
        /* There is no delete_flags here in C++, but you can clear_flags() before
         * deletion. */


    /* Conversion to C type.
     * DO NOT CALL symtab_delete or symtab_delete_flags ON THE RETURNED VALUE!
     * All other things you do are ok. */

    operator symtab_t *(void)             { cn(); return it(); }
    operator symtab_t const *(void) const { cn(); return it(); }

    /* More operators for easy use: */

    /* int  == int  */

    int  operator[] (char const *  i) const
    {
        nocn();
        return symtab_find (it(), i);
    }

    /* operator int () const { return get_errno(); }
     * FIXME: maybe add this one day.  It produces invisible semantics changes with
     * old versions when 'explicit' is used as well. */
    int &operator[] (char const *  i) {
        cn();
        return *symtab_find_ptr_ensure (it(), i);
    }


    int *find_ptr (char const *  i) const
        { nocn(); return symtab_find_ptr (it(), i); }

    int *find_ptr_ensure (char const *  i)
        { cn(); return symtab_find_ptr_ensure (it(), i); }

    /* All other members map to the C equivalent directly. */
    int  find (char const *  i) const
        { nocn(); return symtab_find (it(), i); }
      
    int  find_ensure (char const *  i)
        { cn(); return symtab_find_ensure (it(), i); }

    int  find_any() const
        { nocn(); return symtab_find_any (it()); }

    char const *  find_any_key() const
        { nocn(); return symtab_find_any_key (it()); }

    symtab_element_ptr_t find_any_ptr() const
        { nocn(); return symtab_find_any_ptr (it()); }

    int find_any_pair(symtab_key_result_t &kp, symtab_element_ptr_t &vp) const
        { nocn(); return symtab_find_any_pair (&kp, &vp, it()); }


    /* insert */
    symtab_t  &insert (char const *  k, int  v)
        { cn(); symtab_insert (it(), k, v); return *this; }

    symtab_t  &insert_map (symtab_t const &other)
        { cn(&other); symtab_insert_map (it(), other.it()); return *this; }

    symtab_t  &insert_map (symtab_t const *other)
        { cn(other); symtab_insert_map (it(), other->it()); return *this; }

#if SYMTAB_DIRECT_RECURSION == 0
    symtab_t  &insert (symtab_t const &other)
        { cn(&other); symtab_insert_map (it(), other.it()); return *this; }

    symtab_t  &insert (symtab_t const *other)
        { cn(other); symtab_insert_map (it(), other->it()); return *this; }

#endif

    /* modify */
    int modify (char const *  i, int  v)
        { cn(); return symtab_modify (it(), i, v); }

    symtab_t  &modify_map (symtab_t const &other)
        { cn(&other);  symtab_modify_map (it(), other.it()); return *this; }

    symtab_t  &modify_map (symtab_t const *other)
        { cn(other); symtab_modify_map (it(), other->it()); return *this; }

#if SYMTAB_DIRECT_RECURSION == 0
    symtab_t  &modify (symtab_t const &other)
        { cn(&other); symtab_modify_map (it(), other.it()); return *this; }

    symtab_t  &modify (symtab_t const *other)
        { cn(other); symtab_modify_map (it(), other->it()); return *this; }

#endif

    /* set */

    symtab_t  &set (char const *  i, int  v)
        { cn(); symtab_set (it(), i, v); return *this; }

    symtab_t  &set_map (symtab_t const &other)
        { cn(&other); symtab_set_map (it(), other.it()); return *this; }

    symtab_t  &set_map (symtab_t const *other)
        { cn(other); symtab_set_map (it(), other->it()); return *this; }


#if SYMTAB_DIRECT_RECURSION == 0
    symtab_t  &set (symtab_t const &other)
        { cn(&other); symtab_set_map (it(), other.it()); return *this; }

    symtab_t  &set (symtab_t const *other)
        { cn(other); symtab_set_map (it(), other->it()); return *this; }

#endif

    /* remove */
    int remove (char const *  i)
        { nocn(); return symtab_remove (it(), i); }

    symtab_t &remove_map (symtab_t const &other)
        { nocn(&other); symtab_remove_map (it(), other.it()); return *this; }

    symtab_t &remove_map (symtab_t const *other)
        { nocn(other); symtab_remove_map (it(), other->it()); return *this; }

    int remove_if (symtab_feature_t f, bool value = true)
    {
        nocn();
        return symtab_remove_if (it(), f, value);
    }

    /* erase */
    symtab_t  &erase (char const *  i)
        { nocn(); symtab_erase (it(), i); return *this; }

    symtab_t  &erase_map (symtab_t const &other)
        { nocn(&other); symtab_erase_map (it(), other.it()); return *this; }

    symtab_t  &erase_map (symtab_t const *other)
        { nocn(other); symtab_erase_map (it(), other->it()); return *this; }

#if SYMTAB_DIRECT_RECURSION == 0
    symtab_t  &erase (symtab_t const &other)
        { nocn(other); symtab_erase_map (it(), other.it()); return *this; }

    symtab_t  &erase (symtab_t const *other)
        { nocn(other); symtab_erase_map (it(), other->it()); return *this; }

#endif

    int erase_if (symtab_feature_t f, bool value = true)
    {
        nocn();
        return symtab_erase_if (it(), f, value);
    }

    symtab_t &intersect (symtab_t const &other)
        { nocn(&other); symtab_intersect (it(), other.it()); return *this; }

    symtab_t &intersect (symtab_t const *other)
        { nocn(other); symtab_intersect (it(), other->it()); return *this; }

    symtab_t &intersect_no_resize (symtab_t const &other)
        { nocn(&other); symtab_intersect_no_resize (it(), other.it()); return *this; }

    symtab_t &intersect_no_resize (symtab_t const *other)
        { nocn(other); symtab_intersect_no_resize (it(), other->it()); return *this; }


    /* others */
    char const *  find_key (char const *  i) const { nocn(); return symtab_find_key (it(), i); }

    int  zero(void) const { nocn(); return symtab_zero (it()); }

    char const *  ensure (char const *  k)
        { cn(); return symtab_ensure (it(), k); }

    char const *  ensure_no_icopy (char *  k)
        { cn(); return symtab_ensure_no_icopy (it(), k); }

    char const *  operator() (char const *  k)
        { cn(); return symtab_ensure (it(), k); }

    symtab_t &poke (
        char const * *kp, int *vo,
        char const *  k, int  v,
        bool aintroduce SYMTAB_DEFAULT_ARG(true),
        bool aoverwrite SYMTAB_DEFAULT_ARG(true))
    {
        cn();
        symtab_poke (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    symtab_t &poke_no_icopy (
        char const * *kp, int *vo,
        char *  k, int  v,
        bool aintroduce SYMTAB_DEFAULT_ARG(true),
        bool aoverwrite SYMTAB_DEFAULT_ARG(true))
    {
        cn();
        symtab_poke_no_icopy (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    symtab_t &poke_no_ocopy (
        char const * *kp, int *vo,
        char const *  k, int  v,
        bool aintroduce SYMTAB_DEFAULT_ARG(true),
        bool aoverwrite SYMTAB_DEFAULT_ARG(true))
    {
        cn();
        symtab_poke_no_ocopy (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    symtab_t &poke_no_icopy_no_ocopy (
        char const * *kp, int *vo,
        char *  k, int  v,
        bool aintroduce SYMTAB_DEFAULT_ARG(true),
        bool aoverwrite SYMTAB_DEFAULT_ARG(true))
    {
        cn();
        symtab_poke_no_icopy_no_ocopy (kp,vo, it(), k,v, aintroduce, aoverwrite);
        return *this;
    }

    /* clear */
    symtab_t &clear (void)
    {
        nocn();
        symtab_clear (it());
        return *this;
    }

    symtab_t &clear_no_resize (void)
    {
        nocn();
        symtab_clear_no_resize (it());
        return *this;
    }

    symtab_t &clear (bool k, bool v)
    {
        nocn();
        symtab_clear_flags (it(), k, v);
        return *this;
    }

    int   nentries (void) const                  { nocn(); return symtab_nentries (it()); }
    bool  empty (void) const                     { nocn(); return ERWIN_TO_BOOL(symtab_empty (it())); }
    bool  non_empty (void) const                 { nocn(); return !symtab_empty (it()); }

    char const *          *get_keys   (void) const      { nocn(); return symtab_get_keys (it()); }
    static void delete_keys        (char const *          *k) { symtab_delete_keys (k); }

    symtab_pair_t     *get_entries (void) const     { nocn(); return symtab_get_entries (it()); }
    symtab_pair_ptr_t *get_entries_ptr (void) const { nocn(); return symtab_get_entries_ptr (it()); }
    int          *get_values (void) const      { nocn(); return symtab_get_values (it()); }

    static void delete_entries_ptr (symtab_pair_ptr_t *k) { symtab_delete_entries_ptr (k); }
    static void delete_entries     (symtab_pair_t     *k) { symtab_delete_entries (k); }
    static void delete_values      (int          *k) { symtab_delete_values (k); }

    int     hash_size (void) const            { nocn(); return symtab_hash_size (it()); }
    symtab_t &rehash (int n)                     { nocn(); symtab_rehash (it(), n); return *this;}
    double  average_line_length (void) const  { nocn(); return symtab_average_line_length (it()); }
    double  variance_line_length (void) const { nocn(); return symtab_variance_line_length (it()); }
#ifdef HAVE_SQRT
    double  deviation_line_length (void) const { nocn(); return symtab_deviation_line_length (it()); }
#endif
    int     max_line_length (void) const      { nocn(); return symtab_max_line_length (it()); }
    int     min_line_length (void) const      { nocn(); return symtab_min_line_length (it()); }

    void    dump (FILE *f) const              { nocn(); symtab_dump (f, it()); }

#ifdef ERWIN_PROFILE
    int     nrehash_ops (void) const          { nocn(); return symtab_nrehash_ops (it()); }
    int     nrehash (void) const              { nocn(); return symtab_nrehash (it()); }
    int     ninsert (void) const              { nocn(); return symtab_ninsert (it()); }
    int     nremove (void) const              { nocn(); return symtab_nremove (it()); }
    int     nfind (void) const                { nocn(); return symtab_nfind (it()); }
    int     nops(void) const                  { nocn(); return symtab_nops (it()); }
#endif

    hashval_t hash_raw(void) const { nocn(); return symtab_hash_raw (it()); }
    hashval_t hash(void) const     { nocn(); return symtab_hash     (it()); }

    bool equal(symtab_t const *other) const
    {
        if (this == NULL || other == NULL) /* must be NULL-safe */
            return this == other;
        return ERWIN_TO_BOOL(symtab_equal (it(), other->it()));
    }

    bool equal(symtab_t const &other) const
    {
        return equal (&other);
    }

    int cmp (symtab_t const *other) const
    {
        if (this == NULL)
            return other == NULL ? 0 : -1;
        if (other == NULL)
            return +1;
        return symtab_cmp (it(), other->it());
    }

    int cmp (symtab_t const &other) const { nocn(); return cmp (&other); }

    bool operator== (symtab_t const &b) { nocn(); return equal(b); }    /* see equal() */
    bool operator== (symtab_t const *b) { nocn(); return equal(b); }    /* see equal() */

    bool operator!= (symtab_t const &b) { nocn(); return !equal(b); }   /* see equal() */
    bool operator!= (symtab_t const *b) { nocn(); return !equal(b); }   /* see equal() */

    bool operator<= (symtab_t const &b) { nocn(); return cmp(b) <= 0; } /* see cmp() */
    bool operator<= (symtab_t const *b) { nocn(); return cmp(b) <= 0; } /* see cmp() */

    bool operator>= (symtab_t const &b) { nocn(); return cmp(b) >= 0; } /* see cmp() */
    bool operator>= (symtab_t const *b) { nocn(); return cmp(b) >= 0; } /* see cmp() */

    bool operator<  (symtab_t const &b) { nocn(); return cmp(b) < 0; }  /* see cmp() */
    bool operator<  (symtab_t const *b) { nocn(); return cmp(b) < 0; }  /* see cmp() */

    bool operator>  (symtab_t const &b) { nocn(); return cmp(b) > 0; }  /* see cmp() */
    bool operator>  (symtab_t const *b) { nocn(); return cmp(b) > 0; }  /* see cmp() */

    /* Type defs */
    typedef int ValueType;

    typedef char const * KeyType;

/* BEGIN: Generated automatically by makeforall.pl (part of Erwin2) */

/* Note: The symtab_pair_cmp_t argument to the next_user_... functions is useful only
 *       to type check the user's comparison function.  The compiler hopefully
 *       throws it away.
 *
 * Further Note:
 *       The iteration member functions are internal.  They should not be
 *       used directly.  They might change whenever changes to the forall macros
 *       become necessary.
 */

    static void init_iterator (void const *map, map_iterator_t *iter)
    {
        symtab_init_iterator (((Symtab const *)map)->it(), iter);
    }

    bool next (map_iterator_t &iter, char const * &k, int &v) const
    {
        return symtab_next_iteration (it(), &iter, &k, &v) != ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_key (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_key (((Symtab const *)map)->it(), iter);
    }

    bool next_sorted (map_iterator_sorted_t &iter, char const * &k, int &v) const
    {
        return symtab_next_iteration_sorted (it(), &iter, &k, &v) != ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_value (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_value (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_key_and_value (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_key_and_value (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_value_and_key (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_value_and_key (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_user (void const *map, map_iterator_sorted_t *iter, symtab_void_pair_cmp_t u)
    {
        symtab_init_iterator_sorted_by_user (((Symtab const *)map)->it(), iter, (symtab_pair_cmp_t)u);
    }

    bool next_user_sorted (map_iterator_sorted_t &iter, symtab_pair_cmp_t, char const * &k, int &v) const
    {
        return symtab_next_iteration_sorted (it(), &iter, &k, &v) != ERWIN_FALSE;
    }

    bool next_ptr (map_iterator_t &iter, char const * &k, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_ptr (it(), &iter, &k, &V) != ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_key (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_key (((Symtab const *)map)->it(), iter);
    }

    bool next_sorted_ptr (map_iterator_sorted_t &iter, char const * &k, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_ptr (it(), &iter, &k, &V) != ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_value (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_value (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_key_and_value (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_key_and_value (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_value_and_key (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_value_and_key (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_user (void const *map, map_iterator_sorted_t *iter, symtab_void_pair_cmp_t U)
    {
        symtab_init_iterator_ptr_sorted_by_user (((Symtab const *)map)->it(), iter, (symtab_pair_ptr_cmp_t)U);
    }

    bool next_user_sorted_ptr (map_iterator_sorted_t &iter, symtab_pair_ptr_cmp_t, char const * &k, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_ptr (it(), &iter, &k, &V) != ERWIN_FALSE;
    }

    bool next_key (map_iterator_t &iter, char const * &k) const
    {
        return symtab_next_iteration_keys (it(), &iter, &k) != ERWIN_FALSE;
    }

    bool next_sorted_key (map_iterator_sorted_t &iter, char const * &k) const
    {
        return symtab_next_iteration_sorted_keys (it(), &iter, &k) != ERWIN_FALSE;
    }

    bool next_user_sorted_key (map_iterator_sorted_t &iter, symtab_pair_cmp_t, char const * &k) const
    {
        return symtab_next_iteration_sorted_keys (it(), &iter, &k) != ERWIN_FALSE;
    }

    bool next_value (map_iterator_t &iter, int &v) const
    {
        return symtab_next_iteration_values (it(), &iter, &v) != ERWIN_FALSE;
    }

    bool next_sorted_value (map_iterator_sorted_t &iter, int &v) const
    {
        return symtab_next_iteration_sorted_values (it(), &iter, &v) != ERWIN_FALSE;
    }

    bool next_user_sorted_value (map_iterator_sorted_t &iter, symtab_pair_cmp_t, int &v) const
    {
        return symtab_next_iteration_sorted_values (it(), &iter, &v) != ERWIN_FALSE;
    }

    bool next_value_ptr (map_iterator_t &iter, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_values_ptr (it(), &iter, &V) != ERWIN_FALSE;
    }

    bool next_sorted_value_ptr (map_iterator_sorted_t &iter, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_values_ptr (it(), &iter, &V) != ERWIN_FALSE;
    }

    bool next_user_sorted_value_ptr (map_iterator_sorted_t &iter, symtab_pair_ptr_cmp_t, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_values_ptr (it(), &iter, &V) != ERWIN_FALSE;
    }

    bool next_pair (map_iterator_t &iter, symtab_pair_t &p) const
    {
        return symtab_next_iteration_pairs (it(), &iter, &p) != ERWIN_FALSE;
    }

    bool next_sorted_pair (map_iterator_sorted_t &iter, symtab_pair_t &p) const
    {
        return symtab_next_iteration_sorted_pairs (it(), &iter, &p) != ERWIN_FALSE;
    }

    bool next_user_sorted_pair (map_iterator_sorted_t &iter, symtab_pair_cmp_t, symtab_pair_t &p) const
    {
        return symtab_next_iteration_sorted_pairs (it(), &iter, &p) != ERWIN_FALSE;
    }

    bool next_pair_ptr (map_iterator_t &iter, symtab_pair_ptr_t &P) const
    {
        return symtab_next_iteration_pairs_ptr (it(), &iter, &P) != ERWIN_FALSE;
    }

    bool next_sorted_pair_ptr (map_iterator_sorted_t &iter, symtab_pair_ptr_t &P) const
    {
        return symtab_next_iteration_sorted_pairs_ptr (it(), &iter, &P) != ERWIN_FALSE;
    }

    bool next_user_sorted_pair_ptr (map_iterator_sorted_t &iter, symtab_pair_ptr_cmp_t, symtab_pair_ptr_t &P) const
    {
        return symtab_next_iteration_sorted_pairs_ptr (it(), &iter, &P) != ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_key_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_key_reverse (((Symtab const *)map)->it(), iter);
    }

    bool next_sorted_reverse (map_iterator_sorted_t &iter, char const * &k, int &v) const
    {
        return symtab_next_iteration_sorted_reverse (it(), &iter, &k, &v) != ERWIN_FALSE;
    }

    static void init_iterator_sorted_by_value_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_value_reverse (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_key_and_value_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_key_and_value_reverse (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_value_and_key_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_sorted_by_value_and_key_reverse (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_sorted_by_user_reverse (void const *map, map_iterator_sorted_t *iter, symtab_void_pair_cmp_t u)
    {
        symtab_init_iterator_sorted_by_user_reverse (((Symtab const *)map)->it(), iter, (symtab_pair_cmp_t)u);
    }

    bool next_user_sorted_reverse (map_iterator_sorted_t &iter, symtab_pair_cmp_t, char const * &k, int &v) const
    {
        return symtab_next_iteration_sorted_reverse (it(), &iter, &k, &v) != ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_key_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_key_reverse (((Symtab const *)map)->it(), iter);
    }

    bool next_sorted_ptr_reverse (map_iterator_sorted_t &iter, char const * &k, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_ptr_reverse (it(), &iter, &k, &V) != ERWIN_FALSE;
    }

    static void init_iterator_ptr_sorted_by_value_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_value_reverse (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_key_and_value_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_key_and_value_reverse (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_value_and_key_reverse (void const *map, map_iterator_sorted_t *iter)
    {
        symtab_init_iterator_ptr_sorted_by_value_and_key_reverse (((Symtab const *)map)->it(), iter);
    }

    static void init_iterator_ptr_sorted_by_user_reverse (void const *map, map_iterator_sorted_t *iter, symtab_void_pair_cmp_t U)
    {
        symtab_init_iterator_ptr_sorted_by_user_reverse (((Symtab const *)map)->it(), iter, (symtab_pair_ptr_cmp_t)U);
    }

    bool next_user_sorted_ptr_reverse (map_iterator_sorted_t &iter, symtab_pair_ptr_cmp_t, char const * &k, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_ptr_reverse (it(), &iter, &k, &V) != ERWIN_FALSE;
    }

    bool next_sorted_key_reverse (map_iterator_sorted_t &iter, char const * &k) const
    {
        return symtab_next_iteration_sorted_keys_reverse (it(), &iter, &k) != ERWIN_FALSE;
    }

    bool next_user_sorted_key_reverse (map_iterator_sorted_t &iter, symtab_pair_cmp_t, char const * &k) const
    {
        return symtab_next_iteration_sorted_keys_reverse (it(), &iter, &k) != ERWIN_FALSE;
    }

    bool next_sorted_value_reverse (map_iterator_sorted_t &iter, int &v) const
    {
        return symtab_next_iteration_sorted_values_reverse (it(), &iter, &v) != ERWIN_FALSE;
    }

    bool next_user_sorted_value_reverse (map_iterator_sorted_t &iter, symtab_pair_cmp_t, int &v) const
    {
        return symtab_next_iteration_sorted_values_reverse (it(), &iter, &v) != ERWIN_FALSE;
    }

    bool next_sorted_value_ptr_reverse (map_iterator_sorted_t &iter, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_values_ptr_reverse (it(), &iter, &V) != ERWIN_FALSE;
    }

    bool next_user_sorted_value_ptr_reverse (map_iterator_sorted_t &iter, symtab_pair_ptr_cmp_t, symtab_element_ptr_t &V) const
    {
        return symtab_next_iteration_sorted_values_ptr_reverse (it(), &iter, &V) != ERWIN_FALSE;
    }

    bool next_sorted_pair_reverse (map_iterator_sorted_t &iter, symtab_pair_t &p) const
    {
        return symtab_next_iteration_sorted_pairs_reverse (it(), &iter, &p) != ERWIN_FALSE;
    }

    bool next_user_sorted_pair_reverse (map_iterator_sorted_t &iter, symtab_pair_cmp_t, symtab_pair_t &p) const
    {
        return symtab_next_iteration_sorted_pairs_reverse (it(), &iter, &p) != ERWIN_FALSE;
    }

    bool next_sorted_pair_ptr_reverse (map_iterator_sorted_t &iter, symtab_pair_ptr_t &P) const
    {
        return symtab_next_iteration_sorted_pairs_ptr_reverse (it(), &iter, &P) != ERWIN_FALSE;
    }

    bool next_user_sorted_pair_ptr_reverse (map_iterator_sorted_t &iter, symtab_pair_ptr_cmp_t, symtab_pair_ptr_t &P) const
    {
        return symtab_next_iteration_sorted_pairs_ptr_reverse (it(), &iter, &P) != ERWIN_FALSE;
    }

/* END: Generated automatically */

/*--END-CLASS--*/
#endif /* __cplusplus */
};

#ifdef __cplusplus


/* some nasty global functions that are useful e.g. for forall.  Note that these
 * are not local to one vector but will be overloaded by all different vector
 * instantiations. */
extern "C++" {
ERWIN_WRAPPER
symtab_t *erwin_ptr_of(symtab_t *x) { return x;  }

ERWIN_WRAPPER
symtab_t *erwin_ptr_of(symtab_t &x) { return &x; }

ERWIN_WRAPPER
symtab_t const *erwin_ptr_const_of (symtab_t const *x) { return x;  }

ERWIN_WRAPPER
symtab_t const *erwin_ptr_const_of (symtab_t const &x) { return &x; }
} /* extern "C++" */


/*
 * For the sorted iteration you must provide CHAR_CONST_P_CMP and INT_CMP resp.  Otherwise, you
 * will get run-time errors when using these macros.
 */
#if defined (ERWIN_REQUIRE_DETERMINISM) && !defined (ERWIN_WEAK_DETERMINISM)
/* Force forall macros that allow deterministic sort order if user required determinism.
 * When _sorted_by_user functions are given the NULL function, they will still
 * sort the map if that is required.
 */
#  ifndef map_forall
#    define map_forall(h,k,v) map_forall_copy(h,k,v)
/* Operator for hash iteration in C++.  This iterates over keys and values.  You do not
 * need any additional structure when using C++ since this is declared automatically.
 * Use it as follows.
 *    : MapIntCharP m;
 *    : ...
 *    : int i;
 *    : char *s;
 *    : map_forall (m, i, s) {
 *    :     printf ("key=%d, value=%s\n", i, s);
 *    : }
 *
 *
 * The macro also accepts pointers to maps.  So you could also have used:
 *    : ...
 *    : map_forall (&m, i, s)
 *    : ...
 *
 * It might be interesting to compare this to the C version symtab_forall.
 *
 * Other variants for C++ are available.  In addition to the C macros, the
 * C++ macros allow sorted iteration (..._sorted_by_... variants).
 *
 * All C++ macros support determinism by possibly pre-sorting the map.
 *
 * For convenience, the non-deterministic iterators are available for C++, too.
 * These are the ..._nondet variants.
 *
 * Further, all sorted versions and the copied versions (..._copy) allow you
 * to arbitrarily modify (symtab_erase, symtab_insert, symtab_modify) the map while you
 * iterate it.  These changes are not reflected during that loop, however.
 *
 * Iteration is allowed on points to values, too.  These are the ...ptr
 * variants.  This way, you can modify values on the fly.  You need not use
 * the copied functions for this to work.  There is no way of modifying keys
 * on the fly, since this needs restructuring of the internal hash table.
 * Use symtab_erase and symtab_insert for this.
 *
 * The following is the complete list of C++ iteration macros, which should be
 * self-explained, since naming is completely regular.
 *
 *    : map_forall(h,k,v)
 *    : map_forall_copy(h,k,v)
 *    : map_forall_nondet(h,k,v)
 *    : map_forall_sorted_by_key(h,k,v)
 *    : map_forall_sorted_by_value(h,k,v)
 *    : map_forall_sorted_by_key_and_value(h,k,v)
 *    : map_forall_sorted_by_value_and_key(h,k,v)
 *    : map_forall_sorted_by_user(h,u,k,v)
 *    : map_forall_ptr(h,k,V)
 *    : map_forall_ptr_copy(h,k,V)
 *    : map_forall_ptr_nondet(h,k,V)
 *    : map_forall_ptr_sorted_by_key(h,k,V)
 *    : map_forall_ptr_sorted_by_value(h,k,V)
 *    : map_forall_ptr_sorted_by_key_and_value(h,k,V)
 *    : map_forall_ptr_sorted_by_value_and_key(h,k,V)
 *    : map_forall_ptr_sorted_by_user(h,U,k,V)
 *    : map_forall_keys(h,k)
 *    : map_forall_keys_copy(h,k)
 *    : map_forall_keys_nondet(h,k)
 *    : map_forall_keys_sorted_by_key(h,k)
 *    : map_forall_keys_sorted_by_value(h,k)
 *    : map_forall_keys_sorted_by_key_and_value(h,k)
 *    : map_forall_keys_sorted_by_value_and_key(h,k)
 *    : map_forall_keys_sorted_by_user(h,u,k)
 *    : map_forall_values(h,v)
 *    : map_forall_values_copy(h,v)
 *    : map_forall_values_nondet(h,v)
 *    : map_forall_values_sorted_by_key(h,v)
 *    : map_forall_values_sorted_by_value(h,v)
 *    : map_forall_values_sorted_by_key_and_value(h,v)
 *    : map_forall_values_sorted_by_value_and_key(h,v)
 *    : map_forall_values_sorted_by_user(h,u,v)
 *    : map_forall_values_ptr(h,V)
 *    : map_forall_values_ptr_copy(h,V)
 *    : map_forall_values_ptr_nondet(h,V)
 *    : map_forall_values_ptr_sorted_by_key(h,V)
 *    : map_forall_values_ptr_sorted_by_value(h,V)
 *    : map_forall_values_ptr_sorted_by_key_and_value(h,V)
 *    : map_forall_values_ptr_sorted_by_value_and_key(h,V)
 *    : map_forall_values_ptr_sorted_by_user(h,U,V)
 *    : map_forall_pairs(h,p)
 *    : map_forall_pairs_copy(h,p)
 *    : map_forall_pairs_nondet(h,p)
 *    : map_forall_pairs_sorted_by_key(h,p)
 *    : map_forall_pairs_sorted_by_value(h,p)
 *    : map_forall_pairs_sorted_by_key_and_value(h,p)
 *    : map_forall_pairs_sorted_by_value_and_key(h,p)
 *    : map_forall_pairs_sorted_by_user(h,u,p)
 *    : map_forall_pairs_ptr(h,P)
 *    : map_forall_pairs_ptr_copy(h,P)
 *    : map_forall_pairs_ptr_nondet(h,P)
 *    : map_forall_pairs_ptr_sorted_by_key(h,P)
 *    : map_forall_pairs_ptr_sorted_by_value(h,P)
 *    : map_forall_pairs_ptr_sorted_by_key_and_value(h,P)
 *    : map_forall_pairs_ptr_sorted_by_value_and_key(h,P)
 *    : map_forall_pairs_ptr_sorted_by_user(h,U,P)
 *
 */
#  endif

#  ifndef map_forall_ptr
#    define map_forall_ptr(h,k,v) map_forall_ptr_copy(h,k,v)
#  endif

#  ifndef map_forall_keys
#    define map_forall_keys(h,k) map_forall_keys_copy(h,k)
#  endif

#  ifndef map_forall_values
#    define map_forall_values(h,v) map_forall_values_copy(h,v)
#  endif

#  ifndef map_forall_values_ptr
#    define map_forall_values_ptr(h,v) map_forall_values_ptr_copy(h,v)
#  endif

#  ifndef map_forall_pairs
#    define map_forall_pairs(h,p) map_forall_pairs_copy(h,p)
#  endif

#  ifndef map_forall_pairs_ptr
#    define map_forall_pairs_ptr(h,p) map_forall_pairs_ptr_copy(h,p)
#  endif

#else

#  ifndef map_forall
#    define map_forall(h,k,v) map_forall_nondet(h,k,v)
#  endif

#  ifndef map_forall_ptr
#    define map_forall_ptr(h,k,v) map_forall_ptr_nondet(h,k,v)
#  endif

#  ifndef map_forall_keys
#    define map_forall_keys(h,k) map_forall_keys_nondet(h,k)
#  endif

#  ifndef map_forall_values
#    define map_forall_values(h,v) map_forall_values_nondet(h,v)
#  endif

#  ifndef map_forall_values_ptr
#    define map_forall_values_ptr(h,v) map_forall_values_ptr_nondet(h,v)
#  endif

#  ifndef map_forall_pairs
#    define map_forall_pairs(h,p) map_forall_pairs_nondet(h,p)
#  endif

#  ifndef map_forall_pairs_ptr
#    define map_forall_pairs_ptr(h,p) map_forall_pairs_ptr_nondet(h,p)
#  endif

#endif

/*
 * The following are convenience macros for iterating over a copy of the map
 * in order to allow modification during iteration. */
#ifndef map_forall_copy
#  define map_forall_copy(h,k,v) map_forall_sorted_by_user(h,NULL,k,v)
#endif

#ifndef map_forall_ptr_copy
#  define map_forall_ptr_copy(h,k,v) map_forall_ptr_sorted_by_user(h,NULL,k,v)
#endif

#ifndef map_forall_keys_copy
#  define map_forall_keys_copy(h,k) map_forall_keys_sorted_by_user(h,NULL,k)
#endif

#ifndef map_forall_values_copy
#  define map_forall_values_copy(h,v) map_forall_values_sorted_by_user(h,NULL,v)
#endif

#ifndef map_forall_values_ptr_copy
#  define map_forall_values_ptr_copy(h,v) map_forall_values_ptr_sorted_by_user(h,NULL,v)
#endif

#ifndef map_forall_pairs_copy
#  define map_forall_pairs_copy(h,p) map_forall_pairs_sorted_by_user(h,NULL,p)
#endif

#ifndef map_forall_pairs_ptr_copy
#  define map_forall_pairs_ptr_copy(h,p) map_forall_pairs_ptr_sorted_by_user(h,NULL,p)
#endif

/* BEGIN: Generated automatically by makeforall.pl (part of Erwin2) */

/* Note: While iterating over a map with a non-sorting map_forall*
 *       function, you may not alter the contents of the map!
 *
 *       All sorting functions allow altering, because the map has to be
 *       copied completely to enable sorted iteration.  You will iterate over
 *       the old contents, i.e, the modifications do not become visible to the
 *       iterator.
 *
 *       If you want non-sorted iteration with the possibility of altering the
 *       map, use the map_forall_*sorted_by_user family.
 */

#ifndef map_forall_nondet
#   define map_forall_nondet(h,k,v) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_key
#   define map_forall_sorted_by_key(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_value
#   define map_forall_sorted_by_value(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_key_and_value
#   define map_forall_sorted_by_key_and_value(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_value_and_key
#   define map_forall_sorted_by_value_and_key(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_user
#   define map_forall_sorted_by_user(h,u,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted(ERWIN_GENSYM(erwin_local_i), u,k,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_ptr_nondet
#   define map_forall_ptr_nondet(h,k,V) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_key
#   define map_forall_ptr_sorted_by_key(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_value
#   define map_forall_ptr_sorted_by_value(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_key_and_value
#   define map_forall_ptr_sorted_by_key_and_value(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_value_and_key
#   define map_forall_ptr_sorted_by_value_and_key(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_user
#   define map_forall_ptr_sorted_by_user(h,U,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user, \
                    (void const *)erwin_ptr_of(h), (symtab_void_pair_cmp_t)U); \
            erwin_ptr_of(h)->next_user_sorted_ptr(ERWIN_GENSYM(erwin_local_i), U,k,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_keys_nondet
#   define map_forall_keys_nondet(h,k) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_key
#   define map_forall_keys_sorted_by_key(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_value
#   define map_forall_keys_sorted_by_value(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_key_and_value
#   define map_forall_keys_sorted_by_key_and_value(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_value_and_key
#   define map_forall_keys_sorted_by_value_and_key(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_user
#   define map_forall_keys_sorted_by_user(h,u,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_key(ERWIN_GENSYM(erwin_local_i), u,k); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_values_nondet
#   define map_forall_values_nondet(h,v) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_key
#   define map_forall_values_sorted_by_key(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_value
#   define map_forall_values_sorted_by_value(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_key_and_value
#   define map_forall_values_sorted_by_key_and_value(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_value_and_key
#   define map_forall_values_sorted_by_value_and_key(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_user
#   define map_forall_values_sorted_by_user(h,u,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_value(ERWIN_GENSYM(erwin_local_i), u,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_values_ptr_nondet
#   define map_forall_values_ptr_nondet(h,V) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_key
#   define map_forall_values_ptr_sorted_by_key(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_value
#   define map_forall_values_ptr_sorted_by_value(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_key_and_value
#   define map_forall_values_ptr_sorted_by_key_and_value(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_value_and_key
#   define map_forall_values_ptr_sorted_by_value_and_key(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_user
#   define map_forall_values_ptr_sorted_by_user(h,U,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user, \
                    (void const *)erwin_ptr_of(h), (symtab_void_pair_cmp_t)U); \
            erwin_ptr_of(h)->next_user_sorted_value_ptr(ERWIN_GENSYM(erwin_local_i), U,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_pairs_nondet
#   define map_forall_pairs_nondet(h,p) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_key
#   define map_forall_pairs_sorted_by_key(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_value
#   define map_forall_pairs_sorted_by_value(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_key_and_value
#   define map_forall_pairs_sorted_by_key_and_value(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_value_and_key
#   define map_forall_pairs_sorted_by_value_and_key(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_user
#   define map_forall_pairs_sorted_by_user(h,u,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_pair(ERWIN_GENSYM(erwin_local_i), u,p); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_pairs_ptr_nondet
#   define map_forall_pairs_ptr_nondet(h,P) \
        for(map_iterator_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_key
#   define map_forall_pairs_ptr_sorted_by_key(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_value
#   define map_forall_pairs_ptr_sorted_by_value(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_key_and_value
#   define map_forall_pairs_ptr_sorted_by_key_and_value(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_value_and_key
#   define map_forall_pairs_ptr_sorted_by_value_and_key(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_user
#   define map_forall_pairs_ptr_sorted_by_user(h,U,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user, \
                    (void const *)erwin_ptr_of(h), (symtab_void_pair_cmp_t)U); \
            erwin_ptr_of(h)->next_user_sorted_pair_ptr(ERWIN_GENSYM(erwin_local_i), U,P); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_sorted_by_key_reverse
#   define map_forall_sorted_by_key_reverse(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_value_reverse
#   define map_forall_sorted_by_value_reverse(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_key_and_value_reverse
#   define map_forall_sorted_by_key_and_value_reverse(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_value_and_key_reverse
#   define map_forall_sorted_by_value_and_key_reverse(h,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_reverse(ERWIN_GENSYM(erwin_local_i), k,v); \
            /* no stepper */)
#endif

#ifndef map_forall_sorted_by_user_reverse
#   define map_forall_sorted_by_user_reverse(h,u,k,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_reverse(ERWIN_GENSYM(erwin_local_i), u,k,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_ptr_sorted_by_key_reverse
#   define map_forall_ptr_sorted_by_key_reverse(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_value_reverse
#   define map_forall_ptr_sorted_by_value_reverse(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_key_and_value_reverse
#   define map_forall_ptr_sorted_by_key_and_value_reverse(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_value_and_key_reverse
#   define map_forall_ptr_sorted_by_value_and_key_reverse(h,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), k,V); \
            /* no stepper */)
#endif

#ifndef map_forall_ptr_sorted_by_user_reverse
#   define map_forall_ptr_sorted_by_user_reverse(h,U,k,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_of(h), (symtab_void_pair_cmp_t)U); \
            erwin_ptr_of(h)->next_user_sorted_ptr_reverse(ERWIN_GENSYM(erwin_local_i), U,k,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_keys_sorted_by_key_reverse
#   define map_forall_keys_sorted_by_key_reverse(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_value_reverse
#   define map_forall_keys_sorted_by_value_reverse(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_key_and_value_reverse
#   define map_forall_keys_sorted_by_key_and_value_reverse(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_value_and_key_reverse
#   define map_forall_keys_sorted_by_value_and_key_reverse(h,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), k); \
            /* no stepper */)
#endif

#ifndef map_forall_keys_sorted_by_user_reverse
#   define map_forall_keys_sorted_by_user_reverse(h,u,k) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_key_reverse(ERWIN_GENSYM(erwin_local_i), u,k); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_values_sorted_by_key_reverse
#   define map_forall_values_sorted_by_key_reverse(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_value_reverse
#   define map_forall_values_sorted_by_value_reverse(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_key_and_value_reverse
#   define map_forall_values_sorted_by_key_and_value_reverse(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_value_and_key_reverse
#   define map_forall_values_sorted_by_value_and_key_reverse(h,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), v); \
            /* no stepper */)
#endif

#ifndef map_forall_values_sorted_by_user_reverse
#   define map_forall_values_sorted_by_user_reverse(h,u,v) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_value_reverse(ERWIN_GENSYM(erwin_local_i), u,v); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_values_ptr_sorted_by_key_reverse
#   define map_forall_values_ptr_sorted_by_key_reverse(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_value_reverse
#   define map_forall_values_ptr_sorted_by_value_reverse(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_key_and_value_reverse
#   define map_forall_values_ptr_sorted_by_key_and_value_reverse(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_value_and_key_reverse
#   define map_forall_values_ptr_sorted_by_value_and_key_reverse(h,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), V); \
            /* no stepper */)
#endif

#ifndef map_forall_values_ptr_sorted_by_user_reverse
#   define map_forall_values_ptr_sorted_by_user_reverse(h,U,V) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_of(h), (symtab_void_pair_cmp_t)U); \
            erwin_ptr_of(h)->next_user_sorted_value_ptr_reverse(ERWIN_GENSYM(erwin_local_i), U,V); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_pairs_sorted_by_key_reverse
#   define map_forall_pairs_sorted_by_key_reverse(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_value_reverse
#   define map_forall_pairs_sorted_by_value_reverse(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_key_and_value_reverse
#   define map_forall_pairs_sorted_by_key_and_value_reverse(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_value_and_key_reverse
#   define map_forall_pairs_sorted_by_value_and_key_reverse(h,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_const_of(h)); \
            erwin_ptr_const_of(h)->next_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), p); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_sorted_by_user_reverse
#   define map_forall_pairs_sorted_by_user_reverse(h,u,p) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_const_of(h)->init_iterator_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_const_of(h), (symtab_void_pair_cmp_t)u); \
            erwin_ptr_const_of(h)->next_user_sorted_pair_reverse(ERWIN_GENSYM(erwin_local_i), u,p); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

#ifndef map_forall_pairs_ptr_sorted_by_key_reverse
#   define map_forall_pairs_ptr_sorted_by_key_reverse(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_value_reverse
#   define map_forall_pairs_ptr_sorted_by_value_reverse(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_key_and_value_reverse
#   define map_forall_pairs_ptr_sorted_by_key_and_value_reverse(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_key_and_value_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_value_and_key_reverse
#   define map_forall_pairs_ptr_sorted_by_value_and_key_reverse(h,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_value_and_key_reverse, \
                    (void const *)erwin_ptr_of(h)); \
            erwin_ptr_of(h)->next_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), P); \
            /* no stepper */)
#endif

#ifndef map_forall_pairs_ptr_sorted_by_user_reverse
#   define map_forall_pairs_ptr_sorted_by_user_reverse(h,U,P) \
        for(map_iterator_sorted_t \
                ERWIN_GENSYM(erwin_local_i)(erwin_ptr_of(h)->init_iterator_ptr_sorted_by_user_reverse, \
                    (void const *)erwin_ptr_of(h), (symtab_void_pair_cmp_t)U); \
            erwin_ptr_of(h)->next_user_sorted_pair_ptr_reverse(ERWIN_GENSYM(erwin_local_i), U,P); \
            /* no stepper */)
/* If you use NULL as the sort function, you the map will be iterated
 * without sorting.  However, this is usefull since you then
 * modify the map while iterating over the old version of the map.
 */
#endif

/* END: Generated automatically */

#endif /* defined(__cplusplus) */

#endif /* !defined(ERWIN_SYMTAB_h) */

