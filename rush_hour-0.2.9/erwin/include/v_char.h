/* -*- Mode: C -*- */
/* Generated Tue Aug 19 15:44:01 GMT 2008
 */
/*
 * Author: Henrik Theiling
 * Description:
 *     Public header file for vectors with arbitrary value types.
 *
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including v_char.h"
#endif

#ifndef ERWIN_V_CHAR_h
#define ERWIN_V_CHAR_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of v_char.h"
#endif

/* Include basic configuration */
#ifdef ERWIN_COMPILING
#  include "erwin/defs.h"
#else
#  include <erwin/defs.h>
#endif

/* Include definitions */
#include "v_char_d.h"

/* Include basic definitions */
#ifdef ERWIN_COMPILING
#  include "erwin/base.h"
#else
#  include <erwin/base.h>
#endif

#ifdef ERWIN_COMPILING
#  include "erwin/forwards.h"
#else
#  include <erwin/forwards.h>
#endif

#ifdef HAVE_STDIO_H
#  include <stdio.h>
#endif


#undef vector_errno
#if ERWIN_GLOBAL_ERRNO
#  define vector_errno erwininternalvectorerrno
  /* If you compiled Erwin without the ERWIN_THREAD_SAFE flag,
   * this variable holds global status code for vectors.
   */
#endif

#undef  vector_strerror
#define vector_strerror(X) erwininternalvectorstrerror(X)
  /* Returns a textual description of a given error.  This description
   * starts with `Error: ' or `Warning: ' or something the like
   * to indicate the status level.  This is then followed by a
   * short description phrase.
   */

/*! enum: VECTOR_OK, VECTOR_ERR_*, VECTOR_WARN_* */
#undef  VECTOR_OK
#define VECTOR_OK ERWININTERNALVECTOROK
  /* No error occurred. */

#undef  VECTOR_IS_OK
#define VECTOR_IS_OK(X) ERWININTERNALVECTORISOK(X)
  /* Find out whether the status code vector_errno indicates that everything is fine. */

#undef  VECTOR_IS_ERROR
#define VECTOR_IS_ERROR(X) ERWININTERNALVECTORISERROR(X)
  /* Find out whether the status code vector_errno indicates that an error occured. */

#undef  VECTOR_IS_WARNING
#define VECTOR_IS_WARNING(X) ERWININTERNALVECTORISWARNING(X)
  /* Find out whether the status code vector_errno indicates that an error occured. */

#undef  VECTOR_ERR_NOMEM
#define VECTOR_ERR_NOMEM ERWININTERNALVECTORERRNOMEM
  /* Memory exhausted.  If you think this is a fatal error and should be
   * treated like a failed assertion, #define ERWIN_NOMEM_IS_FATAL.
   */

#undef  VECTOR_ERR_OUTOFRANGE
#define VECTOR_ERR_OUTOFRANGE ERWININTERNALVECTORERROUTOFRANGE
  /* Returned whenever an argument has a value that cannot be handled. */

#undef  VECTOR_ERR_TOOLARGE
#define VECTOR_ERR_TOOLARGE ERWININTERNALVECTORERRTOOLARGE
  /* The vector cannot handle the new size due to the limited range of
   * the data type for the index. */

#undef  VECTOR_ERR_IO
#define VECTOR_ERR_IO ERWININTERNALVECTORERRIO
  /* Operations doing I/O return this error when an I/O error occured.  Which
   * error it was can be determined by calling ferror(3) on the FILE * you
   * passed to the vector function.
   *
   * Currently, v_char_fread and v_char_fgets may return this error.
   */

#undef  VECTOR_ERR_ASSERTIONFAILED
#define VECTOR_ERR_ASSERTIONFAILED ERWININTERNALVECTORERRASSERTIONFAILED
  /* Whenever an axiomatic assertion failed, this error is occured.
   *
   * Note: Something really went wrong in this case, so do not expect that
   *       every failed assertion allows normal control flow to continue.
   *       This error means the program is broken and would have crashed
   *       or done something bad if the assertion had not been checked.
   */

#undef  VECTOR_ERR_NOTCOMPILED
#define VECTOR_ERR_NOTCOMPILED ERWININTERNALVECTORERRNOTCOMPILED
  /* If some compile time flags prevented compilation of parts a function needs
   * at run-time, this is returned.  Currently only the `V' argument specifier
   * of the format functions return this if the files where compiled with
   * a C compiler instead of a C++ compiler.
   */

  /*
   * The following are warnings only. */
#undef  VECTOR_WARN_OUTOFRANGE
#define VECTOR_WARN_OUTOFRANGE       ERWININTERNALVECTORWARNOUTOFRANGE
  /* If a value is out of range, this warning is returned. */

#undef  VECTOR_WARN_EMTPY
#define VECTOR_WARN_EMPTY            ERWININTERNALVECTORWARNEMPTY
  /* v_char_fgets returns this if EOF was reached and no character could be
   * read anymore. */

#if V_CHAR_SMALL_SIZE
/* Size: 16 bit, index:32 bits.  if possible. */
   /* We should use 'int' in the API here, but this requires assert()s
    * due to different sizes, which are not yet implemented.
    *
    * Anyway, since there are not enough overflow checks for the other
    * settings either, we allow this to be used...
    */

   /* 16 bit sizes are large enough. */
   /* The index type is always 'int'. */

#  ifndef V_CHAR_PREALLOC_SIZE
#    define V_CHAR_PREALLOC_SIZE  (16*1024)
#  endif
#  ifndef V_CHAR_CHUNK_SIZE
#    define V_CHAR_CHUNK_SIZE      (4*1024)
#  endif
#  if SIZEOF_INT == 2
     /* Prefer 'int' over 'short'. */
     typedef unsigned int v_char_size_t;
     typedef int          v_char_index_t;
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define V_CHAR_SIZE_INDEX_DIFF 0
#  elif SIZEOF_SHORT == 2
     typedef unsigned short v_char_size_t;
     typedef int            v_char_index_t;  /* 'int' in API, not 'short' */
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_SHORT)
#    define V_CHAR_SIZE_INDEX_DIFF 1
#  else
     /* Hmm?  Strange.  Just use int. */
     typedef unsigned int v_char_size_t;
     typedef int          v_char_index_t;
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define V_CHAR_SIZE_INDEX_DIFF 0
#  endif

#elif V_CHAR_MEDIUM_SIZE

   /* Try 32 bit sizes, do not use 64 bits if avoidable. */
   /* The index type is always 'int'. */

#  ifndef V_CHAR_PREALLOC_SIZE
#    define V_CHAR_PREALLOC_SIZE   (8*1024)
#  endif
#  ifndef V_CHAR_CHUNK_SIZE
#    define V_CHAR_CHUNK_SIZE      (128*1024)
#  endif

#  if SIZEOF_INT == 4
     /* Prefer 'int' over 'short'. */
     typedef unsigned int v_char_size_t;
     typedef int          v_char_index_t;
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define V_CHAR_SIZE_INDEX_DIFF 0
#  elif SIZEOF_LONG == 4 && SIZEOF_INT > SIZEOF_LONG
     typedef unsigned long v_char_size_t;
     typedef int           v_char_index_t;
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_LONG)
#    define V_CHAR_SIZE_INDEX_DIFF 1
#  elif SIZEOF_SHORT == 4
     typedef unsigned short v_char_size_t;
     typedef int            v_char_index_t;
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_SHORT)
#    define V_CHAR_SIZE_INDEX_DIFF 0
#  else
     /* Hmm? Just use int. */
     typedef unsigned int v_char_size_t;
     typedef int          v_char_index_t;
#    define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#    define V_CHAR_SIZE_INDEX_DIFF 0
#  endif

#elif V_CHAR_LARGE_INDEX

   /* Full size_t support (e.g. >= 2G entries on 64 bit). */
   /* The size and index are both '(s)size_t'.
    * This is a different API: we do not have an 'int' index. */
#  ifndef V_CHAR_PREALLOC_SIZE
#    define V_CHAR_PREALLOC_SIZE   (16*1024)
#  endif
#  ifndef V_CHAR_CHUNK_SIZE
#    define V_CHAR_CHUNK_SIZE      (256*1024)
#  endif
   typedef size_t  v_char_size_t;
   typedef ssize_t v_char_index_t;
#  define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_SIZE_T)
#  define V_CHAR_SIZE_INDEX_DIFF 0

#else

   /* By default, vectors work with 'int' as index type. */
#  ifndef V_CHAR_PREALLOC_SIZE
#    define V_CHAR_PREALLOC_SIZE   (8*1024*1024)
#  endif
#  ifndef V_CHAR_CHUNK_SIZE
#    define V_CHAR_CHUNK_SIZE      (128*1024)
#  endif
   typedef unsigned int   v_char_size_t;
   typedef int            v_char_index_t;
#  define V_CHAR_MAY_BE_INVALID  (SIZEOF_VOIDP > SIZEOF_INT)
#  define V_CHAR_SIZE_INDEX_DIFF 0

#endif


typedef v_char_index_t v_char_cnt_t;
   /* index is always the same as cnt, it just marks a different usage */

#define v_char_char_t char

typedef char v_char_value_t;


typedef int (*v_char_cmp_t) (char const *, char const *);

typedef ERWIN_BOOL (*v_char_feature_t)(char );

#ifndef V_CHAR_MAP_T_DEFINED
#define V_CHAR_MAP_T_DEFINED
/* In order to have char  as a result type for v_char_map_t, declare that
 * function yourself and define V_CHAR_MAP_T_DEFINED.
 */
typedef char (*v_char_map_t)(char );
#endif
#define V_CHAR_CMP_T_NULL ((v_char_cmp_t)NULL)

#ifdef __cplusplus
typedef bool (*v_char_cpp_feature_t)(char );
#endif /* defined __cplusplus */

typedef char *v_char_element_ptr_t;
#ifdef __cplusplus
typedef char &v_char_element_ref_t;
#endif /* defined __cplusplus */

typedef int  (*v_char_combine_t) (v_char_element_ptr_t, char const *);
#define V_CHAR_COMBINE_T_NULL ((v_char_combine_t)NULL)

#define V_CHAR_STRING_LIT(X) X
#define v_char_tchar_strlen(X) ((X) == NULL ? 0 : strlen(X))
     /* For wchar_t, we'll have to change this */

/*
 * For user defined quotation methods */
typedef struct _v_char_quotation_method_t {
    /* This class is used for customising formatting.
     * The library supports several standard quotations
     * like C strings or Lisp, Shell, etc.  You may
     * want to define your own syntax by implementing
     * a few functions here and using
     * v_char_set_quotation_method() to define your style.
     */

    char const *prefix;
    /* The prefix to print in front of a quoted string.
     * NULL means empty.
     * E.g. for C, this is |"\""|.
     */

    char const *suffix;
    /* The suffix to print in front of a quoted string.
     * NULL means empty.
     *
     * E.g. for C, this is |"\""|.
     */

    char const *null_name;
    /* The string to use for quoted output if the string to
     * print is NULL.  (No prefix or suffix will be used in
     * this case)
     *
     * E.g. for C, this is "NULL" and for Lisp, this is "nil".
     *
     * If this is NULL, an out of range error is generated when the
     * NULL string is encountered to be quoted.
     */

    char const *empty_name;
    /* If this is != NULL, the empty string is exceptionally represent this way.
     *
     * Similar to null_name, but this handles the empty string.  E.g. in Unxi Shell
     * syntax quotation, which is currently implemented to not print string
     * delimiters, the empty string would in normal printing result in just that:
     * the empty string.  But that's wrong, so this member has the value "''" for
     * Shell quotation.
     *
     * If this is NULL, the string is normally printed using the other fields
     * and functions of this struct.
     */

    int  (*needs_quotation)(char const *);
    /* A function that decides whether a string needs quotations.
     * You can either implement your own checks, or simply return
     * a value of 2 to let the library check each character for
     * quotation.
     *
     * Results:
     *     [0]  no, no quotation
     *     [1]  yes, quotation
     *     [2]  decide by checking results of the quoted_length function.
     *          If for some char it returns != 1, it needs quotation.
     *     [3]  yes, quote, but leave out prefix and suffix.
     *     [4]  Always quote, but decide whether the prefix and suffix
     *          are used by checking the results of the quoted_length
     *          function.  If it is != 1 for some character, use them,
     *          otherwise leave them away.
     *
     * If the function pointer is NULL, this means to never quote.
     */

    int  (*quoted_length)(int /* previous_quotation_length */, char /* tobequoted */);
    /* For checking individually whether to quote or not for each character:
     *
     * NULL means: literal length 1 (no quotation)
     *
     * The integer given to this function is the output of this function for the
     * previous characters.  The function can then decide whether and how to quote
     * depending on the previous value.  Initially, -1 is given.
     * If this function returns a negative value, its absolute value is taked as
     * the quoted string's length.  This is useful for indicating that a string
     * needs quotation even if the current character's quoted length is 1.
     */

    void (*quote)(char * /* destination */, char /* tobequoted */, int /* length */);
    /* The actual implementation of a quotation of one character.
     *
     * NULL means: no quotation
     *
     * This function must write exactly length non-null characters.  No null
     * character may follow (use memcpy instead of strcpy!)
     * The length argument is the output of the quoted_length function.
     */

    void (*check_quote)(char * /* destination */, int /* length */);
    /* Check that the quotation has worked and eventually fix it so
     * that it is properly quoted.  The string passed is not
     * null-terminated, but instead the length is given.
     *
     * This function pointer may be NULL: in that case it is not invoked.
     *
     * NOTE: This function must not change the length of the string!
     *
     * E.g. this function is used for the Windows shell quotation method to
     *      swap the last two characters if they are \".  This is necessary because
     *      the quotation method is really weird (the backslash has two meanings):
     *
     *      +----------+-------------+---------------------+
     *      |! Before  |! Quoted     |                     |
     *      |  B\C D   | "B\C D"     |                     |
     *      |  B\"C D  | "B\\"C D"   |                     |
     *      |  B\"C D\ | "B\\"C D"\  | *not* "B\\"C D\"    |
     *      +----------+-------------+---------------------+
     *
     *      The last one cannot be "B\\"C D\" since a backslash before a double quote
     *      is interpreted as a quoted double quote.  This is prevented by the
     *      check_quote function.
     *
     */
} v_char_quotation_method_t;

typedef struct _v_char_format_info_t {
    /* This class is used to store information after a
     * v_char_format() or the like has printed some string
     * into a vector.
     */

    ERWIN_BOOL quoted;
     /* Whether the last %s in the format string was quoted. */

    v_char_cnt_t  pos;
     /* How many characters from the given string were read by the last %s in
      * the format string. */

#ifdef __cplusplus
    _v_char_format_info_t ():
        quoted (0),
        pos (0)
    {}
#endif /* defined __cplusplus */
} v_char_format_info_t;


/*
 * ***** handling `vector' objects: ***** */
/*--BEGIN-C--*/

ERWIN_EXPORT
v_char_t *v_char_new (void) ATTR_MALLOC;
   /* Create a new vector with default values.   I.e., with the
   * default zero element V_CHAR_ZERO and the default initial hash table
   * size of V_CHAR_INITIAL_SIZE.
   *
   */


#if V_CHAR_DYN_ZERO
ERWIN_EXPORT
v_char_t *v_char_new_with_zero (char  /*zero*/) ATTR_MALLOC;
  /* Create a vector specifying the zero element. */


ERWIN_EXPORT
v_char_t *v_char_new_with_zero_and_initial_size (
    char  /*zero*/, v_char_cnt_t /*initial_size*/) ATTR_MALLOC;
  /* Create a new, empty vector.  The first form uses char_zero as the zero element.
   *
   * - If \p initial_size < 0:
   *   the default size V_CHAR_INITIAL_SIZE will be used.
   *
   * - If \p initial_size == 0 but V_CHAR_MINIMAL_SIZE > 0:
   *    a size of 1 will be used.
   *
   * Note: The vector always has size==0 even if \p initial_size > 0.  This
   *       initial size is the size of the data structure used.
   *       The vector does not resize it until the
   *       vector becomes larger than that.
   */
#endif

ERWIN_EXPORT
v_char_t *v_char_new_with_initial_size (v_char_cnt_t /*initial_size*/) ATTR_MALLOC;
  /* Initialise with a given table size.  See v_char_new_with_zero_and_initial_size.
   */

ERWIN_EXPORT
v_char_t *v_char_new_from_raw (
    char * /*contents*/, v_char_cnt_t /*nentries*/, v_char_cnt_t /*allocsize*/) ATTR_MALLOC;
  /* This makes a vector from contents.   It 'steals' the pointer and makes it its
   * internal vector table.  It is assumed that we can (re/de)allocate the contents
   * using the normal ERWIN_TMALLOC/REALLOC/CMALLOC/FREE mechanism.
   *
   * Initial_size is the amount of memory that is allocated.  You can safely pass less
   * than nentries, meaning we should assume that there are only nentries allocated
   * cells (this is safe behaviour).  If you know the amount that is allocated, you
   * should pass it to this function to improve performance by preventing unnecessary
   * reallocations.
   *
   * If you want to *copy* contents into a vector, use _new_with_initial_size
   * and _append_raw instead.
   *
   * If contents is NULL or allocsize is 0, then we invoke new_with_initial_size
   * instead, so whether you get a vector that has no allocated table
   * at all depends on the setting of V_CHAR_ZERO_SIZE.  By default, table with
   * V_CHAR_INITIAL_SIZE will be allocated.
   *
   * If allocsize is non-zero, V_CHAR_MINIMAL_SIZE is ignored (as with the
   * constructors that contain _with_initial_size), so you may allocate smaller
   * vectors.  (A size of 0, however, is special, see previous paragraph.)
   */

#if V_CHAR_DYN_ZERO

ERWIN_EXPORT
v_char_t *v_char_new_from_raw_with_zero (
    char   * /*contents*/,
    v_char_cnt_t /*nentries*/,
    v_char_cnt_t /*allocsize*/,
    char  /*zero*/) ATTR_MALLOC;
  /* Same as before but with a given zero element. */

#endif

ERWIN_EXPORT
v_char_t *v_char_new_from_vector (v_char_t * /*other*/) ATTR_MALLOC;
  /* This might be strange: it makes a new vector from the contents of the other
   * vector and then detaches the data from the other vector.  Its purpose is
   * mainly useful in C++ where you can clone vectors from a static vector
   * by this means.  E.g.:
   *
   *   :  VChar a;
   *   :  ...
   *   :  return v_char_new_from_vector (a);
   *
   * Or with the same effect, but without the need to use a long functions name:
   *     return a.copy_detach();
   *
   * A related thing is v_char_xchg(), because the above is also roughly
   * equivalent to:
   *   : v_char_t a;
   *   : ...
   *   : v_char_t *b= v_char_new();
   *   : v_char_xchg(&a, b);
   *   : return b;
   */

ERWIN_EXPORT
int v_char_init (v_char_t * /*self*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap v_char_t objects that are allocated
   * manually (thus, not via v_char_new).
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

#if V_CHAR_DYN_ZERO
ERWIN_EXPORT
int v_char_init_with_zero_and_initial_size (
    v_char_t * /*self*/,
    char  /*zero*/,
    v_char_cnt_t /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap v_char_t objects that are allocated
   * manually (thus, not via v_char_new).
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */
#endif

ERWIN_EXPORT
int v_char_init_with_initial_size (
    v_char_t * /*self*/,
    v_char_cnt_t /*initial_size*/) ATTR_NONNULL((1));
  /*
   * This is for initialising non-heap v_char_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK, ERR_NOMEM)
   */

ERWIN_EXPORT
void v_char_destroy (v_char_t * /*self*/);
  /*
   * This is for deleting non-heap v_char_t objects.
   *
   * Invoking this function manually is usually discouraged.  It is thought
   * to be for nesting data structures.  However, if you need to optimise
   * heap usage, it is ok to use this function.
   *
   * \errno(OK)
   */

ERWIN_EXPORT
void v_char_xchg (v_char_t * /*self*/, v_char_t * /*other*/);
  /*
   * Exchanges the two vectors' contents.  No memory allocation is
   * performed; this is a fast O(1) operation for swapping two values.
   */

#if !ERWIN_GLOBAL_ERRNO
ERWIN_EXPORT
int v_char_errno(v_char_t const *) ATTR_PURE ATTR_NONNULL((1));
  /* If you compiled Erwin with ERWIN_THREAD_SAFE, this is the way
   * to get the status code of a given vector.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \noerrno
   */

ERWIN_EXPORT
void v_char_clear_errno(v_char_t const * /*self*/) ATTR_NONNULL((1));
  /* If you compiled Erwin with ERWIN_THREAD_SAFE, this is the way
   * to get the status code of a given vector.
   *
   * If you do not
   * have a thread-safe Erwin library, there is a macro with the same name as
   * this function.
   *
   * \errno(OK)
   */

#else

#define v_char_errno(X) vector_errno
  /* If you compiled Erwin without ERWIN_THREAD_SAFE, v_char_errno
   * is just a synonym for vector_errno.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \noerrno
   */

#define v_char_clear_errno(X)    ((void)(map_errno= MAP_OK))
  /* If the library was not compiled with ERWIN_THREAD_SAFE, v_char_clear_errno(X)
   * is a small macro that resets the status code to VECTOR_OK.
   *
   * If you
   * have a thread-safe Erwin library, there is a function with the same name as
   * this macro.
   *
   * \errno(OK)
   */
#endif


ERWIN_EXPORT
v_char_t *v_char_copy (v_char_t const* /*self*/);
  /* Copies a vector with all its elements and returns that copy.
   */

ERWIN_EXPORT
v_char_t *v_char_copy_err (v_char_t const* /*self*/, int * /*err*/);
  /* Like v_char_copy but sets *\p err to 1 on failure.
   */

ERWIN_EXPORT
int v_char_insert_subvector (
    v_char_t *        /*self*/,
    v_char_index_t    /*start_index_self*/,
    v_char_t const*   /*other*/,
    v_char_index_t    /*start_index_other*/,
    v_char_cnt_t      /*size*/,
    ERWIN_BOOL /*docopy*/);
  /* Inserts a portion of a vector into another one. If \p size is < 0, it defines
   * the last element to enter. -1 therefore means: the rest of the vector starting
   * at \p start_index
   *
   * Returns its success.
   */

ERWIN_EXPORT
v_char_t *v_char_subvector (
    v_char_t const* /*self*/,
    v_char_index_t /*start_index*/,
    v_char_cnt_t /*size*/,
    ERWIN_BOOL /*docopy*/);
  /* Copies only a portion of the vector. The semantics of the parameters is like in
   * v_char_insert_subvector. */

ERWIN_EXPORT
void v_char_delete (v_char_t* /*self*/);
  /* Deletes everything in the vector and the vector structure itself.
   * v_char_delete is NULL safe (\p self may be NULL without crash or failed
   * assertion).
   */

ERWIN_EXPORT
void v_char_detach (v_char_t* /*self*/);
  /* Clears the vector by initialising a new completely empty
   * table not consuming any memory.  The effect is mainly that
   * you can use the value of v_char_as_array and v_char_as_open_array
   * independently from the vector.  The old function
   * delete_flat is now a sequence of detach() and delete().
   *
   * Note: This function should be used when the vector is not
   *       needed anymore after a cast to a raw array (e.g. by
   *       v_char_as_array).
   *
   * Compare this function with v_char_detach_as_is().  These functions
   * are important to distinguish if you defined CHAR_UPDATE_POS.
   *
   * Note: use v_char_delete_array() to deallocate the memory if you retrieve
   *       it with, say, v_char_as_open_array().
   *
   * Note: See the documentation of v_char_delete_array and v_char INLINE_STORE!
   */

ERWIN_EXPORT
void v_char_delete_array (v_char_element_ptr_t /*array*/);
  /* If you extract the vector contents e.g. with v_char_as_array(), then
   * detach a vector to free its contents later, use this function for
   * freeing.  If the memory management is left with its default settings,
   * this is a simple free() (or delete[] if you compiled for C++ only).
   * But to be sure to use the right deallocator in more complex cases,
   * please prefer to use this function.
   *
   * Note: With V_CHAR_INLINE_STORE, you *must only* invoke v_char_delete_array
   *       on arrays obtained with v_char_as_array_detach() or
   *       v_char_as_open_array_detach().  You *must not* invoke it
   *       on arrays obtained with v_char_as_array() or v_char_as_open_array()
   *       because these functions may return a pointer to an inlined array,
   *       causing a SIGSEGV in v_char_delete_array().
   */

ERWIN_EXPORT
void v_char_detach_as_is (v_char_t* /*self*/);
   /* Like v_char_detach_as_is(), but does not invoke CHAR_UPDATE_POS
    * for all elements to set them to -1.
    *
    * This function is only different from v_char_detach if you defined
    * CHAR_UPDATE_POS.  Otherwise, it is the same.
    */

ERWIN_EXPORT
int v_char_append (v_char_t* /*self*/, char  /*value*/);
  /* Appends one elements, namely \p value, to the end of the vector.
   *
   * Returns its success.
   */

ERWIN_EXPORT
char  v_char_zero (v_char_t const * /* self */) ATTR_PURE;
  /* Returns the zero element of this vector.  This need not be the same
   * for all vectors (you can specify it with v_char_new_with_zero) unless
   * you defined V_CHAR_CONSTANT_ZERO.
   */

/*BEGIN:IGNORE*/
#if defined(ERWIN_COMPILING) || V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK || V_CHAR_INLINE_STORE
/*END:IGNORE*/

ERWIN_EXPORT
char  v_char_nth (v_char_t const* /*self*/, v_char_index_t /*index*/) ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element on failure.
   * If \p index is out of range, a message is also output to
   * stderr if you defined ERWIN_VERBOSE.
   */

/*BEGIN:IGNORE*/
#else
#define V_CHAR_INLINE__NTH
#endif
/*END:IGNORE*/

ERWIN_EXPORT
char  v_char_nth_char (v_char_t const* /*self*/, v_char_index_t /*index*/) ATTR_ERRNO_PURE;
  /* Returns the found element or the zero element on failure.
   *
   * If you access the element just after the end of the vector, then
   * that is regarded legal in this function and the zero element is
   * returned.
   *
   * If \p index is out of range, a message is also output to
   * stderr if you defined ERWIN_VERBOSE.
   *
   * Dev.Note: this is pure: cmp to v_char_nth_char_ptr and see v_char_as_array().
   */

ERWIN_EXPORT
char  v_char_first (v_char_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns the first element of the vector.
   * This is the same as
   *   : v_char_nth (self, 0)
   */

ERWIN_EXPORT
char  v_char_last (v_char_t const* /*self*/) ATTR_ERRNO_PURE;
  /* Returns the last element of the vector
   *
   * This is the same as
   *   : v_char_nth (self, v_char_nentries (self) - 1)
   */


ERWIN_EXPORT
char v_char_modify (
    v_char_t* /*self*/, v_char_index_t /*index*/, char  /*newvalue*/) ATTR_NONNULL((1));
  /* Returns the old value and inserts the new one at \p index.
   *
   * Nothing is freed, \p newvalue is copied if CHAR_OCOPY is #defined.
   */


ERWIN_EXPORT
int v_char_set (
    v_char_t* /*self*/, v_char_index_t /*index*/, char  /*newvalue*/) ATTR_NONNULL((1));
  /* Like v_char_modify, but the old value is freed using CHAR_OFREE instead
   * of being returned.
   *
   * Returns its success.
   */

ERWIN_EXPORT
void v_char_swap (
    v_char_t * /*self*/, v_char_index_t /*index1*/, v_char_index_t /*index2*/) ATTR_NONNULL((1));
  /* Because using set or modify to implement swapping of two elements involves
   * freeing and copying elements, this functions provides a way to swap
   * elements without that overhead.
   */

ERWIN_EXPORT
v_char_element_ptr_t v_char_nth_ptr (
    v_char_t * /*self*/, v_char_index_t /*index*/) ATTR_NONNULL((1));
  /* Returns a pointer to the element at \p index or NULL if \p index is out of
   * range.
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

/* Like v_char_nth_ptr, but constant in input and output type.
 *
 * Does not output anything to stderr even if you define ERWIN_VERBOSE.
 *
 * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
 */
ERWIN_STATIC_INLINE
char const *v_char_nth_ptr_const (v_char_t const * self, v_char_index_t idx);

ERWIN_STATIC_INLINE
char const *v_char_nth_ptr_const (v_char_t const * self, v_char_index_t idx)
{
    return v_char_nth_ptr ((v_char_t *)self, idx);
}

ERWIN_EXPORT
v_char_element_ptr_t v_char_nth_ptr_check (v_char_t * /*self*/, v_char_index_t /*index*/);
  /* Returns a pointer to the element at \p index or an signals an error if
   * the \p index is out of range.  (This is the same behaviour towards errors
   * as v_char_nth has)
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

/* Like v_char_nth_ptr_check, but constant in input and output type.
 *
 * Does not output anything to stderr even if you define ERWIN_VERBOSE.
 *
 * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
 */
ERWIN_STATIC_INLINE
char const *v_char_nth_ptr_check_const (v_char_t const * self, v_char_index_t idx);

ERWIN_STATIC_INLINE
char const *v_char_nth_ptr_check_const (v_char_t const * self, v_char_index_t idx)
{
    return v_char_nth_ptr_check ((v_char_t *)self, idx);
}

ERWIN_EXPORT
v_char_element_ptr_t v_char_nth_ptr_char (
    v_char_t * /*self*/, v_char_index_t /*index*/) ATTR_NONNULL((1));
  /* Returns a pointer to the element at \p index if it is in range.
   * If is is one too large, returns a pointer to the element after the end,
   * mimicking string behaviour.  That element is guaranteed to be allocated,
   * of couse.  If you write to that element, it only is guarateed to have
   * any effect up to the next change to the vector size.  Don't change that
   * element, though.
   *
   * Because this function is so similar to adding an integer to a 'char const *',
   * i.e., to get a suffix string, this function always zero-terminates the
   * vector like v_char_as_array() does.  So v_char_nth_ptr_char(self,0) is
   * equivalent to v_char_as_array().
   *
   * NOTE: This behaves a bit strange together with ALLOW_OUTOFRANGE:
   *    Accesses  to any element starting from a[nentries()]  make the vector
   *    larger for the non-const version!  This includes the nentries()th
   *    element, which, even if only read with this function, enlarges the
   *    vector due to the potential threat of the user writing to it.
   *
   * In case ALLOW_OUTOFRANGE is off, this never makes the vector larger,
   * but does allow access to nentries()th element.  That element is always
   * ensured to be ZERO, however, so you cannot write to it.
   *
   * This signals an error if the \p index is out of range.
   * (This is the some behaviour towards errors as v_char_nth_char has.)
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure, see v_char_as_array().
   */

/* Like v_char_nth_ptr_char, but constant in input and output type.
 *
 * Note that despite the 'const', this zero-terminates the vector just like
 * v_char_nth_ptr_char() and v_char_as_array().
 *
 * Does not output anything to stderr even if you define ERWIN_VERBOSE.
 */
ERWIN_STATIC_INLINE
char const *v_char_nth_ptr_char_const (v_char_t const * self, v_char_index_t idx);

ERWIN_STATIC_INLINE
char const *v_char_nth_ptr_char_const (v_char_t const * self, v_char_index_t idx)
{
    return v_char_nth_ptr_char ((v_char_t *)self, idx);
}

ERWIN_EXPORT
v_char_element_ptr_t v_char_first_ptr (v_char_t * /*self*/) ATTR_NONNULL((1));
  /* Returns a pointer to the element at index 0 or NULL if the vector is empty.
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

ERWIN_EXPORT
v_char_element_ptr_t v_char_last_ptr (v_char_t * /*self*/) ATTR_NONNULL((1));
  /* Returns a pointer to the last element or NULL if the vector is empty.
   *
   * Does not output anything to stderr even if you define ERWIN_VERBOSE.
   *
   * Dev.Note: not pure with ALLOW_OUTOFRANGE option.
   */

ERWIN_EXPORT
void v_char_reverse (v_char_t * /*self*/);
   /* Reverses the order of all elements in the vector.
    *
    * See v_char_swap, too, which is vaguely related.
    */

ERWIN_EXPORT
int v_char_erase (v_char_t* /*self*/, v_char_index_t /*index*/, v_char_cnt_t /*number_of_elements*/);
  /* The values erased from the the vector are freed.  If \p number_of_elements
   * is negative, the end of the vector is cut off.  If \p index or
   * \p number_of_elements are out of range, they are adjusted appropriately.
   *
   * E.g.:
   *  - if index == -2 and count == 5:
   *       then elements 0,1,2 are erased,
   *
   *  - if index >= nentries:
   *       nothing is erased,
   *
   *  - if index + count >= nentries:
   *      only the tail of the vector is erased.
   *      However, all this is only done if V_CHAR_ALLOW_OUTOFRANGE is true.
   *      Otherwise, you'll get an assertion failure in all these cases,
   *      because index or count are out of range.
   *
   *  - if count < 0:
   *     then count is adjusted to nelements - index, e.g.
   *     index == 2, count = -1 will cut off the last two elements of
   *     the vector.
   *     (The absolute value of count is not considered here, only the fact
   *     that it is < 0).  This adjustment always happens, i.e., even if
   *     V_CHAR_ALLOW_OUTOFRANGE is false.
   *
   * Returns its success.
   *
   * Reference: v_char_erase_flags, v_char_swap_erase
   */

ERWIN_EXPORT
int v_char_erase_flags (
                v_char_t* /* self */,
                v_char_index_t       /* index */,
                v_char_cnt_t       /* number_of_elements_to_delete */,
                ERWIN_BOOL      /* resize */,
                ERWIN_BOOL      /* delete_elems */);
  /* Like v_char_erase but you can specify whether
   *   - the vector should be re-allocated by \p resize
   *   - elements should be freed by \p delete_elems.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_swap_erase (
    v_char_t* /*self*/, v_char_index_t /*index*/, v_char_cnt_t /*number_of_elements*/);
  /* This is similar to v_char_erase, but instead of shifting all elements after
   * the ones erased, this functions copies elements from the end of the vector
   * into the gap.  This is faster if \p number_of_elements is small.
   * The order of the copied elements is reversed.
   *
   * Example:
   *
   * v_char= [0 1 2 3 4 5 6 7 8 9]
   *    : v_char.swap_erase(2,3)  // erases elements 2,3,4 by overwriting with 9,8,7
   * v_char= [0 1 9 8 7 5 6]
   *
   * There are more interesting cases, too:
   *
   * v_char= [0 1 2 3 4 5 6 7 8 9]
   *    : v_char.swap_erase(4,4)  // erases elements 4,5,6,7 by overwriting with 9,8
   * v_char= [0 1 2 3 9 8]
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_swap_erase_flags (
    v_char_t*          /* self */,
    v_char_index_t     /* index */,
    v_char_cnt_t       /* number_of_elements_to_delete */,
    ERWIN_BOOL  /* resize */,
    ERWIN_BOOL  /* delete_elems */);
  /* Like v_char_swap_erase but you can specify whether
   *   a) the vector should be re-allocated by \p resize
   *   b) elements should be freed by \p delete_elems.
   *
   * Returns its success.
   */

ERWIN_EXPORT
v_char_cnt_t v_char_erase_if (
    v_char_t* /*self*/, v_char_feature_t /* feature */, ERWIN_BOOL /*value*/);
  /* Erases those elements that satisfy \p feature.  You can specify which
   * value \p feature must return for the element in order to trigger that
   * deletion.  So if \p value is ERWIN_FALSE, the feature described
   * by \p feature is negated.
   *
   * The values erased from the vector are freed using CHAR_OFREE.
   *
   * Returns the number of elements cut out of the vector.
   *
   * Note: In CommonLisp, this is called |remove-if|.
   */

ERWIN_EXPORT
v_char_cnt_t v_char_erase_equals (v_char_t* /*self*/, v_char_cmp_t /*cmp*/, v_char_combine_t /*combine*/);
  /* Erases the second of two adjacent elements that is equal (wrt. the
   * given function) to the first.  This is repeated recursively so that
   * groups of adjacent equal elements are reduced to one element.
   *
   * Before erasing, the function calls back combine to let the user
   * adjust things (e.g. copy something from the moribund entry to
   * the surviving one).
   *
   * The default cmp function, used if cmp is NULL, is CHAR_CMP.
   *
   * In a sorted vector, this procedure erases all equal elements.
   *
   * The values erased from the vector are freed using CHAR_OFREE.
   *
   * The number of erased elements is returned.
   */

ERWIN_EXPORT
v_char_cnt_t v_char_erase_zero (v_char_t* /*self*/);
  /* Specialised version of v_char_erase_if: deletes zero elements. */

ERWIN_EXPORT
v_char_cnt_t v_char_erase_if_flags (
        v_char_t* /*self*/,
        v_char_feature_t /* feature */,
        ERWIN_BOOL /*value*/,
        ERWIN_BOOL /*resize*/,
        ERWIN_BOOL /*dealloc*/);
  /* Additional to v_char_erase_if, you can specify whether to resize the
   * vector or whether to deallocate the elements that are cut out.
   *
   * Returns the number of elements cut out of the vector.
   */


ERWIN_EXPORT
void v_char_make_heap(v_char_t * /*self*/, v_char_cmp_t /*cmp*/);
  /* This makes a heap.  The first element of the vector will then
   * be the maximum (according to the given compare function).
   * The others will have the Heap Property:
   *
   * : \forall i \in { 0,..,nentries-1 }:
   * :    nth (floor ((i-1) / 2)) >= nth(i)
   *
   * The operation takes O(n log n) time.
   *
   * This is the heap property graphically:
   *   :     0      n[father(i)] >= n[i], whether father(i) = floor ((i-1) / 2)
   *   :   1   2
   *   :  3 4 5 6   // Note that the indeces in our vectors are just the
   *   :            // other way around to
   *
   * As a special case, a vector that is sorted in reverse order is a heap.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * NOTE:
   * The implementation used here has no dedicated heap_size entry.
   * The heap is always as large as the whole vector.
   *
   * This function checks itself when in debug mode, causing assertion failures
   * if the heap property is violated after operation.
   */

ERWIN_EXPORT
v_char_index_t v_char_heap_left(v_char_t const * /*self*/, v_char_index_t /*i*/) ATTR_PURE;
   /* Returns the index of the left child of i in a heap structure.
    * The index i must be a valid index of the vector.
    * Returns something < 0 if there is no such child of i.
    * The left index is guaranteed to be < than the right index.
    *
    * The operation takes O(1) time.
    */

ERWIN_EXPORT
v_char_index_t v_char_heap_right (v_char_t const * /*self*/, v_char_index_t /*i*/) ATTR_PURE;
   /* Returns the index of the left child of i in a heap structure.
    * The index i must be a valid index of the vector.
    * Returns something < 0 if there is no such child of i.
    * The right index is guaranteed to be > than the left index.
    *
    * The operation takes O(1) time.
    */

ERWIN_EXPORT
v_char_index_t v_char_heap_father (v_char_t const * /*self*/, v_char_index_t /*i*/) ATTR_PURE;
   /* Returns the index of the left child of i in a heap structure.
    * The index i must be a valid index of the vector.
    * Returns something < 0 if i does not have a father, i.e., if i == 0.
    *
    * The operation takes O(1) time.
    */

ERWIN_EXPORT
char v_char_heap_extract (v_char_t * /*self*/, v_char_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* This extracts the maximum from the heap, returns it, shrinks the
   * vector, and re-heapifies it.  See v_char_make_heap()
   * and v_char_heap_sink().  You may only invoke this for vectors that
   * have the heap property and have at least one element.
   *
   * The operation takes O(log n) time, since it reinvokes v_char_heap_sink.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * This function checks the input and itself when in debug mode, causing
   * assertion failures if the heap property is violated.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *   : #define V_CHAR_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors)
   *   : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   *
   * Note: this returns char instead of char  (if these are different),
   * because the element is removed, so no reference can be returned.
   */

ERWIN_EXPORT
void v_char_heap_raise (
    v_char_t * /*self*/, v_char_index_t /*i*/, v_char_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* The operation checks for element i whether its priority has increased.
   * it so, the heap property is re-established.
   *
   * The operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * This function checks itself when in debug mode, causing
   * assertion failures if the heap property is violated after operation.
   * Such an assertion failure may also mean that the vector was no
   * heap (apart from the element i) before this operation.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *   : #define V_CHAR_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors)
   *   : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   */

ERWIN_EXPORT
void v_char_heap_sink (
    v_char_t * /*self*/, v_char_index_t /*i*/, v_char_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* The opposite of v_char_heap_raise: it checks whether the value of i
   * has decresed and if so, re-establishes the heap property.
   *
   * This operation is often called 'heapify'.  Because it is related to
   * heap_raise by being its opposite, we'll call it heap_sink here.
   *
   * The operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * See v_char_heap_raise() for more info.
   *
   * Note that this function does not do debug checks of the heap property,
   * because it may be used to construct a heap, so one of its purposes is to
   * be invoked on heaps.  We might add a check for a partial heap property
   * later, though.
   */

ERWIN_EXPORT
void v_char_heap_fix (
    v_char_t * /*self*/, v_char_index_t /*i*/, v_char_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* Fix the position of element at index i according to its new priority.
   *
   * The operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * This is an abbreviation for:
   *    : v_char_heap_raise (self, i, cmp);
   *    : v_char_heap_sink  (self, i, cmp);
   */

ERWIN_EXPORT
int v_char_heap_insert (
    v_char_t * /*self*/, char  /*elem*/, v_char_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* This function inserts an element into a heap and re-establishes the
   * heap property.
   *
   * This operation is an abbreviation for:
   *    : v_char_append (self, elem);
   *    : v_char_heap_increase (self, v_char_nentries(s) - 1, cmp);
   *
   * Thus the operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * The success is returned.
   *
   * This function checks the input (and itself indirectly via v_char_heap_raise) when
   * in debug mode, causing assertion failures if the heap property is violated.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *    : #define V_CHAR_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors):
   *    : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   */

ERWIN_EXPORT
void v_char_heap_erase (
    v_char_t * /*self*/, v_char_index_t /*i*/, v_char_cmp_t /*cmp*/) ATTR_NONNULL((1));
  /* This function deletes an element from the heap and re-establishes the
   * heap property.
   *
   * This operation is an abbreviation for:
   *    : v_char_swap (self, i, v_char_nentries(s) - 1);
   *    : v_char_chop (self, 1);
   *    : v_char_heap_sink (self, i, cmp);
   *
   * Thus the operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
   *
   * The success is returned.
   *
   * This function checks the input (and itself indirectly via v_char_heap_raise) when
   * in debug mode, causing assertion failures if the heap property is violated.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *   : #define V_CHAR_DEBUG_EXPENSIVE_CHECKS        0
   * or (for all vectors)
   *   : #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0
   */

ERWIN_EXPORT
void v_char_heap_sort (v_char_t * /*self*/, v_char_cmp_t /*cmp*/);
   /* Re-builds the heap structure for the given element.
    * This is one of three sort functions available for vectors:
    *
    *   +------------------+------------+------------+------------+---------+-------------+
    *   |! Function        |! Algorithm |! Typical   |! Worst     |! Space  |!  Stability |
    *   | v_char_qsort     | Quicksort  | O(n log n) | O(n)       | O(1)    | not stable  |
    *   | v_char_heap_sort | Heapsort   | O(n log n) | O(n log n) | O(1)    | not stable  |
    *   | v_char_sort      | Mergesort  | O(n log n) | O(n log n) | O(n)    | stable      |
    *   +------------------+------------+------------+------------+---------+-------------+
    *
    * The default cmp function, used if cmp is NULL, is CHAR_PRIORITY_CMP.
    *
    * NOTE: This uses a different comparison function by default.  Just in case
    *       you defined it (or differently)...
    *
    * FIXME: We should implement bubblesort as well, since it is very fast if
    *        only few elements have changed.
    *
    * The operation takes O(n log n) time.
    */

ERWIN_EXPORT
int v_char_priority_cmp (v_char_t const *, v_char_t const *, v_char_cmp_t /*cmp*/);
    /* Similar to v_char_cmp, with two differences:
     *    - it uses CHAR_PRIORITY_CMP as its default comparison
     *      function
     *    - it uses lexical ordering as its default, unless you define
     *      V_CHAR_PRIORITY_COMPARE_LEXICOGRAPHICALLY to 0.
     *
     * This function is NULL safe.  NULL is smaller than any
     * other vector.
     *
     * If cmp is NULL, CHAR_PRIORITY_CMP will be used.  If that is not
     * defined, an error will occur.
     */

ERWIN_EXPORT
int v_char_chop (v_char_t * /*self*/, v_char_cnt_t /*count*/);
  /* Cuts off the last \p count elements of a vector.
   *
   * This is actually nothing more than an abbreviation for:
   *   : (Assert that count is >= 0)
   *   : v_char_erase(self, v_char_nentries(self)-count, count);
   *
   * This functions generates an assertion failure if the number of
   * elements to chop is greater than the number of elements in the
   * vector.  However, if V_CHAR_ALLOW_OUTOFRANGE is true, then
   * this operation simply clears the vector without assertion failure
   * in this case.
   *
   * Due to the fact that the equivalent using v_char_swap_erase is
   * very trivial: v_char_swap_erase (self, 0, 1), there is no
   * v_char_swap_chop() in C (but in C++, we still have it).
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_chop_flags (
        v_char_t * /* self */,
        v_char_cnt_t        /* count */,
        ERWIN_BOOL       /* resize */,
        ERWIN_BOOL       /* delete_elems */);
  /* Like v_char_chop you can specify the deallocation behaviour.
   *
   * Returns its success.
   */

ERWIN_EXPORT
char v_char_last_chop1 (v_char_t * /*self*/) ATTR_NONNULL((1));
  /* Cuts off the last element of the vector and returns it.
   * Like a pop on a stack.
   */

ERWIN_EXPORT
char v_char_first_swap_chop1 (v_char_t * /*self*/) ATTR_NONNULL((1));
  /* Cuts off the first element of the vector like v_char_swap_erase()
   * and returns it.  This is like v_char_heap_extract() without
   * heap_sink().
   */

ERWIN_EXPORT
int v_char_append_raw (
        v_char_t *    /*self*/,
        char const * /*elements*/,
        v_char_cnt_t  /*count*/) ATTR_NONNULL((1));
  /* Append \p count elements to the end of the vector.
   *
   * This is a frontend to v_char_insert_raw which lets you specify an insertion
   * position.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_append_no_copy (
        v_char_t *       /* self */,
        char const * /* theelements */,
        v_char_cnt_t              /* number_of_elements_to_insert*/) ATTR_NONNULL((1));
  /* Like v_char_append_raw, but the data is not copyied.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_append_vector (
        v_char_t *      /* self */,
        v_char_t const* /* other */) ATTR_NONNULL((1));
  /* Append a whole \p other vector at the end of the vector \p self.
   *
   * This is a frontend to v_char_insert.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_append_string (
        v_char_t*     /*self*/,
        char const * /*theelements*/) ATTR_NONNULL((1));
  /* Like v_char_append_raw, but with a zero-terminated string instead of a
   * number of elements.   The null-termination will *not* be copied.
   *
   * Returns its success.
   */


ERWIN_EXPORT
int v_char_make_gap (
        v_char_t*      /*self*/,
        v_char_index_t /* start_index*/,
        v_char_cnt_t   /* count */);
  /* Inserts \p count zero elements into the vector at position \p start_index.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_make_gap_with (
        v_char_t*       /*self*/,
        v_char_index_t  /* start_index*/,
        char     /* elem */,
        v_char_cnt_t    /* count */);
  /* Like v_char_make_gap but with a given value (which is copied for
   * each entry if necessary.
   */


ERWIN_EXPORT
int v_char_overwrite_raw (
    v_char_t*     /* self*/,
    v_char_index_t           /* start_index_in_self */,
    char const * /* newdata*/,
    v_char_cnt_t           /* count */);
  /* Overwrites portions of the vector from a normal array.
   * The overwritten data is freed using CHAR_OFREE in the old vector and
   * the new data copied from the new data array using CHAR_OCOPY.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_overwrite_flags (
    v_char_t*           /* self */,
    v_char_index_t      /* start_index */,
    char const *       /* values */,
    v_char_cnt_t        /* count */,
    ERWIN_BOOL   /* copy_elements */,
    ERWIN_BOOL   /* delete_overwritten_elements */);
  /* Like v_char_overwrite_raw but you can further specify its
   * (de-)allocation behaviour.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int  v_char_overwrite_string (v_char_t*     /* self*/,
                                     v_char_index_t           /* start_index_in_self */,
                                     char const * /* newdata*/);
  /* Overwrites portions of the vector from a normal array.
   * Like v_char_overwrite_raw but with a zero-terminated string.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_overwrite_vector (
        v_char_t*     /* self*/,
        v_char_index_t           /* start_index_in_self */,
        v_char_t const* /* newdata*/);
  /* Overwrites portions of the vector from a vector.  Like
   * v_char_overwrite_raw but takes its data from another vector.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int  v_char_overwrite (
        v_char_t*         /* self*/,
        v_char_index_t    /* start_index_in_self */,
        v_char_t const*   /* newdata*/,
        v_char_index_t    /* start_index_in_initial */,
        v_char_cnt_t      /* max_count */);
  /* Each element is copied using CHAR_OCOPY, the old contents are deleted
   * with CHAR_OFREE.  This overwrites maximally max_count elements from
   * initial to self starting at position start_index_in* in the two
   * vectors.
   *
   * This is a frontend to v_char_overwrite_raw.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int  v_char_insert (
    v_char_t*       /* self */,
    v_char_index_t  /* index */,
    char     /* element */) ATTR_NONNULL((1));
 /* Inserts one \p element at  position \p index.
  *
  * Possible values for \p index are 0...v_char_nentries(self) both
  * inclusive.
  *
  * Returns its success.
  */

ERWIN_EXPORT
int  v_char_insert_raw (
    v_char_t*       /* self */,
    v_char_index_t  /* index */,
    char const *   /* values */,
    v_char_cnt_t    /* count */);
 /* Inserts elements from an open array whose size is given by \p count.
  * In all other aspects it works just like v_char_insert_vector.
  */

ERWIN_EXPORT
int  v_char_insert_no_copy (
    v_char_t*        /* self */,
    v_char_index_t              /* index */,
    char const * /* values */,
    v_char_cnt_t              /* count */);
  /* Like v_char_insert_raw but does not copy the given data.
   */

ERWIN_EXPORT
int  v_char_insert_string (
        v_char_t*     /* self */,
        v_char_index_t           /* start_index */,
        char const * /* values */) ATTR_NONNULL((1));
  /* Inserts a zero-terminated string into the vector.
   *
   * In all other aspects it works just like v_char_insert_vector.
   */

ERWIN_EXPORT
int  v_char_insert_vector (
        v_char_t* /*self*/,
        v_char_index_t       /* start_index */,
        v_char_t const* /*initial*/);
 /*
  * Each element is copied using CHAR_OCOPY.
  *
  * This is a simple frontend to v_char_make_gap and v_char_overwrite.
  * To insert only portions of the initial vector, use these functions
  * directly.
  *
  * Possible values for \p index are 0...v_char_nentries(self) both
  * inclusive.
  *
  * Returns its success.
  */


ERWIN_EXPORT
v_char_cnt_t v_char_string_length (
    v_char_t const* /* self */, char const * /* string */) ATTR_PURE;
  /* Find out the string length of the given zero-terminated \p string.
   *
   * The zero element is taken from the vector.  This does not modify
   * the vector at all, nor does it look at the vector's elements.  It
   * only gets the zero element from the vector.
   */


ERWIN_EXPORT
int v_char_ensure_size (v_char_t * /*self*/, v_char_cnt_t /*size*/) ATTR_NONNULL((1));
  /* Possibly enlarges the vector by appending null elements.
   *
   * This is more than v_char_ensure_table_size, since the vector gets the given
   * size with zero-initialised elements at the tail if necessary.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_ensure_size_with (
    v_char_t * /*self*/, v_char_cnt_t /*size*/, char  /*elem*/) ATTR_NONNULL((1));
  /* Possibly enlarges the vector by appending the given elements.
   *
   * This is similar to v_char_ensure_size, but you can define with which element
   * the vector will be filled when grown.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_set_size (v_char_t * /*self*/, v_char_cnt_t /*size*/);
  /* Set the vector size (by shrinking or enlarging and filling with
   * null elements).
   *
   * *Note* that the function will never resize the vector smaller
   * than V_CHAR_MINIMAL_SIZE (actually, no function will do that).
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_set_size_with (v_char_t * /*self*/, v_char_cnt_t /*size*/, char  /*elem*/);
  /* Set the vector size (by shrinking or enlarging and filling with
   * the given elements).
   *
   * This is similar to v_char_set_size, but you can define with which element
   * the vector will be filled when grown.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_set_size_no_resize (v_char_t * /*self*/, v_char_cnt_t /*size*/);
  /* Set the vector size (by shrinking or enlarging and filling with
   * null elements).  When shrinking, no resizing of the table will
   * be done.
   *
   * Returns its success.
   */

ERWIN_EXPORT
int v_char_set_size_raw (v_char_t * /*self*/, v_char_cnt_t /*size*/);
  /* Set the vector size by shrinking or enlarging without, resizing,
   * deallocation and without filling with null elements.
   *
   * This function similar to v_char_set_size_no_resize: when shrinking,
   * no resizing will be done.  Further, this function does not free
   * any elements during shrinking, so that the elements up to the
   * allocation size will remain in memory unmodified.  When enlarging
   * the vector up to the allocation size, this function will
   * not initialise the data.
   *
   * This function is useful if you want to temporarily hide elements
   * at the end of the vector.  E.g. when handling heaps where
   * the vector size is different from the heap size.
   * See v_char_make_heap.
   *
   * BE CAREFUL: if you use this function to shrink the vector, and then
   *             use it to enlarge the vector to a size greater than
   *             the original size, then there will be uninitialised
   *             elements.  Basic initialisation (constructor invocation)
   *             is performed when the vector needs to be reallocated
   *             to enlarged it, however.  But no null element is ever
   *             written by this function.
   *
   * Returns its success.
   */

ERWIN_EXPORT
void v_char_shrink (v_char_t * /*self*/, ERWIN_BOOL /* tight */);
  /* Perform a table shrink operation if necessary.  Mostly useful
   * if V_CHAR_NO_AUTO_SHRINK is set, otherwise, this function is
   * automatically invoked whenever the vector shrinks.
   *
   * If \p tight is not ERWIN_FALSE, the vector is reallocated to the
   * absolute minimum that is necessary to store the data.  Otherwise,
   * the standard algorithm of halving chunks is used.
   *
   * *Note* that the function will never resize the vector smaller
   * than V_CHAR_MINIMAL_SIZE (actually, no function will do that).
   *
   * If V_CHAR_MINIMAL_SIZE == 0, and if you invoke this function
   * on an empty vector, the vector will not use any allocated
   * internal structure anymore until you insert anything.
   *
   * When V_CHAR_LOW_MEM is active, this functions has no operation, since the
   * table size cannot be changed independently from the size.
   *
   * *Note* that calling v_char_as_array() on a shrinked
   * vector is not wise since the vector will have to resize for
   * the padded zero element.
   *
   * Note: This function is always successful.  Even if realloc
   *       failed, the vector is still consistent.  Therefore, no
   *       error code is returned.  However, the error code is
   *       set up correctly.
   *
   * Further Note: If you defined memory overflow errors to be
   *       fatal (by #define ERWIN_NOMEM_IS_FATAL), they are also
   *       fatal in this function.
   */

ERWIN_EXPORT
int v_char_ensure_table_size (v_char_t * /*self*/, v_char_cnt_t /*size*/) ATTR_NONNULL((1));
  /* Pre-allocates vector elements.  To be used when you know some good
   * upper approximation to the expected number of elements which will be
   * inserted in the future.  Does not change the contents of the vector.
   *
   * To set a minimal size for the vector by appending zero elements,
   * use v_char_ensure_size.
   *
   * When V_CHAR_LOW_MEM is active, this functions has no operation, since the
   * table size cannot be changed independently from the size.
   *
   * Returns its success.
   */

ERWIN_EXPORT
v_char_element_ptr_t v_char_as_array (v_char_t const *);
  /* returns a pointer to the string the vector is stored in.  The string
   * is terminated with a zero element (usually CHAR_ZERO, but this
   * can be changed by using v_char_new_with_zero).
   *
   * Note: For convenience, this takes a const pointer although the
   * representation (but not the contained data) might be changed.  It only
   * changes things outside the user view (behind the end of the vector).
   *
   * Further note that NULL is ok, NULL is returned, regardless of V_CHAR_ALLOW_NULL.
   *
   * When V_CHAR_INLINE_STORE is active, the returned pointer may become
   * invalid when you invoke v_char_detach or v_char_detach_as_is.  Use
   * v_char_as_array_detach() in that case (you cannot split that operation
   * in this case).
   *
   * Developer's Note: this functions is not __pure__: it may change the
   * internal structure, and thus the result of table_size() and
   * has_heap_storage() etc.
   */

ERWIN_EXPORT
v_char_element_ptr_t v_char_as_open_array (v_char_t const *) ATTR_ERRNO_PURE;
  /* Same as v_char_as_array, but without the guaranteed zero element.
   * This is sometimes faster and /never/ resizes the vector.
   *
   * Note: If V_CHAR_MINIMAL_SIZE is 0 and the vector has size 0, this
   *       function might return NULL instead of an allocated array!
   *       This is because the function will never try to reallocate.
   *
   * When V_CHAR_INLINE_STORE is active, the returned pointer may become
   * invalid when you invoke v_char_detach or v_char_detach_as_is.  Use
   * v_char_as_array_detach() in that case (you cannot split that operation
   * in this case).
   */

ERWIN_EXPORT
v_char_element_ptr_t v_char_as_array_detach (v_char_t *);
  /* Like v_char_as_array() followed by v_char_detach() with the difference
   * that this also works when V_CHAR_INLINE_STORE is active.
   */

ERWIN_EXPORT
void v_char_ensure_heap_storage (v_char_t *) ATTR_NONNULL((1));
  /* Ensure that the contents are stored on the heap so that _detach
   * does not destroy the vector.  Used by v_char_as_array_detach(), but
   * may also be used manually before as_array() or v_char_nth_ptr() to
   * ensure that the pointer is on the heap.
   *
   * This function actually does something only when V_CHAR_INLINE_STORE
   * is used or V_CHAR_MINIMAL_SIZE is 0.  Otherwise, this function does
   * nothing.  This includes not doing any harm.
   *
   * Note: With both LOW_MEM and INLINE_STORE active, this functions may
   *       append ZERO elements to the vector, because resizing the table
   *       may mean to resize the vector.
   *
   * Note: With V_CHAR_MINIMAL_SIZE == 0, vectors of size 0 are still *not*
   *       resized to size 1.
   *       Functions returning pointers to the table (e.g. v_char_as_open_array)
   *       will return NULL in this special case, which is ususally no problem
   *       in handling.
   *       This function is for handling the more complex cases that occur with
   *       the V_CHAR_INLINE_STORE option.
   */

ERWIN_EXPORT
ERWIN_BOOL v_char_has_heap_storage (v_char_t const *) ATTR_PURE;
  /* Returns whether the storage on the heap is allocated or not.
   * This is interesting only when V_CHAR_MINIMIAL_SIZE == 0 or
   * V_CHAR_INLINE_STORE is activated.
   */

ERWIN_EXPORT
v_char_cnt_t v_char_inline_store_cnt (void) ATTR_PURE;
  /* Returns the number of elements the inline store has.
   * This is 0 unless V_CHAR_INLINE_STORE is activated, in which case other
   * values are possible.  The result is a constant, therefore there is no
   * argument to this function.
   */

ERWIN_EXPORT
v_char_element_ptr_t v_char_as_open_array_detach (v_char_t *);
  /* Like v_char_as_open_array() followed by v_char_detach() with the difference
   * that this also works when V_CHAR_INLINE_STORE is active.
   */

ERWIN_EXPORT
void v_char_qsort (v_char_t *, v_char_cmp_t /*order*/);
  /* Uses the \p order function to sort the vector.  The compare function may be NULL
   * if CHAR_CMP is defined.  In this case that default compare function
   * is used.  See v_char_u.h for definition.
   *
   * For a stable sort function, see v_char_sort.
   *
   * For a guaranteed O(n log n) runtime and O(1) space, see v_char_heap_sort.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_CMP.
   *
   * This function the CLib function qsort(3).   Note that qsort(3) need not
   * use Quicksort internally, e.g. if the glibc under Linux finds that there
   * is enough memory, it uses merge sort instead.  So you have good chances
   * that this function is stable *in many cases under Linux*.  However, if you
   * need stability, this function does not guarantee that.  Especially, when
   * running your programm under Windows, its qsort(3) implementation is *not*
   * stable.  That's perfectly ok.  For stability, simply always use
   * v_char_sort().
   *
   * In sorted vectors, you can find entries in O(log n) vector using
   * v_char_bfind or v_char_locate.
   */

ERWIN_EXPORT
void v_char_sort (v_char_t *, v_char_cmp_t /*order*/);
  /* Uses erwin_merge_sort, which implements a stable sorting algorithm.
   * Uses the \p order function. \p order may be NULL (see v_char_qsort and
   * v_char_heap_sort) if CHAR_CMP is defined, which will then be used.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_CMP.
   *
   * Uses Erwin's erwin_merge_sort function which is stable but needs O(n) space.
   *
   * You can find entries in a sorted vector using v_char_bfind or v_char_locate.
   */

ERWIN_EXPORT
v_char_index_t v_char_bfind (v_char_t const *, char , v_char_cmp_t);
  /* Needs a sorted vector.  Then searches with binary search.  Uses the cmp function.
   * cmp may be NULL (see above)
   * -1 means: not found.
   *
   * Uses the system function bsearch().
   *
   * This operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_CMP.
   *
   * This function checks the input when in debug mode, causing assertion
   * failures if input is not sorted.the heap property is violated after operation.
   * Note that this check takes O(n) time, so the function is significantly
   * slower during debugging.  If you don't want this, you may
   *
   *    #define V_CHAR_DEBUG_EXPENSIVE_CHECKS        0
   * or #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0   (for all vectors)
   *
   * References
   * ~~~~~~~~~~
   * v_char_qsort, v_char_sort, v_char_locate, v_char_find.
   */

ERWIN_EXPORT
ERWIN_BOOL v_char_locate (
    v_char_index_t * /*index*/,
    v_char_t const * /*self*/,
    char  /*needle*/,
    v_char_cmp_t /*order*/,
    int /* how */);
  /* Needs a sorted vector.   Then searches with binary search.  Uses the cmp function.
   * cmp may be NULL (see above)
   *
   * In contrast to v_char_bfind you are provided with a possible
   * insertion position that will keep the vector's order.
   *
   * The function returns ERWIN_TRUE if the element was found and ERWIN_FALSE if not.
   *
   * This operation takes O(log n) time.
   *
   * The default cmp function, used if cmp is NULL, is CHAR_CMP.
   *
   * This function checks the input when in debug mode, causing assertion
   * failures if input is not sorted.the heap property is violated after operation.
   * Chis check takes O(n) time, so the function is significantly slower
   * during debugging.  If you don't want this, you may
   *
   *    #define V_CHAR_DEBUG_EXPENSIVE_CHECKS        0
   * or #define VECTOR_DEBUG_EXPENSIVE_CHECKS 0   (for all vectors)
   *
   * The \p how argument defines what value to return for the *\p index.  The following table
   * give an explanation of the value written into *\p index:
   *
   *   +---------+------------------------+------------------------+-----------------------+
   *   |! \p how |! if found (result ==   |! if not found (result  |! usage                |
   *   |         |  ERWIN_TRUE)    |  == ERWIN_FALSE |                       |
   *   +---------+------------------------+------------------------+-----------------------+
   *   | -1      | the smallest index     | insertion position     | to find an element or |
   *   |         | of equal elements      |                        | to insert an element  |
   *   |         |                        |                        | at the smallest       |
   *   |         |                        |                        | possible position     |
   *   +---------+------------------------+------------------------+-----------------------+
   *   | 0       | some index of an equal | insertion position     | to find and insert    |
   *   |         | element                |                        | without caring about  |
   *   |         |                        |                        | order of equal        |
   *   |         |                        |                        | elements              |
   *   +---------+------------------------+------------------------+-----------------------+
   *   | 1       | the largest index of   | insertion position - 1 | to find an element or |
   *   |         | equal elements         |                        | to insert an element  |
   *   |         |                        |                        | at the largest        |
   *   |         |                        |                        | possible position.    |
   *   +---------+------------------------+------------------------+-----------------------+
   *
   * At first sight, for \p how==1 the value of \p index seems strange.  But from the point of
   * view of inserting even in case of equality, you can simply insert at (*\p index+1) to
   * insert at the right most possible position keeping the vector's order without looking at
   * the function's return value.  However, in case of finding the element, *\p index always
   * points to an equal element.  Note that because of this, \p index may be -1 (for \p how=1
   * if you want to insert at the beginning).
   *
   * Note: for \p how==0 and \p how==-1, the functions will set *\p index to
   * v_char_nentries(self) if the searched element is larger than any in the vector,
   * because that is the correct value for v_char_insert.
   *
   * Summarized constraints that always hold:
   *
   *    +-------------------------------------+------------------------------------------+
   *    | for \p how==0 and \p how==-1        | *\p index always is the correct          |
   *    |                                     | insertion position.                      |
   *    +-------------------------------------+------------------------------------------+
   *    | for \p how==1                       | (*\p index + 1) always is the correct    |
   *    |                                     | insert position.                         |
   *    +-------------------------------------+------------------------------------------+
   *    | if the return value is              | *\p index points to an equal element.    |
   *    | ERWIN_TRUE                   |                                          |
   *    +-------------------------------------+------------------------------------------+
   *
   * References
   * ~~~~~~~~~~
   * v_char_qsort, v_char_sort, v_char_bfind.
   */

/* ***** iteration: ***** */
/* New approach: */
#define v_char_forall(v,i,h) \
        for(v_char_init_iterator((v),&(i)); \
            v_char_next_iteration((v),&(i),&(h)); /*nix*/)
/* Iteration operator for vectors.  Iterates over all indices and values starting at index 0
 * and incrementing \p i by 1 in each iteration. In constrast to maps, you do not need an
 * iterator (the index is used as an iterator).
 *
 * In C++, use vector_forall.
 *
 * Iterators are nestable without restriction (even on the same vector).
 * During iteration, the vector may not be changed.
 * If you use C++, the *_copy and *_sorted iterators allow changing during iteration.
 *
 * You may freely use break and continue in the loop.
 *
 * : int i;
 * : char *s;
 * : v_char_p_forall (v, i, s) {
 * :     printf ("v[%d]=%s\n", i, s);
 * : }
 */

#define v_char_forall_ptr(v,i,h) for(v_char_init_iterator(v,&(i)); v_char_next_iteration_ptr(v,&(i),&(h)); /*nix*/)
/* Iteration operator for vectors.  Iterates over all indices and pointers to values starting at
 * index 0.  In contrast to v_char_forall this macro can be used to change the values due to
 * the pointer iteration. */

#define v_char_forall_ptr_const(v,i,h) for(v_char_init_iterator(v,&(i)); v_char_next_iteration_ptr_const(v,&(i),&(h)); /*nix*/)

#define v_char_forall_reverse(v,i,h) for(v_char_init_iterator_reverse(v,&(i)); v_char_next_iteration_reverse(v,&(i),&(h)); /*nix*/)
/* Iterator operator for reversed order, i.e., starting at index v_char_nentries()-1 and
 * decrementing \p i downto 0.  See v_char_forall for details.
 */

#define v_char_forall_ptr_reverse(v,i,h) for(v_char_init_iterator_reverse(v,&(i)); v_char_next_iteration_ptr_reverse(v,&(i),&(h)); /*nix*/)
/* Iterator operator for reversed order, i.e., starting at index v_char_nentries()-1 and
 * decrementing \p i downto 0.  See v_char_forall, v_char_forall_reverse and
 * v_char_forall_ptr for details.
 */

#define v_char_forall_ptr_const_reverse(v,i,h) for(v_char_init_iterator_reverse(v,&(i)); v_char_next_iteration_ptr_const_reverse(v,&(i),&(h)); /*nix*/)

ERWIN_EXPORT
void v_char_init_iterator (v_char_t const *, v_char_index_t * /*keyptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL v_char_next_iteration  (v_char_t const *, v_char_index_t * /*keyptr*/, char * /*valueptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL v_char_next_iteration_ptr  (v_char_t *, v_char_index_t * /*keyptr*/, char ** /*valuepp*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL v_char_next_iteration_ptr_const  (v_char_t const *, v_char_index_t * /*keyptr*/, char const ** /*valuepp*/);
/*private*/

ERWIN_EXPORT
void v_char_init_iterator_reverse (v_char_t const *, v_char_index_t * /*keyptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL v_char_next_iteration_reverse  (v_char_t const *, v_char_index_t * /*keyptr*/, char * /*valueptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL v_char_next_iteration_ptr_reverse  (v_char_t *, v_char_index_t * /*keyptr*/, char ** /*valueptr*/);
/*private*/

ERWIN_EXPORT
ERWIN_BOOL v_char_next_iteration_ptr_const_reverse  (v_char_t const *, v_char_index_t * /*keyptr*/, char const ** /*valueptr*/);
/*private*/

/* ***** access to all entries: ***** */
ERWIN_EXPORT
void v_char_clear (v_char_t* /*self*/);
   /* Like v_char_erase for all elements. */

ERWIN_EXPORT
void v_char_clear_keep (v_char_t* /*self*/, v_char_cnt_t /*table_min_size*/);
   /* Like v_char_clear(), but the internal table is not shrunk below
    * the given minimal size (instead of the predefined minimal table size)
    */

ERWIN_EXPORT
void v_char_clear_flags (v_char_t* /*self*/, ERWIN_BOOL /* resize */, ERWIN_BOOL /* delete_elems */);
   /* Like v_char_clear you can specify whether a realloc will be performed and
    * whether the elements will be freed.
    * The former is useful if you  want to clear the vector but expect new data of
    * around the same length to be inserted afterwards.
    *
    * This function is only available of char == char.
    */

ERWIN_EXPORT
void v_char_clear_no_resize (v_char_t* /*self*/);
   /* Compatibility & convenience:
    * Like v_char_clear(\p self) without resizing the table.
    */

/*BEGIN:IGNORE*/
#if defined(ERWIN_COMPILING) || !defined(NDEBUG)
/*END:IGNORE*/

ERWIN_EXPORT
v_char_cnt_t v_char_nentries (v_char_t const * /*self*/) ATTR_PURE;
   /* Returns the number of entries in the vector.
    *
    * Note: This is not called `v_char_size' in order to prevent confusion
    * about the unit of the result.  `size' might refer to bytes.  `nentries', however,
    * is clearer.
    */

ERWIN_EXPORT
ERWIN_BOOL v_char_empty (v_char_t const * /*self*/) ATTR_PURE;
   /* Returns whether the vector contains no elements. */

/*BEGIN:IGNORE*/
/* #if defined(ERWIN_COMPILING) || V_CHAR_ALLOW_OUTOFRANGE || V_CHAR_RANGE_CHECK */
#else
#define V_CHAR_INLINE__NENTRIES
#endif
/*END:IGNORE*/

ERWIN_EXPORT
v_char_cnt_t v_char_table_size (v_char_t const* /*self*/) ATTR_PURE;
  /* For debugging and optimisation purposes (use rarely): the current
   * size of of the internal pre-allocated array of elements.
   */


ERWIN_EXPORT
v_char_index_t v_char_find  (
    v_char_t const * /*self*/, v_char_index_t /*start*/, char  /*needle*/) ATTR_ERRNO_PURE;
   /* Tries to finds an entry equal to needle.  Returns the index of the first element >= start
    * or -1 of nothing was found.  The search is performed from the beginning to the end.
    *
    * If start is negativ, search is started at the last but start-th position.  So to search
    * the whole vector, start should be 0.
    *
    * Note: This function is not called `v_char_search', because it does not only
    * perform the search, but also returns the result of that search.
    *
    * References
    * ~~~~~~~~~~
    * v_char_rfind, v_char_bfind.
    */

ERWIN_EXPORT
v_char_element_ptr_t v_char_find_ptr (
   v_char_t const * /*self*/, v_char_index_t /*start*/, char  /*needle*/) ATTR_ERRNO_PURE;
   /* Like v_char_find but returns a pointer to the found item or NULL on failure. */

ERWIN_EXPORT
v_char_index_t v_char_rfind (
    v_char_t const * /*self*/, v_char_index_t /*start*/, char  /*needle*/) ATTR_ERRNO_PURE;
   /* Tries to finds an entry equal to needle.  Returns the index of the first element <= start
    * or -1 of nothing was found.  The search is performed from the end to the beginning.
    *
    * If start is negativ, search is started at the last but start-th position.  So to search
    * the whole vector, start should be -1.
    *
    * References
    * ~~~~~~~~~~
    * v_char_find
    */

ERWIN_EXPORT
v_char_element_ptr_t v_char_rfind_ptr (
    v_char_t const * /*self*/, v_char_index_t /*start*/, char  /*needle*/) ATTR_ERRNO_PURE;
   /* Like v_char_rfind but returns a pointer to the found item or NULL on failure. */

ERWIN_EXPORT
v_char_index_t v_char_find_raw (
        v_char_t const * /*self*/,
        v_char_index_t /*start*/,
        char const * /*needle*/,
        v_char_cnt_t /*len*/) ATTR_ERRNO_PURE;
   /* Like v_char_find but tries to find equal parts.  See v_char_rfind_raw. */

ERWIN_EXPORT
v_char_index_t v_char_rfind_raw (v_char_t const * /*self*/, v_char_index_t /*start*/,
                            char const * /*needle*/, v_char_cnt_t /*len*/) ATTR_ERRNO_PURE;
   /* Like v_char_rfind but tries to find equal parts.
    *
    * Return the position of `needle' or -1 if it is not found.
    * Note that it is no problem to search for the zero element CHAR_ZERO.
    * These all use the V_CHAR_EQUAL macro.
    *
    * Negative values for start will count from the end of the vector.
    */

ERWIN_EXPORT
v_char_index_t v_char_find_if (
        v_char_t const * /*self*/,
        v_char_index_t /* start*/,
        v_char_feature_t /*feature*/,
        ERWIN_BOOL /* value */);
   /* find_if behaves like position-if in CommonLisp.
    *
    * Tries to find an entry with a certain feature.  Returns the index of the first element >= start
    * or -1 of nothing was found.  The search is performed from the beginning to the end.
    *
    * If start is negativ, search is started at the last but start-th position.  So to search
    * the whole vector, start should be 0.
    */

ERWIN_EXPORT
v_char_index_t v_char_rfind_if (
        v_char_t const * /*self*/,
        v_char_index_t /* start */,
        v_char_feature_t /*feature*/,
        ERWIN_BOOL /* value */);
   /* Tries to find an entry with a certain feature.  Returns the index of the first element <= start
    * or -1 of nothing was found.  The search is performed from the end to the beginning.
    *
    * If start is negativ, search is started at the last but start-th position. So to search
    * the whole vector, start should be -1.
    */


ERWIN_EXPORT
ERWIN_BOOL v_char_is_equal_at (v_char_t const * /*self*/,  v_char_index_t /*pos*/,
                                char const * /*other*/, v_char_cnt_t /*len*/) ATTR_ERRNO_PURE;
   /* Checks whether the given string is found at the given position.
    * Negative values for pos will count from the end of the vector.
    */

ERWIN_EXPORT
void v_char_ltrim_if (v_char_t * /*self*/, v_char_feature_t /*feature*/, ERWIN_BOOL /*value*/);
   /* Cuts off all elements that have the `feature' from the left of the vector
    *
    * References: v_char_rtrim_if, v_char_trim_if
    */

ERWIN_EXPORT
void v_char_rtrim_if (v_char_t * /*self*/, v_char_feature_t /*feature*/, ERWIN_BOOL /*value*/);
   /* Cuts off all elements that have the `feature' from the right of the vector
    *
    * References: v_char_ltrim_if, v_char_trim_if
    */

ERWIN_EXPORT
void v_char_trim_if  (v_char_t * /*self*/, v_char_feature_t /*feature*/, ERWIN_BOOL /*value*/);
   /* Cuts off all elements that have the `feature' from the left and right of the vector
    *
    * References: v_char_ltrim_if, v_char_rtrim_if
    */

ERWIN_EXPORT
void v_char_map (v_char_t * /*self*/, v_char_map_t /*map*/);
   /* Applies a given function to all elements of the vector. */

ERWIN_EXPORT
int v_char_cmp (v_char_t const *, v_char_t const *, v_char_cmp_t /*cmp*/);
    /* Returns a comparison value for lexical sort order, or by length order,
     * depending on V_CHAR_COMPARE_LEXICOGRAPHICALLY, which defaults to 1 for
     * non-character types, and to 0 for all others.  The difference is that
     * the length order checks the length of the vector first, which is expected
     * to yield a quicker distinction for most vectors.
     *
     * This function is NULL safe.  NULL is smaller than any
     * other vector.  By this you can easily sort a vector in reverse order and then
     * rtrim_if(is_NULL) to get rid of NULL elements.
     *
     * If cmp is NULL, CHAR_CMP will be used.  If that is not defined, an error
     * will occur.
     */

ERWIN_EXPORT
hashval_t v_char_hash_raw (v_char_t const *) ATTR_ERRNO_PURE;
    /* Returns a hash value, which is derived from hash values for char.
     *
     * This is traditionally called hash_raw although the hash value is
     * good enough for a normal HASH nowadays.
     *
     * Note: Usually you want hash values if you work with maps.  So you
     *       should define the hash value in such a way that both the map
     *       header as well as the vector header find them.
     *
     * Further Note: This will only be implemented if CHAR_HASH_RAW
     * is defined.
     *
     */

ERWIN_WRAPPER
hashval_t v_char_hash (v_char_t const *) ATTR_ERRNO_PURE;
    /* Same as v_char_hash_raw() now that hash_raw() is good enough. */

ERWIN_WRAPPER
hashval_t v_char_hash (v_char_t const *x)
{
    return v_char_hash_raw(x);
}


ERWIN_EXPORT
int v_char_fread (v_char_t * /*self*/, FILE * /*f*/, v_char_cnt_t /* max_count */);
   /* Read the whole file or a prefix into the vector.
    * If you pass -1 for max_count, there is no maximal count.
    *
    * This function returns the number of elements read or -1 in case of
    * an error.  If vector_errno is VECTOR_ERR_IO, you can use ferror(f)
    * to query the error.
    */

ERWIN_EXPORT
int v_char_fgets (v_char_t * /*self*/, FILE * /*f*/, v_char_cnt_t /* max_count */);
   /* Read one line into the vector.  You can bound the number of elements stored
    * in the vector.  However, a line is always read completely to the end.
    *
    * This function returns the error code.  VECTOR_OK means no error.
    *
    * If no char could be read, this returns VECTOR_WARN_EMPTY.  Otherwise,
    * VECTOR_OK is returned if not file error occured, VECTOR_ERR_IO
    * otherwise.  Then you can query the error on the file using ferror (f).
    *
    * Like the clib function, the trailing \n is appended if it was there.
    */

/* Note: Clean writing is easier, so that functions for that are not
 *       provided. */

ERWIN_EXPORT
void v_char_ltrim (v_char_t * /*self*/);
   /* See v_char_trim.
    */

ERWIN_EXPORT
void v_char_rtrim (v_char_t * /*self*/);
   /* See v_char_trim.
    */

ERWIN_EXPORT
void v_char_trim  (v_char_t * /*self*/);
   /* Like the v_char_trim_if family with an isspace feature.  The special isspace used
    * here defines '\0' to be a space.  This is useful for pre-allocating space
    * by inserting \0, then using standard clib functions to fill the buffer,
    * and then trimming it.
    */

ERWIN_EXPORT
void v_char_chomp (v_char_t * /*self*/);
   /* Like v_char_rtrim with ((X) == '\n' || (X) == '\r') feature
    */

ERWIN_EXPORT
void v_char_to_upper (v_char_t * /*self*/);
   /* Translates all elements using the erwin_to_upper function.
    */

ERWIN_EXPORT
void v_char_to_lower (v_char_t * /*self*/);
   /* Translates all elements using the erwin_to_lower function.
    */

ERWIN_EXPORT
v_char_index_t v_char_basename_index (v_char_t const * /*self*/) ATTR_ERRNO_PURE;
   /* NOTE: This function is obsolete and left in for compatibility reasons.
    * Use v_char_basename_range instead.
    *
    * Returns the index of the first character that belongs to the basename of a
    * file name.  The algorithm depends on the operating system this runs on.
    *
    * E.g. under Unix, for "/tmp/test///" this function returns 5.  To get the
    * length of the basename, use v_char_basename_range.
    */

ERWIN_EXPORT
void v_char_basename_range (v_char_index_t * /*first*/, v_char_cnt_t * /*length*/, v_char_t const * /*self*/);
   /* Returns the index of the first and last characters that belongs to the basename
    * of a file name.  The algorithm depends on the operating system this runs on.
    *
    * This is an extended version of v_char_basename_index, which does not return
    * the last index.  E.g. under Unix, for "/tmp/test///" this function returns:
    *     *first=  5,
    *     *length= 4
    *
    * first and length may be NULL in which case nothing is returned for the
    * respective value.
    */

ERWIN_EXPORT
int v_char_append_directory (v_char_t * /*self*/, v_char_t const * /*path*/);
   /* Append the directory of path to self.  This appended string includes the
    * path separator if necessary.  Returns vector_errno.
    */

ERWIN_EXPORT
int v_char_append_basename (v_char_t * /*self*/, v_char_t const * /*path*/);
   /* Append the base name of path to self.  This appended string does not include
    * any path separator.  Returns vector_errno.
    */

ERWIN_EXPORT
int v_char_append_config_file_name (
        v_char_t *   /*self*/,
        char const * /*program_name*/,
        ERWIN_BOOL         /*local*/);
   /* Append the default configuration file name (either global or local one) to the vector.
    * The default global name under Unix is
    *    : /etc/progname.conf
    * under Windos it is
    *    : C:\etc\progname.ini
    *
    * The default local name under Unix is
    *    : $HOME/.prognamerc
    * under Windos
    *    : %HOME%\progname.ini
    *
    * Returns vector_errno.  Note that if $HOME is not defined (which is typical under DOS),
    * VECTOR_ERR_OUTOFRANGE is returned and nothing appended if local != 0.
    */

#if V_CHAR_NO_FORMAT == 0

#ifdef HAVE_STDARG_H
#  include <stdarg.h>
#endif

/*
 * Format options for the oformat family
 */
#if !defined(FO_QUOTE_C_STRING)

/*! enum: FO_* */
#define FO_NO_QUOTE            0UL
  /* Format option for v_char_o_format family: perform no quotation on %s strings.
   * This is the default.
   *
   * The NULL pointer is printed as (null).
   */
#define FO_QUOTE_C_STRING      1UL
#define FO_QUOTE_PERL_STRING   1UL
  /* Format option for v_char_oformat family: quote all %s strings for a C compiler.
   * There is another option FO_QUOTE_IN_C_STRING which does not output
   * the surrounding "" of the string.
   *
   * The NULL pointer is printed as NULL.
   */

#define FO_QUOTE_IN_C_STRING    2UL
#define FO_QUOTE_IN_PERL_STRING 2UL
  /* Format option for v_char_oformat family: quote all %s strings for a C compiler,
   * assume that we are inside a string and do not output the embracing "".  With the
   * surrounding "", use the FO_QUOTE_C_STRING option.
   *
   * The NULL pointer is printed as the empty string.
   */

#define FO_QUOTE_BOURNE_SHELL  3UL
  /* Format option for v_char_oformat family: quote all %s strings for a Bourne shell.
   *
   * The NULL pointer produces an out of range error.
   */

#define FO_QUOTE_FORMAT        4UL
  /* Format option for v_char_oformat family: quote all %s strings for fprintf command.
   *
   * Note: Usually the C compiler reads a format string first, so you are likely
   *       to quote again for a C compiler with FO_QUOTE_C_STRING
   *
   * The NULL pointer produces an out of range error.
   */

#define FO_QUOTE_WIN_SHELL     5UL
  /* Format option for v_char_oformat family: quote all %s strings for a Windows shell.
   *
   * The NULL pointer produces an out of range error.
   */

#define FO_QUOTE_LISP_STRING   6UL
  /* Format option for v_char_oformat family: quote all %s strings in CommonLisp syntax.
   *
   * The NULL pointer is printed as nil.
   */

#define FO_QUOTE_IN_LISP_STRING  7UL
  /* Format option for v_char_oformat family: quote all %s strings in CommonLisp
   * syntax.  Do not output the embracing "".  See FO_QUOTE_LISP_STRING.
   *
   * The NULL pointer is printed as the empty string.
   */

#define FO_QUOTE_URL           8UL
  /* Format option for v_char_oformat family: quote all %s strings for
   * using in an URL. */

#define FO_QUOTE_HTML          9UL
#define FO_QUOTE_XML           9UL
#define FO_QUOTE_SGML          9UL
  /* Format option for v_char_oformat family: quote all %s strings for
   * in HTML syntax (no charset conversion is done, so if you pass char*,
   * this is iso-8859-1 in HTML and XML, while in SGML, it is whatever
   * you declared).  This is suitable for HTML,XML, and SGML -- we do
   * not assume any named entities.  (Not even &lt; &gt; and &amp;).
   * Anything else is quoted in decimal for maximum compatibility.
   */

/* FIXME: Have base64 and quoted-printable, too. */
#define FO_QUOTE_RESERVED3    10UL
#define FO_QUOTE_RESERVED2    11UL
#define FO_QUOTE_RESERVED1    12UL

#define FO_QUOTE_USER1        13UL
  /* Format option for v_char_oformat family: user defined %s quotation method no. 1 */

#define FO_QUOTE_USER2        14UL
  /* Format option for v_char_oformat family: user defined %s quotation method no. 2 */

#define FO_QUOTE_USER3        15UL
  /* Format option for v_char_oformat family: user defined %s quotation method no. 3 */

#define FO_QUOTE_USER_MIN   FO_QUOTE_USER1
#define FO_QUOTE_USER_MAX   FO_QUOTE_USER3

/* 4 bits -> 4 bits */
#define FO_QUOTE_MASK       15UL
#ifdef ERWIN_DOS
#    define FO_QUOTE_SHELL FO_QUOTE_WIN_SHELL
  /* Format option for v_char_oformat family: depending on the operating system you compiled
   * for, this is either equal to FO_QUOTE_BOURNE_SHELL or
   * FO_QUOTE_WIN_SHELL. */

#else
#    define FO_QUOTE_SHELL FO_QUOTE_BOURNE_SHELL
#endif /* ERWIN_DOS */

#define FO_VOID_P            0UL   /* default: %p reads a normal pointer */
#define FO_VECTOR           16UL
/* Instead of reading a normal pointer, %p reads a v_char_t *.
 */

#define FO_S_TYPE_MASK      16UL

/* 1 bit -> +4 = 5 bits */
#define FO_NO_CENTER         0UL   /* default: right adjusted, with `-' left adjusted */
#define FO_CENTER           32UL
 /* Format option for v_char_oformat family:
  * Center the string.  The `-' format specifier then determines whether to tend to
  * center to the left or to the right when it is not possible to center perfectly.
  */

/* 1 bit  -> +5 = 6 bits */
#define FO_RADIX_DEFAULT     0UL   /* default: 10 or 16 for %x. */
#define FO_RADIX_SHIFT       6UL
#define FO_RADIX_MASK      127UL
#define FO_RADIX(RADIX)   ((((unsigned long)(RADIX)) & FO_RADIX_MASK) << FO_RADIX_SHIFT)
 /* Format option for v_char_oformat family: specify a radix for numbers.  With printf,
  * only 8, 10, 16 are possible (via the %o, %d and %x formats resp.).  This allows
  * you to specify a different radix.
  *
  * For integers, you may use a format specifier character to set base, casing in
  * a few cases, in which case their variant printing form will be used:
  *
  *     FO_RADIX('d')  - base = 10                   - like %d   - "10"
  *     FO_RADIX('x')  - base = 16, lowcase, variant - like %#x  - "0xa"
  *     FO_RADIX('X')  - base = 16, upcase,  variant - like %#X  - "0XA"
  *     FO_RADIX('o')  - base = 8,           variant - like %#o  - "012"
  *     FO_RADIX('b')  - base = 2,  lowcase, variant             - "0b1010"
  *     FO_RADIX('B')  - base = 2,  upcase,  variant             - "0B1010"
  *
  * Of course, 'b' and 'B' are not format specifiers but are provided
  * for convenience.
  *
  * Other radix values > 64 are undefined.  (Values <= 64 will be treated
  * as numeric, e.g. ASCII '@' will select base64 digits.)
  *
  * This does *not* change the handling of the sign: %d is signed by default
  * and %u,%x,%o are unsigned.
  *
  * For floats, the FO_RADIX setting overrides the format specifier.
  * In contrast to integers, the variant form is not selected when using the
  * base to set the format specifier.
  * You may use:
  *
  *     FO_RADIX('e')  - %e
  *     FO_RADIX('E')  - %E
  *     FO_RADIX('f')  - %f
  *     FO_RADIX('F')  - %F
  *     FO_RADIX('g')  - %g
  *     FO_RADIX('G')  - %G
  *     FO_RADIX('a')  - %a
  *     FO_RADIX('A')  - %A
  */

#define FO_GET_RADIX(X)   (((X) >> FO_RADIX_SHIFT) & FO_RADIX_MASK)

/* 6 bits -> +7 = 13 bits */
#define FO_NO_SEP         0UL   /* default: do not separate digits */
#define FO_SEP_AT_SHIFT   13UL
#define FO_SEP_AT_MASK    7UL
#define FO_SEP_AT(AT)     (((((unsigned long)(AT)) & FO_SEP_AT_MASK) << FO_SEP_AT_SHIFT) | FO_DO_USE_SEP)
 /* Format option for v_char_oformat family: separate digits of numbers every AT digits.
  * If missing or 0, the a value of 3 is used.
  */

#define FO_GET_SEP_AT(X)  (((X) >> FO_SEP_AT_SHIFT) & FO_SEP_AT_MASK)

/* 3 bits -> +13 = 16 bits */
#define FO_DO_USE_SEP     (1UL << 16)
 /* If set, digits are separated into digit groups.
  * Both FO_USE_SEP and FO_SET_AT macros automatically set this flag.
  */
#define FO_USE_SEP_SHIFT  17UL
#define FO_USE_SEP_MASK   255UL
#define FO_USE_SEP(C)     (((((unsigned long)((unsigned char)(C))) & FO_USE_SEP_MASK) << FO_USE_SEP_SHIFT) | FO_DO_USE_SEP)
 /* Format option for v_char_oformat family:
  * The separator to use between digits if FO_SEP_AT was specified.
  * The default separator is ','.
  */

#define FO_GET_USE_SEP(X) (((X) >> FO_USE_SEP_SHIFT) & FO_USE_SEP_MASK)

/* 9 bits -> +16 = 25 bits */
#define FO_LOWCASE        0UL  /* default: digits are lowercase (except for %X) */
#define FO_UPCASE         (1UL << 25)
/* Format option for v_char_oformat family: print digits in upper case.  This is most
 * useful together with the FO_RADIX option.
 *
 * The default is to print in lower case.  Any mentioning of upper case in any
 * way will select upper case printing.  E.g. %X together with FO_LOWCASE
 * will still print in upper case.  Similarly, %d together with FO_LOWCASE
 * and FO_RADIX('X') will print in upper case.
 */

/* 1 bit -> +25 = 26 bits */
#define FO_PRINT          0UL  /* default: do print into vector. */
#define FO_CHECK          (1UL << 26)
/* Format option for v_char_oformat family:  perform all formating actions without
 * modifying the v_char_t.  This is useful to compute the width of the resulting
 * string. */

/* 1 bit -> +26 = 27 bits */
#define FO_SPECIAL        (1UL << 27)
/* Same as # flag in format string: select special form.
 * The reason to give it is because %#d is not defined, but may be feasible
 * together with a RADIX() annotation, when you do want 0x and 0 prefixes.
 */

/* 1 bit -> +27 = 28 bits
 *   There are five bits left.
 */
#endif /* !defined(FO_C_STRING) */


ERWIN_EXPORT
void v_char_set_quotation_method (
    v_char_t const * /* self */,
    int /* which */,
    v_char_quotation_method_t const *);
   /* Set new quotation methods for the `s' and `v' formats.
    * `which' may only be FO_QUOTE_USER1 or FO_QUOTE_USER2.
    *
    * self is needed to set the status code.
    *
    * This function is not thread safe, even if you define ERWIN_THREAD_SAFE.
    * There is only one array of user quotation methods.  If you change it, do it
    * at the beginning of your program in the main thread!
    */

ERWIN_EXPORT
v_char_quotation_method_t const *v_char_get_quotation_method (
    v_char_t const * /*self */,
    int /* which */);
   /* Get quotation methods.
    * Which must be from the FO_QUOTE_* family.
    */

ERWIN_EXPORT
void v_char_format (v_char_t * /*self*/, char const * /*format*/, ...) ATTR_FORMAT_PRINTF(2, 3);
   /* See v_char_oformat. */

ERWIN_EXPORT
void v_char_vformat (
    v_char_t * /*self*/,
    char const * /*format*/,
    va_list) ATTR_FORMAT_VPRINTF(2);
   /* See v_char_oformat. */

/* FIXME: have a scanf function, too, which especially does the unquoting
 * of all implemented formats. */

ERWIN_EXPORT
void v_char_oformat (
    v_char_t * /*self*/,
    unsigned long /* options */,
    char const * /*format*/, ...) ATTR_FORMAT_PRINTF(3, 4);
    /* The format is as in the printf family according to C99 standard. These functions will
     * never cause a buffer overflow. The \type(long long) type (64 bits integer) is supported
     * if the compiler supports one.  Its format  character is 'll', but `L' is also
     * understood.
     *
     * This function reimplements the whole
     * printf functionality, so if you do not like this overhead, you can define V_CHAR_NO_FORMAT,
     * but because of the guaranteed prevention of buffer overflows, it is usually good
     * to use this.
     *
     * To keep ANSI/ISO conformance (ISO/IEC 9899:1999 = C99), all extra functionality has been
     * put into the additional `options' argument.  The following format options are supported:
     *
     *    +------------------------------+------------------------------------------------+
     *    | d, i, u, o, x, X, c, s, m, p | conversion, own implementation                 |
     *    | e, E, f, F, g, G, a, A       | conversions passed through to standard library |
     *    | #, 0, -, SPACE               | flags                                          |
     *    | h, hh, l, ll, L, j, z, t     | length                                         |
     *    +------------------------------+------------------------------------------------+
     *
     * Note: Use ll with integers only and L with floats only to be compliant with POSIX.
     *       (Erwin treats both exactly the same just like glibc.)
     *
     * Currently unsupported
     * ~~~~~~~~~~~~~~~~~~~~~
     *     +----+-------------------------------------+
     *     | $  | argument reordering                 |
     *     | n  | number of characters written so far |
     *     +----+-------------------------------------+
     *
     *     - L + float is only supported if the compiler has is a long double type
     *     - ll + int is only supported if the compiler has a 64 bit int type.
     *
     * Compatibility
     * ~~~~~~~~~~~~~
     * For compatibility, the following are implemented (don't use if you want to
     * be POSIX compliant).
     *     +----------------+--------------------------------------------------------+
     *     | C              | use lc instead                                         |
     *     | S              | use ls instead                                         |
     *     | Z              | use z  instead                                         |
     *     | q              | use ll instead                                         |
     *     | L + int        | use ll instead                                         |
     *     | ll + float     | use L instead                                          |
     *     | l + float      | double instead of float                                |
     *     | ' (apostrophy) | No locale support: always digit width 3, separator=' ' |
     *     +----------------+--------------------------------------------------------+
     *
     * Note: FO_RADIX(64) uses base-64 digits, but is not mmencode compatible, as the
     *       base64 encoding works on chunks of 3 bytes which are interpreted as
     *       4 6-bit digits each.  The problem is that the digit order is reversed to
     *       the normal order, so you cannot easily convert from the format output
     *       to real base64 output.  Maybe we'll introduce a quotation method for
     *       base64 some day.
     *
     * Further note that you can print negative number with base != 10 by using %d with
     * the option FO_RADIX(...).
     *
     * Options
     * ~~~~~~~
     * You can use the FO_CHECK option to simulate operation.  By this, you can check
     * things via the first argument to v_char_rovformat or v_char_roformat.  The use
     * of v_char_format_pos() and v_char_format_quoted() is *deprecated*.
     *
     * The following options are supported to allow extended functionality.
     * They can be ORed together.
     *
     *     - FO_VECTOR:
     *             All %p refer to a \type(v_char_t *) instead of to a \type(char *).
     *
     *     - FO_UPCASE:
     *             Use upper case digits first in numbers (this is needed
     *             because there is no %D).
     *             e.g.
     *                 : format (FO_UPCASE + FO_RADIX(23), "%d", 2387)
     *             appends |4BI|
     *
     *     - FO_CENTER:
     *             Selects centering.  I.e. in addition to default right
     *             adjustment or right adjustment by the |-| option.
     *
     *             This does not work for floating point
     *             arguments (see below) since the clib does not support it.
     *
     *             This can be combined with |-| to
     *             specify that if it cannot be centred exactly, it should
     *             be more left adjusted instead of right.
     *             E.g.
     *                : v_char_oformat (v, FO_CENTER, "%04X", 10)
     *             will append "\tt(00A )" whereas
     *                : v_char_oformat (v, FO_CENTER, "%-04X", 10)
     *             will append "\tt(0A  )".
     *
     *     - FO_RADIX(radix):
     *             radix: a number between 0 and 64:
     *             Switches the radix of the %d, %i, %x and %o command from their
     *             default to this number.
     *
     *             The digit set is as follows:
     *
     *                 - radix <= 36:  for %x (lower case): 0..9, a..z and
     *                                 for %X (upper case): 0..9, A..Z
     *
     *                 - radix =  64:  always base64 digits (but different digit order!)
     *
     *                 - radix > 36 && radix < 64: base64 with only the first radix characters.
     *
     *             Also see the documentation of the FO_RADIX macro to
     *             learn about the special radix values of 'd', 'i', 'o', 'x', 'X',
     *             'b', 'e', 'E', 'f', 'F', 'g', 'G', 'a', 'A'.
     *
     *     - FO_QUOTE_SHELL:
     *             Quotation for Shell: either Unix or Windows, depending on compilation
     *             environment: equivalent to FO_QUOTE_BOURNE_SHELL under Unix
     *             and te FO_QUOTE_WIN_SHELL under Dos or Windows.
     *
     *     - FO_QUOTE_BOURNE_SHELL:
     *             Quote for a Bourne shell.
     *                  : v_char_oformat (FO_QUOTE_BOURNE_SHELL, "%s", "a b!c")
     *             ->   \tt(a\ b\!c)
     *
     *     - FO_QUOTE_WIN_SHELL:
     *             Quote for a Windows shell.
     *                  : v_char_oformat (FO_QUOTE_WIN_SHELL, "%s", "a b!c")
     *             ->   \tt("a b!c")
     *
     *     - FO_QUOTE_C_STRING:
     *             Quote in double quoted C syntax.  Single quotes are still
     *             quoted as \'.  This also tries to get maximum compatibility
     *             for reading such a string by sometimes quoting although
     *             unnecessary since it is known that some buggy compilers may
     *             misinterpret something.  E.g. someone might read \0001 as
     *             only one character.  Therefore, the previous is quoted as
     *             \000\001.
     *
     *                  : v_char_oformat (FO_QUOTE_C_STRING, "%s", "a'b\\c\"d\0\7e")
     *             ->   \tt("a\'b\\c\"d\000\007e")
     *
     *             This handles NULL and prints it as NULL.
     *
     *     - FO_QUOTE_IN_C_STRING:
     *             Similar to previous, but does not output enclosing double
     *             quotes, so it is suitable for either appending several
     *             quoted strings or for quoting in character syntax (single
     *             quotes), by manually providing enclosing quotes in the
     *             format string.
     *
     *                  : v_char_oformat (FO_QUOTE_C_STRING, "%s", "a'b\\c\"d\0\7e")
     *             ->   \tt(a\'b\\c\"d\000\007e)
     *
     *     - FO_QUOTE_LISP_STRING:
     *             CommonLisp quotation: this is like a simple C quotation:
     *             basically, only " and \ need quotation.
     *
     *                  : v_char_oformat (FO_QUOTE_C_STRING, "%s", "a'b\\c\"d")
     *             ->   \tt("a'b\\c\"d")
     *
     *     - FO_QUOTE_IN_LISP_STRING:
     *             Same as before without enclosing double quotes.
     *
     *                  : v_char_oformat (FO_QUOTE_C_STRING, "%s", "a'b\\c\"d")
     *             ->   \tt(a'b\\c\"d)
     *
     *     - FO_QUOTE_FORMAT:
     *             Quote to be suitable as a printf format string.  I.e.,
     *             % is quoted as %%.  Note that this does not include a
     *             C quotation, so when you have a literal string, and want
     *             to print a format string in C, you'll need to first
     *             quote for format, and then again for C.
     *                  : v_char_oformat (FO_QUOTE_FORMAT, "%s", "%s")
     *             ->   \tt(%%s)
     *
     *     - FO_QUOTE_USER1 ... USER3:
     *             User quotation: can be defined by the application by
     *             v_char_set_quotation_method().
     *
     *             Of the above, one can be selected: all %s and %c commands
     *             will quote their argument according to the given quotation.
     *
     *             Note: Quotation is only done for %s and %c, not for anything
     *                   else!
     *
     *             Further Note: because it appeared to happened *too*
     *             often, to mix quotation and non-quotation in one format string,
     *             you can specify left adjustment without giving a minimal width to
     *             switch off quotation.  So to switch off quotation for some %s,
     *             use %-s.
     *
     *             Note: This will only work if the minimal with is not given
     *             at all to prevent confusion:
     *
     *                  : v_char_oformat (FO_QUOTE_C_STRING, "%s.%-s.%s", "b", "c", "d")
     *             This will append:  \tt("b".c."d")
     *
     *     - FO_SEP_AT(position):
     *             Position is a number between 0 and 15.
     *
     *             Put commas into a number.  E.g.
     *                 : oformat (FO_SEP_AT(3), "%d", 10000000)
     *             ->  \tt(10,000,000)
     *
     *             This is equivalent to using "%'d" for an appropriate locale.
     *
     *             The number defines at how many digits this should happen.
     *             So Chinese people would perhaps want it between blocks of
     *             four digits:
     *
     *                 : oformat(FO_SEP_AT(4), "%d", 10000000)
     *             ->  \tt(1000,0000)
     *
     *             (since 1000,0000 = qian1 wan4; qian1 (=1000) wan4 (=10000))
     *
     *             (For some unknown reason, however, it seems that Asian languages
     *             with base words up to 10000 (instead of 1000 as most Western European
     *             languages) still use separators at all three digits.  Why?)
     *
     *     - FO_USE_SEP('.'):
     *             Define which character to use for digit separation:
     *
     *             E.g Germans might want to format their numbers like this:
     *                 : oformat(FO_USE_SEP('.') |
     *                 :         FO_SEP_AT(3), "%d", 10000000)
     *             ->  \tt(10.000.000)
     *
     *  Format specifiers
     *  ~~~~~~~~~~~~~~~~~
     *     - %n:  writes the current length of the vector into the given
     *             int* pointer. (or short* or long* or long long* if this
     *             is indicated by s, l or q).
     *
     *             Note: it writes the absolute length of the vector, NOT
     *             the relative length wrt. to the starting length!
     *
     *  Chopping behaviour with quoted strings
     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     *
     *  When using both width arguments, characters will never be
     *  output in halves (or other pieces).  Instead, the string is
     *  tried to be kept shorter.  Sometimes this is not possible
     *  (e.g. when the length of the prefix + suffix exceeds the total
     *  width).  In rare cases the string will therefore be longer.
     *  This behaviour is useful for breaking strings over several lines.
     *
     *  If you specify the exact length argument, the string will still
     *  not be expanded or chopped. (e.g. %80.78s will produce
     *  lines which are always 80 characters wide and which contain
     *  at most 78 characters representing a string and which will
     *  be padded with spaces to the right):
     *  Example:
     *       : v_char_oformat(FO_SHELL_QUOTE, "%7.5s", "Du da!")
     *       :   // This means: max. 5 chars, min.7 resulting in padding.)
     *  appends  \tt(Du\ d  )
     *
     *  The number of characters read from the input string can be
     *  retrieved by using v_char_roformat() or v_char_rovformat() and
     *  reading it from the resulting info structure.
     *
     *  E.g. the following loop generates a C parsable string which
     *  does not exceed 78 characters on each line:
     *      : int print_c_string (v_char_t *v, char const *c)
     *      : {
     *      :     v_char_format_info_t info;
     *      :     do {
     *      :         v_char_roformat (&info, FO_QUOTE_C_STRING, v, "%.78s\n", c);
     *      :         c+= info.pos;
     *      :     } while (VECTOR_IS_OK(vector_errno) && *c != '\0');
     *      : }
     *
     * If more than one l, q, h and Z flag is given, the last one will be used.
     *
     * Note: float and double formatations are passed to the standard library.
     *       So whether e.g. long double is implemented depends on your clib.
     *       This includes the `a' and `A' conversions (GNU).
     *
     * Further Note:
     *       CHAR_ZERO will be used!  This means that if it is != '\0', the %s
     *       argument will terminate printing at the first character equal to
     *       CHAR_ZERO.
     */


ERWIN_EXPORT
void v_char_ovformat (
    v_char_t *    /* self */,
    unsigned long /* options */,
    char const *  /* format */,
    va_list       /* arguments */) ATTR_FORMAT_VPRINTF(3);
   /* See v_char_oformat. */

ERWIN_EXPORT
void v_char_format_info_init (v_char_format_info_t *);
   /* Initialises a v_char_format_info_t structure.  Only required for C code.
    * In C++, the constructor is used for this.
    *
    * A v_char_format_info_t structure must be initialised before invoking
    * v_char_rovformat() with a pointer to it.
    */

ERWIN_EXPORT
void v_char_format_info_done (v_char_format_info_t *);
   /* Sweeps a v_char_format_info_t structure.  Only required for C code.
    * In C++, the destructor is used for this.
    *
    * A v_char_format_info_t structure must be sweeps before deallocation.
    */

ERWIN_EXPORT
void v_char_roformat (
    v_char_format_info_t * /* info */,
    v_char_t * /* self */,
    unsigned long /* options */,
    char const * /* format */,
    ... /* arguments */) ATTR_FORMAT_PRINTF(4, 5);
   /* Additional to v_char_oformat it stores information about the performed formatting
    * in info.  Use this in favour of v_char_format_quoted to retrieve information you
    * need.
    */

ERWIN_EXPORT
void v_char_rovformat (
    v_char_format_info_t * /* info */,
    v_char_t *   /* self */,
    unsigned long /* options */,
    char const *   /* format */,
    va_list       /* arguments */) ATTR_FORMAT_VPRINTF(4);
   /* Additional to v_char_ovformat it stores information about the performed formatting
    * in info.  Use this in favour of v_char_format_quoted to retrieve information you
    * need.
    */

#if ERWIN_GLOBAL_ERRNO
ERWIN_EXPORT
ERWIN_BOOL v_char_format_quoted (void) ATTR_DEPRECATED;
    /* DEPRECATED
     * ----------
     * Use
     *     : v_char_roformat (&info, FO_CHECK ...
     *
     * Was quotation ever necessary during the format?
     *
     * This function is not thread safe.  It uses global variables.  Therefore, this
     * function is not available when you compile with thread support
     * (ERWIN_THREAD_SAFE).  Use v_char_rovformat or v_char_roformat.
     */

ERWIN_EXPORT
v_char_index_t  v_char_format_pos (void) ATTR_DEPRECATED;
    /* DEPRECATED
     * ----------
     * Use
     *     : v_char_roformat (&info, FO_CHECK ...
     *
     * Returns how many characters were read from the last %s command.
     *
     * This function is not thread safe.  It uses global variables.  Therefore, this
     * function is not available when you compile with thread support
     * (ERWIN_THREAD_SAFE).  Use v_char_rovformat or v_char_roformat.
     */

#endif /* ERWIN_GLOBAL_ERRNO */

#endif /* V_CHAR_NO_FORMAT==0 */


/*--END-C--*/

#include "v_char_i.h"
/* Same problem as for arrays.  For efficient implementation, the compiler
 * needs to know the size of a vector structure.
 */


/*
 * If initial_size < 0 for any of the following functions, the default
 * size will be used.
 */

struct v_char_t
#ifdef V_CHAR_SUPER_CLASS
   : V_CHAR_SUPER_CLASS_ACCESS V_CHAR_SUPER_CLASS
#endif
{
    /*
     * The v_char Class
     * ================
     * This class implements dynamically resizable arrays.
     *
     * Throughout the documentation, the following prefixes will be used:
     *   - :
     *       The library prefix: for applications, this is typically
     *       empty, for an xyz-Library, this is either \tt(XYZ_), \tt(xyz_) or
     *       \tt(Xyz), depending on the identifier in occurs in.
     *       +---------------------+-----------------+
     *       |! Template           |! Instantiation  |
     *       | VECTOR_OK    | XYZ_VECTOR_OK   |
     *       | vector_new   | xyz_vector_new  |
     *       +---------------------+-----------------+
     *
     *   - v_char_:
     *       This is equivalent to v_char, or the name
     *       that was set with \tt(-name=...) for this data structure.
     *       The case and underbar convention is adjusted, too.
     *
     *       Assuming a library prefix \tt(xyz) and char == char, you get:
     *       +-------------------+----------------------------+
     *       |! Template         |! Instantiation             |
     *       | v_char_t          | xyz_v_char_t          |
     *       | V_CHAR_ALLOW_NULL | XYZ_V_CHAR_ALLOW_NULL |
     *       +-------------------+----------------------------+
     *   - VChar:
     *       This is the name of the data structure type in C++: capitalised
     *       and with underbars removed:
     *       +-------------------+-----------------+
     *       |! v_char_t         |! VChar   |
     *       | v_char_t     | VectorChar      |
     *       +-------------------+-----------------+
     *
     * Conventions
     * -----------
     *
     * It was tried to keep the argument order consistent, with some rules:
     *
     *    - for functions returning multiple values into pointer arguments, these
     *      are always /before/ input arguments. (e.g. v_char_locate (output, self, ...)).
     *      (Mnemonic: like memcpy, strcpy, assignment statement etc.)
     *       : ERWIN_BOOL v_char_locate (int *i, v_char_t const *, ...)
     *       : ^output                          ^output ^input            ^input
     *       :                                          ^first input = self
     *    - the self argument is always the first input argument.
     *    - index before element   (e.g.,
     *       : v_char_insert (self, position, element)
     *    - count after element(s). E.g.:
     *       : v_char_insert_raw (self, position, elemnt_ptr, count)
     *    - flags last. E.g.:
     *       : v_char_overwrite_flags (self, start, value, count,
     *       :                         copy_elems, delete_overwritten)
     *
     * Results
     * ~~~~~~~
     *   - if there is no natural result value, C functions return their success,
     *     i.e., the value of vector_errno:
     *       : int v_char_erase (v_char_t *self, int pos, int count)
     *     In these circumstances, C++ functions return the vector itself as
     *     a reference:
     *       : v_char_t &v_char_t::erase (int pos, int count = 1)
     *   - if v_char_errno is not interesting, either because it is not
     *     set or because only memory overflow or assertion failures may be
     *     a possible sources of an error, the C functions return void:
     *       : void v_char_delete (v_char_t *self)
     *     The C++ functions still return the object reference.
     *
     * Status Codes
     * ------------
     *
     * These are undef'ed first because there is only one error code for all
     * the arrays in your program.
     * All the functions returing error codes will both return this error
     * and write it into vector_errno.
     *
     *    +-----------------------+---------------------------+-----------------------------+
     *    |! Condition            |! Description              |! Macro to use               |
     *    +-----------------------+---------------------------+-----------------------------+
     *    | == VECTOR_OK   | Ok.                       | VECTOR_IS_OK(X)      |
     *    +-----------------------+---------------------------+-----------------------------+
     *    | <  VECTOR_OK   | *Error*: operation did    | VECTOR_IS_ERROR(X)   |
     *    |                       | not succeed.              |                             |
     *    +-----------------------+---------------------------+-----------------------------+
     *    | >  VECTOR_OK   | *Warning*: operation      | VECTOR_IS_WARNING(X) |
     *    |                       | succeeded but not         |                             |
     *    |                       | perfectly. (e.g. rehash   |                             |
     *    |                       | failed)                   |                             |
     *    +-----------------------+---------------------------+-----------------------------+
     *
     *
     *  In all cases, the consistency of the data structure is guaranteed.
     *
     *  Warnings are only visible in vector_errno; the functions still return
     *  VECTOR_OK.
     */

    V_CHAR_STD_MEMBERS(v_char_t)

#ifdef __cplusplus
public: /* The implementation is in C, so these need access. */
#endif /* defined __cplusplus */

    v_char_record

#ifdef __cplusplus

    /*! doc-ignore */
    v_char_t *it()             { return this; }

    /*! doc-ignore */
    v_char_t const *it() const { return this; }

/*--BEGIN-CLASS--*/
public:
#ifdef __cplusplus
#if !ERWIN_DEFAULT_NEW_DELETE
    static void *operator new(size_t);
    static void operator delete(void *, size_t);
    static void *operator new[](size_t);
    static void operator delete[](void *, size_t);
#endif
#endif

    /* Creation */

    v_char_t (void);

    static v_char_t const &static_zero();

#if V_CHAR_HAVE_INT_CONSTRUCTOR
    ERWIN_EXPLICIT v_char_t (v_char_cnt_t initial_size);
#endif
#if V_CHAR_DYN_ZERO
    ERWIN_EXPLICIT v_char_t (char );
    v_char_t (char , v_char_cnt_t);
#endif

    /*
     * Enforced vector copying.  All of the following functions create a new vector
     * and leave the old one (if any) intact.  It can be defined whether the elements
     * are to be copied. */

    v_char_t (v_char_t const *, bool do_copy V_CHAR_DEFAULT_ARG(true));

    v_char_t (v_char_t const *, v_char_index_t, v_char_cnt_t, bool do_copy V_CHAR_DEFAULT_ARG(true));

    v_char_t (char const *, bool do_copy V_CHAR_DEFAULT_ARG(true));
    v_char_t (char const *, v_char_cnt_t, bool do_copy V_CHAR_DEFAULT_ARG(true));

    /* The following is thought to be for coercing arrays to vectors.  The vector
     * then operates directly on the given array.  See v_char_new_from_raw for
     * details. */

    v_char_t (bool       /* must_be_true */,
              char * /* other */,
              v_char_cnt_t        /* count */,
              v_char_cnt_t        /* alloc */);
       /* alloc may be -1: see v_char_new_from_raw */

#if V_CHAR_DYN_ZERO
    v_char_t (bool         /* must_be_true */,
              char *   /* other */,
              v_char_cnt_t          /* count */,
              v_char_cnt_t          /* alloc */,
              char  /* zero_element */);
       /* alloc may be -1: see v_char_new_from_raw */
#endif

    v_char_t (bool       /* must_be_true */,
              v_char_t * /* other */);

    v_char_t (bool       /* must_be_true */,
              v_char_t & /* other */);

    void _constructor (void);
    void _destructor  (void);

    /* Check for NULL pointers */
protected:
#ifndef NDEBUG
    void cn() const;
    void cn(void const *) const;
#else
    /* Hopefully optimised away: */
    static void cn() {}
    static void cn(void const *) {}
#endif

public:
    /* Status code */

#if !ERWIN_GLOBAL_ERRNO
    int get_errno(void) const
    { return it()->m_errno; }

    void clear_errno(void) const
    { v_char_clear_errno (it()); }
#else
    static int get_errno(void)
    { return vector_errno; }

    static void clear_errno(void)
    { vector_errno= VECTOR_OK; }
#endif

    /* Copying */

    v_char_t (v_char_t const &, bool docopy V_CHAR_DEFAULT_ARG(true));
    v_char_t (v_char_t const &, v_char_index_t, v_char_cnt_t, bool do_copy V_CHAR_DEFAULT_ARG(true));

    v_char_t *copy (void) const
    {
        if (this == NULL)
            return NULL;
        return new v_char_t (it(), true);
    }

    v_char_t *copy_err (int *err) const
    {
        if (this == NULL) /* special case for copy function */
            return NULL;
        v_char_t *result= new v_char_t (it(), true);
        if (err != NULL && VECTOR_IS_ERROR (get_errno()))
            *err= 1;
        return result;
    }

    /* The following functions assume that v_char_t and v_char_t are the
     * same type making things more easy.  Since they did not exist in pre 2.0.265,
     * we can simply not declare them when the compat is define. */

    v_char_t *copy_detach()
    {
        return v_char_new_from_vector (it());
    }

    v_char_t &xchg(v_char_t *other)
    {
        v_char_xchg (it(), other);
        return *this;
    }

    v_char_t &xchg(v_char_t &other)
    {
        v_char_xchg (this, &other);
        return *this;
    }

    /* Normal members */

    v_char_t *subvector (v_char_index_t b, v_char_cnt_t c) const
    {
        return new v_char_t (this, b, c, true);
    }

    v_char_t *subvector (v_char_index_t b, v_char_cnt_t c, bool d) const
    {
        return new v_char_t (this, b, c, d);
    }


    /* Assignment */

    v_char_t &operator=(v_char_t const &);
    v_char_t &operator=(v_char_t const *);

    /* Destruction */

    ~v_char_t ();

    /* Re-init by dropping responsibility for the table: */

    v_char_t &detach (void)
    { v_char_detach (it()); return *this; }

    v_char_t &detach_as_is (void)
    { v_char_detach_as_is (it()); return *this; }

    /* Conversion to C type <= 2.0.264 / conversion to pointer > 2.0.264 */

    operator v_char_t const *() const
    { return it(); }

    operator v_char_t *()
    { return it(); }

    /* operator int () const { cn(); return get_errno(); }
     * FIXME: maybe add this one day.  It produces invisible semantics changes with
     * old versions when 'explicit' is used as well. */

#if V_CHAR_MANY_CASTS != 0
    operator v_char_element_ptr_t () const
    { return as_array(); }

    operator bool () const
    { return !empty(); }
#endif

#if V_CHAR_POSITION_POINTER
    v_char_index_t *pos_ptr ()                 { return &m_pos; }
    v_char_index_t &pos_ref ()                 { return m_pos;  }
    v_char_index_t  pos     ()                 { return m_pos;  }
    void            set_pos (v_char_index_t y) { m_pos= y;      }
#endif

    char  nth (v_char_index_t i) const
    {
#ifdef V_CHAR_INLINE__NTH
        cn();
        return m_table[i];
#else
        return v_char_nth (it(), i);
#endif
    }

    char  nth_char (v_char_index_t i) const
    { return v_char_nth_char (it(), i); }

    v_char_element_ptr_t nth_ptr_check (v_char_index_t i)
    {
        return v_char_nth_ptr_check (it(), i);
    }

    char const *nth_ptr_check (v_char_index_t i) const
    {
        return v_char_nth_ptr_check_const (it(), i);
    }

    v_char_element_ptr_t nth_ptr_char (v_char_index_t i)
    {
        return v_char_nth_ptr_char (it(), i);
    }

    char const *nth_ptr_char (v_char_index_t i) const
    {
        return v_char_nth_ptr_char_const (it(), i);
    }

    v_char_element_ptr_t nth_ptr (v_char_index_t i)
    {
        return v_char_nth_ptr (it(), i);
    }

    char const *nth_ptr (v_char_index_t i) const
    {
        return v_char_nth_ptr_const (it(), i);
    }

    v_char_element_ref_t nth_ref (v_char_index_t i)
    {
        return *(v_char_nth_ptr (it(), i));
    }

    char const &nth_ref (v_char_index_t i) const
    {
        return *(v_char_nth_ptr_const (it(), i));
    }

    v_char_element_ref_t nth_ref_check (v_char_index_t i)
    {
        return *(v_char_nth_ptr_check (it(), i));
    }

    char const &nth_ref_check (v_char_index_t i) const
    {
        return *(v_char_nth_ptr_check_const (it(), i));
    }

    v_char_element_ref_t nth_ref_char (v_char_index_t i)
    {
        return *(v_char_nth_ptr_char (it(), i));
    }

    char const &nth_ref_char (v_char_index_t i) const
    {
        return *(v_char_nth_ptr_char_const (it(), i));
    }



    char  operator[] (v_char_index_t i) const
    { return nth_char (i); }

    v_char_element_ref_t operator[] (v_char_index_t i)
    { return *nth_ptr_char (i); }


    char  first (void) const
    {
        return nth (0);
    }

    v_char_element_ptr_t first_ptr ()
    {
        return v_char_first_ptr (it());
    }

    v_char_element_ref_t first_ref ()
    {
        return *(v_char_first_ptr (it()));
    }

    char  last (void) const
    {
        return nth (nentries()-1);
    }

    v_char_element_ptr_t last_ptr ()
    {
        return v_char_last_ptr (it());
    }

    v_char_element_ref_t last_ref ()
    {
        return *(v_char_last_ptr (it()));
    }

    char modify (v_char_index_t i, char  v)
    { return v_char_modify (it(), i, v); }

    v_char_t &reverse (void)
    {
        v_char_reverse (it());
        return *this;
    }

    char last_chop1 (void)
    {
        return v_char_last_chop1 (it());
    }

    char first_swap_chop1 (void)
    {
        return v_char_first_swap_chop1 (it());
    }

    /* Set */

    v_char_t &set (v_char_index_t i, char  v)
    { v_char_set (it(), i, v); return *this; }

    /* Erase family */

    v_char_t &swap_erase (v_char_index_t i, v_char_cnt_t n = -1)
    { v_char_swap_erase (it(), i, n); return *this; }


    v_char_t &swap_erase (v_char_index_t i, v_char_cnt_t n, bool a, bool b=true)
    {
        v_char_swap_erase_flags (it(), i, n, a, b);
        return *this;
    }

    v_char_t &erase (v_char_index_t i, v_char_cnt_t n = -1)
    { v_char_erase (it(), i, n); return *this; }


    v_char_cnt_t erase_zero ()
    {
        return v_char_erase_zero (it());
    }

    v_char_t &erase (v_char_index_t i, v_char_cnt_t n, bool a, bool b=true)
    {
        v_char_erase_flags (it(), i, n, a, b);
        return *this;
    }

    v_char_cnt_t erase_if (v_char_feature_t f,
                  bool inv V_CHAR_DEFAULT_ARG(true),
                  bool a   V_CHAR_DEFAULT_ARG(true),
                  bool b   V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_erase_if_flags (it(), f, inv,a,b);
    }

    v_char_cnt_t erase_if_not (
                  v_char_feature_t f,
                  bool inv V_CHAR_DEFAULT_ARG(true),
                  bool a   V_CHAR_DEFAULT_ARG(true),
                  bool b   V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_erase_if_flags (it(), f, !inv, a, b);
    }

    v_char_cnt_t erase_equals (v_char_cmp_t fcmp V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL),
                      v_char_combine_t combine V_CHAR_DEFAULT_ARG(V_CHAR_COMBINE_T_NULL))
    {
        return v_char_erase_equals (it(), fcmp, combine);
    }


    v_char_t &swap_chop (v_char_cnt_t n V_CHAR_DEFAULT_ARG(1))
    {
        v_char_swap_erase (it(), 0, n);
        return *this;
    }

    v_char_t &swap_chop (bool a, bool b V_CHAR_DEFAULT_ARG(true))
    {
        v_char_swap_erase_flags (it(), 0, 1, a, b);
        return *this;
    }
    v_char_t &swap_chop (v_char_cnt_t n, bool a, bool b V_CHAR_DEFAULT_ARG(true))
    {
        v_char_swap_erase_flags (it(), 0, n, a, b);
        return *this;
    }

    v_char_t &chop (v_char_cnt_t n V_CHAR_DEFAULT_ARG(1))
    {
        v_char_chop (it(), n);
        return *this;
    }

    v_char_t &chop (bool a, bool b V_CHAR_DEFAULT_ARG(true))
    {
        v_char_chop_flags (it(), 1, a, b);
        return *this;
    }
    v_char_t &chop (v_char_cnt_t n, bool a, bool b V_CHAR_DEFAULT_ARG(true))
    {
        v_char_chop_flags (it(), n, a, b);
        return *this;
    }

    v_char_t &prepend (char  a)
    { v_char_insert (it(), 0, a); return *this; }

    v_char_t &prepend_raw     (char const *a, v_char_cnt_t n)
    { v_char_insert_raw (it(), 0, a, n); return *this; }

    v_char_t &prepend_no_copy (char const *a, v_char_cnt_t n)
    { v_char_insert_no_copy (it(), 0, a, n); return *this; }

    v_char_t &prepend_vector  (v_char_t const *a)
    { v_char_insert_vector (it(), 0, a->it()); return *this; }

    v_char_t &prepend_vector  (v_char_t const &a)
    { v_char_insert_vector (it(), 0, a.it()); return *this; }

    v_char_t &prepend_string  (char const *a)
    { v_char_insert_string (it(), 0, a); return *this; }


    v_char_t &append (char  a)
    { v_char_append (it(), a); return *this; }

    v_char_t &append_raw     (char const *a, v_char_cnt_t n)
    { v_char_append_raw (it(), a, n); return *this; }

    v_char_t &append_no_copy (char const *a, v_char_cnt_t n)
    { v_char_append_no_copy (it(), a, n); return *this; }

    v_char_t &append_vector  (v_char_t const *a)
    { v_char_append_vector (it(), a->it()); return *this; }

    v_char_t &append_vector  (v_char_t const &a)
    { v_char_append_vector (it(), a.it()); return *this; }

    v_char_t &append_string  (char const *a)
    { v_char_append_string (it(), a); return *this; }

    v_char_t &append_subvector (
        v_char_t const &a,
        v_char_index_t b,
        v_char_cnt_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (0, a, b, c, d);
    }

    v_char_t &append_subvector (
        v_char_t const *a,
        v_char_index_t b,
        v_char_cnt_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (0, a, b, c, d);
    }

#if V_CHAR_DIRECT_RECURSION == 0
    /* The following function is really bad when format() is defined and you mix up
       append and format.

       Compare:
            : v->append ("There are many pieces");
            : v->format ("There are many pieces");

       These are equivalent.  I would choose to use append here.  But look at this:
            : v->append ("There are %d pieces", i);
            : v->format ("There are %d pieces", i);

       Of course, the second one was meant here.  This is an easy typo the compiler
       cannot warn about.

       Therefore, Erwin does not implement the following function.  It is still
       available via append_raw.
    */

    /*
    int append (char const *a, int n)
    { return v_char_append_raw (it(), a, n); }
    */

    v_char_t &prepend (v_char_t const *a)
    { v_char_insert_vector (it(), 0, a->it()); return *this; }

    v_char_t &prepend (v_char_t const &a)
    { v_char_insert_vector (it(), 0, a.it()); return *this; }

    v_char_t &prepend (char const *a)
    { v_char_insert_string (it(), 0, a); return *this; }

    v_char_t &append (v_char_t const *a)
    { v_char_append_vector (it(), a->it()); return *this; }

    v_char_t &append (v_char_t const &a)
    { v_char_append_vector (it(), a.it()); return *this; }

    v_char_t &append (char const *a)
    { v_char_append_string (it(), a); return *this; }

    v_char_t &operator<< (char const *a)
    { v_char_append_string (it(), a); return *this; }

   /* For the same reason as the one above, we will not implement the following functions, since
    * the second one may be invoked for append ("Test", 4) with an autocast.  You will then
    * effectively append "", which is probably not what you want.  The first one is
    * not implemented for symmetry reasons.

    v_char_t &append (
        v_char_t const *a,
        v_char_index_t b,
        v_char_index_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        return append_subvector (a, b, c, d);
    }

    v_char_t &append (
        v_char_t const &a,
        v_char_index_t b,
        v_char_index_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        return append_subvector (a, b, c, d);
    }
    */

#endif /* V_CHAR_DIRECT_RECURSION == 0*/

    v_char_t &operator<< (char  a)
    { v_char_append (it(), a); return *this; }

    v_char_t &operator<< (v_char_t const*a)
    { v_char_append_vector (it(), a->it()); return *this; }

    v_char_t &operator<< (v_char_t const&a)
    { v_char_append_vector (it(), a.it()); return *this; }

    /* Find family */

    v_char_index_t find (char  needle) const
    { return v_char_find (it(), 0, needle); }

    v_char_index_t find_raw (char const *needle, v_char_cnt_t n) const
    { return v_char_find_raw (it(), 0, needle, n); }

    v_char_index_t find_string (char const *needle) const
    { return v_char_find_raw (it(), 0, needle, string_length (needle)); }

    v_char_index_t find_vector (v_char_t const &needle) const
    { return v_char_find_raw (it(), 0, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t find_vector (v_char_t const *needle) const
    { return v_char_find_raw (it(), 0, needle->it()->m_table, needle->it()->m_nentries); }

#if V_CHAR_DIRECT_RECURSION == 0
    v_char_index_t find (char const *needle, v_char_cnt_t n) const
    { return v_char_find_raw (it(), 0, needle, n); }

    v_char_index_t find (char const *needle) const
    { return v_char_find_raw (it(), 0, needle, string_length (needle)); }

    v_char_index_t find (v_char_t const &needle) const
    { return v_char_find_raw (it(), 0, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t find (v_char_t const *needle) const
    { return v_char_find_raw (it(), 0, needle->it()->m_table, needle->it()->m_nentries); }
#endif

    v_char_index_t find (v_char_index_t a, char  needle) const
    { return v_char_find (it(), a, needle); }

    v_char_index_t find_raw (v_char_index_t a, char const *needle, v_char_cnt_t n) const
    { return v_char_find_raw (it(), a, needle, n); }

    v_char_index_t find_string (v_char_index_t a, char const *needle) const
    { return v_char_find_raw (it(), a, needle, string_length (needle)); }

    v_char_index_t find_vector (v_char_index_t a, v_char_t const &needle) const
    { return v_char_find_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t find_vector (v_char_index_t a, v_char_t const *needle) const
    { return v_char_find_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }

#if V_CHAR_DIRECT_RECURSION == 0
    v_char_index_t find (v_char_index_t a, char const *needle, v_char_cnt_t n) const
    { return v_char_find_raw (it(), a, needle, n); }

    v_char_index_t find (v_char_index_t a, char const *needle) const
    { return v_char_find_raw (it(), a, needle, string_length (needle)); }

    v_char_index_t find (v_char_index_t a, v_char_t const &needle) const
    { return v_char_find_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t find (v_char_index_t a, v_char_t const *needle) const
    { return v_char_find_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }
#endif

    /* rFind family */

    v_char_index_t rfind  (char  needle) const
    { return v_char_rfind (it(), -1, needle); }

    v_char_index_t rfind_raw  (char const *needle, v_char_cnt_t n) const
    { return v_char_rfind_raw (it(), -1, needle, n); }

    v_char_index_t rfind_string (char const *needle) const
    { return v_char_rfind_raw (it(), -1, needle, string_length (needle)); }

    v_char_index_t rfind_vector (v_char_t const &needle) const
    { return v_char_rfind_raw (it(), -1, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t rfind_vector (v_char_t const *needle) const
    { return v_char_rfind_raw (it(), -1, needle->it()->m_table, needle->it()->m_nentries); }

#if V_CHAR_DIRECT_RECURSION == 0
    v_char_index_t rfind (char const *needle, v_char_cnt_t n) const
    { return v_char_rfind_raw (it(), -1, needle, n); }

    v_char_index_t rfind (char const *needle) const
    { return v_char_rfind_raw (it(), -1, needle, string_length (needle)); }

    v_char_index_t rfind (v_char_t const &needle) const
    { return v_char_rfind_raw (it(), -1, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t rfind (v_char_t const *needle) const
    { return v_char_rfind_raw (it(), -1, needle->it()->m_table, needle->it()->m_nentries); }
#endif

    v_char_index_t rfind  (v_char_index_t a, char  needle) const
    { return v_char_rfind (it(), a, needle); }

    v_char_index_t rfind_raw  (v_char_index_t a, char const *needle, v_char_cnt_t n) const
    { return v_char_rfind_raw (it(), a, needle, n); }

    v_char_index_t rfind_string  (v_char_index_t a, char const *needle) const
    { return v_char_rfind_raw (it(), a, needle, string_length (needle)); }

    v_char_index_t rfind_vector (v_char_index_t a, v_char_t const &needle) const
    { return v_char_rfind_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t rfind_vector (v_char_index_t a, v_char_t const *needle) const
    { return v_char_rfind_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }

#if V_CHAR_DIRECT_RECURSION == 0
    v_char_index_t rfind (v_char_index_t a, char const *needle, v_char_cnt_t n) const
    { return v_char_rfind_raw (it(), a, needle, n); }

    v_char_index_t rfind (v_char_index_t a, char const *needle) const
    { return v_char_rfind_raw (it(), a, needle, string_length (needle)); }

    v_char_index_t rfind (v_char_index_t a, v_char_t const &needle) const
    { return v_char_rfind_raw (it(), a, needle.it()->m_table, needle.it()->m_nentries); }

    v_char_index_t rfind (v_char_index_t a, v_char_t const *needle) const
    { return v_char_rfind_raw (it(), a, needle->it()->m_table, needle->it()->m_nentries); }
#endif


    /* is_equal_at family
     * FIXME: Some functions are missing.  Compare to overwrite.  This is because
     *        the C function has a bad calling convention.  This must be fixed in
     *        the next major release of Erwin. */

    bool is_equal_at_raw (v_char_index_t a, char const *b, v_char_cnt_t n) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b, n)); }

    bool is_equal_at_string (v_char_index_t a, char const *b) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b, string_length (b))); }

    bool is_equal_at_vector (v_char_index_t a, v_char_t const &b) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b.it()->m_table, b.it()->m_nentries)); }

    bool is_equal_at_vector (v_char_index_t a, v_char_t const *b) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b->it()->m_table, b->it()->m_nentries)); }

#if V_CHAR_DIRECT_RECURSION == 0
    bool is_equal_at (v_char_index_t a, char const *b, v_char_cnt_t n) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b, n)); }

    bool is_equal_at (v_char_index_t a, char const *b) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b, string_length (b))); }

    bool is_equal_at (v_char_index_t a, v_char_t const &b) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b.it()->m_table, b.it()->m_nentries)); }

    bool is_equal_at (v_char_index_t a, v_char_t const *b) const
    { return ERWIN_TO_BOOL(v_char_is_equal_at (it(), a, b->it()->m_table, b->it()->m_nentries)); }
#endif

    v_char_index_t find_if (v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_find_if (it(), 0, feature, inverted);
    }

    v_char_index_t find_if (v_char_index_t start, v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_find_if (it(), start, feature, inverted);
    }

    v_char_index_t rfind_if (v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_rfind_if (it(), -1, feature, inverted);
    }

    v_char_index_t rfind_if (v_char_index_t start, v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_rfind_if (it(), start, feature, inverted);
    }

    /* Convenience functions */

    v_char_index_t find_if_not (v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_find_if (it(), 0, feature, !inverted);
    }

    v_char_index_t find_if_not (v_char_index_t start, v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_find_if (it(), start, feature, !inverted);
    }

    v_char_index_t rfind_if_not (v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_rfind_if (it(), -1, feature, !inverted);
    }

    v_char_index_t rfind_if_not (v_char_index_t start, v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        return v_char_rfind_if (it(), start, feature, !inverted);
    }

    /*  Trimming */

    v_char_t &ltrim_if (v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        v_char_ltrim_if (it(), feature, inverted);
        return *this;
    }

    v_char_t &ltrim_if_not (v_char_feature_t feature, bool inverted V_CHAR_DEFAULT_ARG(true))
    {
        v_char_ltrim_if (it(), feature, !inverted);
        return *this;
    }

    v_char_t &rtrim_if (v_char_feature_t feature, bool inv V_CHAR_DEFAULT_ARG (true))
    {
        v_char_rtrim_if (it(), feature, inv);
        return *this;
    }

    v_char_t &rtrim_if_not (v_char_feature_t feature, bool inv V_CHAR_DEFAULT_ARG (true))
    {
        v_char_rtrim_if (it(), feature, !inv);
        return *this;
    }

    v_char_t &trim_if (v_char_feature_t feature, bool inv V_CHAR_DEFAULT_ARG (true))
    {
        v_char_trim_if (it(), feature, inv);
        return *this;
    }

    v_char_t &trim_if_not (v_char_feature_t feature, bool inv V_CHAR_DEFAULT_ARG (true))
    {
        v_char_trim_if (it(), feature, !inv);
        return *this;
    }

    /* Mapping */

    v_char_t &map (v_char_map_t fmap)
    {
        v_char_map (it(), fmap);
        return *this;
    }

    v_char_t &ltrim (void)
    { v_char_ltrim (it()); return *this; }

    v_char_t &rtrim (void)
    { v_char_rtrim (it()); return *this; }

    v_char_t &trim  (void)
    { v_char_trim (it()); return *this; }

    v_char_t &chomp (void)
    { v_char_chomp (it()); return *this; }

    v_char_t &to_upper (void)
    {
        v_char_to_upper (it());
        return *this;
    }

    v_char_t &to_lower (void)
    {
        v_char_to_lower (it());
        return *this;
    }

    /* Additional operators for appending strings to the vector. */
#ifdef ERWIN_UNSIGNED_LONG_LONG
    v_char_t &operator<< (ERWIN_UNSIGNED_LONG_LONG  a)  { format("%Lu",a); return *this; }
    v_char_t &operator<< (ERWIN_LONG_LONG           a)  { format("%Ld",a); return *this; }
#endif

    v_char_t &operator<< (unsigned long  a)    { format("%lu",a);          return *this; }
    v_char_t &operator<< (signed long    a)    { format("%ld",a);          return *this; }
    v_char_t &operator<< (unsigned int   a)    { format("%u", a);          return *this; }
    v_char_t &operator<< (signed int     a)    { format("%d", a);          return *this; }

    v_char_t &operator<< (double         a)    { format("%g", a);          return *this; }

    v_char_t &operator<< (void *         a)    { format("%p", a);          return *this; }

    v_char_t &operator<< (unsigned short a)    { return operator<< ((unsigned int) a); }
    v_char_t &operator<< (signed short   a)    { return operator<< ((signed   int) a); }

    v_char_t &operator<< (bool a)
    {
        append((char const *)(a ? "true" : "false"));
        return *this;
    }

    /* The stringify() family is for creating vectors from printing values.
     * It was mainly added to make it easier to handle different types of
     * integers without the user needing to know the exact type when using
     * printf-like functions.
     *
     *    fprintf (f, "Number of things: %s\n", +VChar::stringify(thing_count));
     *
     * The stringify() family is also suited for lazy people who want to do
     * something like:
     *
     *   #define _S   +VChar::stringify
     *   #define _F   +VChar().format
     *
     * _S is especially handy when the precise integer type is unknown and you
     * must print via C-style formating.  E.g. you can use:
     *
     *    fprintf (f, "Number of things: %s\n", _S(thing_count));
     *
     * Here, no need to bother about %d vs. %ld vs. %Ld etc.
     *
     * Furthermore, it was decided against having a Qt-like parameter list
     * as QString::arg()), because the primary usage is different: for arg(),
     * you specify the print width in the arg() call while for stringify(),
     * it is cleaner to specify it in the printf-like format string:
     *
     *      printf ("Length: %10s bytes\n", _S(count));
     * vs.
     *      QString("Length: %1 byets\n").arg(count,10)
     *
     * So the width argument is less important for stringify().
     * However, we do want easy access to the base argument for ints,
     * so we move the width (and precision) to the end of the parameter
     * list, and have the base as second for integer arguments.
     *
     * Further, we want the other options arguments to make it easy to
     * quote on the fly.  The options argument will be just after the
     * base (if present).
     *
     *      printf ("Key and value are: %s=%s",
     *          _S(key), _S(value, FO_QUOTE_C_STRING));
     *
     *      printf ("Count: %s", _S(count, 10, FO_USE_SEP_(' ')));
     *
     * For integers, a base of 0 will be interpreted like 10.
     *
     * Also note that zero padding of numbers can be achievd by increasing
     * the precision instead of the width:
     *
     *      _S(5)          = "5"
     *      _S(5,10,0,5,0) = "    5"
     *      _S(5,10,0,0,5) = "00005"
     *
     * For 'double' variant of stringify(), the char argument which may
     * be 'e', 'f', 'g', or 'a' will take the place of the base argument.
     */

#ifdef ERWIN_UNSIGNED_LONG_LONG
    static v_char_t stringify (
        ERWIN_UNSIGNED_LONG_LONG a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options | FO_RADIX(base), "%*.*Lu", width, prec, a);
    }

    static v_char_t stringify (
        ERWIN_LONG_LONG a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options | FO_RADIX(base), "%*.*Ld", width, prec, a);
    }
#endif

    static v_char_t stringify (
        unsigned long a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options | FO_RADIX(base), "%*.*lu", width, prec, a);
    }

    static v_char_t stringify (
        long a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options | FO_RADIX(base), "%*.*ld", width, prec, a);
    }

    static v_char_t stringify (
        unsigned a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((unsigned long)a,base,options,width,prec);
    }

    static v_char_t stringify (
        int a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((long)a,base,options,width,prec);
    }

    static v_char_t stringify (
        unsigned short a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((unsigned long)a,base,options,width,prec);
    }

    static v_char_t stringify (
        short a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((long)a,base,options,width,prec);
    }

#if 0
    /* Must be explicitly typecast to int to make clear code. */
    static v_char_t stringify (
        unsigned char a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((unsigned long)a,base,options,width,prec);
    }

    static v_char_t stringify (
        signed char a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((long)a,base,options,width,prec);
    }
#endif

    static v_char_t stringify (
        double a, int base = 0, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options | FO_RADIX(base), "%*.*lg", width, prec, a);
    }

    static v_char_t stringify (char a, int options = 0, int width = 0)
    {
        return v_char_t().format(options, "%*c", width, a);
    }

    static v_char_t stringify (char const *a, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options, "%*.*s", width, prec, a);
    }

#ifdef ERWIN_WIDE_CHARACTERS
    static v_char_t stringify (wchar_t const *a, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options, "%*.*ls", width, prec, a);
    }
#endif

    static v_char_t stringify (v_char_t const *a, int options = 0, int width = 0, int prec = -1)
    {
        return v_char_t().format(options | FO_VECTOR, "%*.*s",
            width, prec, (char const *)a);
            /* We are using %s to pass the vector to be able to use the precision
             * with a gcc warning.  Both %p and %s honour the FO_VECTOR flag. */
    }

    static v_char_t stringify (v_char_t const &a, int options = 0, int width = 0, int prec = -1)
    {
        return stringify(&a, options, width, prec);
    }

    static v_char_t stringify (bool a, int options = 0, int width = 0, int prec = -1)
    {
        return stringify((char const *)(a ? "true" : "false"), options, width, prec);
    }


    int fread (FILE *fileptr, v_char_cnt_t max_count V_CHAR_DEFAULT_ARG(-1))
    {
        return v_char_fread (it(), fileptr, max_count);
    }

    v_char_t &fgets (FILE *fileptr, v_char_cnt_t max_count V_CHAR_DEFAULT_ARG(-1))
    {
        v_char_fgets (it(), fileptr, max_count);
        return *this;
    }

    v_char_index_t basename_index (void) const
    {
        return v_char_basename_index (it());
    }

    void basename_range (v_char_index_t &no1, v_char_cnt_t &length) const
    {
        v_char_basename_range (&no1, &length, it());
    }

    v_char_t &append_directory (v_char_t const &other)
    {
        v_char_append_directory (it(), other.it());
        return *this;
    }

    v_char_t &append_directory (v_char_t const *other)
    {
        v_char_append_directory (it(), other->it());
        return *this;
    }

    v_char_t &append_basename (v_char_t const &other)
    {
        v_char_append_basename (it(), other.it());
        return *this;
    }

    v_char_t &append_basename (v_char_t const *other)
    {
        v_char_append_basename (it(), other->it());
        return *this;
    }

    v_char_t &append_config_file_name (
        char const *progname,
        bool local V_CHAR_DEFAULT_ARG(false))
    {
        v_char_append_config_file_name (it(), progname, local);
        return *this;
    }


#if V_CHAR_NO_FORMAT == 0
    v_char_t &format  (char const *, ...) ATTR_FORMAT_PRINTF  (2, 3);
    v_char_t &vformat (char const *, va_list) ATTR_FORMAT_VPRINTF (2);

    /* functions with option argument: */
    v_char_t &format  (unsigned long, char const *, ...)     ATTR_FORMAT_PRINTF  (3, 4);
    v_char_t &vformat (unsigned long, char const *, va_list) ATTR_FORMAT_VPRINTF (3);

    /* function with returned info */
    v_char_t &format  (v_char_format_info_t *, char const *, ...)      ATTR_FORMAT_PRINTF  (3, 4);
    v_char_t &vformat (v_char_format_info_t *, char const *, va_list)  ATTR_FORMAT_VPRINTF (3);

    /* functions with returned info and option argument: */
    v_char_t &format  (v_char_format_info_t *, unsigned long, char const *, ...)     ATTR_FORMAT_PRINTF  (4, 5);
    v_char_t &vformat (v_char_format_info_t *, unsigned long, char const *, va_list) ATTR_FORMAT_VPRINTF (4);

#if ERWIN_GLOBAL_ERRNO
    static bool format_quoted () ATTR_DEPRECATED;
    static v_char_index_t format_pos () ATTR_DEPRECATED;
#endif

#endif /* V_CHAR_NO_FORMAT */

    v_char_t &make_gap (v_char_index_t a, v_char_cnt_t b)
    {
        v_char_make_gap (it(), a, b);
        return *this;
    }

    v_char_t &make_gap (v_char_index_t a, char  x, v_char_cnt_t b)
    {
        v_char_make_gap_with (it(), a, x, b);
        return *this;
    }

    /* compatibility function */
    v_char_t &make_gap_with (v_char_index_t a, char  x, v_char_cnt_t b)
    {
        return make_gap (a, x, b);
    }

    char  zero (void) const
    { return v_char_zero (it()); }

    /* Overwrite family */

    v_char_t &overwrite (
        v_char_index_t i,
        v_char_t const *a,
        v_char_index_t ia,
        v_char_cnt_t n)
    {
        v_char_overwrite (it(), i, a->it(), ia, n);
        return *this;
    }

    v_char_t &overwrite (
        v_char_index_t i,
        v_char_t const &a,
        v_char_index_t ia,
        v_char_cnt_t n)
    {
        v_char_overwrite (it(), i, a.it(), ia, n);
        return *this;
    }

    v_char_t &overwrite_raw (v_char_index_t i, char const *a, v_char_cnt_t n)
    {
        v_char_overwrite_raw (it(), i, a, n);
        return *this;
    }

    v_char_t &overwrite_string (v_char_index_t i, char const *a)
    {
        v_char_overwrite_string (it(), i, a);
        return *this;
    }

    v_char_t &overwrite_vector (v_char_index_t i, v_char_t const *a)
    {
        v_char_overwrite_vector (it(), i, a->it());
        return *this;
    }

    v_char_t &overwrite_vector (v_char_index_t i, v_char_t const &a)
    {
        v_char_overwrite_vector (it(), i, a.it());
        return *this;
    }

    v_char_t &overwrite_flags (v_char_index_t i, char const *a, v_char_cnt_t n, bool dealloc, bool docopy)
    {
        v_char_overwrite_flags (it(), i, a, n, dealloc, docopy);
        return *this;
    }

#if V_CHAR_DIRECT_RECURSION == 0
    v_char_t &overwrite (v_char_index_t i, char const *a, v_char_cnt_t n)
    {
        v_char_overwrite_raw (it(), i, a, n);
        return *this;
    }

    v_char_t &overwrite (v_char_index_t i, char const *a)
    {
        v_char_overwrite_string (it(), i, a);
        return *this;
    }

    v_char_t &overwrite (v_char_index_t i, v_char_t const *a)
    {
        v_char_overwrite_vector (it(), i, a->it());
        return *this;
    }

    v_char_t &overwrite (v_char_index_t i, v_char_t const &a)
    {
        v_char_overwrite_vector (it(), i, a.it());
        return *this;
    }
#endif

    /* Insert family */

    v_char_t &insert (v_char_index_t i, char  a)
    {
        v_char_insert (it(), i, a);
        return *this;
    }

    v_char_t &insert_raw (v_char_index_t i, char const *a, v_char_cnt_t n)
    {
        v_char_insert_raw (it(), i, a, n);
        return *this;
    }

    v_char_t &insert_no_copy (v_char_index_t i, char const *a, v_char_cnt_t n)
    {
        v_char_insert_no_copy (it(), i, a, n);
        return *this;
    }

    v_char_t &insert_string (v_char_index_t i, char const *a)
    {
        v_char_insert_string (it(), i, a);
        return *this;
    }

    v_char_t &insert_vector (v_char_index_t i, v_char_t const *a)
    {
        v_char_insert_vector (it(), i, a->it());
        return *this;
    }

    v_char_t &insert_vector (v_char_index_t i, v_char_t const &a)
    {
        v_char_insert_vector (it(), i, a.it());
        return *this;
    }

    v_char_t &insert_subvector (
        v_char_index_t i,
        v_char_t const *a,
        v_char_index_t b V_CHAR_DEFAULT_ARG (0),
        v_char_cnt_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        v_char_insert_subvector (it(), i, a->it(), b, c, d ? ERWIN_TRUE : ERWIN_FALSE);
        return *this;
    }

    v_char_t &insert_subvector (
        v_char_index_t i,
        v_char_t const &a,
        v_char_index_t b V_CHAR_DEFAULT_ARG (0),
        v_char_cnt_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        v_char_insert_subvector (it(), i, a.it(), b, c, d ? ERWIN_TRUE : ERWIN_FALSE);
        return *this;
    }

#if V_CHAR_DIRECT_RECURSION == 0
    v_char_t &insert (
        v_char_index_t i,
        v_char_t const &a,
        v_char_index_t b,
        v_char_cnt_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (i, a, b, c, d);
    }

    v_char_t &insert (
        v_char_index_t i,
        v_char_t const *a,
        v_char_index_t b,
        v_char_cnt_t c V_CHAR_DEFAULT_ARG (-1),
        ERWIN_BOOL d V_CHAR_DEFAULT_ARG (ERWIN_TRUE))
    {
        return insert_subvector (i, a, b, c, d);
    }

    v_char_t &insert (v_char_index_t i, char const *a, v_char_cnt_t n)
    {
        v_char_insert_raw (it(), i, a, n);
        return *this;
    }

    v_char_t &insert (v_char_index_t i, char const *a)
    {
        v_char_insert_string (it(), i, a);
        return *this;
    }

    v_char_t &insert (v_char_index_t i, v_char_t const *a)
    {
        v_char_insert_vector (it(), i, a->it());
        return *this;
    }
                                       
    v_char_t &insert (v_char_index_t i, v_char_t const &a)
    {
        v_char_insert_vector (it(), i, a.it());
        return *this;
    }

#endif

    v_char_cnt_t string_length (char const *a) const
    {
        return v_char_string_length (it(), a);
    }

    v_char_t &ensure_size (v_char_cnt_t a)
    { v_char_ensure_size (it(), a); return *this; }

    v_char_t &ensure_size (v_char_cnt_t a, char  b)
    { v_char_ensure_size_with (it(), a, b); return *this; }

    v_char_t &set_size (v_char_cnt_t a)
    { v_char_set_size (it(), a); return *this; }

    v_char_t &set_size (v_char_cnt_t a, char  b)
    { v_char_set_size_with (it(), a, b); return *this; }

    int ensure_table_size (v_char_cnt_t a)
    { return v_char_ensure_table_size (it(), a); }

    v_char_element_ptr_t as_array (void) const
    { return v_char_as_array (it()); }

    v_char_element_ptr_t as_open_array (void) const
    { return v_char_as_open_array (it()); }

    v_char_element_ptr_t as_array_detach (void)
    { return v_char_as_array_detach (it()); }

    v_char_t &ensure_heap_storage(void)
    {
        v_char_ensure_heap_storage (it());
        return *this;
    }

    bool has_heap_storage() const
    {
        return v_char_has_heap_storage (it());
    }

    static v_char_cnt_t inline_store_cnt()
    {
        return  v_char_inline_store_cnt();
    }

    v_char_element_ptr_t as_open_array_detach (void)
    { return v_char_as_open_array_detach (it()); }

    v_char_element_ptr_t operator+(v_char_index_t i)
    { return  nth_ptr_char (i); }

#if ERWIN_IGNORE_BROKEN_MS_COMPILER
    char const *operator+(v_char_index_t i) const
    { return  (char const *)((VChar *)this)->nth_ptr_char (i); }
#endif

    v_char_element_ref_t operator*()
    { return *nth_ptr_char (0); }

#if ERWIN_IGNORE_BROKEN_MS_COMPILER
    char  operator*() const
    { return nth_char (0); }
#endif

    v_char_element_ptr_t operator+() const
    { return as_array(); }


    v_char_t &make_heap(v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_make_heap(it(), f);
        return *this;
    }

    v_char_index_t heap_left (v_char_index_t i) const
    {
        return v_char_heap_left(it(), i);
    }

    v_char_index_t heap_right (v_char_index_t i) const
    {
        return v_char_heap_right (it(), i);
    }

    v_char_index_t heap_father (v_char_index_t i) const
    {
        return v_char_heap_father (it(), i);
    }

    char heap_extract (v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        return v_char_heap_extract (it(), f);
    }

    v_char_t &heap_raise (v_char_index_t i, v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_heap_raise (it(), i, f);
        return *this;
    }

    v_char_t &heap_sink (v_char_index_t i, v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_heap_sink (it(), i, f);
        return *this;
    }

    v_char_t &heap_fix (v_char_index_t i, v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_heap_fix (it(), i, f);
        return *this;
    }

    v_char_t &heap_insert (
        char  elem, v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_heap_insert (it(), elem, f);
        return *this;
    }

    v_char_t &heap_erase (
        v_char_index_t i, v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_heap_erase (it(), i, f);
        return *this;
    }

    v_char_t &heap_sort (v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_heap_sort (it(), f);
        return *this;
    }


    v_char_t &qsort (v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_qsort (it(), f);
        return *this;
    }

    v_char_t &sort  (v_char_cmp_t f V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL))
    {
        v_char_sort (it(), f);
        return *this;
    }


    v_char_index_t  bfind (char  a, v_char_cmp_t f = NULL) const
    {
        return v_char_bfind (it(), a, f);
    }

    hashval_t hash_raw (void) const
    {
        return v_char_hash_raw (it());
    }

    hashval_t hash (void) const
    {
        return v_char_hash (it());
    }

    void init_iterator (v_char_index_t *a) const
    {
        v_char_init_iterator (it(), a);
    }

    bool next_iteration (v_char_index_t *a, char *b) const
    {
        return ERWIN_TO_BOOL(v_char_next_iteration  (it(), a, b));
    }

    bool next_iteration_ptr (v_char_index_t *a, char **b)
    {
        return ERWIN_TO_BOOL(v_char_next_iteration_ptr  (it(), a, b));
    }

    bool next_iteration_ptr (v_char_index_t *a, char const **b) const
    {
        return ERWIN_TO_BOOL(v_char_next_iteration_ptr_const  (it(), a, b));
    }

    void init_iterator_reverse (v_char_index_t *a) const
    {
        v_char_init_iterator_reverse (it(), a);
    }

    bool next_iteration_reverse (v_char_index_t *a, char *b) const
    {
        return ERWIN_TO_BOOL(v_char_next_iteration_reverse  (it(), a, b));
    }

    bool next_iteration_ptr_reverse (v_char_index_t *a, char **b)
    {
        return ERWIN_TO_BOOL(v_char_next_iteration_ptr_reverse  (it(), a, b));
    }

    bool next_iteration_ptr_reverse (v_char_index_t *a, char const **b) const
    {
        return ERWIN_TO_BOOL(v_char_next_iteration_ptr_const_reverse  (it(), a, b));
    }

    v_char_t &shrink(bool tight = true)
    {
        v_char_shrink(it(), tight ? ERWIN_TRUE : ERWIN_FALSE);
        return *this;
    }
    v_char_t &clear ()
    { v_char_clear (it()); return *this; }

    v_char_t &clear_keep (v_char_cnt_t n)
    { v_char_clear_keep (it(),n); return *this; }

    v_char_t &clear_no_resize ()
    { v_char_clear_no_resize (it()); return *this; }

    static void delete_array(v_char_element_ptr_t array)
    {
        v_char_delete_array(array);
    }

    v_char_t &clear (bool a, bool b=true)
    { v_char_clear_flags (it(), a, b); return *this; }

#ifdef V_CHAR_INLINE__NENTRIES
    v_char_cnt_t  nentries () const
    {
#ifdef V_CHAR_ALLOW_NULL
        if (this == NULL) return 0;
#endif
        return m_nentries;
    }
#else
    v_char_cnt_t nentries () const
    { return v_char_nentries (it()); }
#endif

    bool empty () const
    { return nentries() == 0; }

    bool non_empty () const
    { return !empty(); }

    v_char_cnt_t table_size () const
    { return v_char_table_size (it()); }

    int cmp (v_char_t const *other,           
             v_char_cmp_t fcmp V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL)) const
    {
        if (this == NULL)
            return other == NULL ? 0 : -1;
        if (other == NULL)
            return +1;
        return v_char_cmp(it(), other->it(), fcmp);
    }

    int cmp (v_char_t const &other,
             v_char_cmp_t cmp_func V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL)) const
    {
        return cmp (&other, cmp_func);
    }

    int priority_cmp (v_char_t const *other,
             v_char_cmp_t fcmp V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL)) const
    {
        if (this == NULL)
            return other == NULL ? 0 : -1;
        if (other == NULL)
            return +1;
        return v_char_priority_cmp(it(), other->it(), fcmp);
    }

    int priority_cmp (v_char_t const &other,
             v_char_cmp_t fcmp V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL)) const
    {
        return priority_cmp (&other, fcmp);
    }

    bool operator== (v_char_t const &b)
    { return cmp(b,V_CHAR_CMP_T_NULL) == 0; } /* see cmp() */

    bool operator== (v_char_t const *b)
    { return cmp(b,V_CHAR_CMP_T_NULL) == 0; } /* see cmp() */

    bool operator!= (v_char_t const &b)
    { return cmp(b,V_CHAR_CMP_T_NULL) != 0; } /* see cmp() */

    bool operator!= (v_char_t const *b)
    { return cmp(b,V_CHAR_CMP_T_NULL) != 0; } /* see cmp() */

    bool operator<= (v_char_t const &b)
    { return cmp(b,V_CHAR_CMP_T_NULL) <= 0; } /* see cmp() */

    bool operator<= (v_char_t const *b)
    { return cmp(b,V_CHAR_CMP_T_NULL) <= 0; } /* see cmp() */

    bool operator>= (v_char_t const &b)
    { return cmp(b,V_CHAR_CMP_T_NULL) >= 0; } /* see cmp() */

    bool operator>= (v_char_t const *b)
    { return cmp(b,V_CHAR_CMP_T_NULL) >= 0; } /* see cmp() */

    bool operator<  (v_char_t const &b)
    { return cmp(b,V_CHAR_CMP_T_NULL) < 0; }  /* see cmp() */

    bool operator<  (v_char_t const *b)
    { return cmp(b,V_CHAR_CMP_T_NULL) < 0; }  /* see cmp() */

    bool operator>  (v_char_t const &b)
    { return cmp(b,V_CHAR_CMP_T_NULL) > 0; }  /* see cmp() */

    bool operator>  (v_char_t const *b)
    { return cmp(b,V_CHAR_CMP_T_NULL) > 0; }  /* see cmp() */

    v_char_t &swap (v_char_index_t a, v_char_index_t b)
    {
        v_char_swap (it(), a, b);
        return *this;
    }

    bool locate (v_char_index_t &index, char  element, int how) const
    {
        return ERWIN_TO_BOOL(v_char_locate (&index, it(), element, V_CHAR_CMP_T_NULL, how));
    }

    bool locate (v_char_index_t &index,
                 char  element,
                 v_char_cmp_t fcmp V_CHAR_DEFAULT_ARG(V_CHAR_CMP_T_NULL),
                 int how V_CHAR_DEFAULT_ARG(0)) const
    {
        return ERWIN_TO_BOOL(v_char_locate (&index, it(), element, fcmp, how));
    }

/*--END-CLASS--*/

#endif /* defined __cplusplus */
};

#undef V_CHAR_LOCAL_WRAPPER

#ifdef __cplusplus


/* For nasty code like:
 *
 *    extern "C" {
 *    #include <erwin/erwin.h>
 *    ...
 *    }
 *
 * Yes, some people do such things.
 */
extern "C++" {
/* some nasty global functions that are useful e.g. for forall.  Note that these
 * are not local to one vector but will be overloaded by all different vector
 * instantiations. */

ERWIN_WRAPPER
v_char_t *erwin_ptr_of(v_char_t *x) { return x;  }

ERWIN_WRAPPER
v_char_t *erwin_ptr_of(v_char_t &x) { return &x; }

ERWIN_WRAPPER
v_char_t const *erwin_ptr_const_of (v_char_t const *x) { return x;  }

ERWIN_WRAPPER
v_char_t const *erwin_ptr_const_of (v_char_t const &x) { return &x; }
}


/* Forall macros for C++ */
#ifndef vector_forall
#define vector_forall(v,i,h)                                      \
            for(erwin_ptr_const_of(v)->init_iterator(&(i));       \
                erwin_ptr_const_of(v)->next_iteration(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr
#define vector_forall_ptr(v,i,h)                                \
            for(erwin_ptr_of(v)->init_iterator(&(i));           \
                erwin_ptr_of(v)->next_iteration_ptr(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr_const
#define vector_forall_ptr_const(v,i,h)                                \
            for(erwin_ptr_const_of(v)->init_iterator(&(i));           \
                erwin_ptr_const_of(v)->next_iteration_ptr(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_keys
#define vector_forall_keys(v,i) \
            for((i)=0; ((v_char_index_t)(i)) < erwin_ptr_const_of(v)->nentries(); (i)++)
#endif


#ifndef vector_forall_values
#define vector_forall_values(v,h)                                                         \
            for(v_char_index_t ERWIN_GENSYM(erwin_local_j)=-1;                                   \
                erwin_ptr_const_of(v)->next_iteration(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_values_ptr
#define vector_forall_values_ptr(v,h)                                                   \
            for(v_char_index_t ERWIN_GENSYM(erwin_local_j)=-1;                                            \
                erwin_ptr_of(v)->next_iteration_ptr(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_values_ptr_const
#define vector_forall_values_ptr_const(v,h)                                                   \
            for(v_char_index_t ERWIN_GENSYM(erwin_local_j)=-1;                                       \
                erwin_ptr_const_of(v)->next_iteration_ptr(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_reverse
#define vector_forall_reverse(v,i,h)                                      \
            for(erwin_ptr_const_of(v)->init_iterator_reverse(&(i));       \
                erwin_ptr_const_of(v)->next_iteration_reverse(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr_reverse
#define vector_forall_ptr_reverse(v,i,h)                                \
            for(erwin_ptr_of(v)->init_iterator_reverse(&(i));           \
                erwin_ptr_of(v)->next_iteration_ptr_reverse(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_ptr_const_reverse
#define vector_forall_ptr_const_reverse(v,i,h)                                \
            for(erwin_ptr_const_of(v)->init_iterator_reverse(&(i));           \
                erwin_ptr_const_of(v)->next_iteration_ptr_reverse(&(i),&(h)); \
                /* no stepper */)
#endif


#ifndef vector_forall_keys_reverse
#define vector_forall_keys_reverse(v,i) \
            for((i)=erwin_ptr_const_of(v)->nentries()-1; ((v_char_index_t)(i)) >= 0; (i)--)
#endif


#ifndef vector_forall_values_reverse
#define vector_forall_values_reverse(v,h)                                          \
            for(v_char_index_t ERWIN_GENSYM(erwin_local_j)=erwin_ptr_const_of(v)->nentries(); \
                erwin_ptr_const_of(v)                                              \
                     ->next_iteration_reverse(&ERWIN_GENSYM(erwin_local_j),&(h));         \
                /* no stepper */)
#endif

#ifndef vector_forall_values_ptr_reverse
#define vector_forall_values_ptr_reverse(v,h)                                 \
            for(v_char_index_t ERWIN_GENSYM(erwin_local_j)=                          \
                    erwin_ptr_const_of(v)->nentries();                        \
                erwin_ptr_of(v)                                               \
                    ->next_iteration_ptr_reverse(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif

#ifndef vector_forall_values_ptr_const_reverse
#define vector_forall_values_ptr_const_reverse(v,h)                           \
            for(v_char_index_t ERWIN_GENSYM(erwin_local_j)=                          \
                    erwin_ptr_const_of(v)->nentries();                        \
                erwin_ptr_const_of(v)                                         \
                    ->next_iteration_ptr_reverse(&ERWIN_GENSYM(erwin_local_j),&(h)); \
                /* no stepper */)
#endif

#endif /* defined __cplusplus */

/* ********************************************************************** */
/* Inline implementations: */

#if V_CHAR_POSITION_POINTER

ERWIN_WRAPPER v_char_index_t *v_char_pos_ptr (v_char_t *);
ERWIN_WRAPPER v_char_index_t *v_char_pos_ptr (v_char_t *x)                   { return &x->m_pos; }

ERWIN_WRAPPER v_char_index_t  v_char_pos     (v_char_t *);
ERWIN_WRAPPER v_char_index_t  v_char_pos     (v_char_t *x)                   { return x->m_pos;  }

ERWIN_WRAPPER void            v_char_set_pos (v_char_t *,  v_char_index_t);
ERWIN_WRAPPER void            v_char_set_pos (v_char_t *x, v_char_index_t y) { x->m_pos= y;      }

#endif

#ifdef V_CHAR_INLINE__NTH

ERWIN_STATIC_INLINE
char  v_char_nth (v_char_t const* self, v_char_index_t idx)
{
    return self->m_table[idx];
}

#endif

#ifdef V_CHAR_INLINE__NENTRIES

ERWIN_STATIC_INLINE
v_char_cnt_t v_char_nentries (v_char_t const *self)
{
    return self->m_nentries;
}

ERWIN_STATIC_INLINE
ERWIN_BOOL v_char_empty (v_char_t const *self)
{
    return self->m_nentries == 0;
}

#endif

#endif /* ERWINMM_V_CHAR_h */
