/* -*- Mode: C -*- */

/*
 * Author:      Henrik Theiling
 * Description: Extended C++ programming, definition file.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 */

#ifndef ERWIN_CLASSDEF_H
#define ERWIN_CLASSDEF_H

#ifdef ERWIN_COMPILING
#  include "erwin/defs.h"
#else
#  include <erwin/defs.h>
#endif

/* Configuration options: */

/* ********************************************************************** */
/* #define ERWIN_CLASS_REFCOUNT 1 */
/*
 * Whether you want reference counting to be used by the macros
 * 'abstract' and 'concrete'.
 */
#ifndef ERWIN_CLASS_REFCOUNT
#define ERWIN_CLASS_REFCOUNT 1
#endif /* !defined ERWIN_CLASS_REFCOUNT */

/* ********************************************************************** */
/* #define ERWIN_CLASS_REFCOUNT_FAKE 0 */
/*
 * Whether you want reference counting interface despite the fact that
 * no refcounting in used.  This may be good to keep an existing interface
 * intact instead of removing some functions and macros.
 */
#ifndef ERWIN_CLASS_REFCOUNT_FAKE
#define ERWIN_CLASS_REFCOUNT_FAKE 0
#endif /* !defined ERWIN_CLASS_REFCOUNT_FAKE */

/* ********************************************************************** */
/* #define ERWIN_CLASS_ID 1 */
/*
 * Whether you want unique class ids (via member function klass_id()).
 */
#ifndef ERWIN_CLASS_ID
#define ERWIN_CLASS_ID 1
#endif /* !defined ERWIN_CLASS_ID */

/* ********************************************************************** */
/* #define ERWIN_CLASS_USE_CGEN 1 */
/*
 * Whether erwin-cgen is used to generate the member functions in this
 * file.  Otherwise, inline versions are used.  This slows down compilation,
 * but the resulting program usually executes faster.
 *
 * Note that some features that erwin-cgen provides cannot be emulated with
 * inline functions.  Notable the default result of the types of slots is not
 * available in macros, so the macros may fail while the erwin-cgen generated
 * stuff works and returns a default value (if desired).
 */
#ifndef ERWIN_CLASS_USE_CGEN
#define ERWIN_CLASS_USE_CGEN 1
#endif /* !defined ERWIN_CLASS_USE_CGEN */

#ifdef ERWIN_COMPILING
#  include "erwin/newdelete.h"
#else
#  include <erwin/newdelete.h>
#endif


/*
 * Access macros:
 *
 * For hiding the implementation from the user, we use access
 * functions for every data field of a struct.  This allows
 * changing the internal representation (e.g. from inline to
 * allocated pointer) without changing the user interface.
 *
 * The member itself is declared 'private: ... _m_test;'.  The
 * access function the library should use is called m_test().
 * Apart from the constructor, never assign values to _m_test directly,
 * this prevents debugging.
 *
 * Reading a member 'test' works by invoking the member function 'test()',
 * if the slot is readable.
 * Writing works using the 'set_test(...)' method if the slow is writable.
 * For writable non-reference things, a special wrapper is called
 * 'reset_test()' which is equivalent to 'set_test(0)'.
 *
 * If the access mechanism does not suite your type, declare the
 * member _priv and provide own access functions.
 *
 * Part 1: Kind of member (child_, xref_)
 *
 *    There are two types of storage classes:
 *        child: children
 *        xref:  cross references
 *    Children are deallocated when the parent is deleted.  This means
 *    that not only the reference counter is decremented, but that the
 *    child is explicitly deleted.  All scalar types and inlines
 *    structs are also counted as children.
 *
 *    Cross references only exist for pointers.  When a parent is
 *    deleted, only the reference counter of the cross reference is
 *    decremented.
 *
 *    Note that Erwin structures are always children even though their
 *    respective children are usually xrefs.
 *
 * Part 2: Access protection
 *    This decides whether the user can read and/or write the member
 *    data.  There are the following types:
 *
 *         priv: the thing is private:
 *               No access functions are defined.  This can also be
 *               used if want to provide your own functions.
 *
 *         ro:  read-only
 *
 *              No writer function will be implemented.  This can
 *              also be used if you want to provide your own writer.
 *
 *         rw:  read-write
 *
 *              Public reader and writer functions are implemented.
 *
 *         ri:  read, write-inheriting
 *              This is for inlined structs and pointers only: if
 *              the object is const, the pointer is const, too.
 *              the the object is writable, so is the pointer.
 *
 *              Note that this sometimes creates problems with an
 *              operator= and the copy constructor when using
 *              pointers, since the argument to these methods is
 *              const, so you don't get a non-const pointer if you
 *              export is write-inheriting.  For copied child, it
 *              works fine, though.
 *
 *         rp:  Readable but write-protected
 *
 *              Like rw, but the writer is protected, so although
 *              the user has no access, the class has write access
 *              (including automatic REF/UNREF for _obj slots).
 *
 *
 * Part 3: Type of storage in object:
 *     There are the following types:
 *         <empty>    normal data: use for scalars like int, bool,
 *                    symbol, etc.  Members of this kind must
 *                    understand an assignment from 0.
 *
 *         _ref       an inlined object/struct: C++ handles copying.
 *                    This declares the member like a scalar, but
 *                    the user interface has pointers so that you
 *                    can change the type to _ptr or _obj later.
 *
 *         _eref      an inlined object/struct: C++ handles copying.
 *                    In contrast to _ref, this generates a reference
 *                    interface in C++.  Usually this is deprecated,
 *                    use _ref instead.  But of course there may be
 *                    cases where the _eref interface is just natural
 *                    and you do want to use it.  Note that the
 *                    C interface will still use pointers.
 *
 *         _obj       a pointer to a class in the Object class
 *                    hierarchy.  The objects are automatically
 *                    ref'ed and unref'ed by the set_... method.
 *                    Specify the type without the trailing *.
 *
 *         _ptr       a foreign pointer, i.e. one that is not from
 *                    the Object class hierarchy.  Use for
 *                    objects that do not support the ->ref(),
 *                    ->unref() methods.
 *                    Specify the type without the trailing *.
 *
 *
 * Note that for _obj and _ptr, the object itself is still writable,
 * only the pointer in the internal structure is not.
 *
 * Theoretically, we could generate a good amount of code for
 * constructors and destructors from all this information, but
 * we currently don't.
 *
 * For xref, only _ptr and _obj is available.
 *
 * For child, child_rw_ptr is not supported, because we cannot handle
 * children of *some* type automatically.  Declare it _ro_ptr and
 * provide set_ methods yourself.
 */

/*
 * All the macros end with visibility 'public' (and never depend on any
 * visibility themselves).
 */

/* Totally private: */
#define _member_priv(TYPE, NAME, DOCSTRING) \
        private:                                   \
            TYPE _m_##NAME;                        \
        protected:                                 \
            TYPE &m_##NAME();                      \
            TYPE const &m_##NAME() const;          \
        public:

#define _member_priv_ref(TYPE, NAME, DOCSTRING) \
        _member_priv    (TYPE, NAME, DOCSTRING)

#define _member_priv_eref(TYPE, NAME, DOCSTRING) \
        _member_priv     (TYPE, NAME, DOCSTRING)

#define _member_priv_ptr(TYPE,   NAME, DOCSTRING) \
        _member_priv    (TYPE *, NAME, DOCSTRING)

#define _member_priv_obj(TYPE, NAME, DOCSTRING) \
        private:                                       \
            TYPE *_m_##NAME;                           \
        protected:                                     \
            TYPE *&m_##NAME();                         \
            TYPE *const &m_##NAME() const;             \
        public:

/* Read-only inheriting pointer: */
#define _member_ri_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME();                                   \
            TYPE const *NAME() const;

#define _member_ri_obj(TYPE, NAME, DOCSTRING)        \
            _member_priv_obj (TYPE, NAME, DOCSTRING) \
            TYPE *NAME();                                   \
            TYPE const *NAME() const;

/* Read-only inheriting reference: */
#define _member_ri_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE *NAME();                                   \
            TYPE const *NAME() const;

#define _member_ri_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE &NAME();                                    \
            TYPE const &NAME() const;

/* Read-only member: */
#define _member_ro(TYPE, NAME, DOCSTRING)        \
            _member_priv (TYPE, NAME, DOCSTRING) \
            TYPE NAME() const;

/* Read-only member that is returned by reference:
 * Note that this returns a pointer no matter what.  This allows changing this
 * to _ri_ptr and even _ro_ptr without a significant change in the interface.
 */
#define _member_ro_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE const *NAME() const;


#define _member_ro_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE const &NAME() const;

/* Read-only member that is returned by reference: */
#define _member_ro_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const;

#define _member_ro_obj(TYPE, NAME, DOCSTRING)         \
            _member_priv_obj (TYPE, NAME, DOCSTRING)  \
            TYPE *NAME() const;

/* Read/Write member (these are by reference only): */
#define _member_rw(TYPE, NAME, DOCSTRING)        \
            _member_priv (TYPE, NAME, DOCSTRING) \
            TYPE NAME() const;       \
            void set_##NAME (TYPE a);

#define _member_rw_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE *NAME();                                \
            TYPE const *NAME() const;                    \
            void set_##NAME (TYPE const *a);

#define _member_rw_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE &NAME();                                    \
            TYPE const &NAME() const;                        \
            void set_##NAME (TYPE const &a);

#define _member_rw_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const;                          \
            void set_##NAME (TYPE *a);                   \
            void reset_##NAME ();

#define _member_rw_obj(TYPE, NAME, DOCSTRING)        \
            _member_priv_obj (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const;                          \
            void set_##NAME (TYPE *a);                   \
            void reset_##NAME ();

/* Read/Protected Write member (these are by reference only): */
#define _member_rp(TYPE, NAME, DOCSTRING)        \
            _member_priv (TYPE, NAME, DOCSTRING) \
            TYPE NAME() const;                          \
        protected:                                      \
            void set_##NAME (TYPE a);                   \
        public:

#define _member_rp_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE const *NAME() const;                       \
        protected:                                          \
            TYPE *NAME();                                   \
            void set_##NAME (TYPE const *a);                \
        public:

#define _member_rp_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE const &NAME() const;                        \
        protected:                                           \
            TYPE &NAME();                                    \
            void set_##NAME (TYPE const &a);                 \
        public:

#define _member_rp_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const;                             \
        protected:                                          \
            void set_##NAME (TYPE *a);                      \
            void reset_##NAME ();                           \
        public:

#define _member_rp_obj(TYPE, NAME, DOCSTRING)        \
            _member_priv_obj (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const;                             \
        protected:                                          \
            void set_##NAME (TYPE *a);                      \
            void reset_##NAME ();                           \
        public:


/*
 * We distinguish three types of data fields:
 *    data    - non-pointer object, C++ handles automatic deallocation
 *    child   - pointer to an object that is part of the given structure: if the structure
 *              is deallocated, all its objects are deallocated, too.
 *    xref    - like a pointer, but will not be deallocated.
 *
 */

/* CAUTION: WHEN YOU CHANGE THESE, ADJUST THE PERL SCRIPT THAT GENERATES
 *          THE C INTERFACE! */

#define child_priv(TYPE, NAME, DOCSTRING)      _member_priv      (TYPE, NAME, DOCSTRING)
#define child_priv_ref(TYPE, NAME, DOCSTRING)  _member_priv_ref  (TYPE, NAME, DOCSTRING)
#define child_priv_eref(TYPE, NAME, DOCSTRING) _member_priv_eref (TYPE, NAME, DOCSTRING)
#define child_priv_ptr(TYPE, NAME, DOCSTRING)  _member_priv_ptr  (TYPE, NAME, DOCSTRING)
#define child_priv_obj(TYPE, NAME, DOCSTRING)  _member_priv_obj  (TYPE, NAME, DOCSTRING)
#define child_ri_obj(TYPE, NAME, DOCSTRING)    _member_ri_obj    (TYPE, NAME, DOCSTRING)
#define child_ri_ptr(TYPE, NAME, DOCSTRING)    _member_ri_ptr    (TYPE, NAME, DOCSTRING)
#define child_ri_ref(TYPE, NAME, DOCSTRING)    _member_ri_ref    (TYPE, NAME, DOCSTRING)
#define child_ri_eref(TYPE, NAME, DOCSTRING)   _member_ri_eref   (TYPE, NAME, DOCSTRING)
#define child_ro(TYPE, NAME, DOCSTRING)        _member_ro        (TYPE, NAME, DOCSTRING)
#define child_ro_obj(TYPE, NAME, DOCSTRING)    _member_ro_obj    (TYPE, NAME, DOCSTRING)
#define child_ro_ptr(TYPE, NAME, DOCSTRING)    _member_ro_ptr    (TYPE, NAME, DOCSTRING)
#define child_ro_ref(TYPE, NAME, DOCSTRING)    _member_ro_ref    (TYPE, NAME, DOCSTRING)
#define child_ro_eref(TYPE, NAME, DOCSTRING)   _member_ro_eref   (TYPE, NAME, DOCSTRING)
#define child_rw(TYPE, NAME, DOCSTRING)        _member_rw        (TYPE, NAME, DOCSTRING)
#define child_rw_obj(TYPE, NAME, DOCSTRING)    _member_rw_obj    (TYPE, NAME, DOCSTRING)
#define child_rw_ptr(TYPE, NAME, DOCSTRING)    _member_rw_ptr    (TYPE, NAME, DOCSTRING)
#define child_rw_ref(TYPE, NAME, DOCSTRING)    _member_rw_ref    (TYPE, NAME, DOCSTRING)
#define child_rw_eref(TYPE, NAME, DOCSTRING)   _member_rw_eref   (TYPE, NAME, DOCSTRING)
#define child_rp(TYPE, NAME, DOCSTRING)        _member_rp        (TYPE, NAME, DOCSTRING)
#define child_rp_obj(TYPE, NAME, DOCSTRING)    _member_rp_obj    (TYPE, NAME, DOCSTRING)
#define child_rp_ptr(TYPE, NAME, DOCSTRING)    _member_rp_ptr    (TYPE, NAME, DOCSTRING)
#define child_rp_ref(TYPE, NAME, DOCSTRING)    _member_rp_ref    (TYPE, NAME, DOCSTRING)
#define child_rp_eref(TYPE, NAME, DOCSTRING)   _member_rp_eref   (TYPE, NAME, DOCSTRING)

#define xref_priv_obj(TYPE, NAME, DOCSTRING)   _member_priv_obj  (TYPE, NAME, DOCSTRING)
#define xref_priv_ptr(TYPE, NAME, DOCSTRING)   _member_priv_ptr  (TYPE, NAME, DOCSTRING)
#define xref_ri_obj(TYPE, NAME, DOCSTRING)     _member_ri_obj    (TYPE, NAME, DOCSTRING)
#define xref_ri_ptr(TYPE, NAME, DOCSTRING)     _member_ri_ptr    (TYPE, NAME, DOCSTRING)
#define xref_ro_obj(TYPE, NAME, DOCSTRING)     _member_ro_obj    (TYPE, NAME, DOCSTRING)
#define xref_ro_ptr(TYPE, NAME, DOCSTRING)     _member_ro_ptr    (TYPE, NAME, DOCSTRING)
#define xref_rw_obj(TYPE, NAME, DOCSTRING)     _member_rw_obj    (TYPE, NAME, DOCSTRING)
#define xref_rw_ptr(TYPE, NAME, DOCSTRING)     _member_rw_ptr    (TYPE, NAME, DOCSTRING)
#define xref_rp_obj(TYPE, NAME, DOCSTRING)     _member_rp_obj    (TYPE, NAME, DOCSTRING)
#define xref_rp_ptr(TYPE, NAME, DOCSTRING)     _member_rp_ptr    (TYPE, NAME, DOCSTRING)

#define foreign_class(TYPE_CXX)


#define foreign_type(TYPE_C)


#define local_class(TYPE_CXX)


#define local_type(TYPE_C, TYPE_CXX)



#define local_enum(TYPE_C, TYPE_CXX)



#define local_union(TYPE_C, TYPE_CXX)




#if ERWIN_BOOL_VALUE(ERWIN_CLASS_REFCOUNT)
#  define stdclass_refcount                                                   \
        THIS const *_ref() const                                                     \
            { return ((THIS const *)((Object const *)(this))->_ref()); }             \
        THIS *_ref()                                                                 \
            { return ((THIS *)((Object *)(this))->_ref()); }                         \
        THIS const *_unref() const                                                   \
            { return ((THIS const *)((Object const *)(this))->_unref()); }           \
        THIS *_unref()                                                               \
            { return ((THIS *)((Object *)(this))->_unref()); }                       \
        THIS const *_ref_unref() const                                               \
            { return ((THIS const *)((Object const *)(this))->_ref_unref()); }       \
        THIS *_ref_unref()                                                           \
            { return ((THIS *)((Object *)(this))->_ref_unref()); }                   \
        THIS const *_unref_no_delete() const                                         \
            { return ((THIS const *)((Object const *)(this))->_unref_no_delete()); } \
        THIS *_unref_no_delete()                                                     \
            { return ((THIS *)((Object *)(this))->_unref_no_delete()); }
#elif ERWIN_BOOL_VALUE(ERWIN_CLASS_REFCOUNT_FAKE)
#  define stdclass_refcount                             \
        THIS const *_ref() const              { return this; } \
        THIS *_ref()                          { return this; } \
        THIS const *_unref() const            { return this; } \
        THIS *_unref()                        { return this; } \
        THIS const *_ref_unref() const        { return this; } \
        THIS *_ref_unref()                    { return this; } \
        THIS const *_unref_no_delete() const  { return this; } \
        THIS *_unref_no_delete()              { return this; }
#else
#  define stdclass_refcount
#endif

#define stdclass_no_ref                             \
    public:                                                \
        typedef THIS This;                                 \
        typedef SUPER Super;                               \
    protected:                                             \
        virtual THIS *ERWIN_CONCAT_TOKEN(v_as_, THIS) (); \
    public:

#define stdclass                                    \
        stdclass_no_ref                             \
    public:                                                \
        stdclass_refcount

#ifndef SET_ID
#define SET_ID(X) do{;}while(0)
#endif

#if ERWIN_BOOL_VALUE(ERWIN_CLASS_ID)
#  define concrete_id                                                                   \
    private:                                                                                   \
        void set_id() { SET_ID(ERWIN_CONCAT_TOKEN(id_, THIS)); }                \
    protected:                                                                                 \
        virtual class_id_t  v_klass_id() const { return ERWIN_CONCAT_TOKEN(id_,THIS);}
#else
#  define concrete_id
#endif

#define concrete                                                      \
        stdclass                                                      \
    private:                                                                 \
        virtual void _concrete () const { }                                  \
    protected:                                                               \
        virtual char const *v_klass_name() const { return ERWIN_STR(THIS); } \
        concrete_id                                                   \
    public:


#if ERWIN_BOOL_VALUE(ERWIN_CLASS_ID)
#  define abstract_id                          \
    protected:                                        \
        virtual class_id_t  v_klass_id() const   = 0;
#else
#  define abstract_id
#endif


#define abstract                               \
        stdclass                               \
    private:                                          \
        virtual void _concrete () const = 0;          \
    protected:                                        \
        virtual char const *v_klass_name() const = 0; \
        abstract_id                            \
    public:


#define abstract_no_ref                        \
        stdclass_no_ref                        \
    private:                                          \
        virtual void _concrete () const = 0;          \
    protected:                                        \
        virtual char const *v_klass_name() const = 0; \
        abstract_id                            \
    public:


#if ERWIN_BOOL_VALUE(ERWIN_CLASS_ID)
#  define general_object_id                                   \
    protected:                                                       \
        virtual class_id_t klass_id() const                          \
            { return this == NULL ? id_NULL : v_klass_id(); }
#else
#  define general_object_id
#endif


#define general_object                                                           \
        typedef Object This;                                                            \
        announce_class(Object)                                                          \
    private:                                                                            \
        virtual void _concrete () const = 0;                                            \
    protected:                                                                          \
        virtual char const *v_klass_name() const = 0;                                   \
        abstract_id                                                              \
    public:                                                                             \
        char const *klass_name() const { return this == NULL ? NULL : v_klass_name(); } \
        general_object_id


#define make_cast(TYPE)            \
    public:                               \
        TYPE *cast_##TYPE ();             \
        TYPE const *cast_##TYPE () const;

#define announce_class(TYPE)     \
    protected:                          \
        virtual TYPE *v_as_##TYPE();    \
        make_cast(TYPE)          \
    public:                             \
        TYPE *as_##TYPE ();             \
        TYPE const *as_##TYPE () const;


/* The following ones are used to have make-wrap-c.pl generate simple
 * implementations for hidden, trivial, redirecting and inherited
 * functions: */
#define hidden    private
#define trivial
#define redirect
#define inherit

/* Prepend library prefix to THIS/SUPER: */
#undef  THIS
#undef  SUPER
   /* Some Windows header defines THIS to 'void' */

#define THIS        ERWIN_CONCAT_TOKEN(, THIS)
#define SUPER       ERWIN_CONCAT_TOKEN(, SUPER)

#if !ERWIN_BOOL_VALUE(ERWIN_CLASS_USE_CGEN)
/* The classundef file has the inline macros: */
#ifdef ERWIN_COMPILING
#  include "erwin/classundef.h"
#else
#  include <erwin/classundef.h>
#endif
#endif

#endif /* ERWIN_CLASSDEF_H */

/*
 * Note: the following is outside the #ifdef protection for
 * switching the aliases back on after including classundef.h:
 */


























































