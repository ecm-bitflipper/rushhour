/* -*- Mode: C -*- */
/* Author: Henrik Theiling
 * Description:
 *       The Erwin library for standard data structures and algorithms.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 */

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including base.h."
#endif

#ifndef ERWIN_BASE_H
#define ERWIN_BASE_H

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of base.h."
#endif

#ifdef ERWIN_COMPILING
#  include "erwin/defs.h"
#  include "erwin/map.h"
#  include "erwin/vector.h"
#  include "erwin/list.h"
#  include "erwin/typeinfo.h"
#else
#  include <erwin/defs.h>
#  include <erwin/map.h>
#  include <erwin/vector.h>
#  include <erwin/list.h>
#  include <erwin/typeinfo.h>
#endif

#ifdef ERWIN_ADAM_NAME

#ifdef ERWIN_MAJOR_VERSION
#define ERWIN_MAJOR_VERSION ERWIN_MAJOR_VERSION
#endif
#ifdef ERWIN_MINOR_VERSION
#define ERWIN_MINOR_VERSION ERWIN_MINOR_VERSION
#endif
#ifdef ERWIN_MICRO_VERSION
#define ERWIN_MICRO_VERSION ERWIN_MICRO_VERSION
#endif
#ifdef ERWIN_VERSION_CODE
#define ERWIN_VERSION_CODE ERWIN_VERSION_CODE
#endif

#define initializer_t initializer_t
#define erwin_strtoul erwin_strtoul
#define erwin_strtol erwin_strtol
#define erwin_strtoull erwin_strtoull
#define erwin_strtoll erwin_strtoll
#define erwin_strntoul erwin_strntoul
#define erwin_strntol erwin_strntol
#define erwin_strntoull erwin_strntoull
#define erwin_strntoll erwin_strntoll
#define string_free string_free
#define string_cmp string_cmp
#define string_equ string_equ
#define string_case_cmp string_case_cmp
#define string_case_equ string_case_equ
#define string_dup string_dup
#define string_length string_length
#define char_is_alpha char_is_alpha
#define char_is_lower char_is_lower
#define char_is_upper char_is_upper
#define char_is_digit char_is_digit
#define char_is_xdigit char_is_xdigit
#define char_is_space char_is_space
#define char_is_space0 char_is_space0
#define char_is_cr char_is_cr
#define char_is_cr0 char_is_cr0
#define erwin_merge_sort erwin_merge_sort
#define erwin_register_init erwin_register_init
#define erwin_version erwin_version
#define erwin_package_date erwin_package_date
#define erwin_assertion_is_fatal erwin_assertion_is_fatal
#define erwin_install_date erwin_install_date
#define erwin_init_date erwin_init_date
#define erwin_version_1 erwin_version_1
#define erwin_version_2 erwin_version_2
#define erwin_set_determinism erwin_set_determinism
#define erwin_require_determinism erwin_require_determinism
#define erwin_det_random erwin_det_random

#else /* !defined(ERWIN_ADAM_NAME) */

/* A family of overloaded functions to write assertions of the
 * following type:
 *
 *    assert (x >= 0);
 *
 * The problem is that this often leads to a compiler warning while
 * you still do not want to remove the assertion; you agree with
 * the compiler that x >= 0, but you do want to make this assertion
 * explicit.
 *
 * The following function family is overloaded for all numeric types
 * (I think), so whether the x>=0-check is necessary or not is decided
 * here once and forall.  You can simply write:
 *
 *    assert (erwin_nonnegative(x));
 *
 * The result of the function will be a constant true for unsigned
 * types and a dynamically checked condition for signed types.
 *
 * For C, the problem is not fully solved:
 *
 *   Because in C, there is no overloading, the whole thing does not work,
 *   and we're still looking for a solution.  The only thing I came up
 *   with produces additional code and/or only works for ints but not for
 *   floats.  I consider both minor flaws, especially the float thing.
 *   But since you may currently use erwin_nonnegative() in any expression
 *   instead of x >= 0, producing more code is suboptimal.  Depending on
 *   ERWIN_OPTIMISE, we either use our special test (non-optimised code) or
 *   we use x >= 0 (optimised code), which the compiler should eliminate.
 *
 *   Method 1 (works only for ints, but produces faster code):
 *
 *          (int)(x >> (sizeof(x)*8-1)) >= 0
 *
 *   Method 2 (works for floats and ints, but produces more code).
 *
 *          (double)(x / (2 << (sizeof(x)*8-1))) >= 0
 *
 *          This also has the problem that 2 << ... may overflow and
 *          that using a cast might change the result.
 *
 *   So we use Method 1, making erwin_nonnegative() only for for integers
 *   in C mode.  Note that no such restriction exists in C++.
 *
 * assert.pl also uses this function in out_of_bounds assertions.
 */

#ifndef erwin_nonnegative

#ifdef __cplusplus

#define erwin_nonnegative erwin_nonnegative

ERWIN_WRAPPER bool erwin_nonnegative (char) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (char x)
{
#ifdef __CHAR_UNSIGNED__
     return true;
#else
     return x >= 0;
#endif
}

ERWIN_WRAPPER bool erwin_nonnegative (signed char) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed char x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (signed short) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed short x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (signed int) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed int x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (signed long) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (signed long x)
{
     return x >= 0;
}

#ifdef ERWIN_LONG_LONG
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_LONG_LONG) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_LONG_LONG x)
{
     return x >= 0;
}
#endif

ERWIN_WRAPPER bool erwin_nonnegative (float) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (float x)
{
     return x >= 0;
}

ERWIN_WRAPPER bool erwin_nonnegative (double) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (double x)
{
     return x >= 0;
}

#if SIZEOF_LONG_DOUBLE > 0
ERWIN_WRAPPER bool erwin_nonnegative (long double) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (long double x)
{
     return x >= 0;
}
#endif

ERWIN_WRAPPER bool erwin_nonnegative (bool) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (bool)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned char) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned char)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned short) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned short)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned int) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned int)
{
     return true;
}

ERWIN_WRAPPER bool erwin_nonnegative (unsigned long) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (unsigned long)
{
     return true;
}

#ifdef ERWIN_UNSIGNED_LONG_LONG
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_UNSIGNED_LONG_LONG) ATTR_CONST;
ERWIN_WRAPPER bool erwin_nonnegative (ERWIN_UNSIGNED_LONG_LONG)
{
     return true;
}
#endif

#else /* !defined __cplusplus */

/* C mode: no overloading possible, so just do the check: */
#if ERWIN_OPTIMISE
#  define erwin_nonnegative(x)  ((x) >= 0)
#else
#  define erwin_nonnegative(x)  (((int)((x) >> (sizeof(x)*8-1))) >= 0)
#endif

#endif /* !defined __cplusplus */

#endif /* defined erwin_nonnegative */


#ifdef __cplusplus
extern "C" {
#endif

/*
 * An initialisation function */
typedef void (*initializer_t) (int *, char ***);

/*! enum: SO_* */
#define SO_NO_UNDERBAR    0x80
#define SO_NO_BINARY     0x100
#define SO_BASE_MASK      0x7f

/*! group: strtol-Functions
 *
 * Read numbers from string.  Use instead of system functions as the
 * clib functions may be broken on some systems.  Note, however,
 * that the functions have no overflow checking. (FIXME: implement that).
 *
 * These functions have the following extensions compared to the
 * standard strto* family:
 *     - they skip and ignore _ in numbers (like Perl)
 *     - they understand 0b and 0B as binary prefix
 * To disable these extensions, use the following constants in the
 * radix parameter:
 *     - SO_NO_UNDERBAR
 *     - SO_NO_BINARY
 * And or them with the base.  E.g.:
 *    : erwin_strtol (x, &r, 16 | ERWIN_NO_UNDERBAR)
 *
 * SO is short for 'scan option'.
 * (Vectors have a 'format option' and this is the reverse)
 *
 * NULL is allowed for all pointers.  If c == NULL, the result is 0.
 */

extern unsigned long erwin_strtoul  (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern long erwin_strtol (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#ifdef ERWIN_LONG_LONG

extern ERWIN_UNSIGNED_LONG_LONG erwin_strtoull (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern ERWIN_LONG_LONG  erwin_strtoll  (
    char const * /*c*/,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#endif

extern unsigned long erwin_strntoul  (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern long erwin_strntol (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#ifdef ERWIN_LONG_LONG

extern ERWIN_UNSIGNED_LONG_LONG erwin_strntoull (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

extern ERWIN_LONG_LONG  erwin_strntoll  (
    char const * /*c*/,
    size_t /* strlen */,
    char ** /*endptr*/ ERWIN_DEFAULT_ARG (NULL),
    int /*base*/ ERWIN_DEFAULT_ARG(0));

#endif

/*! end-group */

/*
 * Overwrites the string before free() to make sure its contents
 * will not be used.  Do not use this as a random number generator
 * This is NULL safe.
 */
extern void string_free (char * /*c*/);

/*! group: String Comparison
 *
 * NULL-safe string functions:
 *
 * These are all NULL safe (NULL < "") comparison functions:
 * Note that the _case_ functions use 'tolower' (via char_to_lower),
 * so that they pay attention to the locale if that function does.
 *
 */

extern int string_cmp (char const * /*a*/, char const * /*b*/) ATTR_PURE;
  /*
   * This compares two strings like the standard strcmp().
   *
   * This has macro aliases erwin_strcmp().
   *
   * For erwin_strcmp(a,b) == 0, there is an alias:
   *    : erwin_strequ(a,b)
   */

extern int memory_cmp (void const * /*a*/, void const * /*b*/, size_t /*cnt*/) ATTR_PURE;
  /*
   * This compares two strings like the standard memcmp().
   *
   * This has macro aliases erwin_memcmp().
   *
   * For erwin_strcmp(a,b) == 0, there is an alias:
   *    : erwin_strequ(a,b)
   */

extern int string_n_cmp (char const * /*a*/, char const * /*b*/, size_t /*n*/) ATTR_PURE;
  /* Replacement for strncmp()
   *
   * This has macro aliases erwin_strncmp().
   *
   * For erwin_strncmp(a,b,n) == 0, there is an alias:
   *    : erwin_strnequ(a,b,n)
   */

extern char *string_string (char const * /*haystack*/, char const * /*needle*/) ATTR_PURE;
  /* Like strstr: finds a substring.
   *
   * Has a macro alias erwin_strstr.
   */

extern char *string_n_string      (
    char const * /*haystack*/, char const * /*needle*/, size_t) ATTR_PURE;
  /* Like a potential strnstr: finds a substring for a needle with a limited length.
   *
   * Has a macro alias erwin_strnstr.
   */

extern void *memory_memory (
    void const * /*haystack*/, size_t /*haycnt*/,
    void const * /*needle*/,   size_t /*needlecnt*/) ATTR_PURE;
  /* Like memmem: finds a substring.
   *
   * Has a macro alias erwin_memmem.
   */

/*! group: Case Insensitive Variants
 * Note that the _case_ functions use 'tolower' (via char_to_lower),
 * so that they pay attention to the locale if that function does.
 */

extern int string_case_cmp (char const * /*a*/, char const * /*b*/) ATTR_PURE;
  /* Like strcasecmp() / stricmp().
   *
   * This has macro aliases erwin_strcasecmp() and erwin_stricmp
   */

extern int string_n_case_cmp (char const * /*a*/, char const * /*b*/, size_t /*n*/)
     ATTR_PURE;
  /* Like strncasecmp() / strnicmp()
   *
   * This has macro aliases erwin_strncasecmp() and erwin_strnicmp
   */

extern char *string_case_string   (char const * /*haystack*/, char const * /*needle*/)
     ATTR_PURE;
  /* Like a potential strcasestr: finds a substring case-insensitively.
   *
   * Has a macro alias erwin_strcasestr.
   */

extern char *string_n_case_string (
    char const * /*haystack*/, char const * /*needle*/, size_t) ATTR_PURE;
  /* Like a potential strcasestr: finds a substring for a needle with a limited length.
   *
   * Has a macro alias erwin_strncasestr.
   */

/*! end-group */
/*! end-group */

extern char *string_dup   (
    char const * /*c*/, int * /*err*/ ERWIN_DEFAULT_ARG((int*)NULL))
    ATTR_MALLOC;
    /*
     * This DOES NOT change NULL to "(null)" or anything like that. NULL
     * on input returns NULL. Otherwise, the index NULL could not be
     * found after insertion in an array.  If there is not enough memory,
     * *err is set to 1.  Otherwise, *err is not touched.
     * err may be NULL. In that case, NULL is returned of the system
     * is out of memory.
     *
     * This has an alias erwin_strdup.
     */

extern char *string_n_dup (
    char const * /*c*/, size_t /*n*/, int * /*err*/ ERWIN_DEFAULT_ARG((int*)NULL))
    ATTR_MALLOC;
    /* Also see string_dup.
     *
     * This has an alias erwin_strdup.
     */

extern void *erwin_memset0 (
    void * /*p*/, size_t /*start*/, size_t /*end_plus_1*/);
    /* Like memset or bzero, but by using start, you can clear a suffix only.
     * This is internally used to emulate clearing after malloc and realloc.
     * Depending on what is available, the internal implementation uses
     * memset, bzero, or clears with a for loop manually.
     *
     * The returned pointer is just the one passed to the function.  If it is
     * NULL or start >= end_plus_1, no clearing is attempted.
     */

extern size_t string_length (char const *) ATTR_PURE;
   /* A NULL-safe replacement for strlen(): NULL has length 0.
    *
    * This has an alias erwin_strlen.
    */

extern size_t string_n_length (char const *, size_t) ATTR_PURE;
   /* A NULL-safe replacement for strnlen(): NULL has length 0.
    *
    * This has an alias erwin_strnlen.
    */

extern int erwin_digit_value (char) ATTR_CONST;
   /* Returns the digit value of a given character.  Can be used up to
    * a radix of 36.  (Probably usually used for hexadecimal digits.)
    *
    * If the character is invalid, returns 100, which is larger a value
    * than that of any representable digit.
    */

extern char erwin_get_digit (int /*digit*/) ATTR_CONST;
   /* The reverse of the erwin_digit_value.
    * Returns '\0' if digit is not between 0 and 35.
    */

extern char erwin_get_digit_upper (int /*digit*/) ATTR_CONST;
   /* This variant of erwin_get_digit returns upper case
    * letters first. */

/* The names string_... are nice to show that they all belong to the
 * data type string, but they are not nice for remembring when you
 * know the libc function names.  So we introduce aliases here. */

#define erwin_strcmp      string_cmp
#define erwin_memcmp      memory_cmp
#define erwin_strncmp     string_n_cmp
#define erwin_strlen      string_length
#define erwin_strnlen     string_n_length

/* non-ANSI, but BSD */
#define erwin_strdup(A)   string_dup((A), NULL)

/* BSD, Linux: */
#define erwin_strcasecmp  string_case_cmp
#define erwin_strncasecmp string_n_case_cmp
#define erwin_strstr      string_string
#define erwin_memmem      memory_memory
#define erwin_strcasestr  string_case_string
#define erwin_strnstr     string_n_string
#define erwin_strncasestr string_n_case_string

/* Windows: */
#define erwin_stricmp     string_case_cmp
#define erwin_strnicmp    string_n_case_cmp
#define erwin_stristr     string_case_string
#define erwin_strnistr    string_n_case_string

/* Some invented names: */
#define erwin_strfree             string_free
#define erwin_strndup             string_n_dup

#define erwin_memequ(A,B,C)       (memory_cmp(A,B,C) == 0)
#define erwin_strequ(A,B)         (string_cmp(A,B) == 0)
#define erwin_strcaseequ(A,B)     (string_case_cmp(A,B) == 0)
#define erwin_strnequ(A,B,N)      (string_n_cmp(A,B,N) == 0)
#define erwin_strncaseequ(A,B,N)  (string_n_case_cmp(A,B,N) == 0)

#define string_equ(A,B)           (string_cmp(A,B) == 0)
#define string_case_equ(A,B)      (string_case_cmp(A,B) == 0)
#define string_n_equ(A,B,N)       (string_n_cmp(A,B,N) == 0)
#define string_n_case_equ(A,B,N)  (string_n_case_cmp(A,B,N) == 0)

extern ERWIN_BOOL string_is_prefix (
    int * /*needle_length*/, char const * /*haystack*/, char const * /*needle*/);

extern ERWIN_BOOL string_is_suffix (
    int * /*needle_length*/, char const * /*haystack*/, char const * /*needle*/);

extern char const *erwin_strsignal (int);
   /* This returns NULL if the signal is not known or no name is known. */

/*
 * Some character functions.   These are wrappers around ctype functions. */
/* extern char char_to_upper (char);    declared in map.h */
/* extern char char_to_lower (char);    declared in map.h */
extern ERWIN_BOOL char_is_alpha  (char) ATTR_CONST;
extern ERWIN_BOOL char_is_lower  (char) ATTR_CONST;
extern ERWIN_BOOL char_is_upper  (char) ATTR_CONST;
extern ERWIN_BOOL char_is_digit  (char) ATTR_CONST;
extern ERWIN_BOOL char_is_xdigit (char) ATTR_CONST;
extern ERWIN_BOOL char_is_space  (char) ATTR_CONST;  /* '\0' is not space. */
extern ERWIN_BOOL char_is_space0 (char) ATTR_CONST;  /* '\0' is space. */
extern ERWIN_BOOL char_is_cr     (char) ATTR_CONST;  /* '\0' is not cr. */
extern ERWIN_BOOL char_is_cr0    (char) ATTR_CONST;  /* '\0' is cr. */
  /* The *0 versions return ERWIN_TRUE for \0. */

#define erwin_isalpha  char_is_alpha
#define erwin_islower  char_is_lower
#define erwin_isupper  char_is_upper
#define erwin_isdigit  char_is_digit
#define erwin_isxdigit char_is_xdigit
#define erwin_isspace  char_is_space
/* invented ones: */
#define erwin_isspace0  char_is_space0
#define erwin_iscr      char_is_cr
#define erwin_iscr0     char_is_cr0

/* The following functions hash the contents of the strings: */
ERWIN_WRAPPER hashval_t string_hash (char const *) ATTR_PURE;
ERWIN_WRAPPER hashval_t string_hash (char const *c)
{
    return erwin_u8_array_hash ((ERWIN_U8*)c, string_length(c));
}

ERWIN_WRAPPER hashval_t string_case_hash (char const *) ATTR_PURE;
ERWIN_WRAPPER hashval_t string_case_hash (char const *c)
{
    return erwin_u8_array_case_hash ((ERWIN_U8*)c, string_length(c));
}

typedef int (* erwin_comparison_t) (void const *, void const *);

void erwin_merge_sort (
    void *abase,
    size_t anmemb,
    size_t asize,
    erwin_comparison_t /*acompar*/);
   /* The stable sort algorithm Mergesort.
    *
    * Warning: This needs as much additional memory as you have stored in the
    *          array being sorted!
    */

/*
 * Initialise erwin and all its modules.  This might read
 * eventually parse options some time.
 */
extern void erwin_init (int * /*argc*/, char *** /*argv*/);

extern int erwin_register_init (initializer_t);
/* The suggested usage is this:

     static void module_init (int *argc, char ***argv)
     {
       ....
     }

     static int init_dummy = erwin_register_initialiser (module_init);

   module_init will then automatically be called by erwin_init
 */

#define ERWIN_MAJOR_VERSION  2
#define ERWIN_MINOR_VERSION  1
#define ERWIN_MICRO_VERSION  85983
#define ERWIN_VERSION_CODE   ERWIN_VERSION(ERWIN_MAJOR_VERSION,ERWIN_MINOR_VERSION,ERWIN_MICRO_VERSION)
/*
 * Like in the Linux kernel, you can write something like:
 *
 * #if ERWIN_VERSION_CODE >= ERWIN_VERSION(2,0,178)
 *
 */

extern char const *const erwin_version;
extern char const *const erwin_package_date;
   /* version and release date of this Erwin package */

extern ERWIN_BOOL erwin_assertion_is_fatal;
   /* whether assertions are fatal */

extern char const *const erwin_install_date;
   /* site install date */

extern char const *const erwin_init_date;
   /* date of untemplatize -init */

extern int const erwin_version_1;
extern int const erwin_version_2;
   /* These are for link-checking Erwin in a configure script. */

#ifdef ERWIN_REQUIRE_DETERMINISM

extern void erwin_set_determinism (ERWIN_BOOL);
    /* Default: ERWIN_TRUE
     * This means: if you define ERWIN_REQUIRE_DETERMINISM, you get ERWIN_TRUE as a
     *             default.  If you don't, you get ERWIN_FALSE as a default because the
     *             whole machinery needed for enforcing determinism is not compiled in.
     */

extern ERWIN_BOOL erwin_require_determinism (void);
    /* returns the current status of the determinism state. */

#endif
   /* If you compile the library with ERWIN_REQUIRE_DETERMINISM, all the data
    * structures will be able to be switched into determinism mode.  Note that
    * you have to call this function *before* erwin_init()!
    *
    * The influence on data structures is that, e.g for maps, functions
    * returning a list of the entries (either key, values or pairs) will
    * for sorted.  The same holds for iterators.  Note that when comparing
    * pointers by their address, the sort order is still machine and
    * machine configuration (->shared libraries, etc) dependent.  However,
    * directly subsequent calls to your problems will probably result in
    * the same order.
    *
    * NOTE: When you define ERWIN_REQUIRE_DETERMINISM, maps *must* be
    *       supplied with a compare function for the keys.  There can be
    *       a special compare function if you do not want to influence
    *       the rest of the data structure.
    *
    * FURTHER NOTE: When you define this, the library is a bit slower, because
    *       it has to check the determinism flag.
    *
    * FURTHER NOTE: This feature is currently only implemented correctly
    *       for C++ since the map iterators for C cannot be correctly
    *       de-allocated automatically.
    *       E.g. when an application programmer uses `break' to exit a
    *       map_xyz_forall loop, a possibly allocated sorted array cannot
    *       be deallocated in C.  This would require something like
    *       MAP_XYZ_FORALL_BREAK(iter) or (which I do not like because
    *       it breaks nestability) an additional entry in the map_xyz_t struct.
    */
#ifdef ERWIN_NEED_DET_RANDOM
extern unsigned long erwin_det_random (void);
    /* deterministic random. (haha!)
     * No srand() necessary...
     * Usually, use the frontend ERWIN_RANDOM(N) (defs.h)
     */
#endif

#ifdef __cplusplus
}
#endif

#endif /* !defined(ERWIN_ADAM_NAME) */


#include "decls.h"

#endif /* ERWIN_BASE_H */
