/* -*- Mode: C -*- */

/*
 * Author:      Henrik Theiling
 * Description: Extended C++ programming, undefinition file.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 */

#ifndef ERWIN_CLASSUNDEF_H
#define ERWIN_CLASSUNDEF_H

/*
 * Undefines everything that lacks the '' prefix and introduces
 * inline versions of many declarators, because the user of the library
 * will not run erwin-cgen with the library settings.
 */

/* Totally private: */
#undef  _member_priv
#define _member_priv(TYPE, NAME, DOCSTRING) \
        private:                                   \
            TYPE _m_##NAME;                        \
        protected:                                 \
            TYPE &m_##NAME()                       \
            {                                      \
                CHECK_SIG(this);            \
                return _m_##NAME;                  \
            }                                      \
            TYPE const &m_##NAME() const           \
            {                                      \
                CHECK_SIG(this);            \
                return _m_##NAME;                  \
            }                                      \
        public:

#undef  _member_priv_obj
#define _member_priv_obj(TYPE, NAME, DOCSTRING) \
        private:                                       \
            TYPE *_m_##NAME;                           \
        protected:                                     \
            TYPE *&m_##NAME() {                        \
                CHECK_SIG(this);                \
                CHECK_OTHER_SIG(_m_##NAME);     \
                return _m_##NAME;                      \
            }                                          \
            TYPE *const &m_##NAME() const {            \
                CHECK_SIG(this);                \
                CHECK_OTHER_SIG(_m_##NAME);     \
                return _m_##NAME;                      \
            }                                          \
        public:                                        \

/* Read-only inheriting pointer: */
#undef  _member_ri_ptr
#define _member_ri_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() {                                  \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }                                               \
            TYPE const *NAME() const {                      \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }

#undef  _member_ri_obj
#define _member_ri_obj(TYPE, NAME, DOCSTRING)        \
            _member_priv_obj (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() {                                  \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }                                               \
            TYPE const *NAME() const {                      \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }

/* Read-only inheriting reference: */
#undef  _member_ri_ref
#define _member_ri_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() {                                  \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }                                               \
            TYPE const *NAME() const {                      \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }

#undef  _member_ri_eref
#define _member_ri_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE &NAME() {                                   \
                assert (this != NULL);                       \
                return m_##NAME();                           \
            }                                                \
            TYPE const &NAME() const {                       \
                assert (this != NULL);                       \
                return m_##NAME();                           \
            }

/* Read-only member: */
#undef  _member_ro
#define _member_ro(TYPE, NAME, DOCSTRING)        \
            _member_priv (TYPE, NAME, DOCSTRING) \
            TYPE NAME() const {                         \
                assert (this != NULL);                  \
                return m_##NAME();                      \
            }

/* Read-only member that is returned by reference:
 * Note that this returns a pointer no matter what.  This allows changing this
 * to _ri_ptr and even _ro_ptr without a significant change in the interface.
 */
#undef  _member_ro_ref
#define _member_ro_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE const *NAME() const {                      \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }


#undef  _member_ro_eref
#define _member_ro_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE const &NAME() const {                       \
                assert (this != NULL);                       \
                return m_##NAME();                           \
            }


/* Read-only member that is returned by reference: */
#undef  _member_ro_ptr
#define _member_ro_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const {                            \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }

#undef  _member_ro_obj
#define _member_ro_obj(TYPE, NAME, DOCSTRING)        \
            _member_priv_obj (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const {                            \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }

/* Read/Write member (these are by reference only): */
#undef  _member_rw
#define _member_rw(TYPE, NAME, DOCSTRING)        \
            _member_priv (TYPE, NAME, DOCSTRING) \
            TYPE NAME() const {                         \
                assert (this != NULL);                  \
                return m_##NAME();                      \
            }                                           \
            void set_##NAME (TYPE a) {                  \
                assert (this != NULL);                  \
                m_##NAME()= a;                          \
            }

#undef  _member_rw_ref
#define _member_rw_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() {                                  \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }                                               \
            TYPE const *NAME() const {                      \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }                                               \
            void set_##NAME (TYPE const *a) {               \
                assert (this != NULL);                      \
                m_##NAME()= *a;                             \
            }

#undef  _member_rw_eref
#define _member_rw_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE &NAME() {                                   \
                assert (this != NULL);                       \
                return m_##NAME();                           \
            }                                                \
            TYPE const &NAME() const {                       \
                assert (this != NULL);                       \
                return &m_##NAME();                          \
            }                                                \
            void set_##NAME (TYPE const &a) {                \
                assert (this != NULL);                       \
                assert (&a != NULL);                         \
                m_##NAME()= a;                               \
            }

#undef  _member_rw_ptr
#define _member_rw_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const {                            \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }                                               \
            void set_##NAME (TYPE *a) {                     \
                assert (this != NULL);                      \
                m_##NAME()= a;                              \
            }                                               \
            void reset_##NAME () {                          \
                set_##NAME ((TYPE *)NULL);                  \
            }

#undef  _member_rw_obj
#define _member_rw_obj(TYPE, NAME, DOCSTRING)                   \
            _member_priv_obj (TYPE, NAME, DOCSTRING)            \
            TYPE *NAME() const {                                       \
                if (this == NULL) return NULL;                         \
                return m_##NAME();                                     \
            }                                                          \
            void set_##NAME (TYPE *a) {                                \
                assert (this != NULL);                                 \
                REF ((Object *)a);                \
                CHECK_OTHER_SIG(a);                             \
                UNREF_RVAL((Object *)m_##NAME()); \
                _m_##NAME= a;                                          \
            }                                                          \
            void reset_##NAME () {                                     \
                UNREF_RVAL((Object *)m_##NAME()); \
                _m_##NAME= NULL;                                       \
            }

/* Read/Write-protected member (these are by reference only): */
#undef  _member_rp
#define _member_rp(TYPE, NAME, DOCSTRING)        \
            _member_priv (TYPE, NAME, DOCSTRING) \
            TYPE NAME() const {                         \
                assert (this != NULL);                  \
                return m_##NAME();                      \
            }                                           \
        protected:                                      \
            void set_##NAME (TYPE a) {                  \
                assert (this != NULL);                  \
                m_##NAME()= a;                          \
            }                                           \
        public:

#undef  _member_rp_ref
#define _member_rp_ref(TYPE, NAME, DOCSTRING)        \
            _member_priv_ref (TYPE, NAME, DOCSTRING) \
            TYPE const *NAME() const {                      \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }                                               \
        protected:                                          \
            TYPE *NAME() {                                  \
                if (this == NULL) return NULL;              \
                return &m_##NAME();                         \
            }                                               \
            void set_##NAME (TYPE const *a) {               \
                assert (this != NULL);                      \
                m_##NAME()= *a;                             \
            }                                               \
        public:

#undef  _member_rp_eref
#define _member_rp_eref(TYPE, NAME, DOCSTRING)        \
            _member_priv_eref (TYPE, NAME, DOCSTRING) \
            TYPE const &NAME() const {                       \
                assert (this != NULL);                       \
                return &m_##NAME();                          \
            }                                                \
        protected:                                           \
            TYPE &NAME() {                                   \
                assert (this != NULL);                       \
                return m_##NAME();                           \
            }                                                \
            void set_##NAME (TYPE const &a) {                \
                assert (this != NULL);                       \
                assert (&a != NULL);                         \
                m_##NAME()= a;                               \
            }                                                \
        public:

#undef  _member_rp_ptr
#define _member_rp_ptr(TYPE, NAME, DOCSTRING)        \
            _member_priv_ptr (TYPE, NAME, DOCSTRING) \
            TYPE *NAME() const {                            \
                if (this == NULL) return NULL;              \
                return m_##NAME();                          \
            }                                               \
        protected:                                          \
            void set_##NAME (TYPE *a) {                     \
                assert (this != NULL);                      \
                m_##NAME()= a;                              \
            }                                               \
            void reset_##NAME () {                          \
                set_##NAME ((TYPE *)NULL);                  \
            }                                               \
        public:

#undef  _member_rp_obj
#define _member_rp_obj(TYPE, NAME, DOCSTRING)                   \
            _member_priv_obj (TYPE, NAME, DOCSTRING)            \
            TYPE *NAME() const {                                       \
                if (this == NULL) return NULL;                         \
                return m_##NAME();                                     \
            }                                                          \
        protected:                                                     \
            void set_##NAME (TYPE *a) {                                \
                assert (this != NULL);                                 \
                REF ((Object *)a);                \
                CHECK_OTHER_SIG(a);                             \
                UNREF_RVAL((Object *)m_##NAME()); \
                _m_##NAME= a;                                          \
            }                                                          \
            void reset_##NAME () {                                     \
                UNREF_RVAL((Object *)m_##NAME()); \
                _m_##NAME= NULL;                                       \
            }                                                          \
        public:

#undef  stdclass_no_ref
#define stdclass_no_ref                                                                   \
    public:                                                                                      \
        typedef THIS This;                                                                       \
        typedef SUPER Super;                                                                     \
    protected:                                                                                   \
        virtual THIS *ERWIN_CONCAT_TOKEN(v_as_, THIS) () {CHECK_SIG(this); return this; } \
    public:


#undef  stdclass
#define stdclass          \
        stdclass_no_ref   \
    public:                      \
        stdclass_refcount \
    public:


#undef  concrete
#define concrete                                                      \
        stdclass                                                      \
    private:                                                                 \
        virtual void _concrete () const { }                                  \
    protected:                                                               \
        virtual char const *v_klass_name() const { return ERWIN_STR(THIS); } \
        concrete_id                                                   \
    public:


#undef  abstract
#define abstract                               \
        stdclass                               \
    private:                                          \
        virtual void _concrete () const = 0;          \
    protected:                                        \
        virtual char const *v_klass_name() const = 0; \
        abstract_id                            \
    public:

#undef  abstract_no_ref
#define abstract_no_ref                        \
        stdclass_no_ref                        \
    private:                                          \
        virtual void _concrete () const = 0;          \
    protected:                                        \
        virtual char const *v_klass_name() const = 0; \
        abstract_id                            \
    public:


#ifndef NDEBUG

#   undef  make_cast
#   define make_cast(TYPE)                                \
    public:                                                      \
        TYPE *cast_##TYPE () {                                   \
            if (this == NULL) return NULL;                       \
            TYPE *ERWIN_GENSYM(local_result)= as_##TYPE();       \
            assert (ERWIN_GENSYM(local_result) != NULL);         \
            return ERWIN_GENSYM(local_result);                   \
        }                                                        \
        TYPE const *cast_##TYPE () const {                       \
            if (this == NULL) return NULL;                       \
            TYPE const *ERWIN_GENSYM(local_result)= as_##TYPE(); \
            assert (ERWIN_GENSYM(local_result) != NULL);         \
            return ERWIN_GENSYM(local_result);                   \
        }

#else /* NDEBUG */

#  undef  make_cast
#  define make_cast(TYPE)           \
    public:                                \
        TYPE *cast_##TYPE () {             \
            return (TYPE *)this;           \
        }                                  \
        TYPE const *cast_##TYPE () const { \
            return (TYPE const *)this;     \
        }

#endif /* NDEBUG */

#undef  announce_class
#define announce_class(TYPE)                  \
    protected:                                       \
        virtual TYPE *v_as_##TYPE() { return NULL; } \
        make_cast(TYPE)                       \
    public:                                          \
        TYPE *as_##TYPE () {                         \
            if (this == NULL) return NULL;           \
            return v_as_##TYPE();                    \
        }                                            \
        TYPE const *as_##TYPE () const {             \
            if (this == NULL) return NULL;           \
            return ((Object *)this)->v_as_##TYPE();  \
        }

#endif /* !defined(ERWIN_CLASSUNDEF_H) */

/*
 * Note: the following is outside the #ifdef protection for
 * switching the aliases back on and off after including
 * classundef.h and then again classdef.h.
 */

























































