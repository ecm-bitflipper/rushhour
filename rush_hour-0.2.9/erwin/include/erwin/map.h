/*-*- Mode: C -*-*/
/*
 * Author: Henrik Theiling
 * Description:
 *     Support functions for the map template parts of the Erwin--
 *     library.  These are basically hash functions for standard types.
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 * ---------------------------------------------------------------------- */

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including map.h."
#endif

#ifndef ERWIN_MAP_H
#define ERWIN_MAP_H

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of map.h."
#endif

#ifdef ERWIN_COMPILING
#include "erwin/defs.h"
#else
#include <erwin/defs.h>
#endif

#ifdef ERWIN_ADAM_NAME

#define char_to_upper char_to_upper
#define char_to_lower char_to_lower
#define erwin_random_table erwin_random_table
#define erwin_mapinitialised erwin_mapinitialised
#define char_hash char_hash
#define char_hash2 char_hash2
#define char_hash3 char_hash3
#define char_hash4 char_hash4
#define char_case_hash char_case_hash
#define char_case_hash2 char_case_hash2
#define char_case_hash3 char_case_hash3
#define char_case_hash4 char_case_hash4
#define long_hash long_hash
#define int_hash int_hash
#define short_hash short_hash
#define hash_voidp hash_voidp
#define string_hash string_hash
#define string_case_hash string_case_hash
#define erwininternalmaperrno erwininternalmaperrno
#define erwininternalmapstrerror erwininternalmapstrerror
#define ERWININTERNALMAPOK ERWININTERNALMAPOK
#define ERWININTERNALMAPISOK ERWININTERNALMAPISOK
#define ERWININTERNALMAPISERROR ERWININTERNALMAPISERROR
#define ERWININTERNALMAPISWARNING ERWININTERNALMAPISWARNING
#define ERWININTERNALMAPERRNOMEM ERWININTERNALMAPERRNOMEM
#define ERWININTERNALMAPERRASSERTIONFAILED ERWININTERNALMAPERRASSERTIONFAILED
#define ERWININTERNALMAPWARNEMPTY ERWININTERNALMAPWARNEMPTY
#define ERWININTERNALMAPWARNNOMOREELEMS ERWININTERNALMAPWARNNOMOREELEMS
#define ERWININTERNALMAPWARNEXISTINGKEY ERWININTERNALMAPWARNEXISTINGKEY
#define ERWININTERNALMAPWARNKEYNOTFOUND ERWININTERNALMAPWARNKEYNOTFOUND
#define ERWININTERNALMAPREHASHNOMEM ERWININTERNALMAPREHASHNOMEM
#define ERWININTERNALMAPREHASHDUPLICATEKEY ERWININTERNALMAPREHASHDUPLICATEKEY
#define ERWININTERNALMAPREHASHRECURSION ERWININTERNALMAPREHASHRECURSION

#else /* !defined(ERWIN_ADAM_NAME) */

#ifdef __cplusplus
extern "C" {
#endif

/* These are in base.c but are needed here already. */
extern char char_to_upper (char) ATTR_CONST;
extern char char_to_lower (char) ATTR_CONST;

#define erwin_toupper  char_to_upper
#define erwin_tolower  char_to_lower

extern ERWIN_BOOL erwin_mapinitialised;

/* Hashing */

#ifdef ERWIN_REQUIRE_DETERMINISM
typedef hashval_t const erwin_random_table_t[256];
#else
typedef hashval_t erwin_random_table_t[256];
#endif

#if ERWIN_HASH_STRENGTH >= 1
extern erwin_random_table_t erwin_random_table;
extern erwin_random_table_t erwin_random_table2;
#if ERWIN_HASH_STRENGTH >= 3
extern erwin_random_table_t erwin_random_table3;
extern erwin_random_table_t erwin_random_table4;
#endif
#endif

/* Convenience definitions for old applications.  */
#ifdef ERWIN_COMPAT_2_0_236
#  define hash_char        char_hash
#  define hash_char_case   char_case_hash
#  define hash_long        long_hash
#  define hash_int         int_hash
#  define hash_short       short_hash
#  define hash_string      string_hash
#  define hash_string_case string_case_hash
#endif

#define erwin_hash0(X) (((((hashval_t)(X)) * 3) + \
                                (((hashval_t)(X)) * 7131) + \
                                (((hashval_t)(X)) * 9111371)) ^ \
                                (((hashval_t)(X)) * 755543))


ERWIN_WRAPPER hashval_t char_hash(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_hash(unsigned char x)
{
#if ERWIN_HASH_STRENGTH >= 1
    return erwin_random_table[x];
#else
    return erwin_hash0(x);
#endif
}

#define unsigned_char_hash char_hash
#define signed_char_hash   char_hash

ERWIN_WRAPPER hashval_t char_hash2(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_hash2(unsigned char x)
{
#if ERWIN_HASH_STRENGTH >= 1
    return erwin_random_table2[x];
#else
    return char_hash (x);
#endif
}

ERWIN_WRAPPER hashval_t char_hash3(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_hash3(unsigned char x)
{
#if ERWIN_HASH_STRENGTH >= 3
    return erwin_random_table3[x];
#else
    return char_hash (x);
#endif
}

ERWIN_WRAPPER hashval_t char_hash4(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_hash4(unsigned char x)
{
#if ERWIN_HASH_STRENGTH >= 3
    return erwin_random_table4[x];
#else
    return char_hash2 (x);
#endif
}

/* Internal function, do not use!  It may change or disappear without notice! */
ERWIN_WRAPPER hashval_t erwin_mul9 (hashval_t x) ATTR_CONST;
ERWIN_WRAPPER hashval_t erwin_mul9 (hashval_t x)
{
    return x + (x << 3);
        /* i386/x86_64 and probably many: one cycle by using 'lea' */
}

#ifndef erwin_mul_x1_defined

/* Internal function, do not use!  It may change or disappear without notice! */
ERWIN_WRAPPER hashval_t erwin_mul_x1 (hashval_t x) ATTR_CONST;
ERWIN_WRAPPER hashval_t erwin_mul_x1 (hashval_t x)
{
#if SIZEOF_HASHVAL_T == 8 && defined(ERWIN_U64)
    return x * ERWIN_U64_C(0x0000800200400081);
#else
    return x * 0x400081;
        /* i386/x86_64: hardward multiplier, so mul ist fast.
         * Other architectures may want to use shift & add:
         *
         *   return x + (x << 7) + (x << 22)
         */
#endif
}

#endif /*  erwin_mul_x1_defined */


/* Basic hash functions that may be available as assembly versions.
 *
 * All of these hash functions are collision-free, except when compiling
 * with required determinism.  In that case, long_hash() is constructed
 * in such a way that it hashes 'unsigned int' and 'int' in the same
 * way as int_hash(), which requires artificial introduction of collisions.
 */
#ifndef erwin_u16_hash_defined

ERWIN_WRAPPER hashval_t erwin_u16_hash (ERWIN_U16 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_u16_hash (ERWIN_U16 x)
{
    hashval_t y= x;

    y^= erwin_swap16(x) << 1;
    y+= char_hash  ((unsigned char)y);
    y=  erwin_mul_x1 (y);
    y^= char_hash2 ((unsigned char)(y >> 8));

    return y;
}

#endif /* erwin_u16_hash_defined */

#ifndef erwin_u32_hash_defined

ERWIN_WRAPPER hashval_t erwin_u32_hash (ERWIN_U32 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_u32_hash (ERWIN_U32 x)
{
    hashval_t y= x;

    y^= erwin_swap_low32(y) << 1;
    y+= char_hash  ((unsigned char)y);
    y=  erwin_mul_x1 (y);
    y^= char_hash2 ((unsigned char)(y >> 8));

    /* gcc 4:

     x86_64, 32-bit:
        movl    %edx, %eax
        bswapl  %eax
        roll    $1,%eax
        xorl    %edx, %eax
        movzbl  %al, %edx
        addl    erwin_random_table(,%rdx,4), %eax
        imull   $4194433, %eax, %eax
        movzbl  %ah, %edx
        xorl    erwin_random_table2(,%rdx,4), %eax

     x86_64, 64-bit:
        mov     %edx, %edx
        movq    %rdx, %rax
        bswapl  %eax
        rolq    $1,%rax
        xorq    %rdx, %rax
        movzbl  %al, %edx
        addq    erwin_random_table(,%rdx,8), %rax
        movabsq $140746082484353, %rdx
        imulq   %rdx, %rax
        movzbl  %ah, %edx
        xorq    erwin_random_table2(,%rdx,8), %rax
     */

    return y;
}

#endif /* erwin_u32_hash_defined */

#ifdef ERWIN_U64
#ifndef erwin_u64_hash_defined

ERWIN_WRAPPER hashval_t erwin_u64_hash (ERWIN_U64 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_u64_hash (ERWIN_U64 x)
{
    hashval_t y;

#if defined(ERWIN_REQUIRE_DETERMINISM)
    /* In this case, this function must hash values in int and unsigned
     * range in the same way as erwin_u32, otherwise long_hash(x) is
     * different on 32 vs. 64 bits, despite the same bit width of hashval_t. */

    y= erwin_u32_hash((ERWIN_U32)x);
    {
        ERWIN_U32 x32= (ERWIN_U32)(x >> 32);
        if (x32 && ~x32) {
            y^= erwin_swap_low32 (x32) << 1;
            y+= char_hash3 ((unsigned char)y);
            y=  erwin_mul_x1 (y);
            y^= char_hash4 ((unsigned char)(y >> 8));
        }
    }

#else /* !REQUIRE_DETERMINISM */

    y=  (hashval_t)x;

#if SIZEOF_HASHVAL_T == 8
    y^= erwin_swap64(y) << 1;
#else
    y^= erwin_swap_low32(y) << 1;
    y^= erwin_swap_low32((hashval_t)(x >> 32)) << 3;
#endif
    y+= char_hash  ((unsigned char)y);
    y=  erwin_mul_x1 (y);
    y^= char_hash2 ((unsigned char)(y >> 8));

#endif /* !REQUIRE_DETERMINISM */

    return y;
}

#endif /* erwin_u64_hash_defined */
#endif /* ERWIN_U64 */

ERWIN_WRAPPER hashval_t short_hash (unsigned short x) ATTR_PURE;
ERWIN_WRAPPER hashval_t short_hash (unsigned short x)
{
    return erwin_u16_hash (x);
}

#define unsigned_short_hash short_hash

ERWIN_WRAPPER hashval_t int_hash(unsigned int x) ATTR_PURE;
ERWIN_WRAPPER hashval_t int_hash(unsigned int x)
{
#if SIZEOF_INT == 8 && defined(ERWIN_U64)
    return erwin_u64_hash (x);
#elif SIZEOF_INT == 2
    return erwin_u16_hash (x);
#else
    return erwin_u32_hash (x);
#endif
}

#define unsigned_hash int_hash

ERWIN_WRAPPER hashval_t long_hash(unsigned long x) ATTR_PURE;
ERWIN_WRAPPER hashval_t long_hash(unsigned long x)
{
#if SIZEOF_LONG == 8 && defined(ERWIN_U64)
    return erwin_u64_hash (x);
#else
    return erwin_u32_hash (x);
#endif
}

#define unsigned_long_hash long_hash

#if defined(ERWIN_UNSIGNED_LONG_LONG) && defined(ERWIN_U64)

ERWIN_WRAPPER hashval_t long_long_hash(ERWIN_UNSIGNED_LONG_LONG x) ATTR_PURE;
ERWIN_WRAPPER hashval_t long_long_hash(ERWIN_UNSIGNED_LONG_LONG x)
{
    return erwin_u64_hash (x);
}

#define unsigned_long_long_hash long_long_hash

#endif

ERWIN_WRAPPER hashval_t voidp_hash (void const *x) ATTR_PURE;
ERWIN_WRAPPER hashval_t voidp_hash (void const *x)
{
#if SIZEOF_VOIDP == SIZEOF_LONG
    return long_hash ((unsigned long)x);
#else
    return int_hash ((unsigned int)x);
#endif
}

ERWIN_WRAPPER hashval_t size_t_hash(size_t x) ATTR_PURE;
ERWIN_WRAPPER hashval_t size_t_hash(size_t x)
{
#if SIZEOF_SIZE_T == 8 && defined(ERWIN_U64)
    return erwin_u64_hash (x);
#elif SIZEOF_SIZE_T == 2
    return erwin_u16_hash (x);
#else
    return erwin_u32_hash (x);
#endif
}

/* Shoot, this has a bad name.  Use voidp_hash() instead.
 * We keep it for compatibility, but mark it deprecated: */
ERWIN_WRAPPER hashval_t hash_voidp (void const *x) ATTR_PURE ATTR_DEPRECATED;
ERWIN_WRAPPER hashval_t hash_voidp (void const *x)
{
    return voidp_hash (x);
}

ERWIN_WRAPPER hashval_t char_case_hash(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_case_hash(unsigned char x)
{
    return char_hash ((unsigned char)char_to_lower((char)x));
}

#define unsigned_char_case_hash char_case_hash
#define signed_char_case_hash   char_case_hash


ERWIN_WRAPPER hashval_t char_case_hash2(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_case_hash2(unsigned char x)
{
    return char_hash2 ((unsigned char)char_to_lower((char)x));
}

ERWIN_WRAPPER hashval_t char_case_hash3(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_case_hash3(unsigned char x)
{
    return char_hash3 ((unsigned char)char_to_lower((char)x));
}

ERWIN_WRAPPER hashval_t char_case_hash4(unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t char_case_hash4(unsigned char x)
{
    return char_hash4 ((unsigned char)char_to_lower((char)x));
}

ERWIN_WRAPPER hashval_t erwin_make_hash_result(
    hashval_t, hashval_t) ATTR_PURE;

ERWIN_WRAPPER hashval_t erwin_make_hash_result(
    hashval_t h1, hashval_t h2)
{
#if SIZEOF_HASHVAL_T == 4 && defined(ERWIN_U64)
    return erwin_u64_hash (((ERWIN_U64)h1) + (((ERWIN_U64)h2) << 32));
#else
    hashval_t y;

    y=  h1;
    y^= char_hash4 ((unsigned char)(y >> 8));
    y+= h2;
    y^= erwin_swap (y) << 1;
    y+= char_hash3 ((unsigned char)y);

    return y;
#endif
}

/* And another one for hashing memory areas of a given size (with various sizes).
 * All functions take the pointer to the array and the number of elements of the array
 * to be hashed: */
extern hashval_t erwin_u8_array_hash       (ERWIN_U8  const *, size_t) ATTR_PURE;
extern hashval_t erwin_u8_array_case_hash  (ERWIN_U8  const *, size_t) ATTR_PURE;
extern hashval_t erwin_u16_array_hash      (ERWIN_U16 const *, size_t) ATTR_PURE;
extern hashval_t erwin_u32_array_hash      (ERWIN_U32 const *, size_t) ATTR_PURE;

#ifdef ERWIN_U64
extern hashval_t erwin_u64_array_hash      (ERWIN_U64 const *, size_t) ATTR_PURE;
#endif

ERWIN_WRAPPER hashval_t erwin_s8_array_hash (ERWIN_S8 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s8_array_hash (ERWIN_S8 const *x, size_t s)
{
    return erwin_u8_array_hash((ERWIN_U8*)x,s);
}

ERWIN_WRAPPER hashval_t erwin_s8_array_case_hash (ERWIN_S8 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s8_array_case_hash (ERWIN_S8 const *x, size_t s)
{
    return erwin_u8_array_case_hash ((ERWIN_U8*)x,s);
}

ERWIN_WRAPPER hashval_t erwin_s16_array_hash (ERWIN_S16 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s16_array_hash (ERWIN_S16 const *x, size_t s)
{
    return erwin_u16_array_hash((ERWIN_U16*)x,s);
}

ERWIN_WRAPPER hashval_t erwin_s32_array_hash (ERWIN_S32 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s32_array_hash (ERWIN_S32 const *x, size_t s)
{
    return erwin_u32_array_hash((ERWIN_U32*)x,s);
}

#if defined(ERWIN_U64) && defined(ERWIN_S64)
ERWIN_WRAPPER hashval_t erwin_s64_array_hash (ERWIN_S64 const *x, size_t s) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s64_array_hash (ERWIN_S64 const *x, size_t s)
{
    return erwin_u64_array_hash((ERWIN_U64*)x,s);
}
#endif

ERWIN_WRAPPER hashval_t erwin_u8_hash (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_u8_hash (ERWIN_S8 x)
{
    return char_hash((ERWIN_U8)x);
}

ERWIN_WRAPPER hashval_t erwin_u8_hash_case (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_u8_hash_case (ERWIN_S8 x)
{
    return char_case_hash ((ERWIN_U8)x);
}

ERWIN_WRAPPER hashval_t erwin_s8_hash (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s8_hash (ERWIN_S8 x)
{
    return char_hash((ERWIN_U8)x);
}

ERWIN_WRAPPER hashval_t erwin_s8_hash_case (ERWIN_S8 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s8_hash_case (ERWIN_S8 x)
{
    return char_case_hash ((ERWIN_U8)x);
}

ERWIN_WRAPPER hashval_t erwin_s16_hash (ERWIN_S16 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s16_hash (ERWIN_S16 x)
{
    return erwin_u16_hash((ERWIN_U16)x);
}

ERWIN_WRAPPER hashval_t erwin_s32_hash (ERWIN_S32 x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s32_hash (ERWIN_S32 x)
{
    return erwin_u32_hash((ERWIN_U32)x);
}

#if defined(ERWIN_U64) && defined(ERWIN_S64)
ERWIN_WRAPPER hashval_t erwin_s64_hash (ERWIN_S64 const x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_s64_hash (ERWIN_S64 const x)
{
    return erwin_u64_hash((ERWIN_U64)x);
}
#endif


#define erwin_char_array_hash(x,s)   erwin_u8_array_hash((ERWIN_U8 const *)x,s)

#if SIZEOF_SHORT == 2
#define erwin_short_array_hash(x,s)  erwin_u16_array_hash((ERWIN_U16 const *)x,s)
#endif

#if SIZEOF_INT == 2
#define erwin_int_array_hash(x,s)    erwin_u16_array_hash((ERWIN_U16 const *)x,s)
#elif SIZEOF_INT == 4
#define erwin_int_array_hash(x,s)    erwin_u32_array_hash((ERWIN_U32 const *)x,s)
#elif SIZEOF_INT == 8
#define erwin_int_array_hash(x,s)    erwin_u64_array_hash((ERWIN_U64 const *)x,s)
#endif

#if SIZEOF_LONG == 4
#define erwin_long_array_hash(x,s)   erwin_u32_array_hash((ERWIN_U32 const *)x,s)
#elif SIZEOF_LONG == 8
#define erwin_long_array_hash(x,s)   erwin_u64_array_hash((ERWIN_U64 const *)x,s)
#endif


#ifdef __cplusplus
/* overloaded versions: */
extern "C++" {

ERWIN_WRAPPER hashval_t erwin_hash (bool x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (bool x)
{
    return char_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (char x)
{
    return char_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (signed char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (signed char x)
{
    return char_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (unsigned char x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (unsigned char x)
{
    return char_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (short x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (short x)
{
    return short_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (unsigned short x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (unsigned short x)
{
    return short_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (int x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (int x)
{
    return int_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (unsigned x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (unsigned x)
{
    return int_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (long x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (long x)
{
    return long_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (unsigned long x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (unsigned long x)
{
    return long_hash (x);
}

#ifdef ERWIN_LONG_LONG
ERWIN_WRAPPER hashval_t erwin_hash (ERWIN_LONG_LONG x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (ERWIN_LONG_LONG x)
{
    return long_long_hash (x);
}

ERWIN_WRAPPER hashval_t erwin_hash (ERWIN_UNSIGNED_LONG_LONG x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (ERWIN_UNSIGNED_LONG_LONG x)
{
    return long_long_hash (x);
}
#endif /* defined ERWIN_LONG_LONG */


/* Pointers */
ERWIN_WRAPPER hashval_t erwin_hash (void const *x) ATTR_PURE;
ERWIN_WRAPPER hashval_t erwin_hash (void const *x)
{
    return voidp_hash (x);
}

/* Other pointers are not hashed in a default way, because it is up to the
 * user to decide whether the pointer or the contents are to be hashed. */

} /* extern "C++" */
#endif /* C++ */

/* NOTE: string_hash and string_case_hash are now in base.h. */

/* ********************************************************************** */
/* Combine multiple hash values into one.  Use these macros instead of
 * thinking of something yourself when you write hash functions for your
 * own macros so that the macros can eventually be improved if necessary
 * and your code automatically improves, too.
 *
 * Use them as follows (example for a struct):
 *
 *   hashval_t mypair_hash (struct mypair_t const *x)
 *   {
 *       erwin_hash_state_t state;
 *
 *       ERWIN_STATE_INIT (state);
 *       ERWIN_STATE_MIX_ORDERED2(state, mytype1_hash(x->a), mytype2_hash(x->b));
 *
 *       return ERWIN_STATE_GET_HASHVAL(state);
 *   }
 *
 * Or a string.  You may use ERWIN_HASH_INIT* for quick hash values for special
 * keys:
 *
 *   hashval_t mystring_hash (mytype_t const *x)
 *   {
 *       if (x == NULL)
 *           return ERWIN_HASH_INIT;
 *
 *       erwin_hash_state_t state;
 *       ERWIN_STATE_INIT(state);
 *
 *       for (; *x; x++)
 *            ERWIN_STATE_MIX_ORDERED (state, mytype_hash(*x));
 *
 *       return ERWIN_STATE_GET_HASHVAL(state);
 *   }
 *
 * Use the _UNORDERED variants if the iteration is non-deterministic (e.g. in
 * randomised hash tables).
 *
 * To speed up a bit, you can have a slightly faster initialisation (we're talking
 * about a few machine instructions here), you can ERWIN_STATE_INIT_WITH(s,first_value)
 * instead of ERWIN_STATE_INIT(s); ERWIN_STATE_MIX_ORDERED(s,first_value).  This
 * is handy since many structure have a size + dynamic set of elements, and for
 * the size, this comes in handy.  Don't bother to optimise too much, though.  If
 * you have two initial values, use the normal ERWIN_STATE_MIX_ORDERED2 instead to
 * add them too the hash state.
 *
 * The result of such a construction of have values via a state will be very good
 * hash values.  No need for another hashval_t_hash().  You can directly use
 * (hashval % size) or better erwin_hash_into(hashval,size), which uses multiplication
 * instead of division, to reduce the hashval to a given size.
 */

/* Combine some digits:

   (setq *print-base* 16)
   (setf (long-float-digits) 800)
   (integer-decode-float pi)

32 bits:
   C90FDAA2
   2168C234
   C4C6628B
   80DC1CD1
   29024E08
   8A67CC74
   020BBEA6
   3B139B22
   514A0879
   8E3404DD
   EF9519B3
   CD3A431B
   ...

64 bits:
   C90FDAA22168C234
   C4C6628B80DC1CD1
   29024E088A67CC74
   020BBEA63B139B22
   514A08798E3404DD
   EF9519B3CD3A431B
   302B0A6DF25F1437
   4FE1356D6D51C245
   E485B576625E7EC6
   F44C42E9A637ED6B
   0BFF5CB6F406B7ED
   EE386BFB5A899FA5
   ...
*/


/* Some initial hashvalues (quite arbitrary, actually, these are the first
 * few digits of pi (shifted)): */
#if SIZEOF_HASHVAL_T == 8
# ifndef ERWIN_HASH_INIT
# define ERWIN_HASH_INIT   HASHVAL_C(0xC90FDAA22168C234)
# endif /* !defined ERWIN_HASH_INIT */
# ifndef ERWIN_HASH_INIT2
# define ERWIN_HASH_INIT2  HASHVAL_C(0xC4C6628B80DC1CD1)
# endif /* !defined ERWIN_HASH_INIT2 */
# ifndef ERWIN_HASH_INIT3
# define ERWIN_HASH_INIT3  HASHVAL_C(0x29024E088A67CC74)
# endif /* !defined ERWIN_HASH_INIT3 */
# ifndef ERWIN_HASH_INIT4
# define ERWIN_HASH_INIT4  HASHVAL_C(0x020BBEA63B139B22)
# endif /* !defined ERWIN_HASH_INIT4 */
# ifndef ERWIN_HASH_INIT5
# define ERWIN_HASH_INIT5  HASHVAL_C(0x514A08798E3404DD)
# endif /* !defined ERWIN_HASH_INIT5 */
# ifndef ERWIN_HASH_INIT6
# define ERWIN_HASH_INIT6  HASHVAL_C(0xEF9519B3CD3A431B)
# endif /* !defined ERWIN_HASH_INIT6 */
# ifndef ERWIN_HASH_INIT7
# define ERWIN_HASH_INIT7  HASHVAL_C(0x302B0A6DF25F1437)
# endif /* !defined ERWIN_HASH_INIT7 */
# ifndef ERWIN_HASH_INIT8
# define ERWIN_HASH_INIT8  HASHVAL_C(0x4FE1356D6D51C245)
# endif /* !defined ERWIN_HASH_INIT8 */
# ifndef ERWIN_HASH_INIT9
# define ERWIN_HASH_INIT9  HASHVAL_C(0xE485B576625E7EC6)
# endif /* !defined ERWIN_HASH_INIT9 */
#else
# ifndef ERWIN_HASH_INIT
# define ERWIN_HASH_INIT   HASHVAL_C(0xC90FDAA2)
# endif /* !defined ERWIN_HASH_INIT */
# ifndef ERWIN_HASH_INIT2
# define ERWIN_HASH_INIT2  HASHVAL_C(0x2168C234)
# endif /* !defined ERWIN_HASH_INIT2 */
# ifndef ERWIN_HASH_INIT3
# define ERWIN_HASH_INIT3  HASHVAL_C(0xC4C6628B)
# endif /* !defined ERWIN_HASH_INIT3 */
# ifndef ERWIN_HASH_INIT4
# define ERWIN_HASH_INIT4  HASHVAL_C(0x80DC1CD1)
# endif /* !defined ERWIN_HASH_INIT4 */
# ifndef ERWIN_HASH_INIT5
# define ERWIN_HASH_INIT5  HASHVAL_C(0x29024E08)
# endif /* !defined ERWIN_HASH_INIT5 */
# ifndef ERWIN_HASH_INIT6
# define ERWIN_HASH_INIT6  HASHVAL_C(0x8A67CC74)
# endif /* !defined ERWIN_HASH_INIT6 */
# ifndef ERWIN_HASH_INIT7
# define ERWIN_HASH_INIT7  HASHVAL_C(0x020BBEA6)
# endif /* !defined ERWIN_HASH_INIT7 */
# ifndef ERWIN_HASH_INIT8
# define ERWIN_HASH_INIT8  HASHVAL_C(0x3B139B22)
# endif /* !defined ERWIN_HASH_INIT8 */
# ifndef ERWIN_HASH_INIT9
# define ERWIN_HASH_INIT9  HASHVAL_C(0x514A0879)
# endif /* !defined ERWIN_HASH_INIT9 */
#endif

/* For data structures with deterministic combination order: */
#ifndef ERWIN_HASH_MIX_ORDERED
#define ERWIN_HASH_MIX_ORDERED(h1,h2,newvalue)                   \
        do{                                                              \
            h2^= erwin_ror1(h1) - ((hashval_t)(newvalue)); \
            h1+= erwin_mul9(h2);                                  \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_ORDERED */

/* Another function for combining two values at once: */
#ifndef ERWIN_HASH_MIX_ORDERED2
#define ERWIN_HASH_MIX_ORDERED2(h1,h2,newvalue1,newvalue2)        \
        do{                                                               \
            h2^= erwin_ror1(h1) - ((hashval_t)(newvalue1)); \
            h1+= erwin_mul9(h2) ^ newvalue2;                       \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_ORDERED2 */

#ifndef ERWIN_HASH_MIX_ORDERED3
#define ERWIN_HASH_MIX_ORDERED3(h1,h2,n1,n2,n3)  \
        do{                                              \
            ERWIN_HASH_MIX_ORDERED2(h1,h2,n1,n2); \
            ERWIN_HASH_MIX_ORDERED (h1,h2,n3);    \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_ORDERED3 */

#ifndef ERWIN_HASH_MIX_ORDERED4
#define ERWIN_HASH_MIX_ORDERED4(h1,h2,n1,n2,n3,n4) \
        do{                                                \
            ERWIN_HASH_MIX_ORDERED2(h1,h2,n1,n2);   \
            ERWIN_HASH_MIX_ORDERED2(h1,h2,n3,n4);   \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_ORDERED4 */

#ifndef ERWIN_HASH_MIX_ORDERED5
#define ERWIN_HASH_MIX_ORDERED5(h1,h2,n1,n2,n3,n4,n5) \
        do{                                                   \
            ERWIN_HASH_MIX_ORDERED3(h1,h2,n1,n2,n3);   \
            ERWIN_HASH_MIX_ORDERED2(h1,h2,n4,n5);      \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_ORDERED5 */

#ifndef ERWIN_HASH_RESULT_ORDERED
#define ERWIN_HASH_RESULT_ORDERED(h1,h2) \
        erwin_make_hash_result(h1,h2)
#endif /* !defined ERWIN_HASH_RESULT_ORDERED */

/* For data structures with non-deterministic combination order.
 * It is assumed that the arguments of these functions are in
 * deterministic order, i.e., that you hash a non-deterministic
 * sequence of n record entries each:
 *     MIX(h,i,a,b)       ; order of lines non-deterministic, but
 *     MIX(h,i,a,b)       ; never b,a instead of a,b
 *     ...
 *     MIX(h,i,a,b)
 * If this is not the case, the easiest way to mix the result
 * is to use  a simple + or ^.
 */

#ifndef ERWIN_HASH_MIX_UNORDERED
#define ERWIN_HASH_MIX_UNORDERED(h1,h2,newvalue) \
        do{                                              \
            h1^= ((hashval_t)(newvalue));         \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_UNORDERED */

/* Another function for combining two values at once: */
#ifndef ERWIN_HASH_MIX_UNORDERED2
#define ERWIN_HASH_MIX_UNORDERED2(h1,h2,newvalue1,newvalue2) \
        do{                                                          \
            h1^= ((hashval_t)(newvalue1));                    \
            h2+= newvalue2;                                          \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_UNORDERED2 */

#ifndef ERWIN_HASH_MIX_UNORDERED3
#define ERWIN_HASH_MIX_UNORDERED3(h1,h2,n1,n2,n3)  \
        do{                                                \
            ERWIN_HASH_MIX_UNORDERED2(h1,h2,n1,n2); \
            ERWIN_HASH_MIX_UNORDERED (h1,h2,n3);    \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_UNORDERED3 */

#ifndef ERWIN_HASH_MIX_UNORDERED4
#define ERWIN_HASH_MIX_UNORDERED4(h1,h2,n1,n2,n3,n4) \
        do{                                                  \
            ERWIN_HASH_MIX_UNORDERED2(h1,h2,n1,n2);   \
            ERWIN_HASH_MIX_UNORDERED2(h1,h2,n3,n4);   \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_UNORDERED4 */

#ifndef ERWIN_HASH_MIX_UNORDERED5
#define ERWIN_HASH_MIX_UNORDERED5(h1,h2,n1,n2,n3,n4,n5) \
        do{                                                     \
            ERWIN_HASH_MIX_UNORDERED3(h1,h2,n1,n2,n3);   \
            ERWIN_HASH_MIX_UNORDERED2(h1,h2,n4,n5);      \
        }while(0)
#endif /* !defined ERWIN_HASH_MIX_UNORDERED5 */

/* the following function is provided for compatibility with older
 * versions.  It is of no use. */;
#ifndef ERWIN_HASH_RESULT_UNORDERED
#define ERWIN_HASH_RESULT_UNORDERED \
        ERWIN_HASH_RESULT_ORDERED
#endif /* !defined ERWIN_HASH_RESULT_UNORDERED */

/* The more modern state based interface which leaves more space for
 * future improvements. */
#ifndef ERWIN_STATE_INIT
#define ERWIN_STATE_INIT(s)            \
            do{                                \
                s.h1= ERWIN_HASH_INIT2; \
                s.h2= ERWIN_HASH_INIT3; \
            }while(0)
#endif /* !defined ERWIN_STATE_INIT */

#ifndef ERWIN_STATE_INIT_WITH
#define ERWIN_STATE_INIT_WITH(s,h)                             \
            do{                                                        \
                s.h1= ERWIN_HASH_INIT2 - ((hashval_t)h); \
                s.h2= ERWIN_HASH_INIT3;                         \
            }while(0)
#endif /* !defined ERWIN_STATE_INIT_WITH */


struct erwin_hash_state_t {
    hashval_t h1;
    hashval_t h2;
};

#ifndef __cplusplus
typedef struct erwin_hash_state_t erwin_hash_state_t;
#endif

#ifndef ERWIN_STATE_MIX_ORDERED
#define ERWIN_STATE_MIX_ORDERED(s,n1) \
            ERWIN_HASH_MIX_ORDERED(s.h1,s.h2,n1)
#endif /* !defined ERWIN_STATE_MIX_ORDERED */

#ifndef ERWIN_STATE_MIX_ORDERED2
#define ERWIN_STATE_MIX_ORDERED2(s,n1,n2) \
            ERWIN_HASH_MIX_ORDERED2(s.h1,s.h2,n1,n2)
#endif /* !defined ERWIN_STATE_MIX_ORDERED2 */

#ifndef ERWIN_STATE_MIX_ORDERED3
#define ERWIN_STATE_MIX_ORDERED3(s,n1,n2,n3) \
            ERWIN_HASH_MIX_ORDERED3(s.h1,s.h2,n1,n2,n3)
#endif /* !defined ERWIN_STATE_MIX_ORDERED3 */

#ifndef ERWIN_STATE_MIX_ORDERED4
#define ERWIN_STATE_MIX_ORDERED4(s,n1,n2,n3,n4) \
            ERWIN_HASH_MIX_ORDERED4(s.h1,s.h2,n1,n2,n3,n4)
#endif /* !defined ERWIN_STATE_MIX_ORDERED4 */

#ifndef ERWIN_STATE_MIX_ORDERED5
#define ERWIN_STATE_MIX_ORDERED5(s,n1,n2,n3,n4,n5) \
            ERWIN_HASH_MIX_ORDERED5(s.h1,s.h2,n1,n2,n3,n4,n5)
#endif /* !defined ERWIN_STATE_MIX_ORDERED5 */


#ifndef ERWIN_STATE_MIX_UNORDERED
#define ERWIN_STATE_MIX_UNORDERED(s,n1) \
            ERWIN_HASH_MIX_UNORDERED(s.h1,s.h2,n1)
#endif /* !defined ERWIN_STATE_MIX_UNORDERED */

#ifndef ERWIN_STATE_MIX_UNORDERED2
#define ERWIN_STATE_MIX_UNORDERED2(s,n1,n2) \
            ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2)
#endif /* !defined ERWIN_STATE_MIX_UNORDERED2 */

#ifndef ERWIN_STATE_MIX_UNORDERED3
#define ERWIN_STATE_MIX_UNORDERED3(s,n1,n2,n3) \
            ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2,n3)
#endif /* !defined ERWIN_STATE_MIX_UNORDERED3 */

#ifndef ERWIN_STATE_MIX_UNORDERED4
#define ERWIN_STATE_MIX_UNORDERED4(s,n1,n2,n3,n4) \
            ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2,n3,n4)
#endif /* !defined ERWIN_STATE_MIX_UNORDERED4 */

#ifndef ERWIN_STATE_MIX_UNORDERED5
#define ERWIN_STATE_MIX_UNORDERED5(s,n1,n2,n3,n4,n5) \
            ERWIN_HASH_MIX_UNORDERED2(s.h1,s.h2,n1,n2,n3,n4,n5)
#endif /* !defined ERWIN_STATE_MIX_UNORDERED5 */


#ifndef ERWIN_STATE_GET_HASHVAL
#define ERWIN_STATE_GET_HASHVAL(s) \
            ERWIN_HASH_RESULT_ORDERED(s.h1,s.h2)
#endif /* !defined ERWIN_STATE_GET_HASHVAL */


/*
 * The implementation of global errno is not straightforward when using
 * a complex string replacement algorithm like the template mechanism
 * of Erwin--.  E.g. we cannot declare a global map_errno, because
 * someone might choose to map `map' to `hash'.  Then the instantiated
 * templates would not be able to be liked with this library.  Therefore,
 * we must introduce stupid names which hopefully no-one remaps to
 * something strange.  Then, {map,vector}_errno (or whatever they will
 * be renamed to) are macros mapping to one of the following variables.
 *
 * Another problem is that map_errno is a global variable which is not
 * thread safe.  Therefore, its declaration is not straightforward...
 */
/* must be in sync with map.c: */
#if !defined(ERWIN_THREAD_SAFE) || ERWIN_USE_THREAD_KEYWORD
extern ERWIN_THREAD_LOCAL int erwininternalmaperrno;
#elif ERWIN_USE_PTHREAD
extern int *erwininternalmaperrnoptr(void);
#define erwininternalmaperrno (*erwininternalmaperrnoptr())
#endif

extern char const *erwininternalmapstrerror (int) ATTR_PURE;

#define ERWININTERNALMAPOK                   1
/* The value 0 is not used for error codes because 0 is polymorphic
 * and can be a pointer.  1 cannot. */

#define ERWININTERNALMAPISOK(X)              ((X) == ERWININTERNALMAPOK)
#define ERWININTERNALMAPISERROR(X)           ((X) <  ERWININTERNALMAPOK)
#define ERWININTERNALMAPISWARNING(X)         ((X) >  ERWININTERNALMAPOK)

#define ERWININTERNALMAPERRNOMEM             (-2)
#define ERWININTERNALMAPERRASSERTIONFAILED   (-5)

#define ERWININTERNALMAPWARNEMPTY            5
#define ERWININTERNALMAPWARNNOMOREELEMS      6
#define ERWININTERNALMAPWARNEXISTINGKEY      7
#define ERWININTERNALMAPWARNKEYNOTFOUND      8

#define ERWININTERNALMAPREHASHNOMEM          2
#define ERWININTERNALMAPREHASHDUPLICATEKEY   3
#define ERWININTERNALMAPREHASHRECURSION      4

#ifdef __cplusplus
}
#endif

#endif /* defined(ERWIN_ADAM_NAME) */

#endif /* ERWIN_ERWIN_MAP_H */
