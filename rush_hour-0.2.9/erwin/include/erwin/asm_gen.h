/* -*- Mode: C -*-
 *
 * Author: Henrik Theiling
 * Description:
 *     Assembly routines for the i386:
 *
 * @@Begin: Licencing and Copying@@
 *
 * Copyright (c) Henrik Theiling
 * Licence Version 2, Special Version for Erwin.
 *
 * The term 'this software' used in the following, additional to its
 * usual usage, also includes the instantiated source files generated by
 * tools of this package.
 *
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must
 * not claim that you wrote the original software. If you use this
 * software in a product, an acknowledgment in the product documentation
 * would be appreciated.
 *
 * 2. Altered source versions must be plainly marked as such, and must
 * not be misrepresented as being the original software.
 *
 * 3. You must not use any of the names of the authors or copyright
 * holders of the original software for advertising or publicity
 * pertaining to distribution without specific, written prior permission.
 *
 * 4. If you change this software and redistribute parts or all of it in
 * any form, you must make the source code of the altered version of this
 * software available.  As an exception, files that were generated by
 * tools of this package may be used freely, including modification.
 *
 * 5. This notice must not be removed or altered from any source
 * distribution.
 *
 * This licence is governed by the Laws of Germany.  Disputes shall be
 * settled by Saarbruecken City Court.
 *
 * @@End: Licencing and Copying@@
 *
 */

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including asm_gen.h."
#endif

#ifndef ERWIN_ASM_GENERIC_H
#define ERWIN_ASM_GENERIC_H

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of asm_gen.h."
#endif

/* ********************************************************************** */
/* If you are about to modify or extend this file, be sure to read
 * 'Hacker's Delight' before you try. */

/* Note:
 *   It is a bit unfortunate that some functions work on 'unsigned long',
 *   others on hashval_t, and for some, there are several versions for
 *   ERWIN_U32 and ERWIN_U64 (and maybe more).  We will probably try to
 *   fix this in the future, meaning that the interface will change.
 *   The goal is the following: for an algorithm 'erwin_xyz', we
 *   will have at least three functions:
 *
 *     - erwin_xyz()      working on hashval_t
 *     - erwin_xyz32()    working on ERWIN_U32
 *     - erwin_xyz64()    working on ERWIN_U64
 *
 *   Note that hashval_t is never shorter than 'unsigned', so it may be
 *   used when you handle with unsigneds.  hashval_t is usually the
 *   natural width of the processor, so it is the fast choice, too.
 *
 *   Most functions already work like this, and some have been converted
 *   already.  The following are not compliant yet:
 *
 *   TODO: these still only work on 'unsigned long':
 *        - _count_bits
 *        - _count_bits_non0
 *        - _trailing_0s
 *        - _trailing_0s_non0
 *        - _count_set_bits
 *        - _next_power2_minus1
 *        - _next_power2
 *        - _prev_power2
 *        - _is_power2
 *
 * Other functions work on 'long' and will probably continue to do so, e.g.:
 *        - _sign            : long      -> int
 *        - _sign64          : ERWIN_S64 -> int
 *
 * Please also excuse the confusion due to 'count_bits' vs. 'count_set_bits' vs.
 * 'trailing_0s'.
 */

/* ********************************************************************** */
#ifndef erwin_mulh32_defined

ERWIN_WRAPPER ERWIN_U32 erwin_mulh32 (ERWIN_U32 a, ERWIN_U32 b)
{
#ifdef ERWIN_U64
    return (((ERWIN_U64)a) * ((ERWIN_U64)b)) >> 32;
#else
    ERWIN_U32 al=  a & ERWIN_U32_C(0xffff);
    ERWIN_U32 ah=  a >> 16;
    ERWIN_U32 bl=  b & ERWIN_U32_C(0xffff);
    ERWIN_U32 bh=  b >> 16;
    ERWIN_U32 lh1= ah*bl + ((al*bl) >> 16);
    return ah*bh + (lh1 >> 16) + ((al*bh + (lh1 & ERWIN_U32_C(0xffff))) >> 16);
#endif
}

#endif /*!defined(erwin_mulh32_defined) */
/* ********************************************************************** */
#ifndef erwin_mulh64_defined


#ifdef ERWIN_U64
ERWIN_WRAPPER ERWIN_U64 erwin_mulh64 (ERWIN_U64 a, ERWIN_U64 b)
{
    ERWIN_U64 al=  a & ERWIN_U64_C(0xffffffff);
    ERWIN_U64 ah=  a >> 32;
    ERWIN_U64 bl=  b & ERWIN_U64_C(0xffffffff);
    ERWIN_U64 bh=  b >> 32;
    ERWIN_U64 lh1= ah*bl + erwin_mulh32((ERWIN_U32)al,(ERWIN_U32)bl);
    return ah*bh + (lh1 >> 32) + ((al*bh + (lh1 & ERWIN_U64_C(0xffffffff))) >> 32);
}
#endif /* defined ERWIN_U64 */

#endif /*!defined(erwin_mulh64_defined) */
/* ********************************************************************** */

ERWIN_WRAPPER hashval_t erwin_mulh (hashval_t a, hashval_t b)
{
#if SIZEOF_HASHVAL_T == 8
    return erwin_mulh64(a,b);
#else
    return erwin_mulh32(a,b);
#endif
}

/* ********************************************************************** */

ERWIN_WRAPPER int erwin_sign (long d)
{
    return ((signed   long)( d) >> (ERWIN_BIT_SIZEOF(d) - 1)) |
           ((unsigned long)(-d) >> (ERWIN_BIT_SIZEOF(d) - 1));
}

/* ********************************************************************** */

#ifdef ERWIN_S64
ERWIN_WRAPPER int erwin_sign64 (ERWIN_S64 d)
{
    return ((ERWIN_S64)( d) >> (ERWIN_BIT_SIZEOF(d) - 1)) |
           ((ERWIN_U64)(-d) >> (ERWIN_BIT_SIZEOF(d) - 1));
}
#endif

/* ********************************************************************** */

#ifndef erwin_hash_into_defined
#define erwin_hash_into   erwin_mulh
#endif /* !defined erwin_hash_into_defined */

/* ********************************************************************** */

ERWIN_WRAPPER ERWIN_U32 erwin_golden_mul32 (ERWIN_U32 i, ERWIN_U32 mod)
{
    return erwin_mulh32 (i * ERWIN_GOLDEN_RATIO_SHL_32, mod);
}

#ifdef ERWIN_U64
ERWIN_WRAPPER ERWIN_U64 erwin_golden_mul64 (ERWIN_U64 i, ERWIN_U64 mod)
{
    return erwin_mulh64 (i * ERWIN_GOLDEN_RATIO_SHL_64, mod);
}
#endif

ERWIN_WRAPPER hashval_t erwin_golden_mul (hashval_t i, hashval_t mod)
{
#if SIZEOF_HASHVAL_T == 8
    return erwin_golden_mul64(i,mod);
#else
    return erwin_golden_mul32(i,mod);
#endif
}

/* ********************************************************************** */
#ifndef erwin_count_bits_defined

ERWIN_WRAPPER int erwin_count_bits (unsigned long x)
{
#ifdef erwin_count_bits_non0_defined
    return x == 0 ? 0 : erwin_count_bits_non0(x);

#else

    int r;
    unsigned long y;
#  if SIZEOF_LONG > 8
#    error "'long' has too many bits (> 8 bytes)."
#  endif
    r= 0;
#if SIZEOF_LONG > 4
    y= x >> 32; if (y) { r+= 32; x= y; }
#endif
#if SIZEOF_LONG > 2
    y= x >> 16; if (y) { r+= 16; x= y; }
#endif
    y= x >> 8;  if (y) { r+= 8;  x= y; }
    y= x >> 4;  if (y) { r+= 4;  x= y; }
    y= x >> 2;  if (y) { r+= 2;  x= y; }
    y= x >> 1;  if (y) return r + 2;
    return r + x;

#endif /* defined(erwin_count_bits_non0) */
}

#endif /* !erwin_count_bits_defined */

/* ********************************************************************** */
#ifndef erwin_count_bits_non0_defined

ERWIN_WRAPPER int erwin_count_bits_non0 (unsigned long x)
{
    return erwin_count_bits(x);
}

#endif /* !erwin_count_bits_non0_defined */
/* ********************************************************************** */
#ifndef erwin_trailing_0s_defined

ERWIN_WRAPPER int erwin_trailing_0s (unsigned long x)
{
#if defined(erwin_count_set_bits_defined)
    return ERWIN_BIT_SIZEOF(x) - erwin_count_set_bits (x | -x);

#elif defined(erwin_trailing_0s_non0_defined)
    return x == 0 ? ERWIN_BIT_SIZEOF(x) : erwin_trailing_0s_non0(x);

#elif defined(erwin_count_bits_defined)
    return ERWIN_BIT_SIZEOF(x) - erwin_count_bits(~x & (x - 1));

#else
    int r;
    unsigned long y;
#  if SIZEOF_LONG > 8
#    error "'long' has too many bits (> 8 bytes)."
#  endif

    if (x == 0) return ERWIN_BIT_SIZEOF(x);

    r= ERWIN_BIT_SIZEOF(x) - 1;
#if SIZEOF_LONG > 4
    y= x << 32; if (y) { r-= 32; x= y; }
#endif
#if SIZEOF_LONG > 2
    y= x << 16; if (y) { r-= 16; x= y; }
#endif
    y= x << 8;  if (y) { r-= 8;  x= y; }
    y= x << 4;  if (y) { r-= 4;  x= y; }
    y= x << 2;  if (y) { r-= 2;  x= y; }
    return r - ((x << 1) >> (ERWIN_BIT_SIZEOF(x)-1));
#endif /* defined(erwin_trailing_0s_non0) */
}

#endif /* !erwin_trailing_0s_defined */

/* ********************************************************************** */
#ifndef erwin_trailing_0s_non0_defined

ERWIN_WRAPPER int erwin_trailing_0s_non0 (unsigned long x)
{
#ifdef erwin_count_bits_defined
    return ERWIN_BIT_SIZEOF(x) - 1 - erwin_count_bits(x & -x);
#else
    return erwin_trailing_0s(x);
#endif
}

#endif /* !erwin_trailing_0s_non0_defined */
/* ********************************************************************** */
#ifndef erwin_next_power2_minus1_defined

ERWIN_WRAPPER unsigned long erwin_next_power2_minus1 (unsigned long x)
{
    /* Returns a number y >= x where y = 2^n-1 for some n \in int.
     *
     * Instead of returning 0 for 2^(8*sizeof(long)) due to limited range
     * of data type, we always return a power2 minus 1, which is the
     * natural result of the fast manual algorithm anyway.
     */
#ifdef erwin_count_bits_defined
    /* if bit counting is fast, then we use that and shift: */
    return (1UL << erwin_count_bits(x)) - 1;
#else
    x|= x >> 1;
    x|= x >> 2;
    x|= x >> 4;
    x|= x >> 8;
#if SIZEOF_LONG >= 4
    x|= x >> 16;
#endif
#if SIZEOF_LONG >= 8
    x|= x >> 32;
#endif
#if SIZEOF_LONG >= 16
    x|= x >> 64;
#endif
    return x;
#endif
}

#endif /* !erwin_next_power2_minus1_defined */


/* ********************************************************************** */
/* Some more inline tools: */

ERWIN_WRAPPER ERWIN_BOOL erwin_is_power2 (unsigned long x)
{
     /* overcomes the macro problem of multiple evaluation */
     return ERWIN_IS_POWER2(x);
}


/* ********************************************************************** */

ERWIN_WRAPPER unsigned long erwin_next_power2 (unsigned long x)
{
    /* Returns a number y >= x where y = 2^n for some n \in int.
     *
     * But returns 0 instead of 2^(8*sizeof(long))
     */
#ifdef erwin_count_bits_defined
    return (x <= 0) ? 1 : (1UL << erwin_count_bits(x - 1));
#else
    return (x <= 0) ? 1 : erwin_next_power2_minus1(x - 1) + 1;
#endif
}

/* ********************************************************************** */

ERWIN_WRAPPER unsigned long erwin_prev_power2 (unsigned long x)
{
    /* Note: for 0, you get 0, which is not a power of 2, but it is <= 0 */
#ifdef erwin_count_bits_defined
    return (1UL << erwin_count_bits(x)) >> 1;
#else
    unsigned long a= erwin_next_power2_minus1(x);
    return a ^ (a >> 1);
#endif
}

/* ********************************************************************** */
#ifndef erwin_rol16_defined

ERWIN_WRAPPER ERWIN_U16 erwin_rol16 (ERWIN_U16 x, unsigned n)
{
    return (x << n) | (x >> (16-n));
}

#endif /* !erwin_rol16_defined */
/* ********************************************************************** */
#ifndef erwin_rol32_defined

ERWIN_WRAPPER ERWIN_U32 erwin_rol32 (ERWIN_U32 x, unsigned n)
{
    return (x << n) | (x >> (32-n));
}

#endif /* !erwin_rol32_defined */
/* ********************************************************************** */
#ifndef erwin_ror16_defined

ERWIN_WRAPPER ERWIN_U16 erwin_ror16 (ERWIN_U16 x, unsigned n)
{
    return (x >> n) | (x << (16-n));
}

#endif /* !erwin_ror16_defined */
/* ********************************************************************** */
#ifndef erwin_ror32_defined

ERWIN_WRAPPER ERWIN_U32 erwin_ror32 (ERWIN_U32 x, unsigned n)
{
    return (x >> n) | (x << (32-n));
}

#endif /* !erwin_ror32_defined */
/* ********************************************************************** */
#ifndef erwin_rol1_16_defined

ERWIN_WRAPPER ERWIN_U16 erwin_rol1_16 (ERWIN_U16 x)
{
    return erwin_rol16 (x,1);
}

#endif /* !erwin_rol1_16_defined */
/* ********************************************************************** */
#ifndef erwin_ror1_16_defined

ERWIN_WRAPPER ERWIN_U16 erwin_ror1_16 (ERWIN_U16 x)
{
    return erwin_ror16 (x,1);
}

#endif /* !erwin_ror1_16_defined */
/* ********************************************************************** */
#ifndef erwin_rol1_32_defined

ERWIN_WRAPPER ERWIN_U32 erwin_rol1_32 (ERWIN_U32 x)
{
    return erwin_rol32 (x,1);
}

#endif /* !erwin_rol1_32_defined */
/* ********************************************************************** */
#ifndef erwin_ror1_32_defined

ERWIN_WRAPPER ERWIN_U32 erwin_ror1_32 (ERWIN_U32 x)
{
    return erwin_ror32 (x,1);
}

#endif /* !erwin_ror1_32_defined */
/* ********************************************************************** */

#ifdef ERWIN_U64
#ifndef erwin_rol64_defined

ERWIN_WRAPPER ERWIN_U64 erwin_rol64 (ERWIN_U64 x, unsigned n)
{
    return (x << n) | (x >> (64-n));
}

#endif /* !erwin_rol64_defined */
/* ********************************************************************** */
#ifndef erwin_ror64_defined

ERWIN_WRAPPER ERWIN_U64 erwin_ror64 (ERWIN_U64 x, unsigned n)
{
    return (x >> n) | (x << (64-n));
}

#endif /* !erwin_ror64_defined */
/* ********************************************************************** */
#ifndef erwin_rol1_64_defined

ERWIN_WRAPPER ERWIN_U64 erwin_rol1_64 (ERWIN_U64 x)
{
    return erwin_rol64 (x,1);
}

#endif /* !erwin_rol1_64_defined */
/* ********************************************************************** */
#ifndef erwin_ror1_64_defined

ERWIN_WRAPPER ERWIN_U64 erwin_ror1_64 (ERWIN_U64 x)
{
    return erwin_ror64 (x,1);
}

#endif /* !erwin_ror1_64_defined */
#endif /* ERWIN_U64 */

/* ********************************************************************** */
#ifndef erwin_rol_defined

ERWIN_WRAPPER hashval_t erwin_rol (hashval_t x, unsigned n)
{
#if defined(erwin_rol32_defined) && SIZEOF_HASHVAL_T == 4
    return erwin_rol32(x,n);
#elif defined(erwin_rol64_defined) && SIZEOF_HASHVAL_T == 8
    return erwin_rol64(x,n);
#else
    return (x << n) | (x >> (ERWIN_BIT_SIZEOF(hashval_t) - n));
#endif
}

#endif /* !erwin_rol_defined */
/* ********************************************************************** */
#ifndef erwin_ror_defined

ERWIN_WRAPPER hashval_t erwin_ror (hashval_t x, unsigned n)
{
#if defined(erwin_ror32_defined) && SIZEOF_HASHVAL_T == 4
    return erwin_ror32(x,n);
#elif defined(erwin_ror64_defined) && SIZEOF_HASHVAL_T == 8
    return erwin_ror64(x,n);
#else
    return (x >> n) | (x << (ERWIN_BIT_SIZEOF(hashval_t) - n));
#endif
}

#endif /* !erwin_ror_defined */
/* ********************************************************************** */
#ifndef erwin_rol1_defined

ERWIN_WRAPPER hashval_t erwin_rol1 (hashval_t x)
{
#if defined(erwin_rol1_32_defined) && SIZEOF_HASHVAL_T == 4
    return erwin_rol1_32(x);
#elif defined(erwin_rol1_64_defined) && SIZEOF_HASHVAL_T == 8
    return erwin_rol1_64(x);
#else
    return erwin_rol (x,1);
#endif
}

#endif /* !erwin_rol1_defined */
/* ********************************************************************** */
#ifndef erwin_ror1_defined

ERWIN_WRAPPER hashval_t erwin_ror1 (hashval_t x)
{
#if defined(erwin_ror1_32_defined) && SIZEOF_HASHVAL_T == 4
    return erwin_ror1_32(x);
#elif defined(erwin_ror1_64_defined) && SIZEOF_HASHVAL_T == 8
    return erwin_ror1_64(x);
#else
    return erwin_ror (x,1);
#endif
}

#endif /* !erwin_ror1_defined */
/* ********************************************************************** */
#ifndef erwin_count_set_bits_defined

ERWIN_WRAPPER int erwin_count_set_bits (unsigned long x)
{
    /* The original idea is parallel addition of bits:
     *   x= (x & 0x55555555UL) + ((x >>  1) & 0x55555555UL);
     *   x= (x & 0x33333333UL) + ((x >>  2) & 0x33333333UL);
     *   x= (x & 0x0f0f0f0fUL) + ((x >>  4) & 0x0f0f0f0fUL);
     *   x= (x & 0x00ff00ffUL) + ((x >>  8) & 0x00ff00ffUL);
     *   x= (x & 0x0000ffffUL) + ((x >> 16) & 0x0000ffffUL);
     *
     * The versions below are slightly optimised.
     */
#if SIZEOF_LONG == 4

    x-= (x >> 1) & 0x55555555UL;
    x=  (x & 0x33333333UL) + ((x >> 2) & 0x33333333UL);
    x=  (x + (x >> 4)) & 0x0f0f0f0fUL;

# if ERWIN_ARCH_FAST_MUL
    x= (x * 0x01010101UL) >> 24;
# else
    x+= x >> 8;
    x+= x >> 16;
    x=  (ERWIN_U8)x;
# endif

#else

    x-= (x >> 1) & 0x5555555555555555UL;
    x=  (x & 0x3333333333333333UL) + ((x >> 2) & 0x3333333333333333UL);
    x=  (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fUL;

# if ERWIN_ARCH_FAST_MUL
    x= (x * 0x0101010101010101UL) >> 56;
# else
    x+= x >> 8;
    x+= x >> 16;
    x+= x >> 32;
    x=  (ERWIN_U8)x;
# endif

#endif
    return x;
}

#endif /* !erwin_count_set_bits_defined */

/* ********************************************************************** */
#ifndef erwin_swap16_defined
/* swap 0x1100 to 0x0011
 *        A B       B A  */

ERWIN_WRAPPER ERWIN_U16 erwin_swap16 (ERWIN_U16 x)
{
#if defined(erwin_rol16_defined)
    return erwin_rol16(x,8);
#else
    return (x >> 8) | (x << 8);
#endif
}

#endif /* !erwin_swap16_defined */

/* ********************************************************************** */
#ifndef erwin_swap32_16_defined
/* swap 0x33221100 to 0x11003322
 *        A   B         B   A    */

ERWIN_WRAPPER ERWIN_U32 erwin_swap32_16 (ERWIN_U32 x)
{
#if defined(erwin_rol32_defined)
    return erwin_rol32(x,16);
#else
    return (x >> 16) | (x << 16);
#endif
}

#endif /* !erwin_swap32_16_defined */

/* ********************************************************************** */
#ifndef erwin_swap32_defined
/* swap 0x33221100 to 0x00112233
 *        A B C D       D C B A  */

ERWIN_WRAPPER ERWIN_U32 erwin_swap32 (ERWIN_U32 x)
{
    return ((ERWIN_U32)erwin_swap16((ERWIN_U16)(x >> 16))) |
           (((ERWIN_U32)erwin_swap16((ERWIN_U16)x)) << 16);
}

#endif /* !erwin_swap32_defined */

/* ********************************************************************** */
#ifdef ERWIN_U64
#ifndef erwin_swap64_32_defined
/* swap 0x7766554433221100 to 0x3322110077665544
 *        A       B             B       A         */

ERWIN_WRAPPER ERWIN_U64 erwin_swap64_32 (ERWIN_U64 x)
{
#if defined(erwin_rol64_defined)
    return erwin_rol64(x,32);
#else
    return (x >> 32) | (x << 32);
#endif
}

#endif /* !erwin_swap64_32_defined */
#endif /* ERWIN_U64 */

/* ********************************************************************** */
#ifdef ERWIN_U64
#ifndef erwin_swap64_16_defined
/* swap 0x7766554433221100 to 0x1100332255447766
 *        A   B   C   D         D   C   B   A    */

ERWIN_WRAPPER ERWIN_U64 erwin_swap64_16 (ERWIN_U64 x)
{
    return ((ERWIN_U64)erwin_swap32_16((ERWIN_U32)(x >> ((ERWIN_U32)32)))) |
           (((ERWIN_U64)erwin_swap32_16((ERWIN_U32)x)) << ((ERWIN_U64)32));
}

#endif /* !erwin_swap64_defined */
#endif /* ERWIN_U64 */

/* ********************************************************************** */
#ifdef ERWIN_U64
#ifndef erwin_swap64_defined
/* swap 0x7766554433221100 to 0x0011223344556677
 *        A B C D E F G H       H G F E D C B A  */

ERWIN_WRAPPER ERWIN_U64 erwin_swap64 (ERWIN_U64 x)
{
    return ((ERWIN_U64)erwin_swap32((ERWIN_U32)(x >> ((ERWIN_U64)32)))) |
           (((ERWIN_U64)erwin_swap32((ERWIN_U32)x)) << ((ERWIN_U64)32));
}

#endif /* !erwin_swap64_defined */
#endif /* ERWIN_U64 */

/* ********************************************************************** */
#ifndef erwin_bitswap32_8_defined

ERWIN_WRAPPER ERWIN_U32 erwin_bitswap32_8 (ERWIN_U32 x)
/* reverses the bits in each byte of a 32 bit integer */
{
    x= ((x & ERWIN_U32_C(0x55555555)) << 1) | ((x >> 1) & ERWIN_U32_C(0x55555555));
    x= ((x & ERWIN_U32_C(0x33333333)) << 2) | ((x >> 2) & ERWIN_U32_C(0x33333333));
    x= ((x & ERWIN_U32_C(0x0f0f0f0f)) << 4) | ((x >> 4) & ERWIN_U32_C(0x0f0f0f0f));
    return x;
}

#endif /* !erwin_bitswap32_defined */

/* ********************************************************************** */
#ifdef ERWIN_U64
#ifndef erwin_bitswap64_8_defined

ERWIN_WRAPPER ERWIN_U64 erwin_bitswap64_8 (ERWIN_U64 x)
/* reverses the bits in each byte of a 32 bit integer */
{
    x= ((x & ERWIN_U64_C(0x5555555555555555)) << 1) | ((x >> 1) & ERWIN_U64_C(0x5555555555555555));
    x= ((x & ERWIN_U64_C(0x3333333333333333)) << 2) | ((x >> 2) & ERWIN_U64_C(0x3333333333333333));
    x= ((x & ERWIN_U64_C(0x0f0f0f0f0f0f0f0f)) << 4) | ((x >> 4) & ERWIN_U64_C(0x0f0f0f0f0f0f0f0f));
    return x;
}

#endif /* !erwin_bitswap64_defined */
#endif /* ERWIN_U64 */

/* ********************************************************************** */

ERWIN_WRAPPER hashval_t erwin_bitswap_8 (hashval_t x)
/* reverses the bits in each byte of a 32 bit integer */
{
#if SIZEOF_HASHVAL_T == 4
    return erwin_bitswap32_8 (x);
#elif SIZEOF_HASHVAL_T == 8
    return erwin_bitswap64_8 (x);
#else
#  error "Unsupported width of hashval_t."
#endif
}

/* ********************************************************************** */
#ifndef erwin_bitswap32_defined

ERWIN_WRAPPER ERWIN_U32 erwin_bitswap32 (ERWIN_U32 x)
{
    return erwin_bitswap32_8 (erwin_swap32(x));
}

#endif /* !erwin_bitswap32_defined */

/* ********************************************************************** */
#ifdef ERWIN_U64
#ifndef erwin_bitswap64_defined

ERWIN_WRAPPER ERWIN_U64 erwin_bitswap64 (ERWIN_U64 x)
{
    return erwin_bitswap64_8 (erwin_swap64(x));
}

#endif /* !erwin_bitswap64_defined */
#endif
/* ********************************************************************** */

ERWIN_WRAPPER hashval_t erwin_bitswap (hashval_t x)
/* reverses the bits in each byte of a 32 bit integer */
{
#if SIZEOF_HASHVAL_T == 4
    return erwin_bitswap32 (x);
#elif SIZEOF_HASHVAL_T == 8
    return erwin_bitswap64 (x);
#else
#  error "Unsupported width of hashval_t."
#endif
}

/* ********************************************************************** */

ERWIN_WRAPPER hashval_t erwin_swap (hashval_t x)
{
#if SIZEOF_HASHVAL_T == 2
    return erwin_swap16(x);
#elif SIZEOF_HASHVAL_T == 4
    return erwin_swap32(x);
#elif SIZEOF_HASHVAL_T == 8
    return erwin_swap64(x);
#else
# error "Unsupported width of hashval_t."
#endif
}

ERWIN_WRAPPER hashval_t erwin_swap_low32 (hashval_t x)
/* If sizeof(hashval_t) > 4, clears the upper bits.  So this is almost the
 * same as swap32, but works in data type hashval_t and might be a wee bit
 * faster when some zero extensions may be dropped. */
{
#if SIZEOF_HASHVAL_T == 2
    return erwin_swap16(x);
#elif SIZEOF_HASHVAL_T == 4
    return erwin_swap32(x);
#elif SIZEOF_HASHVAL_T == 8
#ifdef erwin_swap32low_defined
    return erwin_swap32low(x);
#else
    return erwin_swap32(x);
#endif
#else
# error "Unsupported width of hashval_t."
#endif
}

/* FIXME: we might also want:
 *
 * erwin_swap32_pairwise:
 * swap 0x33221100 to 0x622330011
 *        A B C D        B A D C
 *
 * erwin_swap64_pairwise16:
 * swap 0x7766554433221100 to 0x5544776611003322
 *        A   B   C   D         B   A   D   C
 *
 * erwin_swap64_pairwise:
 * swap 0x7766554433221100 to 0x6677445522330011
 *        A B C D E F G H       B A D C F E H G
 *
 * They are easy, but let's wait until someone needs them.
 */

/* ********************************************************************** */
#ifndef erwin_mul_ok_defined

/* FIXME: Unfortunately, if erwin_mulh32/64 is assembly, the compiler does
 *        not know that we actually multiplied a*b and probably have the
 *        result in some register (e.g. on x86), so a*b is likely to be
 *        calculated twice, sadly.  We should have a function that returns
 *        both high and low word of the result and use that one somehow.
 *        Returning two results is not really easy either.
 */
ERWIN_WRAPPER ERWIN_BOOL erwin_mul_ok(size_t a, size_t b)
{
#if defined(erwin_mulh32) && SIZEOF_SIZE_T == 4
    return erwin_mulh32(a,b) == 0;
#elif defined(erwin_mulh64) && SIZEOF_SIZE_T == 8
    return erwin_mulh64(a,b) == 0;
#else
    if (ERWIN_LIKELY(erwin_count_bits(a) + erwin_count_bits(b)
                     <= (int)(ERWIN_BIT_SIZEOF(size_t))))
        return ERWIN_TRUE;    /* true if b == 0, so we won't divide by 0 */
    return ((a * b) / b) == a;
#endif
}

#endif
/* ********************************************************************** */
/* ********************************************************************** */
/* convenience stuff: */

/* byte order stuff: */
#ifdef ERWIN_BYTE_ORDER
   /* If you read an LBF word via a native pointer, you can
    * convert it with lbf2int into an int.
    *
    * If you have an int and want to store it in LBF order via
    * a native pointer, use int2lbf.
    */
#  if ERWIN_BYTE_ORDER == ERWIN_LBF
#    define erwin_int2lbf16(x)   (x)
#    define erwin_lbf2int16(x)   (x)
#    define erwin_int2lbf32(x)   (x)
#    define erwin_lbf2int32(x)   (x)
#    define erwin_int2lbf64(x)   (x)
#    define erwin_lbf2int64(x)   (x)
#    define erwin_int2hbf16(x)   erwin_swap16(x)
#    define erwin_hbf2int16(x)   erwin_swap16(x)
#    define erwin_int2hbf32(x)   erwin_swap32(x)
#    define erwin_hbf2int32(x)   erwin_swap32(x)
#    define erwin_int2hbf64(x)   erwin_swap64(x)
#    define erwin_hbf2int64(x)   erwin_swap64(x)
#  elif ERWIN_BYTE_ORDER == ERWIN_HBF
#    define erwin_int2lbf16(x)   erwin_swap16(x)
#    define erwin_lbf2int16(x)   erwin_swap16(x)
#    define erwin_int2lbf32(x)   erwin_swap32(x)
#    define erwin_lbf2int32(x)   erwin_swap32(x)
#    define erwin_int2lbf64(x)   erwin_swap64(x)
#    define erwin_lbf2int64(x)   erwin_swap64(x)
#    define erwin_int2hbf16(x)   (x)
#    define erwin_hbf2int16(x)   (x)
#    define erwin_int2hbf32(x)   (x)
#    define erwin_hbf2int32(x)   (x)
#    define erwin_int2hbf64(x)   (x)
#    define erwin_hbf2int64(x)   (x)
#  else
   /* All other byte orders are more interesting, since *all*
    * functions, since none is identity.
    *
    * The definitions are long, however.  Note that lbf is the native order
    * of ints (because value(bit i) = 2^i, so for hbf, we need to swap, but
    * for lbf, we don't.  Or put differently:
    *
    *     ERWIN_INDEX_BYTE(ERWIN_LBF,n) == n
    */

#    define erwin_extract_byte(x,n) \
                ((((ERWIN_U32)(x)) >> (ERWIN_INDEX_BYTE(ERWIN_BYTE_ORDER,n) << 3)) & 0xff)

#    define erwin_int2lbf32(x)                                      \
            (                                                              \
                erwin_swap_byte_n(x,ERWIN_BYTE_ORDER,ERWIN_LBF,0) | \
                erwin_swap_byte_n(x,ERWIN_BYTE_ORDER,ERWIN_LBF,1) | \
                erwin_swap_byte_n(x,ERWIN_BYTE_ORDER,ERWIN_LBF,2) | \
                erwin_swap_byte_n(x,ERWIN_BYTE_ORDER,ERWIN_LBF,3)   \
            )

#    define erwin_int2lbf16(x)                                                        \
            (                                                                                \
                erwin_swap_byte_n(x,(ERWIN_BYTE_ORDER & 0x11),(ERWIN_LBF & 0x11),0) | \
                erwin_swap_byte_n(x,(ERWIN_BYTE_ORDER & 0x11),(ERWIN_LBF & 0x11),1)   \
            )

/* FIXME: maybe continue if anyone cares about this. */

#  endif
#endif /* defined ERWIN_BYTE_ORDER */

#endif /* ERWIN_ASM_GENERIC_H */
