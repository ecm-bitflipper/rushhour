/* -*- Mode: C -*- */
/* Generated Tue Aug 19 15:44:09 GMT 2008
 */
/* Author: Henrik Theiling
 *
 * Implementation specific header file.  Only map_int_rgbcolour_p.c should
 * include this.  (For technical reasons, map_int_rgbcolour_p.h also includes
 * it).
 */
/*
 * Copyright (c) 1999-2002 Henrik Theiling
 * 
 * This file was generated by tools of the Erwin library.  It may be used
 * freely.
 * 
 * This software is provided 'as-is', without warranty of any kind,
 * express or implied.  In no event will the authors or copyright holders
 * be held liable for any damages arising from the use of this software.
 * 
 * Disputes shall be settled by Saarbruecken City Court.
*/

#ifdef ERWIN_DEBUG_INCLUDE
#warning "Including map_int_rgbcolour_p_i.h"
#endif

#ifndef ERWIN_MAP_INT_RGBCOLOUR_P_I_h
#define ERWIN_MAP_INT_RGBCOLOUR_P_I_h

#ifdef ERWIN_DEBUG_INCLUDE
#warning "First inclusion of map_int_rgbcolour_p_i.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

ERWIN_KIND_TYPEDEFS(struct, map_int_rgbcolour_p_hashlist_t)

/* For the following ones, type info isn't easy.  We need a new
 * type, a dynamic array, because we do not store the size of
 * the these arrays.  They are no vectors, which must be embedded
 * in structs. */

typedef int map_int_rgbcolour_p_key_dynarray;

typedef RGBColour * map_int_rgbcolour_p_value_dynarray;

typedef map_int_rgbcolour_p_hashlist_t_p map_int_rgbcolour_p_content;
typedef map_int_rgbcolour_p_content *map_int_rgbcolour_p_content_p;

struct _map_int_rgbcolour_p_hashlist_t {
    int key;

    RGBColour * value;

    map_int_rgbcolour_p_hashlist_t_p next;
#ifdef __cplusplus
    _map_int_rgbcolour_p_hashlist_t ():
        next(NULL)
        {}

    _map_int_rgbcolour_p_hashlist_t (int  k, RGBColour *  v):
        key (k),
        value (v),
        next (NULL)
        {}

#endif
};

typedef struct _map_int_rgbcolour_p_internal_Iterator {
    map_int_rgbcolour_p_hashlist_t *cnode;
    int    cslot;
} map_int_rgbcolour_p_internal_Iterator;

typedef struct _map_int_rgbcolour_p_internal_sorted_Iterator {
    map_int_rgbcolour_p_pair_t *table;
    int         lauf;
    int         count;
    void        (*free_cb)(void *);
} map_int_rgbcolour_p_internal_sorted_Iterator;

typedef struct _map_int_rgbcolour_p_internal_sorted_ptr_Iterator {
    map_int_rgbcolour_p_pair_ptr_t *table;
    int             lauf;
    int             count;
    void            (*free_cb)(void *);
} map_int_rgbcolour_p_internal_sorted_ptr_Iterator;

#define map_int_rgbcolour_p_record_table(X) X

#define map_int_rgbcolour_p_record_sizes(X) X

#ifdef ERWIN_THREAD_SAFE
#  define map_int_rgbcolour_p_record_errno(X) X
#else
#  define map_int_rgbcolour_p_record_errno(X)
#endif

#if MAP_INT_RGBCOLOUR_P_DYN_ZERO
#  define map_int_rgbcolour_p_record_zero(X) X
#else
#  define map_int_rgbcolour_p_record_zero(X)
#endif

#ifdef ERWINMM_COMPAT1
#define map_int_rgbcolour_p_record_compat(X) X
#else
#define map_int_rgbcolour_p_record_compat(X)
#endif

#ifdef ERWIN_PROFILE
#define map_int_rgbcolour_p_record_profile(X) X
#else
#define map_int_rgbcolour_p_record_profile(X)
#endif

#if MAP_INT_RGBCOLOUR_P_HAVE_SIG
#  define map_int_rgbcolour_p_record_sig(X) X
#else
#  define map_int_rgbcolour_p_record_sig(X)
#endif

/* If m_hashsize becomes 64 bit, we need to adjust the 64-bit hashinto
 * functions (hashval_t is already 64 bit), but maps with more than
 * 2G entries currently still seem too large no matter what.  This view
 * will change soon, of course...
 *
 * Note than vectors have been switched to 64 bit values (on demand with
 * Vector_LARGE_INDEX).
 */
#define map_int_rgbcolour_p_record                                             \
        map_int_rgbcolour_p_record_sig     (int m_sig;)                        \
        map_int_rgbcolour_p_record_table   (map_int_rgbcolour_p_content_p m_table;)            \
        map_int_rgbcolour_p_record_sizes   (int    m_hashsize;)                \
        map_int_rgbcolour_p_record_sizes   (int    m_nentries;)                \
        map_int_rgbcolour_p_record_errno   (ERWIN_MUTABLE int m_errno;) \
        map_int_rgbcolour_p_record_zero    (RGBColour *  m_zero;)                 \
        map_int_rgbcolour_p_record_compat  (map_iterator_t compat1_iter;)      \
        map_int_rgbcolour_p_record_profile (int m_nrehash;)                    \
        map_int_rgbcolour_p_record_profile (int m_nrehashops;)                 \
        map_int_rgbcolour_p_record_profile (int m_nfind;)                      \
        map_int_rgbcolour_p_record_profile (int m_ninsert;)                    \
        map_int_rgbcolour_p_record_profile (int m_ndelete;)


#ifdef ERWIN_COMPAT_2_0_264

#ifdef ERWIN_COMPAT_2_0_248
struct _map_int_rgbcolour_p_t
#else
struct map_int_rgbcolour_p_t
#endif
{
    map_int_rgbcolour_p_record
};

#endif

/*
 * Force linker error when .c and .h are compiled inconsistently */
#if !defined (MAP_INT_RGBCOLOUR_P_IMPLEMENTATION) && defined(ERWIN_WEAK_STORAGE) && !defined(NDEBUG) && !defined(ERWIN_NO_LINKER_TRICKS)

#if MAP_INT_RGBCOLOUR_P_DYN_ZERO
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_variable_zero_element_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_variable_zero_element_expected(void) {}
#else
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_constant_zero_element_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_constant_zero_element_expected(void) {}
#endif

#ifdef ERWIN_PROFILE
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_profile_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_profile_expected(void) {}
#else
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_no_profile_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_no_profile_expected(void) {}
#endif

#ifdef ERWINMM_COMPAT1
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_erwinmm_compat1_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_erwinmm_compat1_expected(void) {}
#else
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_no_erwinmm_compat1_expected(void) ERWIN_LINK_WEAK;
ERWIN_WEAK_STORAGE void map_int_rgbcolour_p_no_erwinmm_compat1_expected(void) {}
#endif

#endif /* defined(INTERNAL... *) */

#ifdef __cplusplus
}
#endif

#endif /* !defined(ERWIN_MAP_INT_RGBCOLOUR_P_I_h) */
